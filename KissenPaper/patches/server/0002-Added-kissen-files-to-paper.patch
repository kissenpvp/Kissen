From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Groldi <chniucg@gmail.com>
Date: Mon, 11 Sep 2023 00:49:19 +0200
Subject: [PATCH] Added kissen files to paper


diff --git a/src/main/java/net/kissenpvp/paper/ban/KissenPaperBan.java b/src/main/java/net/kissenpvp/paper/ban/KissenPaperBan.java
new file mode 100644
index 0000000000000000000000000000000000000000..e284c572caa8de7a041efb1817d3c30f55a25fb8
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/ban/KissenPaperBan.java
@@ -0,0 +1,13 @@
+package net.kissenpvp.paper.ban;
+
+import net.kissenpvp.core.api.networking.socket.DataPackage;
+import net.kissenpvp.core.ban.KissenBan;
+import net.kissenpvp.paper.api.ban.PaperBan;
+import org.jetbrains.annotations.NotNull;
+
+public class KissenPaperBan extends KissenBan implements PaperBan {
+    @Override
+    public void sendData(@NotNull DataPackage dataPackage) {
+        //TODO
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/ban/KissenPaperBanImplementation.java b/src/main/java/net/kissenpvp/paper/ban/KissenPaperBanImplementation.java
new file mode 100644
index 0000000000000000000000000000000000000000..3b87570564f4754dff39f214bcfcab9146e3657f
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/ban/KissenPaperBanImplementation.java
@@ -0,0 +1,164 @@
+package net.kissenpvp.paper.ban;
+
+import net.kissenpvp.core.api.ban.BanOperator;
+import net.kissenpvp.core.api.ban.BanType;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.database.meta.Meta;
+import net.kissenpvp.core.api.database.meta.ObjectMeta;
+import net.kissenpvp.core.api.database.savable.SavableMap;
+import net.kissenpvp.core.ban.KissenBanImplementation;
+import net.kissenpvp.core.ban.KissenPunishmentNode;
+import net.kissenpvp.paper.api.ban.PaperBan;
+import net.kissenpvp.paper.api.ban.PaperBanImplementation;
+import net.kissenpvp.paper.api.ban.PaperPunishment;
+import net.kissenpvp.paper.api.base.Context;
+import net.kyori.adventure.text.Component;
+import org.bukkit.Bukkit;
+import org.bukkit.entity.Player;
+import org.bukkit.event.player.PlayerKickEvent;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.*;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public class KissenPaperBanImplementation extends KissenBanImplementation<PaperBan, PaperPunishment> implements PaperBanImplementation {
+
+    @Override
+    public void applyBan(@NotNull PaperPunishment ban) {
+        ban.getOnlineAffectedPlayers().forEach(player -> applyBan(ban, player));
+    }
+
+    private void applyBan(@NotNull PaperPunishment ban, @NotNull Player player) {
+        switch (ban.getBanType())
+        {
+            case BAN -> player.kick(Component.translatable("multiplayer.disconnect.banned"), PlayerKickEvent.Cause.BANNED);
+            case KICK -> player.kick(Component.translatable("multiplayer.disconnect.kicked"), PlayerKickEvent.Cause.KICK_COMMAND);
+            case MUTE -> player.sendMessage(Component.translatable("chat.filtered_full"));
+        }
+    }
+
+    @Override
+    protected @NotNull @Unmodifiable Set<PaperBan> obtainBanSet() throws BackendException {
+        return Stream.concat(queryBanStream(getMeta()), queryBanStream(getMeta(Context.LOCAL)))
+                .filter(Objects::nonNull)
+                .collect(Collectors.toSet());
+    }
+
+    @Override
+    protected @NotNull @Unmodifiable ObjectMeta getMeta() {
+        return Bukkit.getKissen().getPublicMeta();
+    }
+
+    @Override
+    protected @NotNull PaperBan buildBan(int id, @NotNull Map<String, String> data) throws BackendException {
+        KissenPaperBan kissenPaperBan = new KissenPaperBan();
+        kissenPaperBan.setup(String.valueOf(id), data);
+        return kissenPaperBan;
+    }
+
+    @Override
+    protected @NotNull PaperPunishment translatePunishment(@NotNull UUID totalID, @NotNull KissenPunishmentNode kissenPunishmentNode, @NotNull Meta meta) {
+        return new KissenPaperPunishment(totalID, kissenPunishmentNode, record -> {
+            try {
+                set(totalID, (KissenPunishmentNode) record, meta);
+            } catch (BackendException backendException) {
+                Bukkit.getKissen()
+                        .getLogger()
+                        .error("The punishment '{}' from total id '{}' could not be updated due to a backend exception. It is advised to shut down the server to prevent further damage to the servers data.", ((KissenPunishmentNode) record).id(), totalID, backendException);
+            }
+        });
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPunishment> getPlayerBanSet(@NotNull Context context) throws BackendException {
+        return getPlayerBanSet(getMeta(context));
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPunishment> getPlayerBanSet(@NotNull UUID totalID, @NotNull Context context) throws BackendException {
+        return getPlayerBanSet(totalID, getMeta(context));
+    }
+
+    @Override
+    public @NotNull Optional<PaperPunishment> getCurrentBan(@NotNull UUID totalID, @NotNull Context context) throws BackendException {
+        return getCurrentBan(totalID, getMeta(context));
+    }
+
+    @Override
+    public @NotNull Optional<PaperPunishment> getCurrentBan(@NotNull UUID totalID, @NotNull BanType banType, @NotNull Context context) throws BackendException {
+        return getCurrentBan(totalID, banType, getMeta(context));
+    }
+
+    @Override
+    public @NotNull PaperPunishment punish(@NotNull UUID totalID, @NotNull PaperBan ban, @NotNull BanOperator banOperator, @Nullable Component reason, @NotNull Context context) throws BackendException {
+        return punish(totalID, ban, banOperator, reason, getMeta(context));
+    }
+
+    /**
+     * Retrieves the meta information based on the provided context.
+     *
+     * @param context The context to determine which meta information to retrieve.
+     * @return The meta information based on the provided context.
+     */
+    protected @NotNull @Unmodifiable ObjectMeta getMeta(@NotNull Context context) {
+        return switch (context) {
+            case GLOBAL -> getMeta();
+            case LOCAL -> Bukkit.getKissen().getPrivateMeta();
+        };
+    }
+
+    /**
+     * Queries the ban stream based on the given meta information.
+     * <p>
+     * This method performs a database operation under the hood to fetch a stream of PaperBan
+     * instances. The query operates on the foundations of the supplied meta information. This
+     * metaobject encapsulates essential data that directs the query towards the appropriate
+     * dataset within the database.
+     * <p>
+     * A stream interface is being utilized here due to its advantages in handling large datasets.
+     * It works by loading data on-demand, instead of loading it all at once into memory, making the
+     * process more efficient.
+     * <p>
+     * The function will map over the values returned from the database query by utilizing the
+     * banProcessor() function on each element, further processing the raw data into PaperBan
+     * objects that the application can interact with.
+     * <p>
+     * An important factor to note is that this method throws a BackendException. This exception
+     * is thrown if there are issues encountered when querying the ban stream from the database,
+     * such as connection problems, invalid query syntax.
+     *
+     * @param meta The meta information containing the data to query. This is an instance of
+     *             ObjectMeta which encapsulates the query parameters.
+     * @return The ban stream based on the given meta information. Takes form as a stream of
+     * PaperBan objects each representing a unique ban instance.
+     * @throws BackendException If there is an error querying the ban stream, this exception
+     *                          will be thrown. It signifies an issue with the backend operation.
+     */
+    private @NotNull Stream<PaperBan> queryBanStream(@NotNull ObjectMeta meta) throws BackendException {
+        return meta.getData(new KissenPaperBan()).values().stream().map(banProcessor());
+    }
+
+    /**
+     * Retrieves the ban processor function, which processes a SavableMap and returns a PaperBan.
+     *
+     * @return The ban processor function.
+     */
+    @Contract(pure = true)
+    private @NotNull Function<SavableMap, PaperBan> banProcessor() {
+        return savableMap -> {
+            try {
+                return createBan(Integer.parseInt(savableMap.getNotNull("id")), savableMap);
+            } catch (BackendException | NumberFormatException exception) {
+                Bukkit.getKissen()
+                        .getLogger()
+                        .error("Error parsing ban entry with id {}.", savableMap.getNotNull("id"), exception);
+            }
+            return null;
+        };
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/ban/KissenPaperMinecraftBan.java b/src/main/java/net/kissenpvp/paper/ban/KissenPaperMinecraftBan.java
new file mode 100644
index 0000000000000000000000000000000000000000..58b72f93b902c177f152855e4ed232847f8dfe29
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/ban/KissenPaperMinecraftBan.java
@@ -0,0 +1,63 @@
+package net.kissenpvp.paper.ban;
+
+import net.kissenpvp.core.api.ban.Ban;
+import net.kissenpvp.core.api.ban.BanType;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.paper.api.ban.PaperBan;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.time.Duration;
+import java.util.Optional;
+
+public class KissenPaperMinecraftBan implements PaperBan {
+
+    private final String name;
+    private final Duration duration;
+
+    public KissenPaperMinecraftBan(@NotNull String name, @Nullable Duration duration) {
+        this.name = name;
+        this.duration = duration;
+    }
+
+    @Override
+    public int getID() {
+        return 0;
+    }
+
+    @Override
+    public @NotNull String getName() {
+        return name;
+    }
+
+    @Override
+    public void setName(@NotNull String name) throws EventCancelledException {
+        throw new EventCancelledException();
+    }
+
+    @Override
+    public @NotNull BanType getBanType() {
+        return BanType.BAN;
+    }
+
+    @Override
+    public void setBanType(@NotNull BanType banType) throws EventCancelledException {
+        throw new EventCancelledException();
+    }
+
+    @Override
+    public @NotNull Optional<Duration> getDuration() {
+        return Optional.ofNullable(duration);
+    }
+
+    @Override
+    public void setDuration(@Nullable Duration duration) throws EventCancelledException {
+        throw new EventCancelledException();
+    }
+
+    @Override
+    public int delete() throws BackendException {
+        throw new BackendException(new EventCancelledException());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/ban/KissenPaperPunishment.java b/src/main/java/net/kissenpvp/paper/ban/KissenPaperPunishment.java
new file mode 100644
index 0000000000000000000000000000000000000000..90a88b13952f9b35eae3062d26b0b15905a305ae
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/ban/KissenPaperPunishment.java
@@ -0,0 +1,26 @@
+package net.kissenpvp.paper.ban;
+
+import net.kissenpvp.core.ban.KissenPunishmentNode;
+import net.kissenpvp.core.ban.KissenPunishment;
+import net.kissenpvp.core.database.DataWriter;
+import net.kissenpvp.paper.api.ban.PaperPunishment;
+import org.bukkit.Bukkit;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Set;
+import java.util.UUID;
+import java.util.stream.Collectors;
+
+public class KissenPaperPunishment extends KissenPunishment<Player> implements PaperPunishment {
+    public KissenPaperPunishment(@NotNull UUID totalID, @NotNull KissenPunishmentNode kissenPunishmentNode, @Nullable DataWriter dataWriter) {
+        super(totalID, kissenPunishmentNode, dataWriter);
+    }
+
+    @Override
+    public @Unmodifiable Set<Player> getOnlineAffectedPlayers() {
+        return Bukkit.getOnlinePlayers().stream().filter(player -> player.getTotalID().equals(getTotalID())).collect(Collectors.toSet());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/base/KissenPaperCore.java b/src/main/java/net/kissenpvp/paper/base/KissenPaperCore.java
new file mode 100644
index 0000000000000000000000000000000000000000..7dbf5fe75fb758aa20db486b123348d7359e567a
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/base/KissenPaperCore.java
@@ -0,0 +1,59 @@
+package net.kissenpvp.paper.base;
+
+import net.kissenpvp.core.api.database.meta.ObjectMeta;
+import net.kissenpvp.core.api.networking.client.entitiy.ConsoleClient;
+import net.kissenpvp.core.base.KissenCore;
+import net.kissenpvp.paper.api.base.PaperKissen;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.slf4j.Logger;
+
+import java.util.UUID;
+
+// KissenPaper
+public class KissenPaperCore extends KissenCore implements PaperKissen {
+
+    /**
+     * Constructs a new instance of the KissenPaperCore class.
+     *
+     * @param logger The logger to be used for logging.
+     */
+    public KissenPaperCore(@NotNull Logger logger) {
+        super(logger);
+    }
+
+    @Override
+    public int getPort() {
+        return Bukkit.getPort();
+    }
+
+    @Override
+    public boolean isOnline(@NotNull UUID uuid) {
+        return Bukkit.getPlayer(uuid) != null;
+    }
+
+    @Override
+    public boolean isOnline(@NotNull String s) {
+        return Bukkit.getPlayer(s) != null;
+    }
+
+    @Override
+    public @NotNull ConsoleClient getConsole() {
+        return Bukkit.getConsoleSender();
+    }
+
+    @Override
+    public void repeatTask(@NotNull String name, int l1, @NotNull Runnable runnable) {
+        //TODO add task class
+    }
+
+    @Override
+    public void runTask(long l, @NotNull Runnable runnable) {
+        //TODO look method above
+    }
+
+    @Override
+    public @NotNull ObjectMeta getPrivateMeta() {
+        return KissenCore.getInstance().getPublicMeta(); //TODO
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/KissenPaperCommandImplementation.java b/src/main/java/net/kissenpvp/paper/command/KissenPaperCommandImplementation.java
new file mode 100644
index 0000000000000000000000000000000000000000..716a1b198dfabb5a1bb8169cc179c9cce2c3c0d5
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/KissenPaperCommandImplementation.java
@@ -0,0 +1,245 @@
+package net.kissenpvp.paper.command;
+
+import net.kissenpvp.core.api.command.annotations.CommandData;
+import net.kissenpvp.core.api.command.annotations.TabCompleter;
+import net.kissenpvp.core.api.command.executor.TabCompleterExecutor;
+import net.kissenpvp.core.base.KissenImplementation;
+import net.kissenpvp.core.command.KissenCommandImplementation;
+import net.kissenpvp.core.command.argument.MethodEvaluator;
+import net.kissenpvp.core.message.localization.KissenLocalizationImplementation;
+import net.kissenpvp.paper.api.command.KissenCommand;
+import net.kissenpvp.paper.api.command.PaperArgumentParser;
+import net.kissenpvp.paper.api.command.PaperCommandImplementation;
+import net.kissenpvp.paper.command.command.KissenPaperAbstractCommand;
+import net.kissenpvp.paper.command.command.plugin.KissenPaperPluginCommand;
+import net.kissenpvp.paper.command.command.system.KissenPaperCommand;
+import net.kissenpvp.paper.command.executor.KissenPaperCommandExecutor;
+import net.kissenpvp.paper.command.executor.KissenPaperCompleteExecutor;
+import net.kissenpvp.paper.command.parser.*;
+import net.kissenpvp.paper.command.target.KissenPaperTargetValidator;
+import net.kyori.adventure.text.format.NamedTextColor;
+import org.bukkit.Bukkit;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandMap;
+import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.entity.Player;
+import org.bukkit.plugin.Plugin;
+import org.jetbrains.annotations.NotNull;
+
+import java.lang.reflect.Method;
+import java.text.MessageFormat;
+import java.util.Optional;
+
+/**
+ * Represents a Kissen Paper command implementation that extends the functionality of the Kissen command framework
+ * and is compatible with the Paper server platform.
+ * <p>
+ * This class extends {@link KissenCommandImplementation} and implements the {@link PaperCommandImplementation} interface
+ * to provide specialized command handling and execution functionality tailored for the Paper server platform.
+ * It integrates seamlessly with the Kissen command framework and enhances it with Paper-specific features.
+ */
+public class KissenPaperCommandImplementation extends KissenCommandImplementation implements PaperCommandImplementation, KissenImplementation {
+
+    private final MethodEvaluator<CommandSender> methodEvaluator;
+    private final KissenPaperTargetValidator kissenPaperTargetValidator;
+
+    /**
+     * Constructs a new instance of {@link KissenPaperCommandImplementation}.
+     * <p>
+     * This constructor initializes the {@link MethodEvaluator} and {@link KissenPaperTargetValidator} instances used by this
+     * Kissen Paper command implementation for evaluating command methods and validating command execution targets.
+     */
+    public KissenPaperCommandImplementation() {
+        super();
+
+        this.methodEvaluator = new MethodEvaluator<>();
+        this.kissenPaperTargetValidator = new KissenPaperTargetValidator();
+
+        registerParser(String.class, new StringParser());
+        registerParser(Byte.class, new ByteParser());
+        registerParser(Short.class, new ShortParser());
+        registerParser(Integer.class, new IntegerParser());
+        registerParser(Float.class, new FloatParser());
+        registerParser(Double.class, new DoubleParser());
+        registerParser(Long.class, new LongParser());
+        registerParser(Character.class, new CharacterParser());
+        registerParser(Boolean.class, new BooleanParser());
+
+        // we love java, right?
+        registerParser(Byte.TYPE, new ByteParser());
+        registerParser(Short.TYPE, new ShortParser());
+        registerParser(Integer.TYPE, new IntegerParser());
+        registerParser(Float.TYPE, new FloatParser());
+        registerParser(Double.TYPE, new DoubleParser());
+        registerParser(Long.TYPE, new LongParser());
+        registerParser(Character.TYPE, new CharacterParser());
+        registerParser(Boolean.TYPE, new BooleanParser());
+
+        // Advanced
+        registerParser(Player.class, new PlayerParser());
+        registerParser(NamedTextColor.class, new NamedTextColorParser());
+
+    }
+
+    @Override
+    public boolean start() {
+
+        KissenLocalizationImplementation localizationImplementation = Bukkit.getKissen().getImplementation(KissenLocalizationImplementation.class);
+        localizationImplementation.register("server.command.incorrect-usage", new MessageFormat("It appears that the command usage is not correct. Please refer to the commands help."));
+        localizationImplementation.register("server.command.player.offline", new MessageFormat("The player {0} seems to be offline."));
+        localizationImplementation.register("server.command.unknown", new MessageFormat("Unknown command. Type \"/help\" for help."));
+
+        return super.start();
+    }
+
+    @Override
+    public void setupComplete() {
+        registerCommand(new TestCommand());
+        KissenImplementation.super.setupComplete();
+    }
+
+    @Override
+    public @NotNull Optional<KissenCommand> getCommand(@NotNull String name) {
+        Command command = getCommandMap().getCommand(name);
+        if (command instanceof KissenPaperAbstractCommand<?> kissenPaperAbstractCommand) {
+            return Optional.of(kissenPaperAbstractCommand);
+        }
+        return Optional.empty();
+    }
+
+    @Override
+    public void registerCommand(@NotNull Plugin plugin, @NotNull Object... objects) {
+        for (Object object : objects) {
+            for (Method method : object.getClass().getDeclaredMethods()) {
+                injectObjectMethod(plugin, object, method);
+            }
+        }
+    }
+
+    public void registerCommand(@NotNull Object... objects) {
+        for (Object object : objects) {
+            for (Method method : object.getClass().getDeclaredMethods()) {
+                injectObjectMethod(object, method);
+            }
+        }
+    }
+
+    @Override
+    public void registerCompleter(@NotNull Plugin plugin, @NotNull String name, @NotNull TabCompleterExecutor<CommandSender> tabCompleterExecutor) {
+        getCommand(name).filter(kissenCommand -> kissenCommand instanceof KissenPaperPluginCommand kissenPaperPluginCommand && kissenPaperPluginCommand.getPlugin()
+                .equals(plugin)).orElse(buildCommand(plugin, name)).initCompleter(tabCompleterExecutor);
+    }
+
+    public void registerCompleter(@NotNull String name, @NotNull TabCompleterExecutor<CommandSender> tabCompleterExecutor) {
+        getCommand(name).filter(kissenCommand -> kissenCommand instanceof KissenPaperCommand).orElse(buildCommand(name)).initCompleter(tabCompleterExecutor);
+    }
+
+    @Override
+    public boolean unregisterCommand(@NotNull String name) {
+        Command command = getCommandMap().getCommand(name);
+        return command != null && command.unregister(getCommandMap()) && getCommandMap().getKnownCommands()
+                .remove(name) != null;
+    }
+
+    @Override
+    public <T> void registerParser(@NotNull Class<T> type, @NotNull PaperArgumentParser<T> argumentParser) {
+        super.registerParser(type, argumentParser);
+    }
+
+    /**
+     * Returns the {@link MethodEvaluator} associated with this Kissen Paper command executor.
+     * <p>
+     * This method retrieves and returns the {@link MethodEvaluator} instance that is used by this Kissen Paper command executor
+     * to evaluate and process command arguments and parameters.
+     *
+     * @return The {@link MethodEvaluator} associated with this Kissen Paper command executor.
+     */
+    public MethodEvaluator<CommandSender> getMethodEvaluator() {
+        return methodEvaluator;
+    }
+
+    /**
+     * Returns the {@link KissenPaperTargetValidator} associated with this Kissen Paper command executor.
+     * <p>
+     * This method retrieves and returns the {@link KissenPaperTargetValidator} instance that is used by this Kissen Paper command executor
+     * to validate and process the target of the command execution.
+     *
+     * @return The {@link KissenPaperTargetValidator} associated with this Kissen Paper command executor.
+     */
+    public KissenPaperTargetValidator getKissenPaperTargetValidator() {
+        return kissenPaperTargetValidator;
+    }
+
+    private void injectObjectMethod(@NotNull Plugin plugin, @NotNull Object object, @NotNull Method method) {
+        final CommandData command = method.getAnnotation(CommandData.class);
+        if (command != null) {
+            KissenPaperPluginCommand kissenPaperPluginCommand = buildCommand(plugin, command.value());
+            kissenPaperPluginCommand.initCommand(command, new KissenPaperCommandExecutor(method, object));
+        }
+
+        TabCompleter completer = method.getAnnotation(TabCompleter.class);
+        if (completer != null) {
+            registerCompleter(plugin, completer.command(), new KissenPaperCompleteExecutor(method, object));
+        }
+    }
+
+    private void injectObjectMethod(@NotNull Object object, @NotNull Method method) {
+        final CommandData command = method.getAnnotation(CommandData.class);
+        if (command != null) {
+            KissenPaperCommand kissenPaperCommand = buildCommand(command.value());
+            kissenPaperCommand.initCommand(command, new KissenPaperCommandExecutor(method, object));
+        }
+
+        TabCompleter completer = method.getAnnotation(TabCompleter.class);
+        if (completer != null) {
+            registerCompleter(completer.command(), new KissenPaperCompleteExecutor(method, object));
+        }
+    }
+
+    private @NotNull KissenPaperPluginCommand buildCommand(@NotNull Plugin plugin, @NotNull String name) {
+        return (KissenPaperPluginCommand) buildCommand(name, new RootCommandFactory() {
+            @Override
+            public @NotNull KissenPaperAbstractCommand<?> constructCommand(@NotNull String name) {
+                return new KissenPaperPluginCommand(plugin, name.split("\\.")[0], 0);
+            }
+        }, plugin.getName());
+    }
+
+    private @NotNull KissenPaperCommand buildCommand(@NotNull String name) {
+        return (KissenPaperCommand) buildCommand(name, new RootCommandFactory() {
+            @Override
+            public @NotNull KissenPaperAbstractCommand<?> constructCommand(@NotNull String name) {
+                return new KissenPaperCommand(name.split("\\.")[0], 0);
+            }
+        }, "kissenpaper");
+    }
+
+    private @NotNull KissenCommand buildCommand(@NotNull String name, @NotNull KissenPaperCommandImplementation.RootCommandFactory rootCommandFactory, @NotNull String fallback) {
+        String rootName = name.split("\\.")[0];
+        KissenPaperAbstractCommand<?> command = (KissenPaperAbstractCommand<?>) getCommand(rootName).orElseGet(() -> buildRootCommand(rootCommandFactory, fallback, rootName));
+        if (!name.equals(rootName)) {
+            command = command.createRecursive(name);
+        }
+        return command;
+    }
+
+    @NotNull
+    private KissenCommand buildRootCommand(@NotNull RootCommandFactory rootCommandFactory, @NotNull String fallback, String rootName) {
+        CommandMap commandMap = getCommandMap();
+        KissenCommand kissenCommand = rootCommandFactory.constructCommand(rootName);
+        kissenCommand.register(commandMap);
+        commandMap.register(fallback, kissenCommand);
+        ((CraftServer) Bukkit.getServer()).syncCommands();
+        return kissenCommand;
+    }
+
+    private @NotNull CommandMap getCommandMap() {
+        return Bukkit.getCommandMap();
+    }
+
+    @FunctionalInterface
+    private interface RootCommandFactory {
+        @NotNull KissenPaperAbstractCommand<?> constructCommand(@NotNull String name);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/TestCommand.java b/src/main/java/net/kissenpvp/paper/command/TestCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..43496d9213db9ca43dd0bc15016e9684699bfc51
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/TestCommand.java
@@ -0,0 +1,38 @@
+package net.kissenpvp.paper.command;
+
+import net.kissenpvp.core.api.ban.Ban;
+import net.kissenpvp.core.api.ban.BanOperator;
+import net.kissenpvp.core.api.ban.BanType;
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.core.api.command.annotations.CommandData;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.paper.api.ban.PaperBanImplementation;
+import net.kissenpvp.paper.api.networking.client.entity.PaperPlayerClient;
+import net.kyori.adventure.text.Component;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+
+public class TestCommand
+{
+
+    @CommandData("test")
+    public boolean command(CommandPayload<CommandSender> commandPayload) {
+
+        PaperBanImplementation paperBanImplementation = Bukkit.getKissen().getImplementation(PaperBanImplementation.class);
+        try {
+            Ban ban = paperBanImplementation.createBan(0, "Hacking", BanType.MUTE);
+            ((PaperPlayerClient) commandPayload.getSender()).punish(ban, new BanOperator() {
+                @Override
+                public @NotNull Component displayName() {
+                    return Component.text("Console");
+                }
+            });
+        } catch (BackendException backendException) {
+            backendException.printStackTrace();
+        }
+
+
+        return true;
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/command/KissenPaperAbstractCommand.java b/src/main/java/net/kissenpvp/paper/command/command/KissenPaperAbstractCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..d0b072ce6409a2e47c51491dca7813353a3274f4
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/command/KissenPaperAbstractCommand.java
@@ -0,0 +1,375 @@
+package net.kissenpvp.paper.command.command;
+
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.core.api.command.annotations.CommandData;
+import net.kissenpvp.core.api.command.executor.CommandExecutor;
+import net.kissenpvp.core.api.command.executor.TabCompleterExecutor;
+import net.kissenpvp.core.command.CommandHolder;
+import net.kissenpvp.core.command.CommandInfo;
+import net.kissenpvp.paper.api.command.KissenCommand;
+import net.kissenpvp.paper.command.KissenPaperCommandImplementation;
+import net.kissenpvp.paper.command.command.system.KissenPaperChildCommand;
+import net.kissenpvp.paper.command.executor.KissenPaperCommandExecutor;
+import net.kissenpvp.paper.command.target.KissenPaperTargetValidator;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandException;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.*;
+
+/**
+ * Represents a command implementation specific to the Kissen Paper framework.
+ * <p>
+ * This class extends the {@link KissenCommand} class and serves as a command implementation tailored for the Kissen Paper framework.
+ * It provides functionality for creating and managing sub-commands within the Kissen Paper command hierarchy.
+ */
+public abstract class KissenPaperAbstractCommand<C extends KissenPaperAbstractCommand<C>> extends KissenCommand implements CommandHolder<CommandSender, C> {
+
+    private final int position;
+    private final List<C> children; //C can be plugin child or system child
+    private CommandInfo commandInfo;
+    private CommandExecutor<CommandSender> commandExecutor;
+    private TabCompleterExecutor<CommandSender> tabExecutor;
+
+    /**
+     * Constructs a new {@link KissenPaperAbstractCommand} instance with the provided plugin, name, and position.
+     * <p>
+     * This constructor is used to create a new {@link KissenPaperAbstractCommand} instance with the specified plugin, command name, and position in the command hierarchy.
+     *
+     * @param name     The name of the command. Must not be null.
+     * @param position The position of the command in the command hierarchy.
+     * @throws NullPointerException If either the {@code plugin} or {@code name} parameter is null.
+     */
+    public KissenPaperAbstractCommand(@NotNull String name, int position) {
+        super(name);
+        this.position = position;
+        this.children = new ArrayList<>();
+    }
+
+    protected @NotNull CommandExecutor<CommandSender> getCommandExecutor() {
+        return commandExecutor;
+    }
+
+    @Override
+    public int getPosition() {
+        return position;
+    }
+
+    @Override
+    public @NotNull CommandExecutor<CommandSender> getExecutor() {
+        return commandExecutor;
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<C> getChildCommandList() {
+        return Collections.unmodifiableList(children);
+    }
+
+    @Override
+    public @NotNull Optional<C> getChildCommand(@NotNull String name) {
+        return getChildCommandList().stream().filter(child -> child.equals(name)).findFirst();
+    }
+
+    @Override
+    public @NotNull CommandInfo getCommandInfo() {
+        return commandInfo;
+    }
+
+    @Override
+    public boolean execute(@NotNull CommandSender sender, @NotNull String commandLabel, @NotNull String[] args) {
+
+        if (!validate(sender)) {
+            return false;
+        }
+
+        if (args.length > 0) {
+            Boolean data = getChildCommand(args[0]).map(command -> command.execute(sender, commandLabel, Arrays.copyOfRange(args, 1, args.length)))
+                    .orElse(null);
+            if (data != null) {
+                return data;
+            }
+        }
+
+        if (commandExecutor == null) {
+            return false;
+        }
+
+        final KissenPaperCommandPayload kissenPaperCommandPayload = new KissenPaperCommandPayload(commandLabel, sender, getTargetValidator().parseSender(sender), args, this);
+
+        if (commandInfo.isAsync()) {
+            runAsync(kissenPaperCommandPayload);
+            return true;
+        }
+
+        return commandExecutor.execute(kissenPaperCommandPayload);
+    }
+
+    @Override
+    public @NotNull List<String> tabComplete(@NotNull CommandSender sender, @NotNull String alias, @NotNull String[] args) throws IllegalArgumentException {
+
+        List<String> result = new ArrayList<>();
+
+        if (!validate(sender)) {
+            return result;
+        }
+
+        if (!(result = obtainChildrenTabSuggestions(sender, alias, args).orElse(obtainTabSuggestions(sender, args, new KissenPaperCommandPayload(alias, sender, getTargetValidator().parseSender(sender), args, this)))).isEmpty()) {
+            return result;
+        }
+
+        return super.tabComplete(sender, alias, args);
+    }
+
+    @Override
+    public @NotNull String getFullName() {
+        return getCommandInfo().getName();
+    }
+
+    /**
+     * Initializes the {@link KissenPaperAbstractCommand} with the provided command information and executor.
+     * <p>
+     * This method is used to initialize the properties and behavior of the {@link KissenPaperAbstractCommand} based on the given command information and executor.
+     *
+     * @param commandData     The {@link CommandData} containing details about the command. Must not be null.
+     * @param commandExecutor The {@link CommandExecutor} responsible for executing the command logic. Must not be null.
+     * @throws NullPointerException If either the {@code commandInfo} or {@code commandExecutor} parameter is null.
+     */
+    public void initCommand(@NotNull CommandData commandData, @NotNull CommandExecutor<CommandSender> commandExecutor) {
+        this.commandInfo = new CommandInfo(commandData);
+        this.commandExecutor = commandExecutor;
+
+        setAliases(Arrays.asList(commandInfo.getAliases()));
+
+        if (commandInfo.isPermissionRequired() && !commandInfo.getPermission().isBlank()) {
+            setPermission(commandInfo.getPermission());
+        }
+
+        String usage = commandInfo.getUsage();
+        if (!usage.isBlank()) {
+            setUsage(usage);
+        } else if (getCommandExecutor() instanceof KissenPaperCommandExecutor kissenPaperCommandExecutor) {
+            setUsage(kissenPaperCommandExecutor.getEvaluator().buildUsage(getName()));
+        }
+
+        String description = commandInfo.getDescription();
+        if (!description.isBlank()) {
+            setDescription(description);
+        }
+
+        if (commandExecutor instanceof KissenPaperCommandExecutor kissenPaperCommandExecutor) {
+            kissenPaperCommandExecutor.setKissenPaperCommand(this);
+        }
+    }
+
+    /**
+     * Initializes the tab completer for the {@link KissenPaperAbstractCommand} instance.
+     * <p>
+     * This method is used to set the tab completer for the current {@link KissenPaperAbstractCommand} instance.
+     * It allows the registration of a {@link TabCompleterExecutor} to handle tab completion logic for the command.
+     *
+     * @param tabExecutor The {@link TabCompleterExecutor} responsible for tab completion of the command. Must not be null.
+     * @throws IllegalStateException If the tab completer has already been initialized for this command.
+     */
+    public final void initCompleter(@NotNull TabCompleterExecutor<CommandSender> tabExecutor) {
+        if (this.tabExecutor != null) {
+            throw new IllegalStateException("Completer already initialized");
+        }
+
+        this.tabExecutor = tabExecutor;
+    }
+
+    /**
+     * Creates a recursive {@link KissenPaperAbstractCommand} hierarchy based on the given sub-command name.
+     * <p>
+     * This method is used to create a recursive hierarchy of {@link KissenPaperAbstractCommand} instances based on a provided sub-command name.
+     * The hierarchy is established by traversing the sub-command name and creating child commands accordingly.
+     * If the sub-command name is already at the current command's position, the method returns the current command itself.
+     *
+     * @param name The sub-command name representing the recursive hierarchy. Must not be null.
+     * @return The final {@link KissenPaperAbstractCommand} instance at the bottom of the recursive hierarchy.
+     * @throws NullPointerException If the provided {@code name} parameter is null.
+     */
+    public @NotNull KissenPaperAbstractCommand<C> createRecursive(String name) {
+
+        int position = getPosition() + (name.split("\\.").length - 1);
+        if (position == getPosition()) {
+            return this;
+        }
+
+        String subName = name.substring(Math.max(name.indexOf('.') + 1, 0));
+
+        int index = subName.indexOf('.');
+        String nextSubCommand;
+        if (index != -1) {
+            nextSubCommand = subName.substring(0, index);
+        } else {
+            nextSubCommand = subName;
+        }
+
+        return getChildCommand(nextSubCommand).orElseGet(() -> {
+            C kissenPaperChildCommand = createChildCommand(nextSubCommand, KissenPaperAbstractCommand.this);
+            children.add(kissenPaperChildCommand);
+            return kissenPaperChildCommand;
+        }).createRecursive(subName);
+    }
+
+
+    /**
+     * Creates and registers a new {@link KissenPaperChildCommand} as a child command of this command.
+     * <p>
+     * This method is used to create a new {@link KissenPaperChildCommand} instance with the provided subcommand name and
+     * registers it as a child command of the current command. The newly created child command is added to the list of children
+     * for this command.
+     *
+     * @param nextSubCommand The name of the subcommand to create. Must not be null.
+     * @return The newly created and registered {@link KissenPaperChildCommand} instance.
+     * @throws NullPointerException If the {@code nextSubCommand} parameter is null.
+     */
+    protected abstract @NotNull C createChildCommand(@NotNull String nextSubCommand, @NotNull KissenPaperAbstractCommand<C> parent);
+
+    /**
+     * Validates whether a command can be executed by the given {@link CommandSender}.
+     * <p>
+     * This method is used to validate whether a command can be executed by the provided {@link CommandSender}.
+     * Validation checks may include verifying the plugin's enabled status, the type of command sender, and other conditions.
+     *
+     * @param commandSender The {@link CommandSender} attempting to execute the command. Must not be null.
+     * @return {@code true} if the command can be executed by the given command sender, {@code false} otherwise.
+     * @throws CommandException     If the plugin associated with the command is not enabled.
+     * @throws NullPointerException If the provided {@code commandSender} parameter is null.
+     */
+    public boolean validate(@NotNull CommandSender commandSender) {
+        return getTargetValidator().validate(getCommandInfo().getTarget(), commandSender);
+    }
+
+    /**
+     * Retrieves the {@link KissenPaperTargetValidator} associated with the command implementation.
+     * <p>
+     * This method is used to obtain the {@link KissenPaperTargetValidator} that is responsible for validating target entities
+     * related to the execution of a command. The validator is specific to the Kissen Paper command implementation.
+     *
+     * @return The {@link KissenPaperTargetValidator} associated with the command implementation.
+     */
+    public @NotNull KissenPaperTargetValidator getTargetValidator() {
+        return Bukkit.getKissen()
+                .getImplementation(KissenPaperCommandImplementation.class)
+                .getKissenPaperTargetValidator();
+    }
+
+    /**
+     * Asynchronously executes the function defined in the command payload.
+     *
+     * <p>This abstract method facilitates asynchronous execution of code paths within commands,
+     * which can be useful when performing potentially lengthy operations such as file access or network communication.
+     * This prevents blocking operations from freezing the thread that the command is currently executing on,
+     * helping avoid potential server lag or non-responsiveness.</p>
+     *
+     * <p>All subclasses must provide an implementation for this method, ensuring that the command payload function is run asynchronously.
+     * The implementation may use the server's scheduler, a thread pool, or any other method of asynchronous execution.</p>
+     *
+     * @param payload A CommandPayload object that encapsulates the command, sender, command related data and a function to execute.
+     *                The exact function varies among different commands and is defined when the payload is constructed.
+     */
+    public abstract void runAsync(@NotNull CommandPayload<CommandSender> payload);
+
+    /**
+     * Attempts to obtain tab completion suggestions from child commands based on the user's current input.
+     *
+     * <p>This method is mainly used to delegate tab completion to child commands when the user has already entered at least one argument and a space.</p>
+     *
+     * <p>When the length of the provided arguments array is greater than 1 (indicating the user has entered some command followed by a space),
+     * the method retrieves the corresponding child command from the second to the last argument provided by the sender.</p>
+     *
+     * <p>If a corresponding child command is found, it delegates the tab completion to that command, passing the sender, alias, and all
+     * arguments excluding the first one (considering command as first). The result of this tab completion is then returned as an Optional.</p>
+     *
+     * <p>If no corresponding child command is found or if the length of provided argument array is less or equal to 1 (indicating user didn't type space after the command),
+     * the method returns an empty Optional.</p>
+     *
+     * @param sender The initiator of the command, used to provide context for the child command's tab completion
+     * @param alias  The used alias of the command, provided to offer context for child command's tab completion
+     * @param args   An array encapsulating the arguments inputted by the sender, used to deduce the corresponding child command and to provide
+     *               content to the child command's tab completion
+     * @return An Optional encapsulating a List of Strings which, if present, includes tab completion suggestions derived from the relevant child command
+     */
+    private @NotNull Optional<List<String>> obtainChildrenTabSuggestions(@NotNull CommandSender sender, @NotNull String alias, @NotNull String[] args) {
+        if (args.length > 1) {
+            return getChildCommand(args[args.length - 2]).map(commandHolders -> commandHolders.tabComplete(sender, alias, Arrays.copyOfRange(args, 1, args.length)));
+        }
+        return Optional.empty();
+    }
+
+
+    /**
+     * Obtains a list of tab completion suggestions for a given command.
+     *
+     * <p>This function primarily retrieves possible suggestions either from a custom tabExecutor or an automatic
+     * suggestion generator based on defined child commands and the command executor.</p>
+     *
+     * <p>If a tabExecutor is defined (not null), it is used to execute the commandSenderCommandPayload and generates a list of suggestions.</p>
+     *
+     * <p>If there is no tabExecutor assigned (null), the method defaults to obtaining suggestions through the obtainAutoSuggestions method,
+     * which populates suggestions based on child commands and the command executor (if applicable).</p>
+     *
+     * <p>The collected suggestions are sorted in ascending order (case-insensitive) and returned as a list.</p>
+     *
+     * @param sender                      The sender of the command. It serves as a reference for permission checks and establishes context for suggestion generation.
+     * @param args                        An array containing the arguments provided by the sender. It is used in the obtainAutoSuggestions method to generate relevant command completions.
+     * @param commandSenderCommandPayload A CommandPayload object encapsulating command related data. It is passed to either the tabExecutor or the obtainAutoSuggestions method for further processing.
+     * @return A List of Strings representing possible command completions. The list is sorted in case-insensitive order.
+     */
+    private @NotNull List<String> obtainTabSuggestions(@NotNull CommandSender sender, @NotNull String @NotNull [] args, CommandPayload<CommandSender> commandSenderCommandPayload) {
+        List<String> suggestions = new ArrayList<>(tabExecutor != null ? tabExecutor.execute(commandSenderCommandPayload) : obtainAutoSuggestions(sender, args, commandSenderCommandPayload));
+        suggestions.sort(String.CASE_INSENSITIVE_ORDER);
+        return suggestions;
+    }
+
+    /**
+     * This method retrieves auto suggestions for command completion based on the user's current input.
+     *
+     * <p>The primary function of this method is to generate automatic suggestions using the list
+     * of child commands and the command executor (if applicable).</p>
+     *
+     * <p>The method starts by checking if any child commands exist and whether the command sender has supplied any arguments.
+     *
+     * <p>Moreover, if the a command executor belongs to instance of KissenPaperCommandExecutor, the evaluator corresponding to
+     * the user's current command is retrieved based on the number of arguments provided by the sender. The argument parser from the
+     * evaluator then provides tab completion options based on the context of the sender's current command. These options are also added to the
+     * list of auto suggestions provided.</p>
+     *
+     * @param sender                      The identifier of the command, used to check permissions and providing command context to the command executor and tab completion options
+     * @param args                        An array of arguments that command sender provided, used to find the next expected argument in the child command
+     *                                    and to find the last argument for comparison with child command names
+     * @param commandSenderCommandPayload A command payload object containing context for the command sender, arguments and other command-related data.
+     *                                    It is used to get the completion options from the evaluator's command argument parser.
+     * @return A List of Strings populated with auto suggestions for the user's current command input
+     */
+    private @NotNull List<String> obtainAutoSuggestions(@NotNull CommandSender sender, @NotNull String @NotNull [] args, CommandPayload<CommandSender> commandSenderCommandPayload) {
+        List<String> suggestions = new ArrayList<>();
+        if (!getChildCommandList().isEmpty() && args.length != 0) {
+
+            for (C command : getChildCommandList()) {
+                if (command.getPosition() == args.length && (command.getName()
+                        .toLowerCase()
+                        .startsWith(args[args.length - 1].toLowerCase())) && command.testPermissionSilent(sender)) {
+                    suggestions.add(command.getName());
+                }
+            }
+        }
+
+        if (getCommandExecutor() instanceof KissenPaperCommandExecutor kissenPaperCommandExecutor) {
+            if (kissenPaperCommandExecutor.getEvaluator()
+                    .arguments()
+                    .size() >= commandSenderCommandPayload.getArgumentCount()) {
+                suggestions.addAll(kissenPaperCommandExecutor.getEvaluator()
+                        .arguments()
+                        .get(commandSenderCommandPayload.getArgumentCount())
+                        .argumentParser()
+                        .tabCompletion(commandSenderCommandPayload));
+            }
+        }
+        return suggestions;
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/command/KissenPaperCommandPayload.java b/src/main/java/net/kissenpvp/paper/command/command/KissenPaperCommandPayload.java
new file mode 100644
index 0000000000000000000000000000000000000000..2a200f6850dbd69a940f9c1377390cbfff878bb6
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/command/KissenPaperCommandPayload.java
@@ -0,0 +1,87 @@
+package net.kissenpvp.paper.command.command;
+
+import net.kissenpvp.core.api.command.ArgumentParser;
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.core.api.command.CommandTarget;
+import net.kissenpvp.core.api.networking.client.entitiy.ServerEntity;
+import net.kissenpvp.core.api.permission.PermissionEntry;
+import net.kissenpvp.core.command.CommandHolder;
+import net.kissenpvp.paper.command.KissenPaperCommandImplementation;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+
+import java.lang.reflect.Array;
+
+public class KissenPaperCommandPayload implements CommandPayload<CommandSender> {
+
+    private final String label;
+    private final CommandSender sender;
+    private final CommandTarget target;
+    private final String[] args;
+    private final CommandHolder<?, ?> commandHolder;
+
+    public KissenPaperCommandPayload(String label, CommandSender sender, CommandTarget target, String[] args, CommandHolder<?, ?> commandHolder) {
+        this.label = label;
+        this.sender = sender;
+        this.target = target;
+        this.args = args;
+        this.commandHolder = commandHolder;
+    }
+
+    public CommandHolder<?, ?> getCommandHolder() {
+        return commandHolder;
+    }
+
+    @Override
+    public @NotNull String getLabel() {
+        return label;
+    }
+
+    @Override
+    public @NotNull CommandSender getSender() {
+        return sender;
+    }
+
+    @Override
+    public @NotNull CommandTarget getTarget() {
+        return target;
+    }
+
+    @Override
+    public @NotNull String[] getArguments() {
+        return args;
+    }
+
+    @Override
+    public <T> @NotNull T[] getArgument(int from, int to, @NotNull Class<T> type) throws ArrayIndexOutOfBoundsException {
+
+        KissenPaperCommandImplementation kissenPaperCommandImplementation = Bukkit.getKissen()
+                .getImplementation(KissenPaperCommandImplementation.class);
+
+        final ArgumentParser<?, ?> adapter = kissenPaperCommandImplementation.getParserList().get(type);
+        final T[] instance = (T[]) Array.newInstance(type, to - from);
+
+        for (int i = from; i <= to; i++) {
+            instance[i - from] = (T) kissenPaperCommandImplementation.deserialize(getArgument(i).orElseThrow(IllegalArgumentException::new), adapter);
+        }
+
+        return instance;
+    }
+
+    @Override
+    public boolean validate(@NotNull ServerEntity serverEntity) {
+
+        if (getCommandHolder().getCommandInfo()
+                .isPermissionRequired() && serverEntity instanceof PermissionEntry<?> permissionEntry) {
+
+            if (!permissionEntry.hasPermission(getCommandHolder().getCommandInfo().getPermission())) {
+                return false;
+            }
+        }
+
+        KissenPaperCommandImplementation kissenPaperCommandImplementation = Bukkit.getKissen()
+                .getImplementation(KissenPaperCommandImplementation.class);
+        return kissenPaperCommandImplementation.getKissenPaperTargetValidator().validate(getTarget(), serverEntity);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/command/plugin/KissenPaperPluginChildCommand.java b/src/main/java/net/kissenpvp/paper/command/command/plugin/KissenPaperPluginChildCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..b06ac7e55eebd2e80954b2a7a21874138eaea8aa
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/command/plugin/KissenPaperPluginChildCommand.java
@@ -0,0 +1,45 @@
+package net.kissenpvp.paper.command.command.plugin;
+
+import net.kissenpvp.paper.api.command.KissenCommand;
+import net.kissenpvp.paper.command.command.KissenPaperAbstractCommand;
+import org.bukkit.plugin.Plugin;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Optional;
+
+/**
+ * Represents a child command within the Kissen Paper command framework, specifically designed for plugin-related commands.
+ * <p>
+ * This class extends {@link KissenPaperPluginCommand} and provides functionality for creating and managing child commands
+ * related to a specific plugin. Child commands of this type belong to a parent plugin command and are organized in a hierarchical structure.
+ */
+public class KissenPaperPluginChildCommand extends KissenPaperPluginCommand {
+    private final KissenPaperAbstractCommand<KissenPaperPluginChildCommand> parent;
+
+    /**
+     * Constructs a new {@link KissenPaperPluginChildCommand} with the specified plugin, name, and parent command.
+     *
+     * @param plugin The plugin to which this child command belongs. Must not be null.
+     * @param name   The name of the child command. Must not be null.
+     * @param parent The parent command to which this child command belongs. Must not be null.
+     * @throws NullPointerException If any of the parameters is null.
+     */
+    public KissenPaperPluginChildCommand(@NotNull Plugin plugin, @NotNull String name, @NotNull KissenPaperAbstractCommand<KissenPaperPluginChildCommand> parent) {
+        super(plugin, name, parent.getPosition() + 1);
+        this.parent = parent;
+    }
+
+    @Override
+    public @NotNull String getFullName() {
+        return parent.getFullName() + " " + getName();
+    }
+
+    /**
+     * Returns an {@link Optional} containing the parent command to which this child command belongs.
+     *
+     * @return An {@link Optional} containing the parent command.
+     */
+    public @NotNull Optional<KissenCommand> getParentCommand() {
+        return Optional.of(parent);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/command/plugin/KissenPaperPluginCommand.java b/src/main/java/net/kissenpvp/paper/command/command/plugin/KissenPaperPluginCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..6df71a9f9ba7664270c8049a8658af00272ab874
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/command/plugin/KissenPaperPluginCommand.java
@@ -0,0 +1,66 @@
+package net.kissenpvp.paper.command.command.plugin;
+
+import io.papermc.paper.threadedregions.scheduler.ScheduledTask;
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.paper.command.command.KissenPaperAbstractCommand;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandException;
+import org.bukkit.command.CommandSender;
+import org.bukkit.plugin.Plugin;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Optional;
+
+/**
+ * Represents a top-level Kissen Paper command specifically designed for plugin-related commands.
+ * <p>
+ * This class extends {@link KissenPaperAbstractCommand} and provides functionality for creating and managing plugin-related commands.
+ * It is used as a container for subcommands related to a specific plugin and supports the creation of child commands using the specified parent command.
+ */
+public class KissenPaperPluginCommand extends KissenPaperAbstractCommand<KissenPaperPluginChildCommand> {
+
+    private final Plugin plugin;
+
+    public Plugin getPlugin() {
+        return plugin;
+    }
+
+    /**
+     * Constructs a new {@link KissenPaperAbstractCommand} instance with the provided plugin, name, and position.
+     * <p>
+     * This constructor is used to create a new {@link KissenPaperAbstractCommand} instance with the specified plugin, command name, and position in the command hierarchy.
+     *
+     * @param plugin   The {@link Plugin} that owns this command. Must not be null.
+     * @param name     The name of the command. Must not be null.
+     * @param position The position of the command in the command hierarchy.
+     * @throws NullPointerException If either the {@code plugin} or {@code name} parameter is null.
+     */
+    public KissenPaperPluginCommand(@NotNull Plugin plugin, @NotNull String name, int position) {
+        super(name, position);
+        this.plugin = plugin;
+    }
+
+    @Override
+    public @NotNull Optional<KissenPaperPluginChildCommand> getChildCommand(@NotNull String name) {
+        return super.getChildCommand(name);
+    }
+
+    @Override
+    public void runAsync(@NotNull CommandPayload<CommandSender> payload) {
+        Bukkit.getAsyncScheduler().runNow(getPlugin(), scheduledTask -> getCommandExecutor().execute(payload));
+    }
+
+    @Override
+    protected @NotNull KissenPaperPluginChildCommand createChildCommand(@NotNull String nextSubCommand, @NotNull KissenPaperAbstractCommand<KissenPaperPluginChildCommand> parent) {
+        return new KissenPaperPluginChildCommand(plugin, nextSubCommand, parent);
+    }
+
+    @Override
+    public boolean validate(@NotNull CommandSender commandSender) {
+        if (!this.plugin.isEnabled()) {
+            throw new CommandException(String.format("Plugin '%s' is not enabled.", plugin.getName()), new IllegalStateException());
+        }
+
+        return super.validate(commandSender);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/command/system/KissenPaperChildCommand.java b/src/main/java/net/kissenpvp/paper/command/command/system/KissenPaperChildCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..4ba32a6586d1681ae668695fccb8751e16527209
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/command/system/KissenPaperChildCommand.java
@@ -0,0 +1,45 @@
+package net.kissenpvp.paper.command.command.system;
+
+import net.kissenpvp.paper.api.command.KissenCommand;
+import net.kissenpvp.paper.command.command.KissenPaperAbstractCommand;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Optional;
+
+/**
+ * Represents a child command within the Kissen Paper command framework.
+ * <p>
+ * This class extends {@link KissenPaperCommand} and provides functionality for creating and managing child commands.
+ * Child commands are subcommands that belong to a parent command and are organized in a hierarchical structure.
+ */
+public class KissenPaperChildCommand extends KissenPaperCommand {
+
+    private final KissenPaperAbstractCommand<KissenPaperChildCommand> parent;
+
+    /**
+     * Constructs a new {@link KissenPaperChildCommand} with the specified name and parent command.
+     *
+     * @param name   The name of the child command. Must not be null.
+     * @param parent The parent command to which this child command belongs. Must not be null.
+     * @throws IllegalArgumentException If the {@code name} is null.
+     * @throws NullPointerException     If the {@code parent} is null.
+     */
+    public KissenPaperChildCommand(@NotNull String name, @NotNull KissenPaperAbstractCommand<KissenPaperChildCommand> parent) {
+        super(name, parent.getPosition() + 1);
+        this.parent = parent;
+    }
+
+    @Override
+    public @NotNull String getFullName() {
+        return parent.getFullName() + " " + getName();
+    }
+
+    /**
+     * Returns an {@link Optional} containing the parent command to which this child command belongs.
+     *
+     * @return An {@link Optional} containing the parent command.
+     */
+    public @NotNull Optional<KissenCommand> getParentCommand() {
+        return Optional.of(parent);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/command/system/KissenPaperCommand.java b/src/main/java/net/kissenpvp/paper/command/command/system/KissenPaperCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..76773747d9ebf60d04b509bbb0506872ff2006a4
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/command/system/KissenPaperCommand.java
@@ -0,0 +1,45 @@
+package net.kissenpvp.paper.command.command.system;
+
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.paper.command.command.KissenPaperAbstractCommand;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.scheduler.MinecraftInternalPlugin;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Represents a top-level Kissen Paper command within the command hierarchy.
+ * <p>
+ * This class extends {@link KissenPaperAbstractCommand} and provides functionality for creating and managing top-level Kissen Paper commands.
+ * It is used as a container for subcommands and supports the creation of child commands using the specified parent command.
+ */
+public class KissenPaperCommand extends KissenPaperAbstractCommand<KissenPaperChildCommand> {
+
+    static final MinecraftInternalPlugin MINECRAFT;
+
+    static
+    {
+        MINECRAFT = new MinecraftInternalPlugin();
+    }
+
+    /**
+     * Constructs a new {@link KissenPaperCommand} with the specified name and position.
+     *
+     * @param name     The name of the command. Must not be null.
+     * @param position The position of the command. Must be non-negative.
+     * @throws IllegalArgumentException If the {@code name} is null or if the {@code position} is negative.
+     */
+    public KissenPaperCommand(@NotNull String name, int position) {
+        super(name, position);
+    }
+
+    @Override
+    public void runAsync(@NotNull CommandPayload<CommandSender> payload) {
+        Bukkit.getAsyncScheduler().runNow(MINECRAFT, (scheduledTask) -> getCommandExecutor().execute(payload));
+    }
+
+    @Override
+    protected @NotNull KissenPaperChildCommand createChildCommand(@NotNull String nextSubCommand, @NotNull KissenPaperAbstractCommand<KissenPaperChildCommand> parent) {
+        return new KissenPaperChildCommand(nextSubCommand, parent);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/executor/KissenPaperCommandExecutor.java b/src/main/java/net/kissenpvp/paper/command/executor/KissenPaperCommandExecutor.java
new file mode 100644
index 0000000000000000000000000000000000000000..88b7b16f775bf9d0a7924832d07e0d85073b447f
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/executor/KissenPaperCommandExecutor.java
@@ -0,0 +1,133 @@
+package net.kissenpvp.paper.command.executor;
+
+import net.kissenpvp.core.api.command.ArgumentParser;
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.core.api.command.exception.CommandException;
+import net.kissenpvp.core.api.command.executor.CommandExecutor;
+import net.kissenpvp.core.api.networking.client.entitiy.PlayerOfflineException;
+import net.kissenpvp.core.command.argument.Argument;
+import net.kissenpvp.core.command.argument.ArgumentEvaluator;
+import net.kissenpvp.paper.command.KissenPaperCommandImplementation;
+import net.kissenpvp.paper.command.command.KissenPaperAbstractCommand;
+import net.kyori.adventure.text.Component;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+
+public class KissenPaperCommandExecutor implements CommandExecutor<CommandSender> {
+
+    private final Method method;
+
+    private final Object holder;
+
+    private final ArgumentEvaluator<CommandSender> evaluator;
+    private final boolean useMethodValue;
+    private KissenPaperAbstractCommand<?> kissenPaperCommand;
+
+    public KissenPaperCommandExecutor(@NotNull Method method, @NotNull Object holder) {
+        final Class<?> returnType = method.getReturnType();
+
+        if (!returnType.equals(Void.TYPE) && !returnType.equals(Boolean.TYPE)) {
+            throw new IllegalArgumentException(String.format("The return type %s cannot be processed.", returnType.getName()));
+        }
+
+
+        this.method = method;
+        this.holder = holder;
+
+        this.evaluator = new ArgumentEvaluator<>(Bukkit.getKissen()
+                .getImplementation(KissenPaperCommandImplementation.class)
+                .getMethodEvaluator()
+                .evaluateMethod(method));
+
+        useMethodValue = returnType.equals(Boolean.TYPE);
+    }
+
+    @Override
+    public boolean execute(@NotNull CommandPayload<CommandSender> context) {
+        return invokeCommand(context);
+    }
+
+    /**
+     * Invokes a command method associated with this command handler using the provided context.
+     * <p>
+     * This method is used to invoke a command method based on the given command context.
+     * The command method is typically defined in a class and is invoked based on the evaluation of command arguments and conditions.
+     *
+     * @param context The {@link CommandPayload} representing the command execution context, containing the command sender and arguments. Must not be null.
+     * @return {@code true} if the command method was successfully invoked, {@code false} if no method value is expected and the method was invoked successfully.
+     * @throws CommandException     If an error occurs while processing the command, such as an illegal access or invocation target exception.
+     * @throws NullPointerException If the provided {@code context} parameter is null.
+     */
+    public boolean invokeCommand(@NotNull CommandPayload<CommandSender> context) {
+        try {
+            if (evaluator.arguments().isEmpty()) {
+                if (useMethodValue) {
+                    return (boolean) method.invoke(holder);
+                }
+                method.invoke(holder);
+                return true;
+            }
+
+            Object[] parameter = evaluator.parseArguments(context);
+
+            if (useMethodValue) {
+                return (boolean) method.invoke(holder, parameter);
+            }
+            method.invoke(holder, parameter);
+            return true;
+        } catch (CommandException commandException) {
+            processError(context, commandException.getCause());
+            return false;
+        } catch (IllegalAccessException | InvocationTargetException exception) {
+            throw new CommandException(String.format("An error occurred while processing the command '%s'.", context.getLabel()), exception);
+        }
+    }
+
+    /**
+     * Processes the specified error, typically thrown during command invocation, by applying a defined error handling strategy.
+     * <p>
+     * The {@code processError} method is a private helper method used within this class to isolate the error processing logic from the main command invocation logic implemented in the {@code invokeCommand} method.
+     * This method gets invoked when a {@link CommandException} is caught in the main method and is handed the cause of the exception for further processing.
+     * This method currently has no implementation (TODO) and hence no error processing is performed at the moment. A suitable implementation could, for example, entail logging the error in a specific way, transforming
+     * the error into another form, or handling the error based on its type or content, etc.
+     *
+     * @param cause The {@link Throwable} that caused the method invocation to fail. This parameter must not be null.
+     * @throws NullPointerException If the provided {@code cause} parameter is null.
+     */
+    private void processError(@NotNull CommandPayload<CommandSender> context, @NotNull Throwable cause) {
+
+        Component component = null;
+        if(cause instanceof NullPointerException)
+        {
+            component = Component.translatable("messages.command.error.incorrect-usage");
+        } else if(cause instanceof PlayerOfflineException playerOfflineException)
+        {
+            component = Component.translatable("messages.command.error.player-offline", Component.text(playerOfflineException.getName()));
+        }
+
+        if(component != null)
+        {
+            context.getSender().sendMessage(component);
+            return;
+        }
+
+        throw new CommandException(cause);
+    }
+
+    public @NotNull ArgumentEvaluator<CommandSender> getEvaluator() {
+        return evaluator;
+    }
+
+    public KissenPaperAbstractCommand<?> getKissenPaperCommand() {
+        return kissenPaperCommand;
+    }
+
+    public void setKissenPaperCommand(@NotNull KissenPaperAbstractCommand<?> kissenPaperCommand) {
+        this.kissenPaperCommand = kissenPaperCommand;
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/executor/KissenPaperCompleteExecutor.java b/src/main/java/net/kissenpvp/paper/command/executor/KissenPaperCompleteExecutor.java
new file mode 100644
index 0000000000000000000000000000000000000000..c37029b6a29b165395d9d404755943f724b0064a
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/executor/KissenPaperCompleteExecutor.java
@@ -0,0 +1,55 @@
+package net.kissenpvp.paper.command.executor;
+
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.core.api.command.exception.CommandException;
+import net.kissenpvp.core.api.command.exception.IllegalParameterException;
+import net.kissenpvp.core.api.command.exception.IllegalReturnValueException;
+import net.kissenpvp.core.api.command.executor.TabCompleterExecutor;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+
+import java.lang.reflect.Method;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.List;
+
+public class KissenPaperCompleteExecutor implements TabCompleterExecutor<CommandSender> {
+
+    private final Method method;
+    private final Object holder;
+
+    public KissenPaperCompleteExecutor(@NotNull Method method, @NotNull Object holder) {
+        final Class<?> returnType = method.getReturnType();
+        final Class<?>[] parameters = method.getParameterTypes();
+
+        if (!Collection.class.isAssignableFrom(returnType)) {
+            throw new IllegalReturnValueException(returnType, List.class);
+        }
+
+        if (parameters.length > 1 || (parameters.length == 1 && !CommandPayload.class.isAssignableFrom(parameters[0]))) {
+            throw new IllegalParameterException(parameters[0], CommandPayload.class);
+        }
+
+        this.method = method;
+        this.holder = holder;
+    }
+
+    @Override
+    public @NotNull Collection<String> execute(@NotNull CommandPayload<CommandSender> context) {
+        final Class<?>[] types = method.getParameterTypes();
+        try {
+            if (types.length == 0) {
+                return (Collection<String>) method.invoke(holder);
+            }
+
+            if (types.length == 1 && types[0] == CommandPayload.class) {
+                return (Collection<String>) method.invoke(holder, context);
+            }
+
+            return new HashSet<>();
+        } catch (Exception exception) {
+            throw new CommandException(String.format("An error occurred while processing the tab request for command '%s'.", context.getLabel()), exception);
+        }
+    }
+
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/parser/BooleanParser.java b/src/main/java/net/kissenpvp/paper/command/parser/BooleanParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..fcd6ef1ca4ae70ef81b270f2ea0dcc3edfe97eff
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/parser/BooleanParser.java
@@ -0,0 +1,26 @@
+package net.kissenpvp.paper.command.parser;
+
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.paper.api.command.PaperArgumentParser;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collection;
+import java.util.List;
+
+public class BooleanParser implements PaperArgumentParser<Boolean> {
+    @Override
+    public @NotNull String serialize(@NotNull Boolean object) {
+        return object.toString();
+    }
+
+    @Override
+    public @NotNull Boolean deserialize(@NotNull String input) {
+        return Boolean.parseBoolean(input);
+    }
+
+    @Override
+    public @NotNull Collection<String> tabCompletion(@NotNull CommandPayload<CommandSender> commandPayload) {
+        return List.of("true", "false");
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/parser/ByteParser.java b/src/main/java/net/kissenpvp/paper/command/parser/ByteParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..56f1b8b9717cee571aef6adb464da8925b7ce12c
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/parser/ByteParser.java
@@ -0,0 +1,17 @@
+package net.kissenpvp.paper.command.parser;
+
+import net.kissenpvp.paper.api.command.PaperArgumentParser;
+import org.jetbrains.annotations.NotNull;
+
+public class ByteParser implements PaperArgumentParser<Byte> {
+
+    @Override
+    public @NotNull String serialize(@NotNull Byte object) {
+        return String.valueOf(object);
+    }
+
+    @Override
+    public @NotNull Byte deserialize(@NotNull String input) {
+        return Byte.parseByte(input);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/parser/CharacterParser.java b/src/main/java/net/kissenpvp/paper/command/parser/CharacterParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..9bda06fe3baa11ce685ddf2df90bd8660bfb5c82
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/parser/CharacterParser.java
@@ -0,0 +1,17 @@
+package net.kissenpvp.paper.command.parser;
+
+import net.kissenpvp.paper.api.command.PaperArgumentParser;
+import org.jetbrains.annotations.NotNull;
+
+public class CharacterParser implements PaperArgumentParser<Character> {
+
+    @Override
+    public @NotNull String serialize(@NotNull Character object) {
+        return String.valueOf(object);
+    }
+
+    @Override
+    public @NotNull Character deserialize(@NotNull String input) {
+        return input.charAt(0);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/parser/DoubleParser.java b/src/main/java/net/kissenpvp/paper/command/parser/DoubleParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..53bd0ef9de222a95eee99ae8431f69d01047aa32
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/parser/DoubleParser.java
@@ -0,0 +1,17 @@
+package net.kissenpvp.paper.command.parser;
+
+import net.kissenpvp.paper.api.command.PaperArgumentParser;
+import org.jetbrains.annotations.NotNull;
+
+public class DoubleParser implements PaperArgumentParser<Double> {
+
+    @Override
+    public @NotNull String serialize(@NotNull Double object) {
+        return String.valueOf(object);
+    }
+
+    @Override
+    public @NotNull Double deserialize(@NotNull String input) {
+        return Double.parseDouble(input);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/parser/FloatParser.java b/src/main/java/net/kissenpvp/paper/command/parser/FloatParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..5a0cc33fedf9d747c43f2d27708893972ae3041c
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/parser/FloatParser.java
@@ -0,0 +1,17 @@
+package net.kissenpvp.paper.command.parser;
+
+import net.kissenpvp.paper.api.command.PaperArgumentParser;
+import org.jetbrains.annotations.NotNull;
+
+public class FloatParser implements PaperArgumentParser<Float> {
+
+    @Override
+    public @NotNull String serialize(@NotNull Float object) {
+        return String.valueOf(object);
+    }
+
+    @Override
+    public @NotNull Float deserialize(@NotNull String input) {
+        return Float.parseFloat(input);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/parser/IntegerParser.java b/src/main/java/net/kissenpvp/paper/command/parser/IntegerParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..2e02a161f7ed9bab43b5989e8efc186f873ac722
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/parser/IntegerParser.java
@@ -0,0 +1,17 @@
+package net.kissenpvp.paper.command.parser;
+
+import net.kissenpvp.paper.api.command.PaperArgumentParser;
+import org.jetbrains.annotations.NotNull;
+
+public class IntegerParser implements PaperArgumentParser<Integer> {
+
+    @Override
+    public @NotNull String serialize(@NotNull Integer object) {
+        return String.valueOf(object);
+    }
+
+    @Override
+    public @NotNull Integer deserialize(@NotNull String input) {
+        return Integer.parseInt(input);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/parser/LongParser.java b/src/main/java/net/kissenpvp/paper/command/parser/LongParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..60244eae4890c2282f5ee06c1a4b17288ca60405
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/parser/LongParser.java
@@ -0,0 +1,17 @@
+package net.kissenpvp.paper.command.parser;
+
+import net.kissenpvp.paper.api.command.PaperArgumentParser;
+import org.jetbrains.annotations.NotNull;
+
+public class LongParser implements PaperArgumentParser<Long> {
+
+    @Override
+    public @NotNull String serialize(@NotNull Long object) {
+        return String.valueOf(object);
+    }
+
+    @Override
+    public @NotNull Long deserialize(@NotNull String input) {
+        return Long.parseLong(input);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/parser/NamedTextColorParser.java b/src/main/java/net/kissenpvp/paper/command/parser/NamedTextColorParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..c727d375a674306a04bb46d4b5f5204a88573de2
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/parser/NamedTextColorParser.java
@@ -0,0 +1,27 @@
+package net.kissenpvp.paper.command.parser;
+
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.paper.api.command.PaperArgumentParser;
+import net.kyori.adventure.text.format.NamedTextColor;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collection;
+import java.util.Objects;
+
+public class NamedTextColorParser implements PaperArgumentParser<NamedTextColor> {
+    @Override
+    public @NotNull String serialize(@NotNull NamedTextColor object) {
+        return object.examinableName();
+    }
+
+    @Override
+    public @NotNull NamedTextColor deserialize(@NotNull String input) {
+        return Objects.requireNonNull(NamedTextColor.NAMES.value(input));
+    }
+
+    @Override
+    public @NotNull Collection<String> tabCompletion(@NotNull CommandPayload<CommandSender> commandPayload) {
+        return NamedTextColor.NAMES.keys();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/parser/PlayerParser.java b/src/main/java/net/kissenpvp/paper/command/parser/PlayerParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..2179be8fc71ad69879f8d55e6c026e22d919048c
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/parser/PlayerParser.java
@@ -0,0 +1,49 @@
+package net.kissenpvp.paper.command.parser;
+
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.core.api.networking.client.entitiy.PlayerOfflineException;
+import net.kissenpvp.paper.api.command.PaperArgumentParser;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collection;
+import java.util.UUID;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+
+public class PlayerParser implements PaperArgumentParser<Player> {
+    @Override
+    public @NotNull String serialize(@NotNull Player object) {
+        return object.getName();
+    }
+
+    @Override
+    public @NotNull Player deserialize(@NotNull String input) {
+        Player player;
+        Pattern pattern = Pattern.compile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$");
+        Matcher matcher = pattern.matcher(input);
+        if(matcher.matches())
+        {
+            player = Bukkit.getPlayer(UUID.fromString(input));
+        }
+        else
+        {
+            player = Bukkit.getPlayer(input);
+        }
+
+        if(player == null)
+        {
+            throw new PlayerOfflineException(input);
+        }
+
+        return player;
+    }
+
+    @Override
+    public @NotNull Collection<String> tabCompletion(@NotNull CommandPayload<CommandSender> commandPayload) {
+        return Bukkit.getOnlinePlayers().stream().map(Player::getName).collect(Collectors.toSet());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/parser/ShortParser.java b/src/main/java/net/kissenpvp/paper/command/parser/ShortParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..ac394d4ff01ebd90a9cd003eaa8f79cbc6cc625c
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/parser/ShortParser.java
@@ -0,0 +1,17 @@
+package net.kissenpvp.paper.command.parser;
+
+import net.kissenpvp.paper.api.command.PaperArgumentParser;
+import org.jetbrains.annotations.NotNull;
+
+public class ShortParser implements PaperArgumentParser<Short> {
+
+    @Override
+    public @NotNull String serialize(@NotNull Short object) {
+        return String.valueOf(object);
+    }
+
+    @Override
+    public @NotNull Short deserialize(@NotNull String input) {
+        return Short.parseShort(input);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/parser/StringParser.java b/src/main/java/net/kissenpvp/paper/command/parser/StringParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..ab25c40527cfc1b8f0ddfbc0bb855e68ac66a80e
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/parser/StringParser.java
@@ -0,0 +1,16 @@
+package net.kissenpvp.paper.command.parser;
+
+import net.kissenpvp.paper.api.command.PaperArgumentParser;
+import org.jetbrains.annotations.NotNull;
+
+public class StringParser implements PaperArgumentParser<String> {
+    @Override
+    public @NotNull String serialize(@NotNull String object) {
+        return object;
+    }
+
+    @Override
+    public @NotNull String deserialize(@NotNull String input) {
+        return input;
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/target/KissenPaperTargetValidator.java b/src/main/java/net/kissenpvp/paper/command/target/KissenPaperTargetValidator.java
new file mode 100644
index 0000000000000000000000000000000000000000..d5f457a0797705853d4ef582a4cac607e9062f78
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/target/KissenPaperTargetValidator.java
@@ -0,0 +1,41 @@
+package net.kissenpvp.paper.command.target;
+
+import net.kissenpvp.core.api.command.CommandTarget;
+import net.kissenpvp.core.api.networking.client.entitiy.ConsoleClient;
+import net.kissenpvp.core.api.networking.client.entitiy.PlayerClient;
+import net.kissenpvp.core.api.networking.client.entitiy.ServerEntity;
+import net.kissenpvp.core.command.TargetValidator;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Represents a target validator implementation tailored for the Kissen Paper command framework.
+ * <p>
+ * This class implements the {@link TargetValidator} interface and provides specialized logic to validate command targets
+ * within the context of the Kissen Paper command framework. It determines whether a given command target is valid based on
+ * the type of server entity and provides methods to parse the sender's server entity into a valid command target.
+ */
+public class KissenPaperTargetValidator implements TargetValidator {
+
+    @Override
+    public boolean validate(@NotNull CommandTarget commandTarget, @NotNull ServerEntity serverEntity) {
+        return switch (commandTarget) {
+            case PLAYER -> serverEntity instanceof PlayerClient<?, ?, ?>;
+            case SYSTEM -> serverEntity instanceof ConsoleClient;
+            case ALL -> true;
+        };
+    }
+
+    @Override
+    public @NotNull CommandTarget parseSender(@NotNull ServerEntity serverEntity) {
+        if (serverEntity instanceof ConsoleClient) {
+            return CommandTarget.SYSTEM;
+        }
+
+        if (serverEntity instanceof PlayerClient<?, ?, ?>) {
+            return CommandTarget.PLAYER;
+        }
+
+        throw new IllegalArgumentException(String.format("No suitable target type has been found for target %s.", serverEntity.getClass()
+            .getName()));
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/message/localization/KissenPaperLocalizationImplementation.java b/src/main/java/net/kissenpvp/paper/message/localization/KissenPaperLocalizationImplementation.java
new file mode 100644
index 0000000000000000000000000000000000000000..e140877b4d5c8cdd4a93c49d4369fc8bd8fd366e
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/message/localization/KissenPaperLocalizationImplementation.java
@@ -0,0 +1,39 @@
+package net.kissenpvp.paper.message.localization;
+
+import net.kissenpvp.core.message.KissenComponentSerializer;
+import net.kissenpvp.core.message.localization.KissenLocalizationImplementation;
+import net.kyori.adventure.text.Component;
+
+import java.text.MessageFormat;
+
+public class KissenPaperLocalizationImplementation extends KissenLocalizationImplementation {
+
+    @Override
+    public boolean postStart() {
+
+        //I love disconnect messages
+        register("server.disconnect.server-shutdown", getTranslation("multiplayer.disconnect.server_shutdown"));
+        register("server.disconnect.not-whitelisted", getTranslation("multiplayer.disconnect.not_whitelisted"));
+        register("server.disconnect.server-full", getTranslation("multiplayer.disconnect.server_full"));
+        register("server.disconnect.outdated-client", getTranslation("multiplayer.disconnect.outdated_client"));
+        register("server.disconnect.outdated-server", getTranslation("multiplayer.disconnect.outdated_server"));
+        register("server.disconnect.server-restart", getTranslation("multiplayer.disconnect.server_shutdown"));
+
+        register("paper.kick.connection-throttle", new MessageFormat("Connection throttled! Please wait before reconnecting."));
+        register("paper.unauthorized", new MessageFormat("You do not have the permission to perform this command."));
+
+        return super.postStart();
+    }
+
+    /**
+     * Retrieves a translated message format based on the provided language key.
+     *
+     * @param languageKey the string representing the language key for the translation
+     * @return the translated message format
+     */
+    private MessageFormat getTranslation(String languageKey) {
+        return new MessageFormat(KissenComponentSerializer.getInstance()
+                .getMiniSerializer()
+                .serialize(Component.translatable(languageKey)));
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperOnlinePlayerClient.java b/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperOnlinePlayerClient.java
new file mode 100644
index 0000000000000000000000000000000000000000..69f55ce02fbe3a96169eaf296c0ac3583e50315d
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperOnlinePlayerClient.java
@@ -0,0 +1,77 @@
+package net.kissenpvp.paper.networking.client.entity;
+
+import io.netty.channel.Channel;
+import net.kissenpvp.core.api.ban.Ban;
+import net.kissenpvp.core.api.networking.client.entitiy.ServerEntity;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.message.KissenComponentSerializer;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.networking.client.entity.PaperOnlinePlayerClient;
+import net.kyori.adventure.audience.Audience;
+import net.kyori.adventure.text.Component;
+import net.minecraft.network.protocol.Packet;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public abstract class KissenPaperOnlinePlayerClient extends KissenPaperPlayerClient implements PaperOnlinePlayerClient {
+
+    public abstract @NotNull CraftPlayer getCraftPlayer();
+
+    // Only methods based in CraftPlayer due to permission subscription
+    @Override
+    public @NotNull User getUser() {
+        return getCraftPlayer().getUser();
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull Context context) {
+        return getCraftPlayer().getUser(context);
+    }
+    //
+
+    @Override
+    public final boolean isConnected() {
+        return true;
+    }
+
+    @Override
+    public void kick(@NotNull String message) {
+        kick(KissenComponentSerializer.getInstance().getMiniSerializer().deserialize(message));
+    }
+
+    @Override
+    public void kick(@NotNull Component component) {
+        getCraftPlayer().kick(component);
+    }
+
+    @Override
+    public void killConnection() {
+        getConnection().close();
+    }
+
+    @Override
+    public @NotNull Channel getConnection() {
+        return getCraftPlayer().getHandle().connection.connection.channel;
+    }
+
+    @Override
+    public void sendPacket(@NotNull Object object) throws ClassNotFoundException, ClassCastException {
+        getCraftPlayer().getHandle().connection.send((Packet<?>) object);
+    }
+
+    @Override
+    public @Nullable String getCurrentServer() {
+        return null;
+    }
+
+    @Override
+    public @NotNull Audience getKyoriAudience() {
+        return getCraftPlayer();
+    }
+
+    @Override
+    public int warn(@NotNull Ban ban, @NotNull ServerEntity warnOperator) {
+        return 0;
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperPlayerClient.java b/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperPlayerClient.java
new file mode 100644
index 0000000000000000000000000000000000000000..b689a620c2e9e20479f42c5c78237cd4c3a79954
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperPlayerClient.java
@@ -0,0 +1,328 @@
+package net.kissenpvp.paper.networking.client.entity;
+
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.permission.PermissionGroup;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.api.user.suffix.Suffix;
+import net.kissenpvp.core.database.DataWriter;
+import net.kissenpvp.core.networking.client.entity.KissenPlayerClient;
+import net.kissenpvp.core.user.rank.KissenPlayerRankNode;
+import net.kissenpvp.paper.api.ban.PaperPunishment;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.networking.client.entity.PaperOnlinePlayerClient;
+import net.kissenpvp.paper.api.networking.client.entity.PaperPlayerClient;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PermissibleOverriddenException;
+import net.kissenpvp.paper.api.user.rank.PaperPlayerRank;
+import net.kissenpvp.paper.permission.permissible.KissenPaperPermissible;
+import net.kissenpvp.paper.user.KissenPaperPublicUser;
+import net.kissenpvp.paper.user.rank.KissenPaperPlayerFallBackRank;
+import net.kissenpvp.paper.user.rank.KissenPaperPlayerRank;
+import net.kyori.adventure.text.Component;
+import org.bukkit.Bukkit;
+import org.bukkit.permissions.Permission;
+import org.bukkit.permissions.PermissionAttachment;
+import org.bukkit.permissions.PermissionAttachmentInfo;
+import org.bukkit.plugin.Plugin;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.HashSet;
+import java.util.Optional;
+import java.util.Set;
+import java.util.UUID;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public abstract class KissenPaperPlayerClient extends KissenPlayerClient<PaperPermission, PaperPlayerRank, PaperPunishment> implements PaperPlayerClient {
+
+    @Override
+    public @NotNull User getUser() {
+        return Bukkit.getKissen()
+                .getImplementation(UserImplementation.class)
+                .getOnlineUser(getUniqueId())
+                .orElseThrow(IllegalStateException::new);
+    }
+
+    @Override
+    protected @NotNull PaperPlayerRank translateRank(@NotNull KissenPlayerRankNode kissenPlayerRankNode, @Nullable DataWriter dataWriter) {
+        return new KissenPaperPlayerRank(kissenPlayerRankNode, dataWriter);
+    }
+
+    @Override
+    protected @NotNull PaperPlayerRank fallbackRank() {
+        return new KissenPaperPlayerFallBackRank();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<@NotNull PaperOnlinePlayerClient> getOnlineAltAccounts() {
+        return Bukkit.getOnlinePlayers().stream().filter(client -> client.getTotalID().equals(getTotalID())).collect(Collectors.toSet());
+    }
+
+    @Override
+    public @NotNull Set<Suffix> getSuffixSet() {
+        return Stream.concat(getSuffixSet(Context.LOCAL).stream(), getSuffixSet(Context.GLOBAL).stream()).collect(Collectors.toSet());
+    }
+
+    @Override
+    public @NotNull Set<Suffix> getSuffixSet(@NotNull Context context) {
+        //TODO
+        return new HashSet<>();
+    }
+
+    @Override
+    public @NotNull Optional<Suffix> getSuffix(@NotNull String name) {
+        return getSuffix(name, Context.LOCAL).or(() -> super.getSuffix(name));
+    }
+
+    @Override
+    public @NotNull Optional<Suffix> getSuffix(@NotNull String name, @NotNull Context context) {
+        return Optional.empty(); //TODO
+    }
+
+
+    @Override
+    public @NotNull Optional<Suffix> setSuffix(@NotNull String name, @NotNull Component content) {
+        return setSuffix(name, content, Context.LOCAL);
+    }
+
+    @Override
+    public @NotNull Optional<Suffix> setSuffix(@NotNull String name, @NotNull Component content, @NotNull Context context) {
+        return Optional.empty(); //TODO
+    }
+
+    @Override
+    public boolean deleteSuffix(@NotNull String name) {
+        return getSuffix(name, Context.LOCAL).map((suffix) -> deleteSuffix(name, Context.LOCAL)).orElse(false) || super.deleteSuffix(name);
+    }
+
+    @Override
+    public boolean deleteSuffix(@NotNull String name, @NotNull Context context) {
+        return false; //TODO
+    }
+
+    @Override
+    public void setSelectedSuffix(@NotNull String name) throws NullPointerException {
+        setSelectedSuffix(name, Context.LOCAL);
+    }
+
+    @Override
+    public void setSelectedSuffix(@NotNull String name, @NotNull Context context) throws NullPointerException {
+        //TODO
+    }
+
+    @Override
+    public long getOnlineTime() {
+        return getOnlineTime(Context.LOCAL);
+    }
+
+    @Override
+    public long getOnlineTime(@NotNull Context context) {
+        return getOnlineTime(getUser(context));
+    }
+
+    @Override
+    public long getLastPlayed(@NotNull Context context) {
+        return getLastPlayed(getUser(context));
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull Context context) {
+        KissenPaperPublicUser kissenPublicUser = (KissenPaperPublicUser) getUser();
+        return switch (context) {
+            case GLOBAL -> kissenPublicUser;
+            case LOCAL -> kissenPublicUser.getPrivateUserEntry();
+        };
+    }
+
+    public @NotNull KissenPaperPermissible getPermissionContext() throws PermissibleOverriddenException {
+        return (KissenPaperPermissible) getPermissible();
+    }
+
+    @Override
+    public boolean isPermissionSet(@NotNull String name) {
+        return getPermissionContext().isPermissionSet(name);
+    }
+
+    @Override
+    public boolean isPermissionSet(@NotNull Permission perm) {
+        return getPermissionContext().isPermissionSet(perm);
+    }
+
+    @Override
+    public @NotNull String getPermissionID() {
+        return getPermissionContext().getPermissionID();
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission) throws EventCancelledException {
+        return getPermissionContext().setPermission(permission);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, boolean value) throws EventCancelledException {
+        return getPermissionContext().setPermission(permission, value);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission) {
+        return getPermissionContext().unsetPermission(permission);
+    }
+
+    @Override
+    public int wipePermissions() {
+        return getPermissionContext().wipePermissions();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList() {
+        return getPermissionContext().getPermissionList();
+    }
+
+    @Override
+    public @NotNull Optional<PaperPermission> getPermission(@NotNull String permission) {
+        return getPermissionContext().getPermission(permission);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAffectedPermissionPlayer() {
+        return getPermissionContext().getAffectedPermissionPlayer();
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull PaperPermission permission) throws EventCancelledException {
+        return getPermissionContext().setPermission(permission);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String name) {
+        return getPermissionContext().hasPermission(name);
+    }
+
+    @Override
+    public void permissionUpdate() {
+        getPermissionContext().permissionUpdate();
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull Permission perm) {
+        return getPermissionContext().hasPermission(perm);
+    }
+
+    @Override
+    public @NotNull PermissionAttachment addAttachment(@NotNull Plugin plugin, @NotNull String name, boolean value) {
+        return getPermissionContext().addAttachment(plugin, name, value);
+    }
+
+    @Override
+    public @NotNull PermissionAttachment addAttachment(@NotNull Plugin plugin) {
+        return getPermissionContext().addAttachment(plugin);
+    }
+
+    @Override
+    public @Nullable PermissionAttachment addAttachment(@NotNull Plugin plugin, @NotNull String name, boolean value, int ticks) {
+        return getPermissionContext().addAttachment(plugin, name, value, ticks);
+    }
+
+    @Override
+    public @Nullable PermissionAttachment addAttachment(@NotNull Plugin plugin, int ticks) {
+        return getPermissionContext().addAttachment(plugin, ticks);
+    }
+
+    @Override
+    public void removeAttachment(@NotNull PermissionAttachment attachment) {
+        getPermissionContext().removeAttachment(attachment);
+    }
+
+    @Override
+    public void recalculatePermissions() {
+        getPermissionContext().recalculatePermissions();
+    }
+
+    @Override
+    public @NotNull Set<PermissionAttachmentInfo> getEffectivePermissions() {
+        return getPermissionContext().getEffectivePermissions();
+    }
+
+    @Override
+    public boolean isOp() {
+        return getPermissionContext().isOp();
+    }
+
+    @Override
+    public void setOp(boolean value) {
+        getPermissionContext().setOp(value);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getOwnPermissions() {
+        return getPermissionContext().getOwnPermissions();
+    }
+
+    @Override
+    public int wipeGroups() {
+        return getPermissionContext().wipeGroups();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups() {
+        return getPermissionContext().getPermissionGroups();
+    }
+
+    @Override
+    public boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup) {
+        return getPermissionContext().inGroup(permissionGroup);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getOwnPermissions(@NotNull Context context) {
+        return getPermissionContext().getOwnPermissions(context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups(@NotNull Context context) {
+        return getPermissionContext().getPermissionGroups(context);
+    }
+
+    @Override
+    public boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup, @NotNull Context context) {
+        return getPermissionContext().inGroup(permissionGroup, context);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, @NotNull Context context) throws EventCancelledException {
+        return getPermissionContext().setPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, boolean value, @NotNull Context context) throws EventCancelledException {
+        return getPermissionContext().setPermission(permission, value, context);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull PaperPermission permission, @NotNull Context context) throws EventCancelledException {
+        return getPermissionContext().setPermission(permission, context);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission, @NotNull Context context) {
+        return getPermissionContext().unsetPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList(@NotNull Context context) {
+        return getPermissionContext().getPermissionList(context);
+    }
+
+    @Override
+    public @NotNull Optional<PaperPermission> getPermission(@NotNull String permission, @NotNull Context context) {
+        return getPermissionContext().getPermission(permission, context);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String permission, @NotNull Context context) {
+        return getPermissionContext().hasPermission(permission, context);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/KissenPaperAttachmentPermission.java b/src/main/java/net/kissenpvp/paper/permission/KissenPaperAttachmentPermission.java
new file mode 100644
index 0000000000000000000000000000000000000000..7ccb3b608cd719b01efc6a98ebb28d571e80f038
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/KissenPaperAttachmentPermission.java
@@ -0,0 +1,29 @@
+package net.kissenpvp.paper.permission;
+
+import net.kissenpvp.core.api.permission.Permission;
+import net.kissenpvp.core.api.permission.PermissionEntry;
+import net.kissenpvp.core.api.util.Container;
+import net.kissenpvp.core.permission.KissenPermissionNode;
+import org.bukkit.permissions.PermissionAttachment;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.HashMap;
+
+public class KissenPaperAttachmentPermission extends KissenPaperPermission {
+
+    private final PermissionAttachment permissionAttachment;
+
+    public KissenPaperAttachmentPermission(@NotNull String permission, boolean value, @NotNull PermissionEntry<? extends Permission> permissionEntry, boolean immutable) {
+        this(null, permission, value, permissionEntry, immutable);
+    }
+
+    public KissenPaperAttachmentPermission(@Nullable PermissionAttachment permissionAttachment, @NotNull String permission, boolean value, @NotNull PermissionEntry<? extends Permission> permissionEntry, boolean immutable) {
+        super(new KissenPermissionNode(permission, permissionEntry.getPermissionID(), new Container<>(value), System.currentTimeMillis(), new Container<>(-1L), new Container<>(-1L), -1L, new HashMap<>()), permissionEntry, immutable ? null : (record) -> { /* ignored */ });
+        this.permissionAttachment = permissionAttachment;
+    }
+
+    public PermissionAttachment getPermissionAttachment() {
+        return permissionAttachment;
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/KissenPaperGroupablePermissionEntry.java b/src/main/java/net/kissenpvp/paper/permission/KissenPaperGroupablePermissionEntry.java
new file mode 100644
index 0000000000000000000000000000000000000000..27e3920dabaa4b11dd4edd177974774c961c963c
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/KissenPaperGroupablePermissionEntry.java
@@ -0,0 +1,146 @@
+package net.kissenpvp.paper.permission;
+
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.permission.GroupablePermissionEntry;
+import net.kissenpvp.core.api.permission.PermissionGroup;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.PaperGroubablePermissionEntry;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Optional;
+import java.util.Set;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public interface KissenPaperGroupablePermissionEntry extends PaperGroubablePermissionEntry {
+
+    @Override
+    default int wipePermissions() {
+        return getPermissionEntry(Context.LOCAL).wipePermissions() + getPermissionEntry(Context.GLOBAL).wipePermissions();
+    }
+
+    @Override
+    default int wipeGroups() {
+        return getPermissionEntry(Context.LOCAL).wipeGroups() + getPermissionEntry(Context.GLOBAL).wipeGroups();
+    }
+
+    @Override
+    default @NotNull @Unmodifiable Set<PaperPermission> getOwnPermissions() {
+        return Stream.concat(getPermissionEntry(Context.LOCAL).getOwnPermissions().stream(), getPermissionEntry(Context.GLOBAL).getOwnPermissions().stream()).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    @NotNull
+    default Set<PaperPermission> getOwnPermissions(@NotNull Context context) {
+        return getPermissionEntry(context).getOwnPermissions();
+    }
+
+    @Override
+    default @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups() {
+        return Stream.concat(getPermissionEntry(Context.LOCAL).getPermissionGroups().stream(), getPermissionEntry(Context.GLOBAL).getPermissionGroups().stream()).collect(Collectors.toUnmodifiableSet()); //TODO
+    }
+
+
+    @Override
+    @NotNull
+    default Set<PermissionGroup<PaperPermission>> getPermissionGroups(@NotNull Context context) {
+        return getPermissionEntry(context).getPermissionGroups();
+    }
+
+    @Override
+    default boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup) {
+        return getPermissionEntry(Context.LOCAL).inGroup(permissionGroup) || getPermissionEntry(Context.GLOBAL).inGroup(permissionGroup);
+    }
+
+    @Override
+    default boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup, @NotNull Context context) {
+        return getPermissionEntry(context).inGroup(permissionGroup);
+    }
+
+    @Override
+    @NotNull
+    default PaperPermission setPermission(@NotNull String s) throws EventCancelledException {
+        return setPermission(s, Context.LOCAL);
+    }
+
+    @Override
+    @NotNull
+    default PaperPermission setPermission(@NotNull String permission, @NotNull Context context) throws EventCancelledException {
+        return getPermissionEntry(context).setPermission(permission);
+    }
+
+    @Override
+    @NotNull
+    default PaperPermission setPermission(@NotNull String s, boolean b) throws EventCancelledException {
+        return setPermission(s, b, Context.LOCAL);
+    }
+
+    @Override
+    @NotNull
+    default PaperPermission setPermission(@NotNull String permission, boolean value, @NotNull Context context) throws EventCancelledException {
+        return getPermissionEntry(context).setPermission(permission, value);
+    }
+
+    @Override
+    @NotNull
+    default PaperPermission setPermission(@NotNull PaperPermission paperPermission) throws EventCancelledException {
+        return setPermission(paperPermission, Context.LOCAL);
+    }
+
+    @Override
+    @NotNull
+    default PaperPermission setPermission(@NotNull PaperPermission permission, @NotNull Context context) throws EventCancelledException {
+        return getPermissionEntry(context).setPermission(permission);
+    }
+
+    @Override
+    default boolean unsetPermission(@NotNull String s) {
+        if (unsetPermission(s, Context.LOCAL)) {
+            return unsetPermission(s, Context.GLOBAL);
+        }
+        return false;
+    }
+
+    @Override
+    default boolean unsetPermission(@NotNull String permission, @NotNull Context context) {
+        return getPermissionEntry(context).unsetPermission(permission);
+    }
+
+    @Override
+    default @NotNull @Unmodifiable Set<PaperPermission> getPermissionList() {
+        return Stream.concat(getPermissionList(Context.LOCAL).stream(), getPermissionList(Context.GLOBAL).stream()).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    @NotNull
+    @Unmodifiable
+    default Set<PaperPermission> getPermissionList(@NotNull Context context) {
+        return getPermissionEntry(context).getPermissionList();
+    }
+
+    @Override
+    default @NotNull Optional<PaperPermission> getPermission(@NotNull String s) {
+        return getPermission(s, Context.LOCAL).or(() -> getPermission(s, Context.GLOBAL));
+    }
+
+    @Override
+    @NotNull
+    default Optional<PaperPermission> getPermission(@NotNull String permission, @NotNull Context context) {
+        return getPermissionEntry(context).getPermission(permission);
+    }
+
+    @Override
+    default boolean hasPermission(@NotNull String s) {
+        return isOp() || hasPermission(s, Context.LOCAL) || hasPermission(s, Context.GLOBAL);
+    }
+
+    @Override
+    default boolean hasPermission(@NotNull String permission, @NotNull Context context) {
+        return getPermissionEntry(context).hasPermission(permission);
+    }
+
+    @NotNull GroupablePermissionEntry<PaperPermission> getPermissionEntry(@NotNull Context context);
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermission.java b/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermission.java
new file mode 100644
index 0000000000000000000000000000000000000000..214e799aaf498af46e3b9854058168af30ba81e3
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermission.java
@@ -0,0 +1,16 @@
+package net.kissenpvp.paper.permission;
+
+import net.kissenpvp.core.api.permission.Permission;
+import net.kissenpvp.core.api.permission.PermissionEntry;
+import net.kissenpvp.core.database.DataWriter;
+import net.kissenpvp.core.permission.KissenPermission;
+import net.kissenpvp.core.permission.KissenPermissionNode;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class KissenPaperPermission extends KissenPermission implements PaperPermission {
+    public KissenPaperPermission(@NotNull KissenPermissionNode kissenPermissionNode, @NotNull PermissionEntry<? extends Permission> permissionEntry, @Nullable DataWriter dataWriter) {
+        super(kissenPermissionNode, permissionEntry, dataWriter);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermissionImplementation.java b/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermissionImplementation.java
new file mode 100644
index 0000000000000000000000000000000000000000..a4fa55607af6370e5cf56799013a578c6666021c
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermissionImplementation.java
@@ -0,0 +1,206 @@
+package net.kissenpvp.paper.permission;
+
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.database.savable.SavableMap;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.event.EventImplementation;
+import net.kissenpvp.core.api.permission.PermissionGroup;
+import net.kissenpvp.core.base.KissenCore;
+import net.kissenpvp.core.base.KissenImplementation;
+import net.kissenpvp.core.database.savable.KissenSavableMap;
+import net.kissenpvp.core.permission.PermissionImplementation;
+import net.kissenpvp.core.permission.event.KissenPermissionGroupCreateEvent;
+import net.kissenpvp.core.permission.event.KissenPermissionGroupCreatedEvent;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PaperPermissionGroup;
+import net.kissenpvp.paper.api.permission.PaperPermissionImplementation;
+import net.kissenpvp.paper.api.permission.PaperPrivatePermissionGroup;
+import net.kissenpvp.paper.command.KissenPaperCommandImplementation;
+import net.kissenpvp.paper.permission.group.KissenPaperPermissionGroup;
+import net.kissenpvp.paper.permission.group.KissenPaperPrivatePermissionGroup;
+import net.kissenpvp.paper.permission.group.KissenPaperPublicPermissionGroup;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.function.Consumer;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public class KissenPaperPermissionImplementation implements PaperPermissionImplementation, PermissionImplementation, KissenImplementation {
+
+    private final Set<PermissionGroup<PaperPermission>> cachedGroups;
+
+    public KissenPaperPermissionImplementation() {
+        this.cachedGroups = new HashSet<>();
+    }
+
+    @Override
+    public boolean postStart() {
+        try {
+            Stream.concat(KissenCore.getInstance()
+                    .getPublicMeta()
+                    .getData(new KissenPaperPublicPermissionGroup())
+                    .values()
+                    .stream(), Bukkit.getKissen()
+                    .getPrivateMeta()
+                    .getData(new KissenPaperPrivatePermissionGroup())
+                    .values()
+                    .stream()).forEach(permissionGroupInitializer());
+        } catch (BackendException e) {
+            KissenCore.getInstance()
+                    .getLogger()
+                    .error("The system was unable to load the permission groups from the database.");
+            return false;
+        }
+
+        return PaperPermissionImplementation.super.postStart();
+    }
+
+    private Consumer<SavableMap> permissionGroupInitializer() {
+        return savableMap -> {
+            String id = ((KissenSavableMap) savableMap).getId();
+
+            if (id.startsWith(new KissenPaperPublicPermissionGroup().getSaveID())) {
+                createInternalPermissionGroup(savableMap.getNotNull("id"), savableMap);
+            } else {
+                if (id.startsWith(new KissenPaperPrivatePermissionGroup().getSaveID())) {
+                    try {
+                        createPrivateInternalPermissionGroup(savableMap.getNotNull("id"), savableMap);
+                    } catch (BackendException backendException) {
+                        KissenCore.getInstance()
+                                .getLogger()
+                                .error("The system was unable to load the permission group '{}' from the database.", id);
+                    }
+                }
+            }
+        };
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermissionGroup> getPermissionGroupSet() {
+        return cachedGroups.stream()
+                .filter(permissionGroup -> permissionGroup instanceof PaperPermissionGroup)
+                .map(paperPermissionPermissionGroup -> (PaperPermissionGroup) paperPermissionPermissionGroup)
+                .collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPrivatePermissionGroup> getPrivatePermissionGroupSet() {
+        return cachedGroups.stream()
+                .filter(permissionGroup -> permissionGroup instanceof PaperPrivatePermissionGroup)
+                .map(paperPermissionPermissionGroup -> (PaperPrivatePermissionGroup) paperPermissionPermissionGroup)
+                .collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @Nullable PaperPermissionGroup getPermissionGroup(@NotNull String group) {
+        return getPermissionGroupSet().stream()
+                .filter(paperPermissionGroup -> paperPermissionGroup.getPermissionID().equals(group))
+                .findFirst()
+                .orElse(null);
+    }
+
+    @Override
+    public @Nullable PermissionGroup<?> getPermissionGroupSavable(@NotNull String name) {
+        return getPermissionGroupSet().stream()
+                .map(paperPermissionGroup -> paperPermissionGroup.getCoreGroup(Context.GLOBAL))
+                .filter(paperPermissionGroup -> paperPermissionGroup.getPermissionID().equals(name))
+                .findFirst()
+                .orElse(null);
+    }
+
+    @Override
+    public void removePermissionGroup(@NotNull String name) {
+        cachedGroups.removeIf(paperPermissionPermissionGroup -> paperPermissionPermissionGroup.getPermissionID()
+                .equals(name));
+    }
+
+    public void removePublicPermissionGroup(String name) {
+        cachedGroups.removeIf(paperPermissionPermissionGroup -> paperPermissionPermissionGroup instanceof PaperPermissionGroup && paperPermissionPermissionGroup.getPermissionID()
+                .equals(name));
+    }
+
+    @Override
+    public @Nullable PaperPrivatePermissionGroup getPrivatePermissionGroup(@NotNull String group) {
+        return getPrivatePermissionGroupSet().stream()
+                .filter(paperPrivatePermissionGroup -> paperPrivatePermissionGroup.getPermissionID().equals(group))
+                .findFirst()
+                .orElse(null);
+    }
+
+    @Override
+    public @NotNull PaperPrivatePermissionGroup getPrivatePermissionGroupNotNull(@NotNull String group) throws EventCancelledException, BackendException {
+        PaperPrivatePermissionGroup permissionGroup = getPrivatePermissionGroup(group);
+        if (permissionGroup == null) {
+            permissionGroup = createPrivatePermissionGroup(group, null);
+        }
+        return permissionGroup;
+    }
+
+    @Override
+    public @NotNull PaperPermissionGroup getPermissionGroupNotNull(@NotNull String group) throws EventCancelledException {
+        PaperPermissionGroup permissionGroup = getPermissionGroup(group);
+        if (permissionGroup == null) {
+            permissionGroup = createPermissionGroup(group, null);
+        }
+        return permissionGroup;
+    }
+
+    @Override
+    public @NotNull PaperPermissionGroup createPermissionGroup(@NotNull String name, @Nullable Map<String, String> data) throws EventCancelledException {
+        KissenPermissionGroupCreateEvent kissenPermissionGroupCreateEvent = new KissenPermissionGroupCreateEvent(name, data);
+        if (Bukkit.getKissen().getImplementation(EventImplementation.class).call(kissenPermissionGroupCreateEvent)) {
+            this.createInternalPermissionGroup(name, data);
+        }
+        throw new EventCancelledException();
+    }
+
+    @Override
+    public @NotNull PermissionGroup<?> createInternalPermissionGroup(@NotNull String name, @Nullable Map<String, String> data) {
+        KissenPaperPublicPermissionGroup kissenPaperPublicPermissionGroup = new KissenPaperPublicPermissionGroup();
+        try {
+            kissenPaperPublicPermissionGroup.setup(name, data);
+            PaperPermissionGroup permissionGroup = new KissenPaperPermissionGroup(kissenPaperPublicPermissionGroup);
+            cachedGroups.removeIf(paperPermissionPermissionGroup -> paperPermissionPermissionGroup.getPermissionID()
+                    .equals(name));
+            cachedGroups.add(permissionGroup);
+
+            PaperPrivatePermissionGroup paperPrivatePermissionGroup = getPrivatePermissionGroup(name);
+            if (paperPrivatePermissionGroup == null) {
+                paperPrivatePermissionGroup = createPrivateInternalPermissionGroup(name, null);
+            }
+            cachedGroups.add(paperPrivatePermissionGroup);
+            Bukkit.getKissen()
+                    .getImplementation(EventImplementation.class)
+                    .call(new KissenPermissionGroupCreatedEvent(permissionGroup));
+            return permissionGroup;
+        } catch (BackendException e) {
+            throw new RuntimeException(e); //TODO replace with throw list
+        }
+    }
+
+    @Override
+    public @NotNull PaperPrivatePermissionGroup createPrivatePermissionGroup(@NotNull String group, @Nullable Map<String, String> data) throws EventCancelledException, BackendException {
+        KissenPermissionGroupCreateEvent kissenPermissionGroupCreateEvent = new KissenPermissionGroupCreateEvent(group, data);
+        if (Bukkit.getKissen().getImplementation(EventImplementation.class).call(kissenPermissionGroupCreateEvent)) {
+            return createPrivateInternalPermissionGroup(group, data);
+        }
+        throw new EventCancelledException();
+    }
+
+    public @NotNull PaperPrivatePermissionGroup createPrivateInternalPermissionGroup(@NotNull String group, @Nullable Map<String, String> data) throws BackendException {
+        KissenPaperPrivatePermissionGroup kissenPaperPrivatePermissionGroup = new KissenPaperPrivatePermissionGroup();
+        kissenPaperPrivatePermissionGroup.setup(group, data);
+        cachedGroups.add(kissenPaperPrivatePermissionGroup);
+        Bukkit.getKissen()
+                .getImplementation(EventImplementation.class)
+                .call(new KissenPermissionGroupCreatedEvent(kissenPaperPrivatePermissionGroup));
+        return kissenPaperPrivatePermissionGroup;
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/RemoveAttachmentRunnable.java b/src/main/java/net/kissenpvp/paper/permission/RemoveAttachmentRunnable.java
new file mode 100644
index 0000000000000000000000000000000000000000..64401fe14b92af9d12b34f4065ecf5e18e69df4b
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/RemoveAttachmentRunnable.java
@@ -0,0 +1,15 @@
+package net.kissenpvp.paper.permission;
+
+import org.bukkit.permissions.PermissionAttachment;
+import org.jetbrains.annotations.NotNull;
+
+public record RemoveAttachmentRunnable(PermissionAttachment attachment) implements Runnable {
+    public RemoveAttachmentRunnable(@NotNull PermissionAttachment attachment) {
+        this.attachment = attachment;
+    }
+
+    @Override
+    public void run() {
+        attachment.remove();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperAbstractPermissionGroup.java b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperAbstractPermissionGroup.java
new file mode 100644
index 0000000000000000000000000000000000000000..3540b74b166eeede1dde1baef3c694fbfb9dfaca
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperAbstractPermissionGroup.java
@@ -0,0 +1,41 @@
+package net.kissenpvp.paper.permission.group;
+
+import net.kissenpvp.core.api.permission.PermissionGroup;
+import net.kissenpvp.core.database.DataWriter;
+import net.kissenpvp.core.permission.KissenPermissionGroup;
+import net.kissenpvp.core.permission.KissenPermissionNode;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PaperPermissionImplementation;
+import net.kissenpvp.paper.permission.KissenPaperPermission;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Set;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public abstract class KissenPaperAbstractPermissionGroup extends KissenPermissionGroup<PaperPermission> {
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups() {
+        PaperPermissionImplementation paperPermissionImplementation = Bukkit.getKissen()
+            .getImplementation(PaperPermissionImplementation.class);
+
+        return Stream.concat(paperPermissionImplementation
+                .getPermissionGroupSet()
+                .stream()
+                .filter(paperPermissionGroup -> paperPermissionGroup.getMember()
+                    .contains(getPermissionID())), paperPermissionImplementation
+                .getPrivatePermissionGroupSet()
+                .stream()
+                .filter(paperPermissionGroup -> paperPermissionGroup.getMember().contains(getPermissionID())))
+            .collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    protected @NotNull PaperPermission translatePermission(@NotNull KissenPermissionNode kissenPermissionNode, @Nullable DataWriter dataWriter) {
+        return new KissenPaperPermission(kissenPermissionNode, this, dataWriter);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPermissionGroup.java b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPermissionGroup.java
new file mode 100644
index 0000000000000000000000000000000000000000..bba64c7c3a28b51d33a6b37e909a71b781df6578
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPermissionGroup.java
@@ -0,0 +1,282 @@
+package net.kissenpvp.paper.permission.group;
+
+import net.kissenpvp.core.api.database.StorageImplementation;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.permission.GroupablePermissionEntry;
+import net.kissenpvp.core.api.permission.PermissionGroup;
+import net.kissenpvp.core.base.KissenCore;
+import net.kissenpvp.core.permission.InternalGroupablePermissionEntry;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PaperPermissionGroup;
+import net.kissenpvp.paper.api.permission.PaperPublicPermissionGroup;
+import net.kissenpvp.paper.permission.KissenPaperAttachmentPermission;
+import net.kissenpvp.paper.permission.permissible.KissenPaperPermissible;
+import net.kyori.adventure.text.Component;
+import org.bukkit.Bukkit;
+import org.bukkit.permissions.Permissible;
+import org.bukkit.permissions.PermissionAttachment;
+import org.bukkit.permissions.PermissionAttachmentInfo;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.*;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public class KissenPaperPermissionGroup extends KissenPaperPermissible implements PaperPermissionGroup, InternalGroupablePermissionEntry<PaperPermission> {
+    private final PaperPublicPermissionGroup permissionGroup;
+
+    public KissenPaperPermissionGroup(PaperPublicPermissionGroup permissionGroup) {
+        this.permissionGroup = permissionGroup;
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getOwnPermissions() {
+        return Stream.concat(getOwnPermissions(Context.LOCAL).stream(), getOwnPermissions(Context.GLOBAL).stream())
+            .collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public int wipeGroups() {
+        return getCoreGroup(Context.LOCAL).wipeGroups();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups() {
+        return Stream.concat(getPermissionGroups(Context.LOCAL).stream(), getPermissionGroups(Context.GLOBAL).stream())
+            .collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup) {
+        return getCoreGroup(Context.LOCAL).inGroup(permissionGroup) || getCoreGroup(Context.GLOBAL).inGroup(permissionGroup);
+    }
+
+    @Override
+    public @NotNull String getPermissionID() {
+        return getCoreGroup(Context.GLOBAL).getPermissionID();
+    }
+
+    @Override
+    public @NotNull Component displayName() {
+        return getCoreGroup(Context.GLOBAL).displayName();
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission) throws EventCancelledException {
+        return setPermission(permission, Context.GLOBAL);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, boolean value) throws EventCancelledException {
+        return setPermission(permission, value, Context.GLOBAL);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull PaperPermission permission) throws EventCancelledException {
+        return setPermission(permission, Context.GLOBAL);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission) {
+        return unsetPermission(permission, Context.GLOBAL);
+    }
+
+    @Override
+    public int wipePermissions() {
+        return getCoreGroup(Context.LOCAL).wipePermissions() + getCoreGroup(Context.GLOBAL).wipePermissions();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList() {
+        return Stream.concat(getPermissionList(Context.LOCAL).stream(), getPermissionList(Context.GLOBAL).stream())
+            .collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @NotNull Optional<PaperPermission> getPermission(@NotNull String permission) {
+        return Optional.ofNullable(getPermissionList(Context.LOCAL).stream()
+            .filter(paperPermission -> paperPermission.getName().equalsIgnoreCase(permission))
+            .findFirst()
+            .orElse(getPermissionList(Context.GLOBAL).stream()
+                .filter(paperPermission -> paperPermission.getName().equalsIgnoreCase(permission))
+                .findFirst()
+                .orElse(null)));
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAffectedPermissionPlayer() {
+        return Stream.concat(getCoreGroup(Context.LOCAL).getAffectedPermissionPlayer()
+                .stream(), getCoreGroup(Context.GLOBAL).getAffectedPermissionPlayer().stream())
+            .collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String permission) {
+        Optional<PaperPermission> optionalPaperPermission = getPermission(permission);
+        return optionalPaperPermission.isPresent() && optionalPaperPermission.get().getValue();
+    }
+
+    @Override
+    public @NotNull Set<PermissionAttachmentInfo> getEffectivePermissions() {
+        return getPermissionList().stream().map(permission ->
+        {
+            PermissionAttachment attachment = null;
+            if (permission instanceof KissenPaperAttachmentPermission kissenPaperAttachmentPermission) {
+                attachment = kissenPaperAttachmentPermission.getPermissionAttachment();
+            }
+            return new PermissionAttachmentInfo(this, permission.getName(), attachment, permission.getValue());
+        }).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public void permissionUpdate() {
+        getCoreGroup(Context.GLOBAL).permissionUpdate();
+        getCoreGroup(Context.LOCAL).permissionUpdate();
+        getAffectedPermissionPlayer().stream()
+            .map(Bukkit::getPlayer)
+            .filter(Objects::nonNull)
+            .forEach(Permissible::recalculatePermissions);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<String> getMember() {
+        return Stream.concat(getCoreGroup(Context.LOCAL).getMember()
+            .stream(), getCoreGroup(Context.GLOBAL).getMember().stream()).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public boolean addMember(@NotNull GroupablePermissionEntry<?> groupablePermissionEntry) {
+        return addMember(groupablePermissionEntry, Context.GLOBAL);
+    }
+
+    @Override
+    public boolean removeMember(@NotNull GroupablePermissionEntry<?> groupablePermissionEntry) {
+        return removeMember(groupablePermissionEntry, Context.GLOBAL);
+    }
+
+    @Override
+    public boolean addMember(@NotNull GroupablePermissionEntry<?> groupablePermissionEntry, @NotNull Context context) {
+        return getCoreGroup(context).addMember(groupablePermissionEntry);
+    }
+
+    @Override
+    public boolean removeMember(@NotNull GroupablePermissionEntry<?> groupablePermissionEntry, @NotNull Context context) {
+        return getCoreGroup(context).removeMember(groupablePermissionEntry);
+    }
+
+    @Override
+    public @NotNull PermissionGroup<PaperPermission> getCoreGroup(@NotNull Context context) {
+        return switch (context) {
+            case GLOBAL -> permissionGroup;
+            case LOCAL -> permissionGroup.getPrivatePermissionGroup();
+        };
+    }
+
+    @Override
+    public @NotNull Set<PaperPermission> getOwnPermissions(@NotNull Context context) {
+        return getCoreGroup(context).getOwnPermissions();
+    }
+
+    @Override
+    public @NotNull Set<PermissionGroup<PaperPermission>> getPermissionGroups(@NotNull Context context) {
+        return getCoreGroup(context).getPermissionGroups();
+    }
+
+    @Override
+    public boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup, @NotNull Context context) {
+        return getCoreGroup(context).inGroup(permissionGroup);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, @NotNull Context context) throws EventCancelledException {
+        return getCoreGroup(context).setPermission(permission);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, boolean value, @NotNull Context context) throws EventCancelledException {
+        return getCoreGroup(context).setPermission(permission, value);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull PaperPermission permission, @NotNull Context context) throws EventCancelledException {
+        return getCoreGroup(context).setPermission(permission);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission, @NotNull Context context) {
+        return getCoreGroup(context).unsetPermission(permission);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList(@NotNull Context context) {
+        return getCoreGroup(context).getPermissionList();
+    }
+
+    @Override
+    public @NotNull Optional<PaperPermission> getPermission(@NotNull String permission, @NotNull Context context) {
+        return getCoreGroup(context).getPermission(permission);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String permission, @NotNull Context context) {
+        return getCoreGroup(context).hasPermission(permission);
+    }
+
+    @Override
+    public @NotNull GroupablePermissionEntry<PaperPermission> getPermissionEntry(@NotNull Context context) {
+        return this;
+    }
+
+    @Override
+    public @NotNull Set<PaperPermission> internalPermissionCollector(@NotNull Set<String> blacklistedGroups, @NotNull Set<String> blacklistedPermissions) {
+        Set<PaperPermission> permissionSet = new HashSet<>(((InternalGroupablePermissionEntry<PaperPermission>) getCoreGroup(Context.LOCAL)).internalPermissionCollector(blacklistedGroups, blacklistedPermissions));
+        blacklistedGroups.remove(getPermissionID()); //remove blacklist because public group will be added as well.
+        permissionSet.addAll(((InternalGroupablePermissionEntry<PaperPermission>) getCoreGroup(Context.GLOBAL)).internalPermissionCollector(blacklistedGroups, blacklistedPermissions));
+        return permissionSet;
+    }
+
+    @Override
+    public @NotNull Set<String> internalGroupCollector(@NotNull Set<String> blacklistedGroups) {
+        Set<String> groups = new HashSet<>(((InternalGroupablePermissionEntry<PaperPermission>) getCoreGroup(Context.GLOBAL)).internalGroupCollector(blacklistedGroups));
+        blacklistedGroups.remove(getPermissionID()); //remove blacklist because public group will be added as well.
+        groups.addAll(((InternalGroupablePermissionEntry<PaperPermission>) getCoreGroup(Context.GLOBAL)).internalGroupCollector(blacklistedGroups));
+        return groups;
+    }
+
+    @Override
+    public boolean isOp() {
+        return hasPermission("*");
+    }
+
+    @Override
+    public void setOp(boolean value) {
+        if (isOp() && !value) {
+            unsetPermission("*");
+            return;
+        }
+
+        try {
+            setPermission("*", value);
+        } catch (EventCancelledException eventCancelledException) {
+            throw new RuntimeException(eventCancelledException);
+        }
+    }
+
+    /**
+     * Retrieves a map containing stored data from the storage system.
+     * <p>
+     * This method fetches data from the storage implementation associated with the Kissen Core instance. The data is retrieved based on the provided storage key.
+     * The retrieved data is returned as a map of string keys to associated objects.
+     *
+     * @return A non-null map containing the retrieved data from the storage system.
+     * @throws UnsupportedOperationException If the storage system is not supported or not properly configured.
+     */
+    private @NotNull Map<String, Object> getStorage() {
+        return KissenCore.getInstance()
+            .getImplementation(StorageImplementation.class)
+            .getStorage("permissiongroupattachments");
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPrivatePermissionGroup.java b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPrivatePermissionGroup.java
new file mode 100644
index 0000000000000000000000000000000000000000..e5622678e7c6b1d52b3b956aea9a2e2876b22008
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPrivatePermissionGroup.java
@@ -0,0 +1,39 @@
+package net.kissenpvp.paper.permission.group;
+
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.database.meta.ObjectMeta;
+import net.kissenpvp.core.api.database.savable.Savable;
+import net.kissenpvp.core.api.networking.socket.DataPackage;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.PaperPermissionGroup;
+import net.kissenpvp.paper.api.permission.PaperPermissionImplementation;
+import net.kissenpvp.paper.api.permission.PaperPrivatePermissionGroup;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Objects;
+
+public class KissenPaperPrivatePermissionGroup extends KissenPaperAbstractPermissionGroup implements PaperPrivatePermissionGroup {
+    @Override
+    public void sendData(@NotNull DataPackage dataPackage) { /* ignored */ }
+
+    @Override
+    public @Nullable PaperPermissionGroup getPublicGroup() {
+        return Bukkit.getKissen()
+            .getImplementation(PaperPermissionImplementation.class)
+            .getPermissionGroup(getPermissionID());
+    }
+
+    @Override
+    public @NotNull ObjectMeta getMeta() {
+        return Bukkit.getKissen().getPrivateMeta();
+    }
+
+    @Override
+    public int softDelete() throws BackendException {
+        getSerializableSavableHandler().delete();
+        ((Savable) Objects.requireNonNull(getPublicGroup()).getCoreGroup(Context.GLOBAL)).delete();
+        return super.softDelete();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPublicPermissionGroup.java b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPublicPermissionGroup.java
new file mode 100644
index 0000000000000000000000000000000000000000..861f8ec4bca4d48796efeba8b8eaa6ff3c20b600
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPublicPermissionGroup.java
@@ -0,0 +1,45 @@
+package net.kissenpvp.paper.permission.group;
+
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.networking.socket.DataPackage;
+import net.kissenpvp.paper.api.permission.PaperPrivatePermissionGroup;
+import net.kissenpvp.paper.api.permission.PaperPublicPermissionGroup;
+import net.kissenpvp.paper.permission.KissenPaperPermissionImplementation;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Objects;
+
+public class KissenPaperPublicPermissionGroup extends KissenPaperAbstractPermissionGroup implements PaperPublicPermissionGroup {
+
+    @Override
+    public @NotNull String getSaveID() {
+        return "PublicPermissionGroup";
+    }
+
+    @Override
+    public void sendData(@NotNull DataPackage dataPackage) {
+        //TODO
+    }
+
+    @Override
+    public @NotNull PaperPrivatePermissionGroup getPrivatePermissionGroup() {
+        KissenPaperPermissionImplementation paperPermissionImplementation = Bukkit.getKissen()
+            .getImplementation(KissenPaperPermissionImplementation.class);
+        return Objects.requireNonNullElseGet(paperPermissionImplementation.getPrivatePermissionGroup(getPermissionID()), () -> {
+            try {
+                return paperPermissionImplementation.createPrivateInternalPermissionGroup(getPermissionID(), null);
+            } catch (BackendException backendException) {
+                throw new RuntimeException(backendException); //TODO use better approach
+            }
+        });
+    }
+
+    @Override
+    public int softDelete() throws BackendException {
+        Bukkit.getKissen()
+            .getImplementation(KissenPaperPermissionImplementation.class)
+            .removePublicPermissionGroup(getPermissionID());
+        return super.softDelete();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPermissible.java b/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPermissible.java
new file mode 100644
index 0000000000000000000000000000000000000000..b4c4b1b13fb416e71abfdca1358ce81a18e183f7
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPermissible.java
@@ -0,0 +1,179 @@
+package net.kissenpvp.paper.permission.permissible;
+
+import net.kissenpvp.core.api.message.ComponentSerializer;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.PaperPermissible;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.permission.KissenPaperAttachmentPermission;
+import net.kissenpvp.paper.permission.KissenPaperGroupablePermissionEntry;
+import net.kissenpvp.paper.permission.RemoveAttachmentRunnable;
+import net.kissenpvp.paper.user.KissenPaperPublicUser;
+import org.bukkit.Bukkit;
+import org.bukkit.permissions.*;
+import org.bukkit.plugin.Plugin;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.logging.Level;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public abstract class KissenPaperPermissible implements KissenPaperGroupablePermissionEntry, PaperPermissible {
+
+    protected final Permissible parent;
+    protected final Set<PermissionAttachment> attachments;
+
+    public KissenPaperPermissible() {
+        this(null);
+    }
+
+    public KissenPaperPermissible(@Nullable Permissible parent) {
+        this.attachments = new HashSet<>();
+        this.parent = parent == null ? this : parent;
+        permissionUpdate();
+    }
+
+    @Override
+    public void permissionUpdate() {
+        unsubscribe();
+
+        Bukkit.getServer().getPluginManager().subscribeToDefaultPerms(isOp() || hasPermission("*"), parent);
+        for (PaperPermission permission : getPermissionList()) {
+            Bukkit.getServer().getPluginManager().subscribeToPermission(permission.getName(), parent);
+        }
+    }
+
+    @Override
+    public boolean isPermissionSet(@NotNull String name) {
+        return getPermission(name).isPresent();
+    }
+
+    @Override
+    public boolean isPermissionSet(@NotNull Permission perm) {
+        return isPermissionSet(perm.getName());
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull Permission perm) {
+        return hasPermission(perm.getName());
+    }
+
+    @Override
+    public @NotNull PermissionAttachment addAttachment(@NotNull Plugin plugin) {
+        PermissionAttachment result = new PermissionAttachment(plugin, parent);
+
+        attachments.add(result);
+        permissionUpdate();
+
+        return result;
+    }
+
+    @Override
+    public @NotNull PermissionAttachment addAttachment(@NotNull Plugin plugin, @NotNull String name, boolean value) {
+        PermissionAttachment permissionAttachment = addAttachment(plugin);
+        permissionAttachment.setPermission(name, value);
+        return permissionAttachment;
+    }
+
+    @Override
+    public @Nullable PermissionAttachment addAttachment(@NotNull Plugin plugin, @NotNull String name, boolean value, int ticks) {
+        PermissionAttachment permissionAttachment = addAttachment(plugin, ticks);
+        if (permissionAttachment != null) {
+            permissionAttachment.setPermission(name, value);
+        }
+        return permissionAttachment;
+    }
+
+    @Override
+    public @Nullable PermissionAttachment addAttachment(@NotNull Plugin plugin, int ticks) {
+        PermissionAttachment result = addAttachment(plugin);
+
+        if (Bukkit.getServer()
+                .getScheduler()
+                .scheduleSyncDelayedTask(plugin, new RemoveAttachmentRunnable(result), ticks) == -1) {
+            Bukkit.getServer()
+                    .getLogger()
+                    .log(Level.WARNING, "Could not add PermissionAttachment to " + ComponentSerializer.getInstance()
+                            .getLegacySerializer()
+                            .serialize(displayName()) + " for plugin " + plugin.getPluginMeta()
+                            .getDisplayName() + ": Scheduler returned -1");
+            result.remove();
+            return null;
+        } else {
+            return result;
+        }
+    }
+
+    @Override
+    public void removeAttachment(@NotNull PermissionAttachment attachment) {
+        if (attachments.remove(attachment)) {
+            PermissionRemovedExecutor permissionRemovedExecutor = attachment.getRemovalCallback();
+
+            if (permissionRemovedExecutor != null) {
+                permissionRemovedExecutor.attachmentRemoved(attachment);
+            }
+
+            permissionUpdate();
+        } else {
+            throw new IllegalArgumentException("Given attachment is not part of Permissible object " + ComponentSerializer.getInstance()
+                    .getLegacySerializer()
+                    .serialize(displayName()));
+        }
+    }
+
+    @Override
+    public void recalculatePermissions() {
+        permissionUpdate();
+    }
+
+    @Override
+    public @NotNull Set<PermissionAttachmentInfo> getEffectivePermissions() {
+        Set<PermissionAttachmentInfo> permissionAttachments = getPermissionList().stream().map(permission -> {
+            PermissionAttachment attachment = null;
+            if (permission instanceof KissenPaperAttachmentPermission kissenPaperAttachmentPermission) {
+                attachment = kissenPaperAttachmentPermission.getPermissionAttachment();
+            }
+            return new PermissionAttachmentInfo(parent, permission.getName(), attachment, permission.getValue());
+        }).collect(Collectors.toSet());
+        return permissionAttachments;
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList() {
+
+        Set<KissenPaperAttachmentPermission> kissenPaperAttachmentPermissions = new HashSet<>();
+        for (PermissionAttachment permissionAttachment : attachments) {
+            permissionAttachment.getPermissions()
+                    .forEach((key, value) -> kissenPaperAttachmentPermissions.add(new KissenPaperAttachmentPermission(permissionAttachment, key, value, KissenPaperPermissible.this, true)));
+        }
+
+        return Stream.concat(KissenPaperGroupablePermissionEntry.super.getPermissionList()
+                .stream(), kissenPaperAttachmentPermissions.stream()).collect(Collectors.toSet());
+    }
+
+    /**
+     * The <code>unsubscribe</code> method is used to deregister all permissions from a parent permission holder in the Bukkit server.
+     *
+     * <p>As a result of calling this method, the permission holder specified by 'parent' would not hold the permissions anymore until re-registered.</p>
+     *
+     * <p>Note: Parent could be a Player, a Group, or any entity that can hold permissions in Bukkit.</p>
+     *
+     * <p>It is advised to call this method when you no longer need the permissions to be associated with the parent or want to clear current permissions before setting new ones.</p>
+     *
+     * @see net.kissenpvp.core.api.permission.Permission
+     * @see org.bukkit.permissions.Permissible
+     */
+    public void unsubscribe() {
+        for (String name : getPermissionList().stream()
+                .map(net.kissenpvp.core.api.permission.Permission::getName)
+                .collect(Collectors.toSet())) {
+            Bukkit.getServer().getPluginManager().unsubscribeFromPermission(name, parent);
+        }
+
+        Bukkit.getServer().getPluginManager().unsubscribeFromDefaultPerms(false, parent);
+        Bukkit.getServer().getPluginManager().unsubscribeFromDefaultPerms(true, parent);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPlayerPermissible.java b/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPlayerPermissible.java
new file mode 100644
index 0000000000000000000000000000000000000000..5bdd283dcf595f720adf4536fd90f97d54309c6f
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPlayerPermissible.java
@@ -0,0 +1,55 @@
+package net.kissenpvp.paper.permission.permissible;
+
+import net.kissenpvp.core.api.permission.GroupablePermissionEntry;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kyori.adventure.text.Component;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.permissions.Permissible;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Collections;
+import java.util.Set;
+import java.util.UUID;
+
+public class KissenPaperPlayerPermissible extends KissenPaperPermissible {
+
+    public KissenPaperPlayerPermissible(@NotNull Permissible parent) {
+        super(parent);
+    }
+
+    public @NotNull OfflinePlayer getPlayer() {
+        return (OfflinePlayer) parent; // Can be offline or online, does not matter
+    }
+
+    @Override
+    public @NotNull GroupablePermissionEntry<PaperPermission> getPermissionEntry(@NotNull Context context) {
+        return (GroupablePermissionEntry<PaperPermission>) getPlayer().getUser(context);
+    }
+
+    @Override
+    public @NotNull String getPermissionID() {
+        return getPermissionEntry(Context.GLOBAL).getPermissionID();
+    }
+
+    @Override
+    public @NotNull Component displayName() {
+        return getPlayer().displayName();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAffectedPermissionPlayer() {
+        return Collections.singleton(getPlayer().getUniqueId());
+    }
+
+    @Override
+    public boolean isOp() {
+        return getPlayer().isOp();
+    }
+
+    @Override
+    public void setOp(boolean value) {
+        getPlayer().setOp(value);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenPaperPrivateUser.java b/src/main/java/net/kissenpvp/paper/user/KissenPaperPrivateUser.java
new file mode 100644
index 0000000000000000000000000000000000000000..afb1b94314b0c919ee88219d2c6a625d193c4c8e
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/KissenPaperPrivateUser.java
@@ -0,0 +1,70 @@
+package net.kissenpvp.paper.user;
+
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.networking.client.entitiy.PlayerClient;
+import net.kissenpvp.core.api.networking.socket.DataPackage;
+import net.kissenpvp.core.api.permission.PermissionGroup;
+import net.kissenpvp.core.base.KissenCore;
+import net.kissenpvp.core.database.DataWriter;
+import net.kissenpvp.core.networking.client.entity.KissenPlayerClient;
+import net.kissenpvp.core.permission.KissenPermissionNode;
+import net.kissenpvp.core.user.KissenUser;
+import net.kissenpvp.paper.api.ban.PaperPunishment;
+import net.kissenpvp.paper.api.networking.client.entity.PaperPlayerClient;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PaperPermissionImplementation;
+import net.kissenpvp.paper.api.user.rank.PaperPlayerRank;
+import net.kissenpvp.paper.permission.KissenPaperPermission;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Objects;
+import java.util.Set;
+import java.util.UUID;
+import java.util.stream.Collectors;
+
+public class KissenPaperPrivateUser extends KissenUser<PaperPermission> {
+
+    public KissenPaperPrivateUser(@Nullable UUID uuid, @Nullable String name) throws BackendException {
+        super(uuid, name);
+    }
+
+    @Override
+    public @NotNull String getSaveID() {
+        return "privateuser";
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups() {
+        return KissenCore.getInstance()
+            .getImplementation(PaperPermissionImplementation.class)
+            .getPrivatePermissionGroupSet()
+            .stream()
+            .filter(permissionGroup -> permissionGroup.getMember().contains(getPermissionID()))
+            .collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public PlayerClient<?, ?, ?> getPlayerClient() {
+        if (!getStorage().containsKey("player_client")) {
+            getStorage().put("player_client", injectPlayerClient());
+        }
+        return (PlayerClient<?, ?, ?>) getStorage().get("player_client");
+    }
+
+    protected @NotNull PaperPlayerClient injectPlayerClient() {
+        UUID uuid = UUID.fromString(getRawID());
+        return Bukkit.getKissen()
+            .isOnline(uuid) ? Objects.requireNonNull(Bukkit.getPlayer(uuid)) : Bukkit.getOfflinePlayer(uuid);
+    }
+
+    @Override
+    protected @NotNull PaperPermission translatePermission(@NotNull KissenPermissionNode kissenPermissionNode, @Nullable DataWriter dataWriter) {
+        return new KissenPaperPermission(kissenPermissionNode, this, dataWriter);
+    }
+
+    @Override
+    public void sendData(@NotNull DataPackage dataPackage) { /* Ignored because it's private */ }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenPaperPublicUser.java b/src/main/java/net/kissenpvp/paper/user/KissenPaperPublicUser.java
new file mode 100644
index 0000000000000000000000000000000000000000..b99bcfe1787035c5fadd3b08411a3cf3ff852725
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/KissenPaperPublicUser.java
@@ -0,0 +1,100 @@
+package net.kissenpvp.paper.user;
+
+import net.kissenpvp.core.api.database.StorageImplementation;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.networking.client.entitiy.PlayerClient;
+import net.kissenpvp.core.api.networking.socket.DataPackage;
+import net.kissenpvp.core.api.permission.PermissionGroup;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.base.KissenCore;
+import net.kissenpvp.core.database.DataWriter;
+import net.kissenpvp.core.permission.KissenPermissionNode;
+import net.kissenpvp.core.user.KissenPublicUser;
+import net.kissenpvp.core.user.KissenUser;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PaperPermissionImplementation;
+import net.kissenpvp.paper.permission.KissenPaperPermission;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Set;
+import java.util.UUID;
+import java.util.stream.Collectors;
+
+public class KissenPaperPublicUser extends KissenPublicUser<PaperPermission> {
+
+    public KissenPaperPublicUser(@Nullable UUID uuid, @Nullable String name) throws BackendException {
+        super(uuid, name);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups() {
+        return KissenCore.getInstance()
+            .getImplementation(PaperPermissionImplementation.class)
+            .getPermissionGroupSet()
+            .stream()
+            .filter(permissionGroup -> permissionGroup.getMember().contains(getPermissionID()))
+            .collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public PlayerClient<?, ?, ?> getPlayerClient() {
+        return getPrivateUserEntry().getPlayerClient();
+    }
+
+    @Override
+    protected @NotNull PaperPermission translatePermission(@NotNull KissenPermissionNode kissenPermissionNode, @Nullable DataWriter dataWriter) {
+        return new KissenPaperPermission(kissenPermissionNode, this, dataWriter);
+    }
+
+    @Override
+    public void sendData(@NotNull DataPackage dataPackage) {
+        // TODO Networking and stuff
+    }
+
+    @Override
+    public void login() {
+        super.login();
+        //getStorage().put("visual_hash", kissenPaperPlayerClient.visualHash()); //TODO
+        getStorage().put("time_joined", System.currentTimeMillis());
+        ((KissenUser<?>) getPrivateUserEntry()).login();
+        getStorage().put("tick", true);
+    }
+
+    @Override
+    public void logout() {
+        super.logout();
+        Bukkit.getKissen().getImplementation(StorageImplementation.class).dropStorage("user" + this.getRawID());
+    }
+
+    @Override
+    public void tick() {
+        //TODO check for visuals maybe
+        ((KissenUser<PaperPermission>) getPrivateUserEntry()).tick();
+        super.tick();
+    }
+
+    @Override
+    public int softDelete() throws BackendException {
+        return super.softDelete() + getPrivateUserEntry().delete();
+    }
+
+    public User getPrivateUserEntry() {
+        if (!getStorage().containsKey("private_user_entry")) {
+            try {
+                getStorage().put("private_user_entry", setupPrivateUser(UUID.fromString(getRawID()), getNotNull("name")));
+            } catch (BackendException backendException) {
+                KissenCore.getInstance()
+                    .getLogger()
+                    .error("The backend was not able to create a private user entry for the user '{}' with the id '{}'. It's advised to shutdown the server to prevent further problems with the servers data.", getNotNull("name"), getRawID());
+            }
+        }
+        return (User) getStorage().get("private_user_entry");
+    }
+
+    protected KissenPaperPrivateUser setupPrivateUser(UUID uuid, String name) throws BackendException {
+        return new KissenPaperPrivateUser(uuid, name);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenPaperUserImplementation.java b/src/main/java/net/kissenpvp/paper/user/KissenPaperUserImplementation.java
new file mode 100644
index 0000000000000000000000000000000000000000..24d5563aa6fdb2d3d03e069de2c5f9f5a0704443
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/KissenPaperUserImplementation.java
@@ -0,0 +1,28 @@
+package net.kissenpvp.paper.user;
+
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.database.savable.SavableMap;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.user.KissenUserImplementation;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Optional;
+import java.util.Set;
+import java.util.UUID;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public class KissenPaperUserImplementation extends KissenUserImplementation {
+
+    @Override
+    public @NotNull @Unmodifiable Set<SavableMap> getUserData() throws BackendException {
+        return Stream.concat(getUserMeta().getData(new KissenPaperPublicUser(null, null)).values().stream(), getUserMeta().getData(new KissenPaperPrivateUser(null, null)).values().stream()).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull UUID uuid) {
+        return getOnlineUser(uuid).or(() -> Optional.of(Bukkit.getOfflinePlayer(uuid).getUser())).orElseThrow(IllegalArgumentException::new);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperFallBackRank.java b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperFallBackRank.java
new file mode 100644
index 0000000000000000000000000000000000000000..f382c587fc83cc3b8fdc34ad36ff83b1bb8820b1
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperFallBackRank.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2023 KissenPvP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.kissenpvp.paper.user.rank;
+
+import net.kissenpvp.core.user.rank.KissenFallBackRank;
+import net.kissenpvp.paper.api.networking.client.entity.PaperPlayerClient;
+import net.kissenpvp.paper.api.user.rank.PaperRank;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Optional;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+public class KissenPaperFallBackRank extends KissenFallBackRank implements PaperRank {
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPlayerClient> getPlayers() {
+        return Bukkit.getOnlinePlayers().stream().filter(playerClient ->
+        {
+            Optional<PaperRank> paperRankOptional = playerClient.getRank().getSource();
+            return paperRankOptional.isPresent() && paperRankOptional.get().equals(this);
+        }).collect(Collectors.toUnmodifiableSet());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperPlayerFallBackRank.java b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperPlayerFallBackRank.java
new file mode 100644
index 0000000000000000000000000000000000000000..5f5f117ececb617afa6c26705318d6d28b47ddb9
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperPlayerFallBackRank.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2023 KissenPvP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.kissenpvp.paper.user.rank;
+
+import net.kissenpvp.core.user.rank.KissenPlayerFallBackRank;
+import net.kissenpvp.paper.api.user.rank.PaperPlayerRank;
+import net.kissenpvp.paper.api.user.rank.PaperRank;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Optional;
+
+public class KissenPaperPlayerFallBackRank extends KissenPlayerFallBackRank<PaperRank> implements PaperPlayerRank
+{
+    @Override public @NotNull Optional<PaperRank> getSource()
+    {
+        return Optional.of(new KissenPaperFallBackRank());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperPlayerRank.java b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperPlayerRank.java
new file mode 100644
index 0000000000000000000000000000000000000000..dfbb88cf0967780950a0a9a9b638bfa5b7358ec3
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperPlayerRank.java
@@ -0,0 +1,15 @@
+package net.kissenpvp.paper.user.rank;
+
+import net.kissenpvp.core.database.DataWriter;
+import net.kissenpvp.core.user.rank.KissenPlayerRank;
+import net.kissenpvp.core.user.rank.KissenPlayerRankNode;
+import net.kissenpvp.paper.api.user.rank.PaperPlayerRank;
+import net.kissenpvp.paper.api.user.rank.PaperRank;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class KissenPaperPlayerRank extends KissenPlayerRank<PaperRank> implements PaperPlayerRank {
+    public KissenPaperPlayerRank(@NotNull KissenPlayerRankNode kissenPlayerRankNode, @Nullable DataWriter dataWriter) {
+        super(kissenPlayerRankNode, dataWriter);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperRank.java b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperRank.java
new file mode 100644
index 0000000000000000000000000000000000000000..e595eb22e76fb5d110c3d9897c640d3ebff84286
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperRank.java
@@ -0,0 +1,13 @@
+package net.kissenpvp.paper.user.rank;
+
+import net.kissenpvp.core.api.networking.socket.DataPackage;
+import net.kissenpvp.core.api.user.rank.Rank;
+import net.kissenpvp.core.user.rank.KissenRank;
+import org.jetbrains.annotations.NotNull;
+
+public class KissenPaperRank extends KissenRank implements Rank {
+    @Override
+    public void sendData(@NotNull DataPackage dataPackage) {
+        //TODO async network and so on
+    }
+}
