From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Groldi <chniucg@gmail.com>
Date: Thu, 10 Aug 2023 02:15:10 +0200
Subject: [PATCH] Integrated kissen into paper


diff --git a/src/main/java/io/papermc/paper/plugin/manager/PaperPluginInstanceManager.java b/src/main/java/io/papermc/paper/plugin/manager/PaperPluginInstanceManager.java
index 9c7552968b8c017c71a7a77557a66a03ed89f125..9ae147de1f07a7b8f06d6d6b213b3fcf7907c247 100644
--- a/src/main/java/io/papermc/paper/plugin/manager/PaperPluginInstanceManager.java
+++ b/src/main/java/io/papermc/paper/plugin/manager/PaperPluginInstanceManager.java
@@ -11,6 +11,8 @@ import io.papermc.paper.plugin.provider.classloader.ConfiguredPluginClassLoader;
 import io.papermc.paper.plugin.provider.classloader.PaperClassLoaderStorage;
 import io.papermc.paper.plugin.provider.source.DirectoryProviderSource;
 import io.papermc.paper.plugin.provider.source.FileProviderSource;
+import net.kissenpvp.core.base.KissenCore;
+import net.kissenpvp.core.base.KissenImplementation;
 import org.bukkit.Bukkit;
 import org.bukkit.Server;
 import org.bukkit.World;
@@ -145,7 +147,17 @@ class PaperPluginInstanceManager {
     public void disablePlugins() {
         Plugin[] plugins = this.getPlugins();
         for (int i = plugins.length - 1; i >= 0; i--) {
+            // KissenPaper start
+            for (KissenImplementation kissenImplementation : KissenCore.getInstance().getKissenImplementations()) {
+                kissenImplementation.disable(plugins[i]);
+            }
+            // KissenPaper end
             this.disablePlugin(plugins[i]);
+            // KissenPaper start
+            for (KissenImplementation kissenImplementation : KissenCore.getInstance().getKissenImplementations()) {
+                kissenImplementation.postDisable(plugins[i]);
+            }
+            // KissenPaper end
         }
     }
 
diff --git a/src/main/java/io/papermc/paper/plugin/storage/ServerPluginProviderStorage.java b/src/main/java/io/papermc/paper/plugin/storage/ServerPluginProviderStorage.java
index cb9b13522a976b82bcb71cef486f11f4172e3e99..7d9eef61b53e190aabd82e143c47ff54c994c466 100644
--- a/src/main/java/io/papermc/paper/plugin/storage/ServerPluginProviderStorage.java
+++ b/src/main/java/io/papermc/paper/plugin/storage/ServerPluginProviderStorage.java
@@ -9,6 +9,7 @@ import io.papermc.paper.plugin.provider.PluginProvider;
 import io.papermc.paper.plugin.provider.ProviderStatus;
 import io.papermc.paper.plugin.provider.ProviderStatusHolder;
 import io.papermc.paper.plugin.provider.type.paper.PaperPluginParent;
+import net.kissenpvp.core.base.KissenCore;
 import org.bukkit.plugin.Plugin;
 import org.bukkit.plugin.java.JavaPlugin;
 import org.slf4j.Logger;
@@ -35,6 +36,11 @@ public class ServerPluginProviderStorage extends ConfiguredProviderStorage<JavaP
 
             @Override
             public boolean load(PluginProvider<JavaPlugin> provider, JavaPlugin provided) {
+                // KissenPaper start
+                KissenCore.getInstance()
+                        .getKissenImplementations()
+                        .forEach(kissenImplementation -> kissenImplementation.load(provided));
+                // KissenPaper end
                 // Add it to the map here, we have to run the actual loading logic later.
                 PaperPluginManagerImpl.getInstance().loadPlugin(provided);
                 return true;
@@ -57,6 +63,12 @@ public class ServerPluginProviderStorage extends ConfiguredProviderStorage<JavaP
         try {
             provided.getLogger().info(String.format("Loading server plugin %s", provided.getPluginMeta().getDisplayName()));
             provided.onLoad();
+
+            // KissenPaper start
+            KissenCore.getInstance()
+                    .getKissenImplementations()
+                    .forEach(kissenImplementation -> kissenImplementation.postLoad(provided));
+            // KissenPaper end
         } catch (Throwable ex) {
             // Don't mark that provider as ERRORED, as this apparently still needs to run the onEnable logic.
             provided.getSLF4JLogger().error("Error initializing plugin '%s' in folder '%s' (Is it up to date?)".formatted(provider.getFileName(), provider.getParentSource()), ex);
diff --git a/src/main/java/net/kissenpvp/paper/base/KissenPaperCore.java b/src/main/java/net/kissenpvp/paper/base/KissenPaperCore.java
new file mode 100644
index 0000000000000000000000000000000000000000..185601aca6de6346061d1c2f97f7a2742c96f486
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/base/KissenPaperCore.java
@@ -0,0 +1,54 @@
+package net.kissenpvp.paper.base;
+
+import net.kissenpvp.core.api.database.meta.ObjectMeta;
+import net.kissenpvp.core.api.networking.client.entitiy.ConsoleClient;
+import net.kissenpvp.core.base.KissenCore;
+import net.kissenpvp.paper.api.base.PaperKissen;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.slf4j.Logger;
+
+import java.util.UUID;
+
+// KissenPaper
+public class KissenPaperCore extends KissenCore implements PaperKissen {
+
+    public KissenPaperCore(@NotNull Logger logger) {
+        super(logger);
+    }
+
+    @Override
+    public int getPort() {
+        return Bukkit.getPort();
+    }
+
+    @Override
+    public boolean isOnline(@NotNull UUID uuid) {
+        return Bukkit.getPlayer(uuid) != null;
+    }
+
+    @Override
+    public boolean isOnline(@NotNull String s) {
+        return Bukkit.getPlayer(s) != null;
+    }
+
+    @Override
+    public @NotNull ConsoleClient getConsole() {
+        return Bukkit.getConsoleSender();
+    }
+
+    @Override
+    public void repeatTask(@NotNull String name, int l1, @NotNull Runnable runnable) {
+        //TODO add task class
+    }
+
+    @Override
+    public void runTask(long l, @NotNull Runnable runnable) {
+        //TODO look method above
+    }
+
+    @Override
+    public ObjectMeta getPrivateMeta() {
+        return KissenCore.getInstance().getPublicMeta(); //TODO
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/KissenPaperCommandImplementation.java b/src/main/java/net/kissenpvp/paper/command/KissenPaperCommandImplementation.java
new file mode 100644
index 0000000000000000000000000000000000000000..a6b230a62bc7da369503f24d8d0df9143721beb0
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/KissenPaperCommandImplementation.java
@@ -0,0 +1,185 @@
+package net.kissenpvp.paper.command;
+
+import net.kissenpvp.core.api.command.annotations.CommandData;
+import net.kissenpvp.core.api.command.annotations.TabCompleter;
+import net.kissenpvp.core.api.command.executor.TabCompleterExecutor;
+import net.kissenpvp.core.base.KissenImplementation;
+import net.kissenpvp.core.command.CommandInfo;
+import net.kissenpvp.core.command.KissenCommandImplementation;
+import net.kissenpvp.core.command.argument.MethodEvaluator;
+import net.kissenpvp.paper.api.command.KissenCommand;
+import net.kissenpvp.paper.api.command.PaperCommandImplementation;
+import net.kissenpvp.paper.command.command.plugin.KissenPaperPluginCommand;
+import net.kissenpvp.paper.command.command.system.KissenPaperCommand;
+import net.kissenpvp.paper.command.executor.KissenPaperCommandExecutor;
+import net.kissenpvp.paper.command.executor.KissenPaperCompleteExecutor;
+import net.kissenpvp.paper.command.target.KissenPaperTargetValidator;
+import org.bukkit.Bukkit;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandMap;
+import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.plugin.Plugin;
+import org.jetbrains.annotations.NotNull;
+
+import java.lang.reflect.Method;
+import java.util.Optional;
+import java.util.function.Consumer;
+
+/**
+ * Represents a Kissen Paper command implementation that extends the functionality of the Kissen command framework
+ * and is compatible with the Paper server platform.
+ * <p>
+ * This class extends {@link KissenCommandImplementation} and implements the {@link PaperCommandImplementation} interface
+ * to provide specialized command handling and execution functionality tailored for the Paper server platform.
+ * It integrates seamlessly with the Kissen command framework and enhances it with Paper-specific features.
+ */
+public class KissenPaperCommandImplementation extends KissenCommandImplementation implements PaperCommandImplementation, KissenImplementation {
+
+    private final MethodEvaluator methodEvaluator;
+    private final KissenPaperTargetValidator kissenPaperTargetValidator;
+
+    /**
+     * Constructs a new instance of {@link KissenPaperCommandImplementation}.
+     * <p>
+     * This constructor initializes the {@link MethodEvaluator} and {@link KissenPaperTargetValidator} instances used by this
+     * Kissen Paper command implementation for evaluating command methods and validating command execution targets.
+     */
+    public KissenPaperCommandImplementation() {
+        this.methodEvaluator = new MethodEvaluator();
+        this.kissenPaperTargetValidator = new KissenPaperTargetValidator();
+    }
+
+    @Override
+    public @NotNull Optional<Command> getCommand(@NotNull String name) {
+        return Optional.ofNullable(getCommandMap().getCommand(name));
+    }
+
+    @Override
+    public void registerCommand(@NotNull Plugin plugin, @NotNull Object... objects) {
+        for (Object object : objects) {
+            for (Method method : object.getClass().getDeclaredMethods()) {
+                injectObjectMethod(plugin, object, method);
+            }
+        }
+    }
+
+    public void registerCommand(@NotNull Object... objects) {
+        for (Object object : objects) {
+            for (Method method : object.getClass().getDeclaredMethods()) {
+                injectObjectMethod(object, method);
+            }
+        }
+    }
+
+    @Override
+    public void registerCompleter(@NotNull Plugin plugin, @NotNull String name, @NotNull TabCompleterExecutor<CommandSender> tabCompleterExecutor) {
+        //TODO
+    }
+
+    public void registerCompleter(@NotNull String name, @NotNull TabCompleterExecutor<CommandSender> tabCompleterExecutor) {
+        //TODO
+    }
+
+    @Override
+    public boolean unregisterCommand(@NotNull String name) {
+        Command command = getCommandMap().getCommand(name);
+        return command != null && command.unregister(getCommandMap()) && getCommandMap().getKnownCommands()
+            .remove(name) != null;
+    }
+
+    /**
+     * Returns the {@link MethodEvaluator} associated with this Kissen Paper command executor.
+     * <p>
+     * This method retrieves and returns the {@link MethodEvaluator} instance that is used by this Kissen Paper command executor
+     * to evaluate and process command arguments and parameters.
+     *
+     * @return The {@link MethodEvaluator} associated with this Kissen Paper command executor.
+     */
+    public MethodEvaluator getMethodEvaluator() {
+        return methodEvaluator;
+    }
+
+    /**
+     * Returns the {@link KissenPaperTargetValidator} associated with this Kissen Paper command executor.
+     * <p>
+     * This method retrieves and returns the {@link KissenPaperTargetValidator} instance that is used by this Kissen Paper command executor
+     * to validate and process the target of the command execution.
+     *
+     * @return The {@link KissenPaperTargetValidator} associated with this Kissen Paper command executor.
+     */
+    public KissenPaperTargetValidator getKissenPaperTargetValidator() {
+        return kissenPaperTargetValidator;
+    }
+
+    /**
+     * Injects a method from an object as a command or tab completer into the Kissen Paper command framework.
+     * <p>
+     * This method is used to register a method from an object as a command or tab completer within the Kissen Paper command framework.
+     * The method's annotations are inspected to determine whether it should be registered as a command or tab completer.
+     *
+     * @param plugin The {@link Plugin} that owns the command or tab completer. Must not be null.
+     * @param object The object containing the method to be registered. Must not be null.
+     * @param method The method to be registered as a command or tab completer. Must not be null.
+     * @throws NullPointerException If any of the {@code plugin}, {@code object}, or {@code method} parameters is null.
+     */
+    private void injectObjectMethod(@NotNull Plugin plugin, @NotNull Object object, @NotNull Method method) {
+        final CommandData command = method.getAnnotation(CommandData.class);
+        if (command != null) {
+            KissenPaperPluginCommand kissenPaperPluginCommand = internalCommandRegister(plugin, command, (var) -> {});
+            kissenPaperPluginCommand.initCommand(new CommandInfo(command), new KissenPaperCommandExecutor(method, object));
+        }
+
+        TabCompleter completer = method.getAnnotation(TabCompleter.class);
+        if (completer != null) {
+            registerCompleter(plugin, completer.command(), new KissenPaperCompleteExecutor(method, object));
+        }
+    }
+
+    private void injectObjectMethod(@NotNull Object object, @NotNull Method method) {
+        final CommandData command = method.getAnnotation(CommandData.class);
+        if (command != null) {
+            KissenPaperCommand kissenPaperCommand = internalCommandRegister(command, (var) -> {});
+            kissenPaperCommand.initCommand(new CommandInfo(command), new KissenPaperCommandExecutor(method, object));
+        }
+
+        TabCompleter completer = method.getAnnotation(TabCompleter.class);
+        if (completer != null) {
+            registerCompleter(completer.command(), new KissenPaperCompleteExecutor(method, object));
+        }
+    }
+
+    /**
+     * Registers a new {@link KissenCommand} with the provided plugin and commandData using a command consumer.
+     * <p>
+     * This method is used to create and register a new {@link KissenCommand} instance under the given commandData within the Kissen Paper command framework.
+     * A command consumer is used to configure and customize the newly created command before registration.
+     *
+     * @param plugin          The {@link Plugin} that owns the command. Must not be null.
+     * @param commandData     The commandData of the command. Must not be null.
+     * @param commandConsumer A {@link Consumer} that configures the properties of the command. Must not be null.
+     * @return The registered {@link KissenCommand} instance.
+     * @throws NullPointerException If any of the {@code plugin}, {@code commandData}, or {@code commandConsumer} parameters is null.
+     */
+    private @NotNull KissenPaperPluginCommand internalCommandRegister(@NotNull Plugin plugin, @NotNull CommandData commandData, @NotNull Consumer<KissenPaperPluginCommand> commandConsumer) {
+        return (KissenPaperPluginCommand) registerCommandObject(new KissenPaperPluginCommand(plugin, commandData.name()
+            .split("\\.")[0], 0), plugin.getName());
+    }
+
+    private @NotNull KissenPaperCommand internalCommandRegister(@NotNull CommandData commandData, @NotNull Consumer<KissenPaperCommand> commandConsumer) {
+
+        return (KissenPaperCommand) registerCommandObject(new KissenPaperCommand(commandData.name()
+            .split("\\.")[0], 0), "kissenpaper");
+    }
+
+    private KissenCommand registerCommandObject(@NotNull KissenCommand kissenCommand, @NotNull String fallback) {
+        kissenCommand.register(getCommandMap());
+        getCommandMap().register(fallback, kissenCommand);
+        ((CraftServer) Bukkit.getServer()).syncCommands();
+        return kissenCommand;
+    }
+
+    private @NotNull CommandMap getCommandMap() {
+        return Bukkit.getCommandMap();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/command/KissenPaperAbstractCommand.java b/src/main/java/net/kissenpvp/paper/command/command/KissenPaperAbstractCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..015bd3b66d2f37ce3aa8dacb97895d7d6276ba53
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/command/KissenPaperAbstractCommand.java
@@ -0,0 +1,276 @@
+package net.kissenpvp.paper.command.command;
+
+import net.kissenpvp.core.api.command.executor.CommandExecutor;
+import net.kissenpvp.core.api.command.executor.TabCompleterExecutor;
+import net.kissenpvp.core.api.networking.client.entitiy.ServerEntity;
+import net.kissenpvp.core.command.CommandHolder;
+import net.kissenpvp.core.command.CommandInfo;
+import net.kissenpvp.paper.api.command.KissenCommand;
+import net.kissenpvp.paper.command.KissenPaperCommandImplementation;
+import net.kissenpvp.paper.command.command.system.KissenPaperChildCommand;
+import net.kissenpvp.paper.command.executor.KissenPaperCommandExecutor;
+import net.kissenpvp.paper.command.target.KissenPaperTargetValidator;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandException;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.*;
+
+/**
+ * Represents a command implementation specific to the Kissen Paper framework.
+ * <p>
+ * This class extends the {@link KissenCommand} class and serves as a command implementation tailored for the Kissen Paper framework.
+ * It provides functionality for creating and managing sub-commands within the Kissen Paper command hierarchy.
+ */
+public abstract class KissenPaperAbstractCommand<C extends KissenPaperAbstractCommand<C>> extends KissenCommand implements CommandHolder<CommandSender, C> {
+
+    private final int position;
+    private final List<C> children; //C can be plugin child or system child
+    private CommandInfo commandInfo;
+    private CommandExecutor<CommandSender> commandExecutor;
+    private TabCompleterExecutor<CommandSender> tabExecutor;
+
+    /**
+     * Constructs a new {@link KissenPaperAbstractCommand} instance with the provided plugin, name, and position.
+     * <p>
+     * This constructor is used to create a new {@link KissenPaperAbstractCommand} instance with the specified plugin, command name, and position in the command hierarchy.
+     *
+     * @param name     The name of the command. Must not be null.
+     * @param position The position of the command in the command hierarchy.
+     * @throws NullPointerException If either the {@code plugin} or {@code name} parameter is null.
+     */
+    public KissenPaperAbstractCommand(@NotNull String name, int position) {
+        super(name);
+        this.position = position;
+
+        this.children = new ArrayList<>();
+    }
+
+    @Override
+    public int getPosition() {
+        return position;
+    }
+
+    @Override
+    public CommandExecutor<CommandSender> getExecutor() {
+        return commandExecutor;
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<C> getChildCommandList() {
+        return Collections.unmodifiableList(children);
+    }
+
+    @Override
+    public @NotNull Optional<C> getChildCommand(@NotNull String name) {
+        return getChildCommandList().stream().filter(child -> child.equals(name)).findFirst();
+    }
+
+    @Override
+    public @NotNull CommandInfo getCommandInfo() {
+        return commandInfo;
+    }
+
+    @Override
+    public boolean execute(@NotNull CommandSender sender, @NotNull String commandLabel, @NotNull String[] args) {
+
+        if (!validate(sender)) {
+            return false;
+        }
+
+        if (args.length > 0) {
+            Boolean data = getChildCommand(args[0]).map(command -> command.execute(sender, commandLabel, Arrays.copyOfRange(args, 1, args.length)))
+                .orElse(null);
+            if (data != null) {
+                return data;
+            }
+        }
+
+        if (commandExecutor == null) {
+            return false;
+        }
+
+        final KissenPaperCommandContext kissenPaperCommandContext = new KissenPaperCommandContext(commandLabel, sender, getTargetValidator().parseSender((ServerEntity) sender), //safe cast
+            args, this);
+        //TODO maybe async
+        return commandExecutor.execute(kissenPaperCommandContext);
+    }
+
+    @Override
+    public @NotNull List<String> tabComplete(@NotNull CommandSender sender, @NotNull String alias, @NotNull String[] args) throws IllegalArgumentException {
+        List<String> result = new ArrayList<>();
+        if (!validate(sender)) {
+            return result;
+        }
+
+        if (tabExecutor != null) {
+            result.addAll(tabExecutor.execute(new KissenPaperCommandContext(alias, sender, getTargetValidator().parseSender((ServerEntity) sender), //safe cast
+                args, this)));
+            return result;
+        }
+
+        if (!getChildCommandList().isEmpty() && args.length != 0) {
+            List<String> matchedChildCommands = new ArrayList<>();
+
+            for (C command : getChildCommandList()) {
+                if ((command.getName()
+                    .toLowerCase()
+                    .startsWith(args[args.length - 1].toLowerCase())) && command.testPermissionSilent(sender)) {
+                    matchedChildCommands.add(command.getName());
+                }
+            }
+
+            if (!matchedChildCommands.isEmpty()) {
+                matchedChildCommands.sort(String.CASE_INSENSITIVE_ORDER);
+                return matchedChildCommands;
+            }
+        }
+
+        return super.tabComplete(sender, alias, args);
+    }
+
+    @Override
+    public @NotNull String getFullName() {
+        return getCommandInfo().getName();
+    }
+
+    /**
+     * Initializes the {@link KissenPaperAbstractCommand} with the provided command information and executor.
+     * <p>
+     * This method is used to initialize the properties and behavior of the {@link KissenPaperAbstractCommand} based on the given command information and executor.
+     *
+     * @param commandInfo     The {@link CommandInfo} containing details about the command. Must not be null.
+     * @param commandExecutor The {@link CommandExecutor} responsible for executing the command logic. Must not be null.
+     * @throws NullPointerException If either the {@code commandInfo} or {@code commandExecutor} parameter is null.
+     */
+    public void initCommand(@NotNull CommandInfo commandInfo, @NotNull CommandExecutor<CommandSender> commandExecutor) {
+        this.commandInfo = commandInfo;
+        this.commandExecutor = commandExecutor;
+
+        setAliases(Arrays.asList(commandInfo.getAliases()));
+
+        if (commandInfo.isPermissionRequired() && !commandInfo.getPermission().isBlank()) {
+            setPermission(commandInfo.getPermission());
+        }
+
+        String usage = commandInfo.getUsage();
+        if (!usage.isBlank()) {
+            setUsage(usage);
+        } else if (commandExecutor instanceof KissenPaperCommandExecutor kissenPaperCommandExecutor) {
+            setUsage(kissenPaperCommandExecutor.getEvaluator().buildUsage(getName()));
+        }
+
+        String description = commandInfo.getDescription();
+        if (!description.isBlank()) {
+            setDescription(description);
+        }
+
+        if (commandExecutor instanceof KissenPaperCommandExecutor kissenPaperCommandExecutor) {
+            kissenPaperCommandExecutor.setKissenPaperCommand(this);
+        }
+    }
+
+    /**
+     * Initializes the tab completer for the {@link KissenPaperAbstractCommand} instance.
+     * <p>
+     * This method is used to set the tab completer for the current {@link KissenPaperAbstractCommand} instance.
+     * It allows the registration of a {@link TabCompleterExecutor} to handle tab completion logic for the command.
+     *
+     * @param tabExecutor The {@link TabCompleterExecutor} responsible for tab completion of the command. Must not be null.
+     * @throws IllegalStateException If the tab completer has already been initialized for this command.
+     */
+    public final void initCompleter(TabCompleterExecutor<CommandSender> tabExecutor) {
+        if (this.tabExecutor != null) {
+            throw new IllegalStateException("Completer already initialized");
+        }
+
+        this.tabExecutor = tabExecutor;
+    }
+
+    /**
+     * Creates a recursive {@link KissenPaperAbstractCommand} hierarchy based on the given sub-command name.
+     * <p>
+     * This method is used to create a recursive hierarchy of {@link KissenPaperAbstractCommand} instances based on a provided sub-command name.
+     * The hierarchy is established by traversing the sub-command name and creating child commands accordingly.
+     * If the sub-command name is already at the current command's position, the method returns the current command itself.
+     *
+     * @param name The sub-command name representing the recursive hierarchy. Must not be null.
+     * @return The final {@link KissenPaperAbstractCommand} instance at the bottom of the recursive hierarchy.
+     * @throws NullPointerException If the provided {@code name} parameter is null.
+     */
+    public @NotNull KissenPaperAbstractCommand<C> createRecursive(String name) {
+
+        int position = getPosition() + (name.split("\\.").length - 1);
+        if (position == getPosition()) {
+            return this;
+        }
+
+        String subName = name.substring(Math.max(name.indexOf('.') + 1, 0));
+
+        int index = subName.indexOf('.');
+        String nextSubCommand;
+        if (index != -1) {
+            nextSubCommand = subName.substring(0, index);
+        } else {
+            nextSubCommand = subName;
+        }
+
+        return getChildCommand(nextSubCommand).orElseGet(() ->
+            {
+                C kissenPaperChildCommand = createChildCommand(nextSubCommand, KissenPaperAbstractCommand.this);
+                children.add(kissenPaperChildCommand);
+                return kissenPaperChildCommand;
+            })
+            .createRecursive(subName);
+    }
+
+
+    /**
+     * Creates and registers a new {@link KissenPaperChildCommand} as a child command of this command.
+     * <p>
+     * This method is used to create a new {@link KissenPaperChildCommand} instance with the provided subcommand name and
+     * registers it as a child command of the current command. The newly created child command is added to the list of children
+     * for this command.
+     *
+     * @param nextSubCommand The name of the subcommand to create. Must not be null.
+     * @return The newly created and registered {@link KissenPaperChildCommand} instance.
+     * @throws NullPointerException If the {@code nextSubCommand} parameter is null.
+     */
+    protected abstract @NotNull C createChildCommand(@NotNull String nextSubCommand, @NotNull KissenPaperAbstractCommand<C> parent);
+
+    /**
+     * Validates whether a command can be executed by the given {@link CommandSender}.
+     * <p>
+     * This method is used to validate whether a command can be executed by the provided {@link CommandSender}.
+     * Validation checks may include verifying the plugin's enabled status, the type of command sender, and other conditions.
+     *
+     * @param commandSender The {@link CommandSender} attempting to execute the command. Must not be null.
+     * @return {@code true} if the command can be executed by the given command sender, {@code false} otherwise.
+     * @throws CommandException     If the plugin associated with the command is not enabled.
+     * @throws NullPointerException If the provided {@code commandSender} parameter is null.
+     */
+    public boolean validate(@NotNull CommandSender commandSender) {
+        if (!(commandSender instanceof ServerEntity serverEntity)) {
+            //TODO maybe make command sender server entity, but rn I am to lazy
+            return false;
+        }
+
+        return getTargetValidator().validate(getCommandInfo().getTarget(), serverEntity);
+    }
+
+    /**
+     * Retrieves the {@link KissenPaperTargetValidator} associated with the command implementation.
+     * <p>
+     * This method is used to obtain the {@link KissenPaperTargetValidator} that is responsible for validating target entities
+     * related to the execution of a command. The validator is specific to the Kissen Paper command implementation.
+     *
+     * @return The {@link KissenPaperTargetValidator} associated with the command implementation.
+     */
+    public @NotNull KissenPaperTargetValidator getTargetValidator() {
+        return Bukkit.getKissen()
+            .getImplementation(KissenPaperCommandImplementation.class)
+            .getKissenPaperTargetValidator();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/command/KissenPaperCommandContext.java b/src/main/java/net/kissenpvp/paper/command/command/KissenPaperCommandContext.java
new file mode 100644
index 0000000000000000000000000000000000000000..af4f0b52a420aaeaaedab0d3efc64bdf3b4377b5
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/command/KissenPaperCommandContext.java
@@ -0,0 +1,87 @@
+package net.kissenpvp.paper.command.command;
+
+import net.kissenpvp.core.api.command.CommandTarget;
+import net.kissenpvp.core.api.command.Context;
+import net.kissenpvp.core.api.networking.client.entitiy.ServerEntity;
+import net.kissenpvp.core.api.permission.PermissionEntry;
+import net.kissenpvp.core.command.CommandHolder;
+import net.kissenpvp.core.command.argument.ArgumentParser;
+import net.kissenpvp.paper.command.KissenPaperCommandImplementation;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+
+import java.lang.reflect.Array;
+
+public class KissenPaperCommandContext implements Context<CommandSender> {
+
+    private final String label;
+    private final CommandSender sender;
+    private final CommandTarget target;
+    private final String[] args;
+    private final CommandHolder<?, ?> commandHolder;
+
+    public KissenPaperCommandContext(String label, CommandSender sender, CommandTarget target, String[] args, CommandHolder<?, ?> commandHolder) {
+        this.label = label;
+        this.sender = sender;
+        this.target = target;
+        this.args = args;
+        this.commandHolder = commandHolder;
+    }
+
+    public CommandHolder<?, ?> getCommandHolder() {
+        return commandHolder;
+    }
+
+    @Override
+    public @NotNull String getLabel() {
+        return label;
+    }
+
+    @Override
+    public @NotNull CommandSender getSender() {
+        return sender;
+    }
+
+    @Override
+    public @NotNull CommandTarget getTarget() {
+        return target;
+    }
+
+    @Override
+    public @NotNull String[] getArguments() {
+        return args;
+    }
+
+    @Override
+    public <T> @NotNull T[] getArgument(int from, int to, @NotNull Class<T> type) throws ArrayIndexOutOfBoundsException {
+
+        KissenPaperCommandImplementation kissenPaperCommandImplementation = Bukkit.getKissen()
+            .getImplementation(KissenPaperCommandImplementation.class);
+
+        final ArgumentParser<?> adapter = kissenPaperCommandImplementation.getParserList().get(type);
+        final T[] instance = (T[]) Array.newInstance(type, to - from);
+
+        for (int i = from; i <= to; i++) {
+            instance[i - from] = (T) adapter.deserialize(getArgument(i).orElseThrow(IllegalArgumentException::new));
+        }
+
+        return instance;
+    }
+
+    @Override
+    public boolean validate(@NotNull ServerEntity serverEntity) {
+
+        if (getCommandHolder().getCommandInfo()
+            .isPermissionRequired() && serverEntity instanceof PermissionEntry<?> permissionEntry) {
+
+            if (!permissionEntry.hasPermission(getCommandHolder().getCommandInfo().getPermission())) {
+                return false;
+            }
+        }
+
+        KissenPaperCommandImplementation kissenPaperCommandImplementation = Bukkit.getKissen()
+            .getImplementation(KissenPaperCommandImplementation.class);
+        return kissenPaperCommandImplementation.getKissenPaperTargetValidator().validate(getTarget(), serverEntity);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/command/plugin/KissenPaperPluginChildCommand.java b/src/main/java/net/kissenpvp/paper/command/command/plugin/KissenPaperPluginChildCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..b06ac7e55eebd2e80954b2a7a21874138eaea8aa
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/command/plugin/KissenPaperPluginChildCommand.java
@@ -0,0 +1,45 @@
+package net.kissenpvp.paper.command.command.plugin;
+
+import net.kissenpvp.paper.api.command.KissenCommand;
+import net.kissenpvp.paper.command.command.KissenPaperAbstractCommand;
+import org.bukkit.plugin.Plugin;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Optional;
+
+/**
+ * Represents a child command within the Kissen Paper command framework, specifically designed for plugin-related commands.
+ * <p>
+ * This class extends {@link KissenPaperPluginCommand} and provides functionality for creating and managing child commands
+ * related to a specific plugin. Child commands of this type belong to a parent plugin command and are organized in a hierarchical structure.
+ */
+public class KissenPaperPluginChildCommand extends KissenPaperPluginCommand {
+    private final KissenPaperAbstractCommand<KissenPaperPluginChildCommand> parent;
+
+    /**
+     * Constructs a new {@link KissenPaperPluginChildCommand} with the specified plugin, name, and parent command.
+     *
+     * @param plugin The plugin to which this child command belongs. Must not be null.
+     * @param name   The name of the child command. Must not be null.
+     * @param parent The parent command to which this child command belongs. Must not be null.
+     * @throws NullPointerException If any of the parameters is null.
+     */
+    public KissenPaperPluginChildCommand(@NotNull Plugin plugin, @NotNull String name, @NotNull KissenPaperAbstractCommand<KissenPaperPluginChildCommand> parent) {
+        super(plugin, name, parent.getPosition() + 1);
+        this.parent = parent;
+    }
+
+    @Override
+    public @NotNull String getFullName() {
+        return parent.getFullName() + " " + getName();
+    }
+
+    /**
+     * Returns an {@link Optional} containing the parent command to which this child command belongs.
+     *
+     * @return An {@link Optional} containing the parent command.
+     */
+    public @NotNull Optional<KissenCommand> getParentCommand() {
+        return Optional.of(parent);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/command/plugin/KissenPaperPluginCommand.java b/src/main/java/net/kissenpvp/paper/command/command/plugin/KissenPaperPluginCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..de50ed583b786f63c997122245d611926130ddde
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/command/plugin/KissenPaperPluginCommand.java
@@ -0,0 +1,54 @@
+package net.kissenpvp.paper.command.command.plugin;
+
+import net.kissenpvp.paper.command.command.KissenPaperAbstractCommand;
+import org.bukkit.command.CommandException;
+import org.bukkit.command.CommandSender;
+import org.bukkit.plugin.Plugin;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Optional;
+
+/**
+ * Represents a top-level Kissen Paper command specifically designed for plugin-related commands.
+ * <p>
+ * This class extends {@link KissenPaperAbstractCommand} and provides functionality for creating and managing plugin-related commands.
+ * It is used as a container for subcommands related to a specific plugin and supports the creation of child commands using the specified parent command.
+ */
+public class KissenPaperPluginCommand extends KissenPaperAbstractCommand<KissenPaperPluginChildCommand> {
+
+    private final Plugin plugin;
+
+    /**
+     * Constructs a new {@link KissenPaperAbstractCommand} instance with the provided plugin, name, and position.
+     * <p>
+     * This constructor is used to create a new {@link KissenPaperAbstractCommand} instance with the specified plugin, command name, and position in the command hierarchy.
+     *
+     * @param plugin   The {@link Plugin} that owns this command. Must not be null.
+     * @param name     The name of the command. Must not be null.
+     * @param position The position of the command in the command hierarchy.
+     * @throws NullPointerException If either the {@code plugin} or {@code name} parameter is null.
+     */
+    public KissenPaperPluginCommand(@NotNull Plugin plugin, @NotNull String name, int position) {
+        super(name, position);
+        this.plugin = plugin;
+    }
+
+    @Override
+    public @NotNull Optional<KissenPaperPluginChildCommand> getChildCommand(@NotNull String name) {
+        return super.getChildCommand(name);
+    }
+
+    @Override
+    protected @NotNull KissenPaperPluginChildCommand createChildCommand(@NotNull String nextSubCommand, @NotNull KissenPaperAbstractCommand<KissenPaperPluginChildCommand> parent) {
+        return new KissenPaperPluginChildCommand(plugin, nextSubCommand, parent);
+    }
+
+    @Override
+    public boolean validate(@NotNull CommandSender commandSender) {
+        if (!this.plugin.isEnabled()) {
+            throw new CommandException(String.format("Plugin '%s' is not enabled.", plugin.getName()), new IllegalStateException());
+        }
+
+        return super.validate(commandSender);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/command/system/KissenPaperChildCommand.java b/src/main/java/net/kissenpvp/paper/command/command/system/KissenPaperChildCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..4ba32a6586d1681ae668695fccb8751e16527209
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/command/system/KissenPaperChildCommand.java
@@ -0,0 +1,45 @@
+package net.kissenpvp.paper.command.command.system;
+
+import net.kissenpvp.paper.api.command.KissenCommand;
+import net.kissenpvp.paper.command.command.KissenPaperAbstractCommand;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Optional;
+
+/**
+ * Represents a child command within the Kissen Paper command framework.
+ * <p>
+ * This class extends {@link KissenPaperCommand} and provides functionality for creating and managing child commands.
+ * Child commands are subcommands that belong to a parent command and are organized in a hierarchical structure.
+ */
+public class KissenPaperChildCommand extends KissenPaperCommand {
+
+    private final KissenPaperAbstractCommand<KissenPaperChildCommand> parent;
+
+    /**
+     * Constructs a new {@link KissenPaperChildCommand} with the specified name and parent command.
+     *
+     * @param name   The name of the child command. Must not be null.
+     * @param parent The parent command to which this child command belongs. Must not be null.
+     * @throws IllegalArgumentException If the {@code name} is null.
+     * @throws NullPointerException     If the {@code parent} is null.
+     */
+    public KissenPaperChildCommand(@NotNull String name, @NotNull KissenPaperAbstractCommand<KissenPaperChildCommand> parent) {
+        super(name, parent.getPosition() + 1);
+        this.parent = parent;
+    }
+
+    @Override
+    public @NotNull String getFullName() {
+        return parent.getFullName() + " " + getName();
+    }
+
+    /**
+     * Returns an {@link Optional} containing the parent command to which this child command belongs.
+     *
+     * @return An {@link Optional} containing the parent command.
+     */
+    public @NotNull Optional<KissenCommand> getParentCommand() {
+        return Optional.of(parent);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/command/system/KissenPaperCommand.java b/src/main/java/net/kissenpvp/paper/command/command/system/KissenPaperCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..613db2789c984799f16f04b1b3b837f81731a195
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/command/system/KissenPaperCommand.java
@@ -0,0 +1,29 @@
+package net.kissenpvp.paper.command.command.system;
+
+import net.kissenpvp.paper.command.command.KissenPaperAbstractCommand;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Represents a top-level Kissen Paper command within the command hierarchy.
+ * <p>
+ * This class extends {@link KissenPaperAbstractCommand} and provides functionality for creating and managing top-level Kissen Paper commands.
+ * It is used as a container for subcommands and supports the creation of child commands using the specified parent command.
+ */
+public class KissenPaperCommand extends KissenPaperAbstractCommand<KissenPaperChildCommand> {
+
+    /**
+     * Constructs a new {@link KissenPaperCommand} with the specified name and position.
+     *
+     * @param name     The name of the command. Must not be null.
+     * @param position The position of the command. Must be non-negative.
+     * @throws IllegalArgumentException If the {@code name} is null or if the {@code position} is negative.
+     */
+    public KissenPaperCommand(@NotNull String name, int position) {
+        super(name, position);
+    }
+
+    @Override
+    protected @NotNull KissenPaperChildCommand createChildCommand(@NotNull String nextSubCommand, @NotNull KissenPaperAbstractCommand<KissenPaperChildCommand> parent) {
+        return new KissenPaperChildCommand(nextSubCommand, parent);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/executor/KissenPaperCommandExecutor.java b/src/main/java/net/kissenpvp/paper/command/executor/KissenPaperCommandExecutor.java
new file mode 100644
index 0000000000000000000000000000000000000000..032114a5c87a4b5374fc96aac9d18422f89c7503
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/executor/KissenPaperCommandExecutor.java
@@ -0,0 +1,93 @@
+package net.kissenpvp.paper.command.executor;
+
+import net.kissenpvp.core.api.command.Context;
+import net.kissenpvp.core.api.command.exception.CommandException;
+import net.kissenpvp.core.api.command.executor.CommandExecutor;
+import net.kissenpvp.core.command.argument.ArgumentEvaluator;
+import net.kissenpvp.paper.command.KissenPaperCommandImplementation;
+import net.kissenpvp.paper.command.command.KissenPaperAbstractCommand;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+
+public class KissenPaperCommandExecutor implements CommandExecutor<CommandSender> {
+
+    private final Method method;
+    private final Object holder;
+
+    private final ArgumentEvaluator<CommandSender> evaluator;
+    private final boolean useMethodValue;
+    private KissenPaperAbstractCommand<?> kissenPaperCommand;
+
+    public KissenPaperCommandExecutor(@NotNull Method method, @NotNull Object holder) {
+        final Class<?> returnType = method.getReturnType();
+
+        if (!returnType.equals(Void.TYPE) && !returnType.equals(Boolean.TYPE)) {
+            throw new IllegalArgumentException(String.format("The return type %s cannot be processed.", returnType.getName()));
+        }
+
+
+        this.method = method;
+        this.holder = holder;
+
+        this.evaluator = new ArgumentEvaluator<>(Bukkit.getKissen()
+            .getImplementation(KissenPaperCommandImplementation.class)
+            .getMethodEvaluator()
+            .evaluateMethod(method));
+
+        useMethodValue = returnType.equals(Boolean.TYPE);
+    }
+
+    @Override
+    public boolean execute(@NotNull Context<CommandSender> context) {
+        return invokeCommand(context);
+    }
+
+    /**
+     * Invokes a command method associated with this command handler using the provided context.
+     * <p>
+     * This method is used to invoke a command method based on the given command context.
+     * The command method is typically defined in a class and is invoked based on the evaluation of command arguments and conditions.
+     *
+     * @param context The {@link Context} representing the command execution context, containing the command sender and arguments. Must not be null.
+     * @return {@code true} if the command method was successfully invoked, {@code false} if no method value is expected and the method was invoked successfully.
+     * @throws CommandException     If an error occurs while processing the command, such as an illegal access or invocation target exception.
+     * @throws NullPointerException If the provided {@code context} parameter is null.
+     */
+    public boolean invokeCommand(@NotNull Context<CommandSender> context) {
+        try {
+            if (evaluator.arguments().isEmpty()) {
+                if (useMethodValue) {
+                    return (boolean) method.invoke(holder);
+                }
+                method.invoke(holder);
+                return true;
+            }
+
+            Object[] parameter = evaluator.parseArguments(context);
+            if (useMethodValue) {
+                return (boolean) method.invoke(holder, parameter);
+            }
+            method.invoke(holder, parameter);
+            return true;
+        } catch (IllegalAccessException | InvocationTargetException exception) {
+            throw new CommandException(String.format("An error occurred while processing the command '%s'.", context.getLabel()), exception);
+        }
+    }
+
+    public @NotNull ArgumentEvaluator<CommandSender> getEvaluator() {
+        return evaluator;
+    }
+
+    public KissenPaperAbstractCommand<?> getKissenPaperCommand() {
+        return kissenPaperCommand;
+    }
+
+    public void setKissenPaperCommand(@NotNull KissenPaperAbstractCommand<?> kissenPaperCommand) {
+        this.kissenPaperCommand = kissenPaperCommand;
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/executor/KissenPaperCompleteExecutor.java b/src/main/java/net/kissenpvp/paper/command/executor/KissenPaperCompleteExecutor.java
new file mode 100644
index 0000000000000000000000000000000000000000..5ef1cb740614b03d178a3fb2001cefdb8f8d82a6
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/executor/KissenPaperCompleteExecutor.java
@@ -0,0 +1,54 @@
+package net.kissenpvp.paper.command.executor;
+
+import net.kissenpvp.core.api.command.Context;
+import net.kissenpvp.core.api.command.exception.CommandException;
+import net.kissenpvp.core.api.command.exception.IllegalParameterException;
+import net.kissenpvp.core.api.command.exception.IllegalReturnValueException;
+import net.kissenpvp.core.api.command.executor.TabCompleterExecutor;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+
+import java.lang.reflect.Method;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+public class KissenPaperCompleteExecutor implements TabCompleterExecutor<CommandSender> {
+
+    private final Method method;
+    private final Object holder;
+
+    public KissenPaperCompleteExecutor(@NotNull Method method, @NotNull Object holder) {
+        final Class<?> returnType = method.getReturnType();
+        final Class<?>[] parameters = method.getParameterTypes();
+
+        if (!List.class.isAssignableFrom(returnType)) {
+            throw new IllegalReturnValueException(returnType, List.class);
+        }
+
+        if (parameters.length > 1 || (parameters.length == 1 && !Context.class.isAssignableFrom(parameters[0]))) {
+            throw new IllegalParameterException(parameters[0], Context.class);
+        }
+
+        this.method = method;
+        this.holder = holder;
+    }
+
+    @Override
+    public @NotNull Set<String> execute(@NotNull Context<CommandSender> context) {
+        final Class<?>[] types = method.getParameterTypes();
+        try {
+            if (types.length == 0) {
+                return (Set<String>) method.invoke(holder);
+            }
+
+            if (types.length == 1 && types[0] == Context.class) {
+                return (Set<String>) method.invoke(holder, context);
+            }
+
+            return new HashSet<>();
+        } catch (Exception exception) {
+            throw new CommandException(String.format("An error occurred while processing the tab request for command '%s'.", context.getLabel()), exception);
+        }
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/target/KissenPaperTargetValidator.java b/src/main/java/net/kissenpvp/paper/command/target/KissenPaperTargetValidator.java
new file mode 100644
index 0000000000000000000000000000000000000000..900cc29bd4a7d5167692a4681b34bf9098808310
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/target/KissenPaperTargetValidator.java
@@ -0,0 +1,49 @@
+package net.kissenpvp.paper.command.target;
+
+import net.kissenpvp.core.api.command.CommandTarget;
+import net.kissenpvp.core.api.networking.client.entitiy.ConsoleClient;
+import net.kissenpvp.core.api.networking.client.entitiy.PlayerClient;
+import net.kissenpvp.core.api.networking.client.entitiy.ServerEntity;
+import net.kissenpvp.core.command.TargetValidator;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Represents a target validator implementation tailored for the Kissen Paper command framework.
+ * <p>
+ * This class implements the {@link TargetValidator} interface and provides specialized logic to validate command targets
+ * within the context of the Kissen Paper command framework. It determines whether a given command target is valid based on
+ * the type of server entity and provides methods to parse the sender's server entity into a valid command target.
+ */
+public class KissenPaperTargetValidator implements TargetValidator {
+    @Override
+    public boolean validate(@NotNull CommandTarget commandTarget, @NotNull ServerEntity serverEntity) {
+        switch (commandTarget) { //TODO when updated to newer java use new functions
+            case PLAYER -> {
+                return serverEntity instanceof PlayerClient<?>;
+            }
+            case SYSTEM -> {
+                return serverEntity instanceof ConsoleClient;
+            }
+            case ALL -> {
+                return true;
+            }
+            default -> {
+                return false;
+            }
+        }
+    }
+
+    @Override
+    public @NotNull CommandTarget parseSender(@NotNull ServerEntity serverEntity) {
+        if (serverEntity instanceof ConsoleClient) {
+            return CommandTarget.SYSTEM;
+        }
+
+        if (serverEntity instanceof PlayerClient<?>) {
+            return CommandTarget.PLAYER;
+        }
+
+        throw new IllegalArgumentException(String.format("No suitable target type has been found for target %s.", serverEntity.getClass()
+            .getName()));
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperOnlinePlayerClient.java b/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperOnlinePlayerClient.java
new file mode 100644
index 0000000000000000000000000000000000000000..5dc375c1023c582d0b106f6316a8e9bee841f1b4
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperOnlinePlayerClient.java
@@ -0,0 +1,34 @@
+package net.kissenpvp.paper.networking.client.entity;
+
+import net.kissenpvp.core.api.ban.Ban;
+import net.kissenpvp.core.api.message.Theme;
+import net.kissenpvp.core.api.networking.client.entitiy.ServerEntity;
+import net.kissenpvp.core.message.PlayerTheme;
+import net.kissenpvp.core.networking.client.entity.KissenOnlinePlayerClient;
+import net.kissenpvp.paper.api.networking.client.entity.PaperOnlinePlayerClient;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public interface KissenPaperOnlinePlayerClient extends KissenOnlinePlayerClient, KissenPaperPlayerClient, PaperOnlinePlayerClient {
+
+
+    @Override
+    default @Nullable String getCurrentServer() {
+        return null; //TODO Create class for the core presenting a server
+    }
+
+    @Override
+    default int warn(@NotNull Ban ban, @NotNull ServerEntity warnOperator) {
+        return 0; //TODO (lazy)
+    }
+
+    @Override
+    default @NotNull Theme getTheme() {
+        return new PlayerTheme(this);
+    }
+
+    @Override
+    default boolean isConnected() {
+        return true;
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperPlayerClient.java b/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperPlayerClient.java
new file mode 100644
index 0000000000000000000000000000000000000000..0242030d771fc91b5460a9215628d7bde23e4081
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperPlayerClient.java
@@ -0,0 +1,131 @@
+package net.kissenpvp.paper.networking.client.entity;
+
+import net.kissenpvp.core.api.ban.Ban;
+import net.kissenpvp.core.api.ban.PlayerBan;
+import net.kissenpvp.core.api.networking.client.entitiy.ServerEntity;
+import net.kissenpvp.core.api.permission.GroupablePermissionEntry;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.api.user.suffix.Suffix;
+import net.kissenpvp.core.database.DataWriter;
+import net.kissenpvp.core.networking.client.entity.KissenPlayerClient;
+import net.kissenpvp.core.user.rank.KissenPlayerRankNode;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.networking.client.entity.PaperOnlinePlayerClient;
+import net.kissenpvp.paper.api.networking.client.entity.PaperPlayerClient;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.user.rank.PaperPlayerRank;
+import net.kissenpvp.paper.user.KissenPaperPublicUser;
+import net.kissenpvp.paper.user.rank.KissenPaperPlayerFallBackRank;
+import net.kissenpvp.paper.user.rank.KissenPaperPlayerRank;
+import net.kyori.adventure.text.Component;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Optional;
+import java.util.Set;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public interface KissenPaperPlayerClient extends KissenPlayerClient<PaperPlayerRank>, PaperPlayerClient {
+    @Override
+    default @NotNull PaperPlayerRank translateRank(@NotNull KissenPlayerRankNode kissenPlayerRankNode, @Nullable DataWriter dataWriter) {
+        return new KissenPaperPlayerRank(kissenPlayerRankNode, dataWriter);
+    }
+
+    @Override
+    default @NotNull @Unmodifiable Set<@NotNull PaperOnlinePlayerClient> getOnlineAltAccounts() {
+        return null; //TODO
+    }
+
+    @Override
+    @NotNull
+    default Set<Suffix> getSuffixSet() {
+        return Stream.concat(getSuffixSet(Context.LOCAL).stream(), getSuffixSet(Context.GLOBAL).stream()).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    default @NotNull Set<Suffix> getSuffixSet(@NotNull Context context) {
+        return null; //TODO
+    }
+
+    @Override
+    @NotNull
+    default Optional<@Nullable Suffix> getSuffix(@NotNull String name) {
+        return getSuffix(name, Context.LOCAL).or(() -> getSuffix(name, Context.GLOBAL));
+    }
+
+    @Override
+    default @NotNull Optional<@Nullable Suffix> getSuffix(@NotNull String name, @NotNull Context context) {
+        return Optional.empty(); //TODO
+    }
+
+    @Override
+    @NotNull
+    default Optional<@Nullable Suffix> setSuffix(@NotNull String name, @NotNull Component content) {
+        return setSuffix(name, content, Context.LOCAL);
+    }
+
+    @Override
+    default @NotNull Optional<@Nullable Suffix> setSuffix(@NotNull String name, @NotNull Component content, Context context) {
+        return Optional.empty(); //TODO
+    }
+
+    @Override
+    default boolean deleteSuffix(@NotNull String name) {
+        return getSuffix(name, Context.LOCAL).map((suffix) -> deleteSuffix(name, Context.LOCAL)).orElse(deleteSuffix(name, Context.GLOBAL));
+    }
+
+    @Override
+    default boolean deleteSuffix(@NotNull String name, @NotNull Context context) {
+        return false; //TODO
+    }
+
+    @Override
+    default void setSelectedSuffix(@NotNull String name) throws NullPointerException {
+        setSelectedSuffix(name, getSuffix(name, Context.LOCAL).map(suffix -> Context.LOCAL).or(() -> getSuffix(name, Context.GLOBAL).map(suffix -> Context.GLOBAL)).orElseThrow(NullPointerException::new));
+    }
+
+    @Override
+    default void setSelectedSuffix(@NotNull String name, @NotNull Context context) throws NullPointerException {
+    }
+
+    @Override
+    default long getOnlineTime(@NotNull Context context) {
+        return getOnlineTime(getUser(context));
+    }
+
+    @Override
+    default long getLastPlayed(@NotNull Context context) {
+        return getOnlineTime(getUser(context));
+    }
+
+    @Override
+    default @NotNull PlayerBan ban(@NotNull Ban ban, @NotNull ServerEntity banOperator, @NotNull Context context) {
+        return null; //TODO
+    }
+
+    @Override
+    default @NotNull PlayerBan ban(@NotNull Ban ban, @NotNull ServerEntity banOperator, @Nullable Component reason, @NotNull Context context) {
+        return null; //TODO
+    }
+
+    @Override
+    default @NotNull User getUser(@NotNull Context context) {
+        KissenPaperPublicUser kissenPublicUser = (KissenPaperPublicUser) getUser();
+        return switch (context) {
+            case GLOBAL -> kissenPublicUser;
+            case LOCAL -> kissenPublicUser.getPrivateUserEntry();
+        };
+    }
+
+    @Override
+    default @NotNull PaperPlayerRank getRank() {
+        int index = getRankIndex();
+        return index == -1 ? new KissenPaperPlayerFallBackRank() : getRankHistory().get(index);
+    }
+
+    default @NotNull GroupablePermissionEntry<PaperPermission> getPermissionEntry(@NotNull Context context) {
+        return (GroupablePermissionEntry<PaperPermission>) getUser(context);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/KissenPaperAttachmentPermission.java b/src/main/java/net/kissenpvp/paper/permission/KissenPaperAttachmentPermission.java
new file mode 100644
index 0000000000000000000000000000000000000000..7ccb3b608cd719b01efc6a98ebb28d571e80f038
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/KissenPaperAttachmentPermission.java
@@ -0,0 +1,29 @@
+package net.kissenpvp.paper.permission;
+
+import net.kissenpvp.core.api.permission.Permission;
+import net.kissenpvp.core.api.permission.PermissionEntry;
+import net.kissenpvp.core.api.util.Container;
+import net.kissenpvp.core.permission.KissenPermissionNode;
+import org.bukkit.permissions.PermissionAttachment;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.HashMap;
+
+public class KissenPaperAttachmentPermission extends KissenPaperPermission {
+
+    private final PermissionAttachment permissionAttachment;
+
+    public KissenPaperAttachmentPermission(@NotNull String permission, boolean value, @NotNull PermissionEntry<? extends Permission> permissionEntry, boolean immutable) {
+        this(null, permission, value, permissionEntry, immutable);
+    }
+
+    public KissenPaperAttachmentPermission(@Nullable PermissionAttachment permissionAttachment, @NotNull String permission, boolean value, @NotNull PermissionEntry<? extends Permission> permissionEntry, boolean immutable) {
+        super(new KissenPermissionNode(permission, permissionEntry.getPermissionID(), new Container<>(value), System.currentTimeMillis(), new Container<>(-1L), new Container<>(-1L), -1L, new HashMap<>()), permissionEntry, immutable ? null : (record) -> { /* ignored */ });
+        this.permissionAttachment = permissionAttachment;
+    }
+
+    public PermissionAttachment getPermissionAttachment() {
+        return permissionAttachment;
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/KissenPaperGroupablePermissionEntry.java b/src/main/java/net/kissenpvp/paper/permission/KissenPaperGroupablePermissionEntry.java
new file mode 100644
index 0000000000000000000000000000000000000000..8007f48fce05228e22e0c9170262517c3e1211e4
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/KissenPaperGroupablePermissionEntry.java
@@ -0,0 +1,146 @@
+package net.kissenpvp.paper.permission;
+
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.permission.GroupablePermissionEntry;
+import net.kissenpvp.core.api.permission.PermissionGroup;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.PaperGroubablePermissionEntry;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Optional;
+import java.util.Set;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public interface KissenPaperGroupablePermissionEntry extends PaperGroubablePermissionEntry {
+
+    @Override
+    default int wipePermissions() {
+        return getPermissionEntry(Context.LOCAL).wipePermissions() + getPermissionEntry(Context.GLOBAL).wipePermissions();
+    }
+
+    @Override
+    default int wipeGroups() {
+        return getPermissionEntry(Context.LOCAL).wipeGroups() + getPermissionEntry(Context.GLOBAL).wipeGroups();
+    }
+
+    @Override
+    default @NotNull @Unmodifiable Set<PaperPermission> getOwnPermissions() {
+        return Stream.concat(getPermissionEntry(Context.LOCAL).getOwnPermissions().stream(), getPermissionEntry(Context.GLOBAL).getOwnPermissions().stream()).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    @NotNull
+    default Set<PaperPermission> getOwnPermissions(@NotNull Context context) {
+        return getPermissionEntry(context).getOwnPermissions();
+    }
+
+    @Override
+    default @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups() {
+        return Stream.concat(getPermissionEntry(Context.LOCAL).getPermissionGroups().stream(), getPermissionEntry(Context.GLOBAL).getPermissionGroups().stream()).collect(Collectors.toUnmodifiableSet()); //TODO
+    }
+
+
+    @Override
+    @NotNull
+    default Set<PermissionGroup<PaperPermission>> getPermissionGroups(@NotNull Context context) {
+        return getPermissionEntry(context).getPermissionGroups();
+    }
+
+    @Override
+    default boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup) {
+        return getPermissionEntry(Context.LOCAL).inGroup(permissionGroup) || getPermissionEntry(Context.GLOBAL).inGroup(permissionGroup);
+    }
+
+    @Override
+    default boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup, @NotNull Context context) {
+        return getPermissionEntry(context).inGroup(permissionGroup);
+    }
+
+    @Override
+    @NotNull
+    default PaperPermission setPermission(@NotNull String s) throws EventCancelledException {
+        return setPermission(s, Context.LOCAL);
+    }
+
+    @Override
+    @NotNull
+    default PaperPermission setPermission(@NotNull String permission, @NotNull Context context) throws EventCancelledException {
+        return getPermissionEntry(context).setPermission(permission);
+    }
+
+    @Override
+    @NotNull
+    default PaperPermission setPermission(@NotNull String s, boolean b) throws EventCancelledException {
+        return setPermission(s, b, Context.LOCAL);
+    }
+
+    @Override
+    @NotNull
+    default PaperPermission setPermission(@NotNull String permission, boolean value, @NotNull Context context) throws EventCancelledException {
+        return getPermissionEntry(context).setPermission(permission, value);
+    }
+
+    @Override
+    @NotNull
+    default PaperPermission setPermission(@NotNull PaperPermission paperPermission) throws EventCancelledException {
+        return setPermission(paperPermission, Context.LOCAL);
+    }
+
+    @Override
+    @NotNull
+    default PaperPermission setPermission(@NotNull PaperPermission permission, @NotNull Context context) throws EventCancelledException {
+        return getPermissionEntry(context).setPermission(permission);
+    }
+
+    @Override
+    default boolean unsetPermission(@NotNull String s) {
+        if (unsetPermission(s, Context.LOCAL)) {
+            return unsetPermission(s, Context.GLOBAL);
+        }
+        return false;
+    }
+
+    @Override
+    default boolean unsetPermission(@NotNull String permission, @NotNull Context context) {
+        return getPermissionEntry(context).unsetPermission(permission);
+    }
+
+    @Override
+    default @NotNull @Unmodifiable Set<PaperPermission> getPermissionList() {
+        return Stream.concat(getPermissionList(Context.LOCAL).stream(), getPermissionList(Context.GLOBAL).stream()).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    @NotNull
+    @Unmodifiable
+    default Set<PaperPermission> getPermissionList(@NotNull Context context) {
+        return getPermissionEntry(context).getPermissionList();
+    }
+
+    @Override
+    default @NotNull Optional<@Nullable PaperPermission> getPermission(@NotNull String s) {
+        return getPermission(s, Context.LOCAL).or(() -> getPermission(s, Context.GLOBAL));
+    }
+
+    @Override
+    @NotNull
+    default Optional<@Nullable PaperPermission> getPermission(@NotNull String permission, @NotNull Context context) {
+        return getPermissionEntry(context).getPermission(permission);
+    }
+
+    @Override
+    default boolean hasPermission(@NotNull String s) {
+        return isOp() || hasPermission(s, Context.LOCAL) || hasPermission(s, Context.GLOBAL);
+    }
+
+    @Override
+    default boolean hasPermission(@NotNull String permission, @NotNull Context context) {
+        return getPermissionEntry(context).hasPermission(permission);
+    }
+
+    @NotNull GroupablePermissionEntry<PaperPermission> getPermissionEntry(@NotNull Context context);
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermissible.java b/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermissible.java
new file mode 100644
index 0000000000000000000000000000000000000000..61dc4e7f33a933e0fddbb8b087df39497d9792d4
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermissible.java
@@ -0,0 +1,158 @@
+package net.kissenpvp.paper.permission;
+
+import net.kissenpvp.core.api.message.ComponentSerializer;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import org.bukkit.Bukkit;
+import org.bukkit.permissions.*;
+import org.bukkit.plugin.Plugin;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.logging.Level;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public abstract class KissenPaperPermissible implements KissenPaperGroupablePermissionEntry {
+
+    protected final Permissible parent;
+    protected final Set<PermissionAttachment> attachments;
+
+    public KissenPaperPermissible() {
+        this(null);
+    }
+
+    public KissenPaperPermissible(@Nullable Permissible parent) {
+        this.attachments = new HashSet<>();
+        this.parent = parent == null ? this : parent;
+        permissionUpdate();
+    }
+
+    @Override
+    public void permissionUpdate() {
+        for (String name : getPermissionList().stream()
+            .map(net.kissenpvp.core.api.permission.Permission::getName)
+            .collect(Collectors.toSet())) {
+            Bukkit.getServer().getPluginManager().unsubscribeFromPermission(name, parent);
+        }
+
+        Bukkit.getServer().getPluginManager().unsubscribeFromDefaultPerms(false, parent);
+        Bukkit.getServer().getPluginManager().unsubscribeFromDefaultPerms(true, parent);
+
+        Bukkit.getServer().getPluginManager().subscribeToDefaultPerms(isOp() || hasPermission("*"), parent);
+        for (PaperPermission permission : getPermissionList()) {
+            Bukkit.getServer().getPluginManager().subscribeToPermission(permission.getName(), parent);
+        }
+    }
+
+    @Override
+    public boolean isPermissionSet(@NotNull String name) {
+        return getPermission(name).isPresent();
+    }
+
+    @Override
+    public boolean isPermissionSet(@NotNull Permission perm) {
+        return isPermissionSet(perm.getName());
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull Permission perm) {
+        return hasPermission(perm.getName());
+    }
+
+    @Override
+    public @NotNull PermissionAttachment addAttachment(@NotNull Plugin plugin) {
+        PermissionAttachment result = new PermissionAttachment(plugin, parent);
+
+        attachments.add(result);
+        permissionUpdate();
+
+        return result;
+    }
+
+    @Override
+    public @NotNull PermissionAttachment addAttachment(@NotNull Plugin plugin, @NotNull String name, boolean value) {
+
+        PermissionAttachment permissionAttachment = addAttachment(plugin);
+        permissionAttachment.setPermission(name, value);
+        return permissionAttachment;
+    }
+
+    @Override
+    public @Nullable PermissionAttachment addAttachment(@NotNull Plugin plugin, @NotNull String name, boolean value, int ticks) {
+        PermissionAttachment permissionAttachment = addAttachment(plugin, ticks);
+        if (permissionAttachment != null) {
+            permissionAttachment.setPermission(name, value);
+        }
+        return permissionAttachment;
+    }
+
+    @Override
+    public @Nullable PermissionAttachment addAttachment(@NotNull Plugin plugin, int ticks) {
+        PermissionAttachment result = addAttachment(plugin);
+
+        if (Bukkit.getServer()
+            .getScheduler()
+            .scheduleSyncDelayedTask(plugin, new RemoveAttachmentRunnable(result), ticks) == -1) {
+            Bukkit.getServer()
+                .getLogger()
+                .log(Level.WARNING, "Could not add PermissionAttachment to " + ComponentSerializer.getInstance()
+                    .getLegacySerializer()
+                    .serialize(displayName()) + " for plugin " + plugin.getPluginMeta()
+                    .getDisplayName() + ": Scheduler returned -1");
+            result.remove();
+            return null;
+        } else {
+            return result;
+        }
+    }
+
+    @Override
+    public void removeAttachment(@NotNull PermissionAttachment attachment) {
+        if (attachments.remove(attachment)) {
+            PermissionRemovedExecutor permissionRemovedExecutor = attachment.getRemovalCallback();
+
+            if (permissionRemovedExecutor != null) {
+                permissionRemovedExecutor.attachmentRemoved(attachment);
+            }
+
+            permissionUpdate();
+        } else {
+            throw new IllegalArgumentException("Given attachment is not part of Permissible object " + ComponentSerializer.getInstance()
+                .getLegacySerializer()
+                .serialize(displayName()));
+        }
+    }
+
+    @Override
+    public void recalculatePermissions() {
+        permissionUpdate();
+    }
+
+    @Override
+    public @NotNull Set<PermissionAttachmentInfo> getEffectivePermissions() {
+        return getPermissionList().stream().map(permission ->
+        {
+            PermissionAttachment attachment = null;
+            if (permission instanceof KissenPaperAttachmentPermission kissenPaperAttachmentPermission) {
+                attachment = kissenPaperAttachmentPermission.getPermissionAttachment();
+            }
+            return new PermissionAttachmentInfo(parent, permission.getName(), attachment, permission.getValue());
+        }).collect(Collectors.toSet());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList() {
+
+        Set<KissenPaperAttachmentPermission> kissenPaperAttachmentPermissions = new HashSet<>();
+        for (PermissionAttachment permissionAttachment : attachments) {
+            permissionAttachment.getPermissions().forEach((key, value) ->
+                kissenPaperAttachmentPermissions.add(new KissenPaperAttachmentPermission(permissionAttachment, key, value, KissenPaperPermissible.this, true)));
+        }
+
+        return Stream.concat(KissenPaperGroupablePermissionEntry.super.getPermissionList()
+            .stream(), kissenPaperAttachmentPermissions.stream()).collect(Collectors.toSet());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermission.java b/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermission.java
new file mode 100644
index 0000000000000000000000000000000000000000..214e799aaf498af46e3b9854058168af30ba81e3
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermission.java
@@ -0,0 +1,16 @@
+package net.kissenpvp.paper.permission;
+
+import net.kissenpvp.core.api.permission.Permission;
+import net.kissenpvp.core.api.permission.PermissionEntry;
+import net.kissenpvp.core.database.DataWriter;
+import net.kissenpvp.core.permission.KissenPermission;
+import net.kissenpvp.core.permission.KissenPermissionNode;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class KissenPaperPermission extends KissenPermission implements PaperPermission {
+    public KissenPaperPermission(@NotNull KissenPermissionNode kissenPermissionNode, @NotNull PermissionEntry<? extends Permission> permissionEntry, @Nullable DataWriter dataWriter) {
+        super(kissenPermissionNode, permissionEntry, dataWriter);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermissionImplementation.java b/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermissionImplementation.java
new file mode 100644
index 0000000000000000000000000000000000000000..a90a024c16c2b1e467584e5cfdc1f103c0ca96ad
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermissionImplementation.java
@@ -0,0 +1,212 @@
+package net.kissenpvp.paper.permission;
+
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.event.EventImplementation;
+import net.kissenpvp.core.api.permission.PermissionGroup;
+import net.kissenpvp.core.base.KissenCore;
+import net.kissenpvp.core.base.KissenImplementation;
+import net.kissenpvp.core.database.savable.KissenSavableMap;
+import net.kissenpvp.core.permission.PermissionImplementation;
+import net.kissenpvp.core.permission.event.KissenPermissionGroupCreateEvent;
+import net.kissenpvp.core.permission.event.KissenPermissionGroupCreatedEvent;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PaperPermissionGroup;
+import net.kissenpvp.paper.api.permission.PaperPermissionImplementation;
+import net.kissenpvp.paper.api.permission.PaperPrivatePermissionGroup;
+import net.kissenpvp.paper.command.KissenPaperCommandImplementation;
+import net.kissenpvp.paper.permission.group.KissenPaperPermissionGroup;
+import net.kissenpvp.paper.permission.group.KissenPaperPrivatePermissionGroup;
+import net.kissenpvp.paper.permission.group.KissenPaperPublicPermissionGroup;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public class KissenPaperPermissionImplementation implements PaperPermissionImplementation, PermissionImplementation, KissenImplementation {
+
+    private final Set<PermissionGroup<PaperPermission>> cachedGroups;
+
+    public KissenPaperPermissionImplementation() {
+        this.cachedGroups = new HashSet<>();
+    }
+
+    @Override
+    public void setupComplete() {
+        Bukkit.getKissen()
+            .getImplementation(KissenPaperCommandImplementation.class)
+            .registerCommand(new PermissionCommand());
+    }
+
+    @Override
+    public boolean postStart() {
+        try {
+            Stream.concat(KissenCore.getInstance()
+                .getPublicMeta()
+                .getData(new KissenPaperPublicPermissionGroup())
+                .values()
+                .stream(), Bukkit.getKissen()
+                .getPrivateMeta()
+                .getData(new KissenPaperPrivatePermissionGroup())
+                .values()
+                .stream()).forEach(savableMap ->
+            {
+                String id = ((KissenSavableMap) savableMap).getId();
+
+                if (id.startsWith(new KissenPaperPublicPermissionGroup().getSaveID())) {
+                    createInternalPermissionGroup(savableMap.getNotNull("id"), savableMap);
+                } else {
+                    if (id.startsWith(new KissenPaperPrivatePermissionGroup().getSaveID())) {
+                        try {
+                            createPrivateInternalPermissionGroup(savableMap.getNotNull("id"), savableMap);
+                        } catch (BackendException backendException) {
+                            KissenCore.getInstance()
+                                .getLogger()
+                                .error("The system was unable to load the permission group '{}' from the database.", id);
+                        }
+                    }
+                }
+            });
+        } catch (BackendException e) {
+            KissenCore.getInstance()
+                .getLogger()
+                .error("The system was unable to load the permission groups from the database.");
+            return false;
+        }
+
+        return PaperPermissionImplementation.super.postStart();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermissionGroup> getPermissionGroupSet() {
+        return cachedGroups.stream()
+            .filter(permissionGroup -> permissionGroup instanceof PaperPermissionGroup)
+            .map(paperPermissionPermissionGroup -> (PaperPermissionGroup) paperPermissionPermissionGroup)
+            .collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPrivatePermissionGroup> getPrivatePermissionGroupSet() {
+        return cachedGroups.stream()
+            .filter(permissionGroup -> permissionGroup instanceof PaperPrivatePermissionGroup)
+            .map(paperPermissionPermissionGroup -> (PaperPrivatePermissionGroup) paperPermissionPermissionGroup)
+            .collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @Nullable PaperPermissionGroup getPermissionGroup(@NotNull String group) {
+        return getPermissionGroupSet().stream()
+            .filter(paperPermissionGroup -> paperPermissionGroup.getPermissionID().equals(group))
+            .findFirst()
+            .orElse(null);
+    }
+
+    @Override
+    public @Nullable PermissionGroup<?> getPermissionGroupSavable(@NotNull String name) {
+        return getPermissionGroupSet().stream()
+            .map(paperPermissionGroup -> paperPermissionGroup.getCoreGroup(Context.GLOBAL))
+            .filter(paperPermissionGroup -> paperPermissionGroup.getPermissionID().equals(name))
+            .findFirst()
+            .orElse(null);
+    }
+
+    @Override
+    public void removePermissionGroup(@NotNull String name) {
+        cachedGroups.removeIf(paperPermissionPermissionGroup -> paperPermissionPermissionGroup.getPermissionID()
+            .equals(name));
+    }
+
+    public void removePublicPermissionGroup(String name) {
+        cachedGroups.removeIf(paperPermissionPermissionGroup -> paperPermissionPermissionGroup instanceof PaperPermissionGroup && paperPermissionPermissionGroup.getPermissionID()
+            .equals(name));
+    }
+
+    @Override
+    public @Nullable PaperPrivatePermissionGroup getPrivatePermissionGroup(@NotNull String group) {
+        return getPrivatePermissionGroupSet().stream()
+            .filter(paperPrivatePermissionGroup -> paperPrivatePermissionGroup.getPermissionID().equals(group))
+            .findFirst()
+            .orElse(null);
+    }
+
+    @Override
+    public @NotNull PaperPrivatePermissionGroup getPrivatePermissionGroupNotNull(@NotNull String group) throws EventCancelledException, BackendException {
+        PaperPrivatePermissionGroup permissionGroup = getPrivatePermissionGroup(group);
+        if (permissionGroup == null) {
+            permissionGroup = createPrivatePermissionGroup(group, null);
+        }
+        return permissionGroup;
+    }
+
+    @Override
+    public @NotNull PaperPermissionGroup getPermissionGroupNotNull(@NotNull String group) throws EventCancelledException {
+        PaperPermissionGroup permissionGroup = getPermissionGroup(group);
+        if (permissionGroup == null) {
+            permissionGroup = createPermissionGroup(group, null);
+        }
+        return permissionGroup;
+    }
+
+    @Override
+    public @NotNull PaperPermissionGroup createPermissionGroup(@NotNull String name, @Nullable Map<String, String> data) throws EventCancelledException {
+        KissenPermissionGroupCreateEvent kissenPermissionGroupCreateEvent = new KissenPermissionGroupCreateEvent(name, data);
+        if (Bukkit.getKissen()
+            .getImplementation(EventImplementation.class)
+            .call(kissenPermissionGroupCreateEvent)) {
+            this.createInternalPermissionGroup(name, data);
+        }
+        throw new EventCancelledException();
+    }
+
+    @Override
+    public @NotNull PermissionGroup<?> createInternalPermissionGroup(@NotNull String name, @Nullable Map<String, String> data) {
+        KissenPaperPublicPermissionGroup kissenPaperPublicPermissionGroup = new KissenPaperPublicPermissionGroup();
+        try {
+            kissenPaperPublicPermissionGroup.setup(name, data);
+            PaperPermissionGroup permissionGroup = new KissenPaperPermissionGroup(kissenPaperPublicPermissionGroup);
+            cachedGroups.removeIf(paperPermissionPermissionGroup -> paperPermissionPermissionGroup.getPermissionID()
+                .equals(name));
+            cachedGroups.add(permissionGroup);
+
+            PaperPrivatePermissionGroup paperPrivatePermissionGroup = getPrivatePermissionGroup(name);
+            if (paperPrivatePermissionGroup == null) {
+                paperPrivatePermissionGroup = createPrivateInternalPermissionGroup(name, null);
+            }
+            cachedGroups.add(paperPrivatePermissionGroup);
+            Bukkit.getKissen()
+                .getImplementation(EventImplementation.class)
+                .call(new KissenPermissionGroupCreatedEvent(permissionGroup));
+            return permissionGroup;
+        } catch (BackendException e) {
+            throw new RuntimeException(e); //TODO replace with throw list
+        }
+    }
+
+    @Override
+    public @NotNull PaperPrivatePermissionGroup createPrivatePermissionGroup(@NotNull String group, @Nullable Map<String, String> data) throws EventCancelledException, BackendException {
+        KissenPermissionGroupCreateEvent kissenPermissionGroupCreateEvent = new KissenPermissionGroupCreateEvent(group, data);
+        if (Bukkit.getKissen()
+            .getImplementation(EventImplementation.class)
+            .call(kissenPermissionGroupCreateEvent)) {
+            return createPrivateInternalPermissionGroup(group, data);
+        }
+        throw new EventCancelledException();
+    }
+
+    public @NotNull PaperPrivatePermissionGroup createPrivateInternalPermissionGroup(@NotNull String group, @Nullable Map<String, String> data) throws BackendException {
+        KissenPaperPrivatePermissionGroup kissenPaperPrivatePermissionGroup = new KissenPaperPrivatePermissionGroup();
+        kissenPaperPrivatePermissionGroup.setup(group, data);
+        cachedGroups.add(kissenPaperPrivatePermissionGroup);
+        Bukkit.getKissen()
+            .getImplementation(EventImplementation.class)
+            .call(new KissenPermissionGroupCreatedEvent(kissenPaperPrivatePermissionGroup));
+        return kissenPaperPrivatePermissionGroup;
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/KissenPaperPlayerPermissible.java b/src/main/java/net/kissenpvp/paper/permission/KissenPaperPlayerPermissible.java
new file mode 100644
index 0000000000000000000000000000000000000000..d6b2c370b2fcf538359a1f5fc452c0eaace3d0f1
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/KissenPaperPlayerPermissible.java
@@ -0,0 +1,55 @@
+package net.kissenpvp.paper.permission;
+
+import net.kissenpvp.core.api.permission.GroupablePermissionEntry;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kyori.adventure.text.Component;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.permissions.Permissible;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Collections;
+import java.util.Set;
+import java.util.UUID;
+
+public class KissenPaperPlayerPermissible extends KissenPaperPermissible {
+
+    public KissenPaperPlayerPermissible(@NotNull Permissible parent) {
+        super(parent);
+    }
+
+    private @NotNull OfflinePlayer getPlayer() {
+        return (OfflinePlayer) parent; // Can be offline or online, does not matter
+    }
+
+    @Override
+    public @NotNull GroupablePermissionEntry<PaperPermission> getPermissionEntry(@NotNull Context context) {
+        return (GroupablePermissionEntry<PaperPermission>) getPlayer().getUser(context);
+    }
+
+    @Override
+    public @NotNull String getPermissionID() {
+        return getPermissionEntry(Context.GLOBAL).getPermissionID();
+    }
+
+    @Override
+    public @NotNull Component displayName() {
+        return getPlayer().displayName();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAffectedPermissionPlayer() {
+        return Collections.singleton(getPlayer().getUniqueId());
+    }
+
+    @Override
+    public boolean isOp() {
+        return getPlayer().isOp();
+    }
+
+    @Override
+    public void setOp(boolean value) {
+        getPlayer().setOp(value);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/PermissionCommand.java b/src/main/java/net/kissenpvp/paper/permission/PermissionCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..217f3d97fefaa3ccbed105fc4b07b1347ed28d3b
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/PermissionCommand.java
@@ -0,0 +1,21 @@
+package net.kissenpvp.paper.permission;
+
+import net.kissenpvp.core.api.command.Context;
+import net.kissenpvp.core.api.command.annotations.CommandData;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Player;
+
+public class PermissionCommand {
+
+
+    @CommandData(name = "test")
+    public void test(Context<CommandSender> commandSender, String permission) {
+        try {
+            ((Player) commandSender.getSender()).getPermissible().setPermission(permission, true);
+        } catch (EventCancelledException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/RemoveAttachmentRunnable.java b/src/main/java/net/kissenpvp/paper/permission/RemoveAttachmentRunnable.java
new file mode 100644
index 0000000000000000000000000000000000000000..64401fe14b92af9d12b34f4065ecf5e18e69df4b
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/RemoveAttachmentRunnable.java
@@ -0,0 +1,15 @@
+package net.kissenpvp.paper.permission;
+
+import org.bukkit.permissions.PermissionAttachment;
+import org.jetbrains.annotations.NotNull;
+
+public record RemoveAttachmentRunnable(PermissionAttachment attachment) implements Runnable {
+    public RemoveAttachmentRunnable(@NotNull PermissionAttachment attachment) {
+        this.attachment = attachment;
+    }
+
+    @Override
+    public void run() {
+        attachment.remove();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperAbstractPermissionGroup.java b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperAbstractPermissionGroup.java
new file mode 100644
index 0000000000000000000000000000000000000000..3540b74b166eeede1dde1baef3c694fbfb9dfaca
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperAbstractPermissionGroup.java
@@ -0,0 +1,41 @@
+package net.kissenpvp.paper.permission.group;
+
+import net.kissenpvp.core.api.permission.PermissionGroup;
+import net.kissenpvp.core.database.DataWriter;
+import net.kissenpvp.core.permission.KissenPermissionGroup;
+import net.kissenpvp.core.permission.KissenPermissionNode;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PaperPermissionImplementation;
+import net.kissenpvp.paper.permission.KissenPaperPermission;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Set;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public abstract class KissenPaperAbstractPermissionGroup extends KissenPermissionGroup<PaperPermission> {
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups() {
+        PaperPermissionImplementation paperPermissionImplementation = Bukkit.getKissen()
+            .getImplementation(PaperPermissionImplementation.class);
+
+        return Stream.concat(paperPermissionImplementation
+                .getPermissionGroupSet()
+                .stream()
+                .filter(paperPermissionGroup -> paperPermissionGroup.getMember()
+                    .contains(getPermissionID())), paperPermissionImplementation
+                .getPrivatePermissionGroupSet()
+                .stream()
+                .filter(paperPermissionGroup -> paperPermissionGroup.getMember().contains(getPermissionID())))
+            .collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    protected @NotNull PaperPermission translatePermission(@NotNull KissenPermissionNode kissenPermissionNode, @Nullable DataWriter dataWriter) {
+        return new KissenPaperPermission(kissenPermissionNode, this, dataWriter);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPermissionGroup.java b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPermissionGroup.java
new file mode 100644
index 0000000000000000000000000000000000000000..015647eda8d09f7facb1fe3c92da4135f938dab8
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPermissionGroup.java
@@ -0,0 +1,282 @@
+package net.kissenpvp.paper.permission.group;
+
+import net.kissenpvp.core.api.database.StorageImplementation;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.permission.GroupablePermissionEntry;
+import net.kissenpvp.core.api.permission.PermissionGroup;
+import net.kissenpvp.core.base.KissenCore;
+import net.kissenpvp.core.permission.InternalGroupablePermissionEntry;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PaperPermissionGroup;
+import net.kissenpvp.paper.api.permission.PaperPublicPermissionGroup;
+import net.kissenpvp.paper.permission.KissenPaperAttachmentPermission;
+import net.kissenpvp.paper.permission.KissenPaperPermissible;
+import net.kyori.adventure.text.Component;
+import org.bukkit.Bukkit;
+import org.bukkit.permissions.Permissible;
+import org.bukkit.permissions.PermissionAttachment;
+import org.bukkit.permissions.PermissionAttachmentInfo;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.*;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public class KissenPaperPermissionGroup extends KissenPaperPermissible implements PaperPermissionGroup, InternalGroupablePermissionEntry<PaperPermission> {
+    private final PaperPublicPermissionGroup permissionGroup;
+
+    public KissenPaperPermissionGroup(PaperPublicPermissionGroup permissionGroup) {
+        this.permissionGroup = permissionGroup;
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getOwnPermissions() {
+        return Stream.concat(getOwnPermissions(Context.LOCAL).stream(), getOwnPermissions(Context.GLOBAL).stream())
+            .collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public int wipeGroups() {
+        return getCoreGroup(Context.LOCAL).wipeGroups();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups() {
+        return Stream.concat(getPermissionGroups(Context.LOCAL).stream(), getPermissionGroups(Context.GLOBAL).stream())
+            .collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup) {
+        return getCoreGroup(Context.LOCAL).inGroup(permissionGroup) || getCoreGroup(Context.GLOBAL).inGroup(permissionGroup);
+    }
+
+    @Override
+    public @NotNull String getPermissionID() {
+        return getCoreGroup(Context.GLOBAL).getPermissionID();
+    }
+
+    @Override
+    public @NotNull Component displayName() {
+        return getCoreGroup(Context.GLOBAL).displayName();
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission) throws EventCancelledException {
+        return setPermission(permission, Context.GLOBAL);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, boolean value) throws EventCancelledException {
+        return setPermission(permission, value, Context.GLOBAL);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull PaperPermission permission) throws EventCancelledException {
+        return setPermission(permission, Context.GLOBAL);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission) {
+        return unsetPermission(permission, Context.GLOBAL);
+    }
+
+    @Override
+    public int wipePermissions() {
+        return getCoreGroup(Context.LOCAL).wipePermissions() + getCoreGroup(Context.GLOBAL).wipePermissions();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList() {
+        return Stream.concat(getPermissionList(Context.LOCAL).stream(), getPermissionList(Context.GLOBAL).stream())
+            .collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @NotNull Optional<PaperPermission> getPermission(@NotNull String permission) {
+        return Optional.ofNullable(getPermissionList(Context.LOCAL).stream()
+            .filter(paperPermission -> paperPermission.getName().equalsIgnoreCase(permission))
+            .findFirst()
+            .orElse(getPermissionList(Context.GLOBAL).stream()
+                .filter(paperPermission -> paperPermission.getName().equalsIgnoreCase(permission))
+                .findFirst()
+                .orElse(null)));
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAffectedPermissionPlayer() {
+        return Stream.concat(getCoreGroup(Context.LOCAL).getAffectedPermissionPlayer()
+                .stream(), getCoreGroup(Context.GLOBAL).getAffectedPermissionPlayer().stream())
+            .collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String permission) {
+        Optional<PaperPermission> optionalPaperPermission = getPermission(permission);
+        return optionalPaperPermission.isPresent() && optionalPaperPermission.get().getValue();
+    }
+
+    @Override
+    public @NotNull Set<PermissionAttachmentInfo> getEffectivePermissions() {
+        return getPermissionList().stream().map(permission ->
+        {
+            PermissionAttachment attachment = null;
+            if (permission instanceof KissenPaperAttachmentPermission kissenPaperAttachmentPermission) {
+                attachment = kissenPaperAttachmentPermission.getPermissionAttachment();
+            }
+            return new PermissionAttachmentInfo(this, permission.getName(), attachment, permission.getValue());
+        }).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public void permissionUpdate() {
+        getCoreGroup(Context.GLOBAL).permissionUpdate();
+        getCoreGroup(Context.LOCAL).permissionUpdate();
+        getAffectedPermissionPlayer().stream()
+            .map(Bukkit::getPlayer)
+            .filter(Objects::nonNull)
+            .forEach(Permissible::recalculatePermissions);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<String> getMember() {
+        return Stream.concat(getCoreGroup(Context.LOCAL).getMember()
+            .stream(), getCoreGroup(Context.GLOBAL).getMember().stream()).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public boolean addMember(@NotNull GroupablePermissionEntry<?> groupablePermissionEntry) {
+        return addMember(groupablePermissionEntry, Context.GLOBAL);
+    }
+
+    @Override
+    public boolean removeMember(@NotNull GroupablePermissionEntry<?> groupablePermissionEntry) {
+        return removeMember(groupablePermissionEntry, Context.GLOBAL);
+    }
+
+    @Override
+    public boolean addMember(@NotNull GroupablePermissionEntry<?> groupablePermissionEntry, @NotNull Context context) {
+        return getCoreGroup(context).addMember(groupablePermissionEntry);
+    }
+
+    @Override
+    public boolean removeMember(@NotNull GroupablePermissionEntry<?> groupablePermissionEntry, @NotNull Context context) {
+        return getCoreGroup(context).removeMember(groupablePermissionEntry);
+    }
+
+    @Override
+    public @NotNull PermissionGroup<PaperPermission> getCoreGroup(@NotNull Context context) {
+        return switch (context) {
+            case GLOBAL -> permissionGroup;
+            case LOCAL -> permissionGroup.getPrivatePermissionGroup();
+        };
+    }
+
+    @Override
+    public @NotNull Set<PaperPermission> getOwnPermissions(@NotNull Context context) {
+        return getCoreGroup(context).getOwnPermissions();
+    }
+
+    @Override
+    public @NotNull Set<PermissionGroup<PaperPermission>> getPermissionGroups(@NotNull Context context) {
+        return getCoreGroup(context).getPermissionGroups();
+    }
+
+    @Override
+    public boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup, @NotNull Context context) {
+        return getCoreGroup(context).inGroup(permissionGroup);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, @NotNull Context context) throws EventCancelledException {
+        return getCoreGroup(context).setPermission(permission);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, boolean value, @NotNull Context context) throws EventCancelledException {
+        return getCoreGroup(context).setPermission(permission, value);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull PaperPermission permission, @NotNull Context context) throws EventCancelledException {
+        return getCoreGroup(context).setPermission(permission);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission, @NotNull Context context) {
+        return getCoreGroup(context).unsetPermission(permission);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList(@NotNull Context context) {
+        return getCoreGroup(context).getPermissionList();
+    }
+
+    @Override
+    public @NotNull Optional<@Nullable PaperPermission> getPermission(@NotNull String permission, @NotNull Context context) {
+        return getCoreGroup(context).getPermission(permission);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String permission, @NotNull Context context) {
+        return getCoreGroup(context).hasPermission(permission);
+    }
+
+    @Override
+    public @NotNull GroupablePermissionEntry<PaperPermission> getPermissionEntry(@NotNull Context context) {
+        return this;
+    }
+
+    @Override
+    public @NotNull Set<PaperPermission> internalPermissionCollector(@NotNull Set<String> blacklistedGroups, @NotNull Set<String> blacklistedPermissions) {
+        Set<PaperPermission> permissionSet = new HashSet<>(((InternalGroupablePermissionEntry<PaperPermission>) getCoreGroup(Context.LOCAL)).internalPermissionCollector(blacklistedGroups, blacklistedPermissions));
+        blacklistedGroups.remove(getPermissionID()); //remove blacklist because public group will be added as well.
+        permissionSet.addAll(((InternalGroupablePermissionEntry<PaperPermission>) getCoreGroup(Context.GLOBAL)).internalPermissionCollector(blacklistedGroups, blacklistedPermissions));
+        return permissionSet;
+    }
+
+    @Override
+    public @NotNull Set<String> internalGroupCollector(@NotNull Set<String> blacklistedGroups) {
+        Set<String> groups = new HashSet<>(((InternalGroupablePermissionEntry<PaperPermission>) getCoreGroup(Context.GLOBAL)).internalGroupCollector(blacklistedGroups));
+        blacklistedGroups.remove(getPermissionID()); //remove blacklist because public group will be added as well.
+        groups.addAll(((InternalGroupablePermissionEntry<PaperPermission>) getCoreGroup(Context.GLOBAL)).internalGroupCollector(blacklistedGroups));
+        return groups;
+    }
+
+    @Override
+    public boolean isOp() {
+        return hasPermission("*");
+    }
+
+    @Override
+    public void setOp(boolean value) {
+        if (isOp() && !value) {
+            unsetPermission("*");
+            return;
+        }
+
+        try {
+            setPermission("*", value);
+        } catch (EventCancelledException eventCancelledException) {
+            throw new RuntimeException(eventCancelledException);
+        }
+    }
+
+    /**
+     * Retrieves a map containing stored data from the storage system.
+     * <p>
+     * This method fetches data from the storage implementation associated with the Kissen Core instance. The data is retrieved based on the provided storage key.
+     * The retrieved data is returned as a map of string keys to associated objects.
+     *
+     * @return A non-null map containing the retrieved data from the storage system.
+     * @throws UnsupportedOperationException If the storage system is not supported or not properly configured.
+     */
+    private @NotNull Map<String, Object> getStorage() {
+        return KissenCore.getInstance()
+            .getImplementation(StorageImplementation.class)
+            .getStorage("permissiongroupattachments");
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPrivatePermissionGroup.java b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPrivatePermissionGroup.java
new file mode 100644
index 0000000000000000000000000000000000000000..e5622678e7c6b1d52b3b956aea9a2e2876b22008
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPrivatePermissionGroup.java
@@ -0,0 +1,39 @@
+package net.kissenpvp.paper.permission.group;
+
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.database.meta.ObjectMeta;
+import net.kissenpvp.core.api.database.savable.Savable;
+import net.kissenpvp.core.api.networking.socket.DataPackage;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.PaperPermissionGroup;
+import net.kissenpvp.paper.api.permission.PaperPermissionImplementation;
+import net.kissenpvp.paper.api.permission.PaperPrivatePermissionGroup;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Objects;
+
+public class KissenPaperPrivatePermissionGroup extends KissenPaperAbstractPermissionGroup implements PaperPrivatePermissionGroup {
+    @Override
+    public void sendData(@NotNull DataPackage dataPackage) { /* ignored */ }
+
+    @Override
+    public @Nullable PaperPermissionGroup getPublicGroup() {
+        return Bukkit.getKissen()
+            .getImplementation(PaperPermissionImplementation.class)
+            .getPermissionGroup(getPermissionID());
+    }
+
+    @Override
+    public @NotNull ObjectMeta getMeta() {
+        return Bukkit.getKissen().getPrivateMeta();
+    }
+
+    @Override
+    public int softDelete() throws BackendException {
+        getSerializableSavableHandler().delete();
+        ((Savable) Objects.requireNonNull(getPublicGroup()).getCoreGroup(Context.GLOBAL)).delete();
+        return super.softDelete();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPublicPermissionGroup.java b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPublicPermissionGroup.java
new file mode 100644
index 0000000000000000000000000000000000000000..861f8ec4bca4d48796efeba8b8eaa6ff3c20b600
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPublicPermissionGroup.java
@@ -0,0 +1,45 @@
+package net.kissenpvp.paper.permission.group;
+
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.networking.socket.DataPackage;
+import net.kissenpvp.paper.api.permission.PaperPrivatePermissionGroup;
+import net.kissenpvp.paper.api.permission.PaperPublicPermissionGroup;
+import net.kissenpvp.paper.permission.KissenPaperPermissionImplementation;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Objects;
+
+public class KissenPaperPublicPermissionGroup extends KissenPaperAbstractPermissionGroup implements PaperPublicPermissionGroup {
+
+    @Override
+    public @NotNull String getSaveID() {
+        return "PublicPermissionGroup";
+    }
+
+    @Override
+    public void sendData(@NotNull DataPackage dataPackage) {
+        //TODO
+    }
+
+    @Override
+    public @NotNull PaperPrivatePermissionGroup getPrivatePermissionGroup() {
+        KissenPaperPermissionImplementation paperPermissionImplementation = Bukkit.getKissen()
+            .getImplementation(KissenPaperPermissionImplementation.class);
+        return Objects.requireNonNullElseGet(paperPermissionImplementation.getPrivatePermissionGroup(getPermissionID()), () -> {
+            try {
+                return paperPermissionImplementation.createPrivateInternalPermissionGroup(getPermissionID(), null);
+            } catch (BackendException backendException) {
+                throw new RuntimeException(backendException); //TODO use better approach
+            }
+        });
+    }
+
+    @Override
+    public int softDelete() throws BackendException {
+        Bukkit.getKissen()
+            .getImplementation(KissenPaperPermissionImplementation.class)
+            .removePublicPermissionGroup(getPermissionID());
+        return super.softDelete();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenPaperPrivateUser.java b/src/main/java/net/kissenpvp/paper/user/KissenPaperPrivateUser.java
new file mode 100644
index 0000000000000000000000000000000000000000..8a3b77d63565e8c7932536e8b92bd8eeef39ce7b
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/KissenPaperPrivateUser.java
@@ -0,0 +1,69 @@
+package net.kissenpvp.paper.user;
+
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.networking.client.entitiy.PlayerClient;
+import net.kissenpvp.core.api.networking.socket.DataPackage;
+import net.kissenpvp.core.api.permission.PermissionGroup;
+import net.kissenpvp.core.base.KissenCore;
+import net.kissenpvp.core.database.DataWriter;
+import net.kissenpvp.core.networking.client.entity.KissenPlayerClient;
+import net.kissenpvp.core.permission.KissenPermissionNode;
+import net.kissenpvp.core.user.KissenUser;
+import net.kissenpvp.paper.api.networking.client.entity.PaperPlayerClient;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PaperPermissionImplementation;
+import net.kissenpvp.paper.api.user.rank.PaperPlayerRank;
+import net.kissenpvp.paper.permission.KissenPaperPermission;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Objects;
+import java.util.Set;
+import java.util.UUID;
+import java.util.stream.Collectors;
+
+public class KissenPaperPrivateUser extends KissenUser<PaperPermission> {
+
+    public KissenPaperPrivateUser(@Nullable UUID uuid, @Nullable String name) throws BackendException {
+        super(uuid, name);
+    }
+
+    @Override
+    public @NotNull String getSaveID() {
+        return "privateuser";
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups() {
+        return KissenCore.getInstance()
+            .getImplementation(PaperPermissionImplementation.class)
+            .getPrivatePermissionGroupSet()
+            .stream()
+            .filter(permissionGroup -> permissionGroup.getMember().contains(getPermissionID()))
+            .collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public PlayerClient<?> getPlayerClient() {
+        if (!getStorage().containsKey("player_client")) {
+            getStorage().put("player_client", injectPlayerClient());
+        }
+        return (KissenPlayerClient<PaperPlayerRank>) getStorage().get("player_client");
+    }
+
+    protected @NotNull PaperPlayerClient injectPlayerClient() {
+        UUID uuid = UUID.fromString(getRawID());
+        return Bukkit.getKissen()
+            .isOnline(uuid) ? Objects.requireNonNull(Bukkit.getPlayer(uuid)) : Bukkit.getOfflinePlayer(uuid);
+    }
+
+    @Override
+    protected @NotNull PaperPermission translatePermission(@NotNull KissenPermissionNode kissenPermissionNode, @Nullable DataWriter dataWriter) {
+        return new KissenPaperPermission(kissenPermissionNode, this, dataWriter);
+    }
+
+    @Override
+    public void sendData(@NotNull DataPackage dataPackage) { /* Ignored because it's private */ }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenPaperPublicUser.java b/src/main/java/net/kissenpvp/paper/user/KissenPaperPublicUser.java
new file mode 100644
index 0000000000000000000000000000000000000000..5b0cb15c1e13a552e0baf4207cae48ff3eef045d
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/KissenPaperPublicUser.java
@@ -0,0 +1,103 @@
+package net.kissenpvp.paper.user;
+
+import net.kissenpvp.core.api.database.StorageImplementation;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.networking.client.entitiy.PlayerClient;
+import net.kissenpvp.core.api.networking.socket.DataPackage;
+import net.kissenpvp.core.api.permission.PermissionGroup;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.base.KissenCore;
+import net.kissenpvp.core.database.DataWriter;
+import net.kissenpvp.core.permission.KissenPermissionNode;
+import net.kissenpvp.core.user.KissenPublicUser;
+import net.kissenpvp.core.user.KissenUser;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PaperPermissionImplementation;
+import net.kissenpvp.paper.networking.client.entity.KissenPaperPlayerClient;
+import net.kissenpvp.paper.permission.KissenPaperPermission;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Set;
+import java.util.UUID;
+import java.util.stream.Collectors;
+
+public class KissenPaperPublicUser extends KissenPublicUser<PaperPermission> {
+
+    public KissenPaperPublicUser(@Nullable UUID uuid, @Nullable String name) throws BackendException {
+        super(uuid, name);
+        getPrivateUserEntry(); // Load private user in authenticator to prevent server thread overload
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups() {
+        return KissenCore.getInstance()
+            .getImplementation(PaperPermissionImplementation.class)
+            .getPermissionGroupSet()
+            .stream()
+            .filter(permissionGroup -> permissionGroup.getMember().contains(getPermissionID()))
+            .collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public PlayerClient<?> getPlayerClient() {
+        return getPrivateUserEntry().getPlayerClient();
+    }
+
+    @Override
+    protected @NotNull PaperPermission translatePermission(@NotNull KissenPermissionNode kissenPermissionNode, @Nullable DataWriter dataWriter) {
+        return new KissenPaperPermission(kissenPermissionNode, this, dataWriter);
+    }
+
+    @Override
+    public void sendData(@NotNull DataPackage dataPackage) {
+        // TODO Networking and stuff
+    }
+
+    @Override
+    public void login() {
+        super.login();
+        KissenPaperPlayerClient kissenPaperPlayerClient = ((KissenPaperPlayerClient) getPlayerClient());
+        getStorage().put("visual_hash", kissenPaperPlayerClient.visualHash());
+        getStorage().put("time_joined", System.currentTimeMillis());
+        ((KissenUser<?>) getPrivateUserEntry()).login();
+        getStorage().put("tick", true);
+    }
+
+    @Override
+    public void logout() {
+        super.logout();
+        Bukkit.getKissen().getImplementation(StorageImplementation.class).dropStorage("user" + this.getRawID());
+    }
+
+    @Override
+    public void tick() {
+        //TODO check for visuals maybe
+        ((KissenUser<PaperPermission>) getPrivateUserEntry()).tick();
+        super.tick();
+    }
+
+    @Override
+    public int softDelete() throws BackendException {
+        return super.softDelete() + getPrivateUserEntry().delete();
+    }
+
+    public User getPrivateUserEntry() {
+        if (!getStorage().containsKey("private_user_entry")) {
+            try {
+                getStorage().put("private_user_entry", setupPrivateUser(UUID.fromString(getRawID()), getNotNull("name")));
+            } catch (BackendException backendException) {
+                KissenCore.getInstance()
+                    .getLogger()
+                    .error("The backend was not able to create a private user entry for the user '{}' with the id '{}'. It's advised to shutdown the server to prevent further problems with the servers data.", getNotNull("name"), getRawID());
+            }
+        }
+        return (User) getStorage().get("private_user_entry");
+    }
+
+    protected KissenPaperPrivateUser setupPrivateUser(UUID uuid, String name) throws BackendException {
+        return new KissenPaperPrivateUser(uuid, name);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenPaperUserImplementation.java b/src/main/java/net/kissenpvp/paper/user/KissenPaperUserImplementation.java
new file mode 100644
index 0000000000000000000000000000000000000000..24d5563aa6fdb2d3d03e069de2c5f9f5a0704443
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/KissenPaperUserImplementation.java
@@ -0,0 +1,28 @@
+package net.kissenpvp.paper.user;
+
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.database.savable.SavableMap;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.user.KissenUserImplementation;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Optional;
+import java.util.Set;
+import java.util.UUID;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public class KissenPaperUserImplementation extends KissenUserImplementation {
+
+    @Override
+    public @NotNull @Unmodifiable Set<SavableMap> getUserData() throws BackendException {
+        return Stream.concat(getUserMeta().getData(new KissenPaperPublicUser(null, null)).values().stream(), getUserMeta().getData(new KissenPaperPrivateUser(null, null)).values().stream()).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull UUID uuid) {
+        return getOnlineUser(uuid).or(() -> Optional.of(Bukkit.getOfflinePlayer(uuid).getUser())).orElseThrow(IllegalArgumentException::new);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperFallBackRank.java b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperFallBackRank.java
new file mode 100644
index 0000000000000000000000000000000000000000..f382c587fc83cc3b8fdc34ad36ff83b1bb8820b1
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperFallBackRank.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2023 KissenPvP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.kissenpvp.paper.user.rank;
+
+import net.kissenpvp.core.user.rank.KissenFallBackRank;
+import net.kissenpvp.paper.api.networking.client.entity.PaperPlayerClient;
+import net.kissenpvp.paper.api.user.rank.PaperRank;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Optional;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+public class KissenPaperFallBackRank extends KissenFallBackRank implements PaperRank {
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPlayerClient> getPlayers() {
+        return Bukkit.getOnlinePlayers().stream().filter(playerClient ->
+        {
+            Optional<PaperRank> paperRankOptional = playerClient.getRank().getSource();
+            return paperRankOptional.isPresent() && paperRankOptional.get().equals(this);
+        }).collect(Collectors.toUnmodifiableSet());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperPlayerFallBackRank.java b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperPlayerFallBackRank.java
new file mode 100644
index 0000000000000000000000000000000000000000..5f5f117ececb617afa6c26705318d6d28b47ddb9
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperPlayerFallBackRank.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2023 KissenPvP
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.kissenpvp.paper.user.rank;
+
+import net.kissenpvp.core.user.rank.KissenPlayerFallBackRank;
+import net.kissenpvp.paper.api.user.rank.PaperPlayerRank;
+import net.kissenpvp.paper.api.user.rank.PaperRank;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Optional;
+
+public class KissenPaperPlayerFallBackRank extends KissenPlayerFallBackRank<PaperRank> implements PaperPlayerRank
+{
+    @Override public @NotNull Optional<PaperRank> getSource()
+    {
+        return Optional.of(new KissenPaperFallBackRank());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperPlayerRank.java b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperPlayerRank.java
new file mode 100644
index 0000000000000000000000000000000000000000..dfbb88cf0967780950a0a9a9b638bfa5b7358ec3
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperPlayerRank.java
@@ -0,0 +1,15 @@
+package net.kissenpvp.paper.user.rank;
+
+import net.kissenpvp.core.database.DataWriter;
+import net.kissenpvp.core.user.rank.KissenPlayerRank;
+import net.kissenpvp.core.user.rank.KissenPlayerRankNode;
+import net.kissenpvp.paper.api.user.rank.PaperPlayerRank;
+import net.kissenpvp.paper.api.user.rank.PaperRank;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class KissenPaperPlayerRank extends KissenPlayerRank<PaperRank> implements PaperPlayerRank {
+    public KissenPaperPlayerRank(@NotNull KissenPlayerRankNode kissenPlayerRankNode, @Nullable DataWriter dataWriter) {
+        super(kissenPlayerRankNode, dataWriter);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperRank.java b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperRank.java
new file mode 100644
index 0000000000000000000000000000000000000000..e595eb22e76fb5d110c3d9897c640d3ebff84286
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperRank.java
@@ -0,0 +1,13 @@
+package net.kissenpvp.paper.user.rank;
+
+import net.kissenpvp.core.api.networking.socket.DataPackage;
+import net.kissenpvp.core.api.user.rank.Rank;
+import net.kissenpvp.core.user.rank.KissenRank;
+import org.jetbrains.annotations.NotNull;
+
+public class KissenPaperRank extends KissenRank implements Rank {
+    @Override
+    public void sendData(@NotNull DataPackage dataPackage) {
+        //TODO async network and so on
+    }
+}
diff --git a/src/main/java/net/minecraft/commands/Commands.java b/src/main/java/net/minecraft/commands/Commands.java
index 80c2c8d565f03ae0ea24fbdecdbe2bc5b9aa4b82..1a52772a3614056e9889f6560bad094b035f8ff4 100644
--- a/src/main/java/net/minecraft/commands/Commands.java
+++ b/src/main/java/net/minecraft/commands/Commands.java
@@ -12,14 +12,16 @@ import com.mojang.brigadier.exceptions.CommandSyntaxException;
 import com.mojang.brigadier.tree.CommandNode;
 import com.mojang.brigadier.tree.RootCommandNode;
 import com.mojang.logging.LogUtils;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.Optional;
-import java.util.Set;
+
+import java.util.*;
 import java.util.function.Predicate;
 import java.util.function.UnaryOperator;
 import java.util.stream.Collectors;
 import javax.annotation.Nullable;
+
+import net.kissenpvp.core.base.KissenCore;
+import net.kissenpvp.core.message.KissenComponentSerializer;
+import net.kissenpvp.core.message.localization.KissenLocalizationImplementation;
 import net.minecraft.ChatFormatting;
 import net.minecraft.SharedConstants;
 import net.minecraft.Util;
@@ -118,12 +120,11 @@ import net.minecraft.server.commands.data.DataCommands;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.tags.TagKey;
 import net.minecraft.util.profiling.jfr.JvmProfiler;
+import org.bukkit.entity.Player;
 import org.slf4j.Logger;
 
 // CraftBukkit start
 import com.google.common.base.Joiner;
-import java.util.Collection;
-import java.util.LinkedHashSet;
 import org.bukkit.event.player.PlayerCommandSendEvent;
 import org.bukkit.event.server.ServerCommandEvent;
 // CraftBukkit end
@@ -320,6 +321,20 @@ public class Commands {
         try {
             byte b1;
 
+            // KissenPaper start
+            Locale senderLocale = KissenCore.getInstance()
+                    .getImplementation(KissenLocalizationImplementation.class)
+                    .getDefaultLocale();
+            if (commandlistenerwrapper.getBukkitSender() instanceof Player player) {
+                senderLocale = player.getCurrentLocale();
+            }
+            String unknownCommandMessage = KissenComponentSerializer.getInstance()
+                    .getLegacySerializer()
+                    .serialize(KissenCore.getInstance()
+                            .getImplementation(KissenLocalizationImplementation.class)
+                            .translate("messages.unknown-command", senderLocale));
+            // KissenPaper end
+
             try {
                 int i = this.dispatcher.execute(parseresults);
 
@@ -332,9 +347,16 @@ public class Commands {
                 // Paper start
                 final net.kyori.adventure.text.TextComponent.Builder builder = net.kyori.adventure.text.Component.text();
                 if ((parseresults.getContext().getNodes().isEmpty() || !this.vanillaCommandNodes.contains(parseresults.getContext().getNodes().get(0).getNode()))) {
-                    if (!org.spigotmc.SpigotConfig.unknownCommandMessage.isEmpty()) {
-                        builder.append(net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(org.spigotmc.SpigotConfig.unknownCommandMessage));
+                    // KissenPaper start
+                    if (!unknownCommandMessage.isEmpty()) {
+                        //pesky bungee chat
+                        builder.append(net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection()
+                                .deserialize(unknownCommandMessage));
                     }
+                    /*if (!org.spigotmc.SpigotConfig.unknownCommandMessage.isEmpty()) {
+                        builder.append(net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(org.spigotmc.SpigotConfig.unknownCommandMessage));
+                    }*/
+                    // KissenPaper end
                 } else {
                 // commandlistenerwrapper.sendFailure(ComponentUtils.fromMessage(commandsyntaxexception.getRawMessage()));
                 builder.color(net.kyori.adventure.text.format.NamedTextColor.RED).append(io.papermc.paper.brigadier.PaperBrigadier.componentFromMessage(commandsyntaxexception.getRawMessage()));
@@ -364,7 +386,7 @@ public class Commands {
                         .append(io.papermc.paper.adventure.PaperAdventure.asAdventure(ichatmutablecomponent));
                 }
                 }
-                org.bukkit.event.command.UnknownCommandEvent event = new org.bukkit.event.command.UnknownCommandEvent(commandlistenerwrapper.getBukkitSender(), s, org.spigotmc.SpigotConfig.unknownCommandMessage.isEmpty() ? null : builder.build());
+                org.bukkit.event.command.UnknownCommandEvent event = new org.bukkit.event.command.UnknownCommandEvent(commandlistenerwrapper.getBukkitSender(), s, /* KissenPaper */ unknownCommandMessage /* org.spigotmc.SpigotConfig.unknownCommandMessage.isEmpty() */ .isEmpty() ? null : builder.build());
                 org.bukkit.Bukkit.getServer().getPluginManager().callEvent(event);
                 if (event.message() != null) {
                     commandlistenerwrapper.sendFailure(io.papermc.paper.adventure.PaperAdventure.asVanilla(event.message()), false);
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 3238cbcba567b1242c77e41f6b6f19a8d157fb4e..e4135793607ff6d29f5f56f5cb337a85625f886e 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -53,6 +53,9 @@ import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
 import javax.imageio.ImageIO;
+
+import net.kissenpvp.core.base.KissenCore;
+import net.kissenpvp.core.message.localization.KissenLocalizationImplementation;
 import net.minecraft.CrashReport;
 import net.minecraft.ReportedException;
 import net.minecraft.SharedConstants;
@@ -1106,6 +1109,10 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             this.statusIcon = (ServerStatus.Favicon) this.loadStatusIcon().orElse(null); // CraftBukkit - decompile error
             this.status = this.buildServerStatus();
 
+            // KissenPaper start
+            KissenCore.getInstance().start();
+            // KissenPaper end
+
             // Spigot start
             // Paper start - move done tracking
             LOGGER.info("Running delayed init tasks");
@@ -2182,8 +2189,17 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             while (iterator.hasNext()) {
                 ServerPlayer entityplayer = (ServerPlayer) iterator.next();
 
+                // KissenPaper start
+                KissenLocalizationImplementation kissenLocalizationImplementation = KissenCore.getInstance()
+                        .getImplementation(KissenLocalizationImplementation.class);
+                // KissenPaper end
+
                 if (!whitelist.isWhiteListed(entityplayer.getGameProfile()) && !this.getPlayerList().isOp(entityplayer.getGameProfile())) { // Paper - Fix kicking ops when whitelist is reloaded (MC-171420)
-                    entityplayer.connection.disconnect(org.spigotmc.SpigotConfig.whitelistMessage, org.bukkit.event.player.PlayerKickEvent.Cause.WHITELIST); // Paper - use configurable message
+                    // KissenPaper start
+                    entityplayer.connection.disconnect(/* KissenPaper */ kissenLocalizationImplementation.translate("messages.whitelist", entityplayer.getBukkitEntity()
+                            .getCurrentLocale()), org.bukkit.event.player.PlayerKickEvent.Cause.WHITELIST); // Paper - use configurable message
+                    //entityplayer.connection.disconnect(org.spigotmc.SpigotConfig.whitelistMessage, org.bukkit.event.player.PlayerKickEvent.Cause.WHITELIST); // Paper - use configurable message
+                    // KissenPaper end
                 }
             }
 
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index 9f422cbeaa52b3e6a0a27af4f8ad4ddb7808483f..3a6a513165a37b983e1bee73e010342ea6c7e156 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -19,6 +19,8 @@ import java.util.Locale;
 import java.util.Optional;
 import java.util.function.BooleanSupplier;
 import javax.annotation.Nullable;
+
+import net.kissenpvp.paper.base.KissenPaperCore;
 import net.minecraft.DefaultUncaughtExceptionHandler;
 import net.minecraft.DefaultUncaughtExceptionHandlerWithName;
 import net.minecraft.SharedConstants;
@@ -50,6 +52,7 @@ import net.minecraft.world.level.GameRules;
 import net.minecraft.world.level.GameType;
 import net.minecraft.world.level.block.entity.SkullBlockEntity;
 import net.minecraft.world.level.storage.LevelStorageSource;
+import org.bukkit.Bukkit;
 import org.slf4j.Logger;
 
 // CraftBukkit start
@@ -192,6 +195,17 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         DedicatedServer.LOGGER.info("Loading properties");
         DedicatedServerProperties dedicatedserverproperties = this.settings.getProperties();
 
+        // KissenPaper start
+        KissenPaperCore kissenPaperCore = new KissenPaperCore(LogUtils.getLogger());
+        Bukkit.setKissen(kissenPaperCore);
+        try {
+            kissenPaperCore.initialize(KissenPaperCore.class);
+        } catch (Exception exception) {
+            throw new RuntimeException(String.format("The system could not load the 'kissen' system due to a '%s' exception.", exception.getClass()
+                    .getSimpleName()), exception);
+        }
+        // KissenPaper stop
+
         if (this.isSingleplayer()) {
             this.setLocalIp("127.0.0.1");
         } else {
@@ -199,6 +213,7 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
             this.setPreventProxyConnections(dedicatedserverproperties.preventProxyConnections);
             this.setLocalIp(dedicatedserverproperties.serverIp);
         }
+
         // Spigot start
         this.setPlayerList(new DedicatedPlayerList(this, this.registries(), this.playerDataStorage));
         org.spigotmc.SpigotConfig.init((java.io.File) options.valueOf("spigot-settings"));
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index dc5fda83a66afbfeb7897fc20b4742899d8aca08..8aff989d6df5813824605f52e47c19795105649f 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -2026,8 +2026,8 @@ public class ServerPlayer extends Player {
         return map;
     }
     // Paper end
-    public String locale = null; // CraftBukkit - add, lowercase // Paper - default to null
-    public java.util.Locale adventure$locale = java.util.Locale.US; // Paper
+    //public String locale = null; // CraftBukkit - add, lowercase // Paper - default to null // KissenPaper not used anymore
+    //public java.util.Locale adventure$locale = java.util.Locale.US; // Paper // KissenPaper not used anymore
     public void updateOptions(ServerboundClientInformationPacket packet) {
         new com.destroystokyo.paper.event.player.PlayerClientOptionsChangeEvent(getBukkitEntity(), getClientOptionMap(packet.language, packet.viewDistance, com.destroystokyo.paper.ClientOption.ChatVisibility.valueOf(packet.chatVisibility().name()), packet.chatColors(), new com.destroystokyo.paper.PaperSkinParts(packet.modelCustomisation()), packet.mainHand() == HumanoidArm.LEFT ? MainHand.LEFT : MainHand.RIGHT, packet.allowsListing(), packet.textFilteringEnabled())).callEvent(); // Paper - settings event
         // CraftBukkit start
@@ -2035,15 +2035,30 @@ public class ServerPlayer extends Player {
             PlayerChangedMainHandEvent event = new PlayerChangedMainHandEvent(this.getBukkitEntity(), getMainArm() == HumanoidArm.LEFT ? MainHand.LEFT : MainHand.RIGHT);
             this.server.server.getPluginManager().callEvent(event);
         }
-        if (this.locale == null || !this.locale.equals(packet.language)) { // Paper - check for null
+        // KissenPaper start - use database backend instead of variable
+
+                /*if (this.locale == null || !this.locale.equals(packet.language)) { // Paper - check for null
             PlayerLocaleChangeEvent event = new PlayerLocaleChangeEvent(this.getBukkitEntity(), packet.language);
             this.server.server.getPluginManager().callEvent(event);
             this.server.server.getPluginManager().callEvent(new com.destroystokyo.paper.event.player.PlayerLocaleChangeEvent(this.getBukkitEntity(), this.locale, packet.language)); // Paper
         }
-        this.locale = packet.language;
+        this.locale = packet.language;*/
+
+        String locale = getBukkitEntity().getCurrentLocale().toString();
+        if (!locale.equalsIgnoreCase(packet.language)) { // Paper - check for null
+            PlayerLocaleChangeEvent event = new PlayerLocaleChangeEvent(this.getBukkitEntity(), packet.language);
+            this.server.server.getPluginManager().callEvent(event);
+            this.server.server.getPluginManager()
+                    .callEvent(new com.destroystokyo.paper.event.player.PlayerLocaleChangeEvent(this.getBukkitEntity(), locale, packet.language)); // Paper
+        }
+        getBukkitEntity().getUser().set("language", packet.language);
+        // KissenPaper end
+
+        //this.locale = packet.language; // KissenPaper
         // Paper start
-        this.adventure$locale = net.kyori.adventure.translation.Translator.parseLocale(this.locale);
-        this.connection.connection.channel.attr(PaperAdventure.LOCALE_ATTRIBUTE).set(this.adventure$locale);
+        // this.adventure$locale = net.kyori.adventure.translation.Translator.parseLocale(this.locale); // KissenPaper remove adventure locale
+        this.connection.connection.channel.attr(PaperAdventure.LOCALE_ATTRIBUTE)
+                .set(/*this.adventure$locale*/ getBukkitEntity().getCurrentLocale()); // KissenPaper use database value instead
         // Paper end
         this.clientViewDistance = packet.viewDistance;
         // CraftBukkit end
diff --git a/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
index 2ff578e4a953ffcf5176815ba8e3f06f73499989..6487990372c19cc2f31b9fc524ea178d38c3b12c 100644
--- a/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
@@ -14,6 +14,9 @@ import java.util.concurrent.atomic.AtomicInteger;
 import javax.annotation.Nullable;
 import javax.crypto.Cipher;
 import javax.crypto.SecretKey;
+
+import net.kissenpvp.core.user.KissenUserImplementation;
+import net.kissenpvp.paper.user.KissenPaperPublicUser;
 import net.minecraft.DefaultUncaughtExceptionHandler;
 import net.minecraft.core.UUIDUtil;
 import net.minecraft.network.Connection;
@@ -36,6 +39,7 @@ import net.minecraft.util.Crypt;
 import net.minecraft.util.CryptException;
 import net.minecraft.util.RandomSource;
 import org.apache.commons.lang3.Validate;
+import org.bukkit.Bukkit;
 import org.slf4j.Logger;
 
 // CraftBukkit start
@@ -388,6 +392,12 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener,
 
                         // Paper start
                         com.destroystokyo.paper.profile.PlayerProfile profile = com.destroystokyo.paper.profile.CraftPlayerProfile.asBukkitMirror(ServerLoginPacketListenerImpl.this.gameProfile);
+
+                        // KissenPaper start
+                        KissenPaperPublicUser kissenPaperPublicUser = new KissenPaperPublicUser(gameProfile.getId(), gameProfile.getName());
+                        Bukkit.getKissen().getImplementation(KissenUserImplementation.class).loadUser(kissenPaperPublicUser);
+                        // KissenPaper end
+
                         AsyncPlayerPreLoginEvent asyncEvent = new AsyncPlayerPreLoginEvent(playerName, address, rawAddress, uniqueId, profile, ServerLoginPacketListenerImpl.this.connection.hostname); // Paper - add rawAddress & hostname
                         server.getPluginManager().callEvent(asyncEvent);
                         profile = asyncEvent.getPlayerProfile();
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 640e9bd618dc8286933318744c2064ede1fd9b5f..7c22284d351e30a1d33a862750dc61406d47140c 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -27,6 +27,11 @@ import java.util.UUID;
 import java.util.function.Function;
 import java.util.function.Predicate;
 import javax.annotation.Nullable;
+
+import net.kissenpvp.core.base.KissenCore;
+import net.kissenpvp.core.message.KissenComponentSerializer;
+import net.kissenpvp.core.message.localization.KissenLocalizationImplementation;
+import net.kissenpvp.core.user.KissenUserImplementation;
 import net.minecraft.ChatFormatting;
 import net.minecraft.FileUtil;
 import net.minecraft.commands.CommandSourceStack;
@@ -101,6 +106,7 @@ import net.minecraft.world.scores.Objective;
 import net.minecraft.world.scores.PlayerTeam;
 import net.minecraft.world.scores.Scoreboard; // Paper
 import net.minecraft.world.scores.Team;
+import org.bukkit.Bukkit;
 import org.slf4j.Logger;
 
 // CraftBukkit start
@@ -335,6 +341,10 @@ public abstract class PlayerList {
         // Ensure that player inventory is populated with its viewer
         player.containerMenu.transferTo(player.containerMenu, bukkitPlayer);
 
+        // KissenPaper start
+        Bukkit.getKissen().getImplementation(KissenUserImplementation.class).loginUser(bukkitPlayer.getUser());
+        // KissenPaper end
+
         PlayerJoinEvent playerJoinEvent = new PlayerJoinEvent(bukkitPlayer, PaperAdventure.asAdventure(ichatmutablecomponent)); // Paper - Adventure
         this.cserver.getPluginManager().callEvent(playerJoinEvent);
 
@@ -686,7 +696,7 @@ public abstract class PlayerList {
         UUID uuid = UUIDUtil.getOrCreatePlayerUUID(gameprofile);
         List<ServerPlayer> list = Lists.newArrayList();
 
-        ServerPlayer entityplayer;
+        ServerPlayer entityplayer = null; // KissenPaper - make null
 
         for (int i = 0; i < this.players.size(); ++i) {
             entityplayer = (ServerPlayer) this.players.get(i);
@@ -740,7 +750,19 @@ public abstract class PlayerList {
         } else {
             // return this.players.size() >= this.maxPlayers && !this.canBypassPlayerLimit(gameprofile) ? IChatBaseComponent.translatable("multiplayer.disconnect.server_full") : null;
             if (this.players.size() >= this.maxPlayers && !this.canBypassPlayerLimit(gameprofile)) {
-                event.disallow(PlayerLoginEvent.Result.KICK_FULL, net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(org.spigotmc.SpigotConfig.serverFullMessage)); // Spigot // Paper - Adventure
+
+                // KissenPaper start
+                String serverFullMessage = KissenComponentSerializer.getInstance()
+                        .getLegacySerializer()
+                        .serialize(KissenCore.getInstance()
+                                .getImplementation(KissenLocalizationImplementation.class)
+                                .translate("messages.server-full", entityplayer.getBukkitEntity().getCurrentLocale()));
+                // KissenPaper end
+
+                event.disallow(PlayerLoginEvent.Result.KICK_FULL, net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection()
+                        .deserialize(/* KissenPaper */ serverFullMessage)); // Spigot // Paper - Adventure
+
+                //event.disallow(PlayerLoginEvent.Result.KICK_FULL, net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(org.spigotmc.SpigotConfig.serverFullMessage)); // Spigot // Paper - Adventure
             }
         }
 
@@ -1156,13 +1178,21 @@ public abstract class PlayerList {
     }
     public boolean isWhiteListed(GameProfile gameprofile, org.bukkit.event.player.PlayerLoginEvent loginEvent) {
         boolean isOp = this.ops.contains(gameprofile);
+        // KissenPaper start
+        KissenLocalizationImplementation kissenLocalizationImplementation = KissenCore.getInstance()
+                .getImplementation(KissenLocalizationImplementation.class);
+        String whitelistMessage = KissenComponentSerializer.getInstance()
+                .getLegacySerializer()
+                .serialize(kissenLocalizationImplementation.translate("messages.whitelist", loginEvent.getPlayer()
+                        .locale()));
+        // KissenPaper end
         boolean isWhitelisted = !this.doWhiteList || isOp || this.whitelist.contains(gameprofile);
         final com.destroystokyo.paper.event.profile.ProfileWhitelistVerifyEvent event;
-        event = new com.destroystokyo.paper.event.profile.ProfileWhitelistVerifyEvent(io.papermc.paper.util.MCUtil.toBukkit(gameprofile), this.doWhiteList, isWhitelisted, isOp, org.spigotmc.SpigotConfig.whitelistMessage);
+        event = new com.destroystokyo.paper.event.profile.ProfileWhitelistVerifyEvent(io.papermc.paper.util.MCUtil.toBukkit(gameprofile), this.doWhiteList, isWhitelisted, isOp, /* KissenPaper */ whitelistMessage /* org.spigotmc.SpigotConfig.whitelistMessage */);
         event.callEvent();
         if (!event.isWhitelisted()) {
             if (loginEvent != null) {
-                loginEvent.disallow(PlayerLoginEvent.Result.KICK_WHITELIST, net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(event.getKickMessage() == null ? org.spigotmc.SpigotConfig.whitelistMessage : event.getKickMessage()));
+                loginEvent.disallow(PlayerLoginEvent.Result.KICK_WHITELIST, net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(event.getKickMessage() == null ? /* KissenPaper */ whitelistMessage /* org.spigotmc.SpigotConfig.whitelistMessage */ : event.getKickMessage()));
             }
             return false;
         }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java b/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java
index c6129dc565b8f874b73e2fefcabd4be1c221fd73..340fdbdb77f8a386be5db58ab200fc0fee97e91e 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java
@@ -4,11 +4,16 @@ import com.mojang.authlib.GameProfile;
 import java.io.File;
 import java.time.Duration;
 import java.time.Instant;
-import java.util.Date;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.UUID;
+import java.util.*;
+
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.paper.api.permission.PaperPermissible;
+import net.kissenpvp.paper.api.permission.PermissibleOverriddenException;
+import net.kissenpvp.paper.networking.client.entity.KissenPaperPlayerClient;
+import net.kissenpvp.paper.permission.KissenPaperPlayerPermissible;
+import net.kissenpvp.paper.user.KissenPaperPublicUser;
+import net.kyori.adventure.text.Component;
 import net.minecraft.core.GlobalPos;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.NbtOps;
@@ -31,21 +36,34 @@ import org.bukkit.craftbukkit.profile.CraftPlayerProfile;
 import org.bukkit.entity.EntityType;
 import org.bukkit.entity.Player;
 import org.bukkit.metadata.MetadataValue;
+import org.bukkit.permissions.Permissible;
+import org.bukkit.permissions.Permission;
+import org.bukkit.permissions.PermissionAttachment;
+import org.bukkit.permissions.PermissionAttachmentInfo;
 import org.bukkit.plugin.Plugin;
 import org.bukkit.profile.PlayerProfile;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
 
 @SerializableAs("Player")
-public class CraftOfflinePlayer implements OfflinePlayer, ConfigurationSerializable {
+public class CraftOfflinePlayer implements OfflinePlayer, ConfigurationSerializable, /* KissenPaper */ KissenPaperPlayerClient {
     private static final org.slf4j.Logger LOGGER = com.mojang.logging.LogUtils.getLogger(); // Paper
     private final GameProfile profile;
     private final CraftServer server;
     private final PlayerDataStorage storage;
 
+    // KissenPaper start
+    private final Permissible permissible;
+
+    private User cachedUser;
+    private User cachePublicUser;
+    // KissenPaper end
+
     protected CraftOfflinePlayer(CraftServer server, GameProfile profile) {
         this.server = server;
         this.profile = profile;
         this.storage = server.console.playerDataStorage;
-
+        this.permissible = new KissenPaperPlayerPermissible(this);
     }
 
     @Override
@@ -81,6 +99,13 @@ public class CraftOfflinePlayer implements OfflinePlayer, ConfigurationSerializa
         return this.profile.getId();
     }
 
+    // KissenPaper start
+    @Override
+    public @NotNull Component displayName() {
+        return Component.text(getName()); //no custom display name set
+    }
+    // KissenPaper end
+
     @Override
     public com.destroystokyo.paper.profile.PlayerProfile getPlayerProfile() { // Paper
         return new com.destroystokyo.paper.profile.CraftPlayerProfile(this.profile); // Paper
@@ -257,6 +282,22 @@ public class CraftOfflinePlayer implements OfflinePlayer, ConfigurationSerializa
         }
     }
 
+    // KissenPaper start
+    @Override
+    public @NotNull User getUser() {
+        if (cachePublicUser == null) {
+            try {
+
+                cachePublicUser = new KissenPaperPublicUser(getUniqueId(), getName());
+            } catch (BackendException backendException) {
+                backendException.printStackTrace();
+            }
+        }
+
+        return cachePublicUser;
+    }
+    // KissenPaper end
+
     @Override
     public boolean hasPlayedBefore() {
         return this.getData() != null;
@@ -560,4 +601,74 @@ public class CraftOfflinePlayer implements OfflinePlayer, ConfigurationSerializa
             manager.save();
         }
     }
+
+    // KissenPaper start
+    @Override
+    public boolean isConnected() {
+        return false;
+    }
+
+    @Override
+    public @NotNull PaperPermissible getPermissible() throws PermissibleOverriddenException {
+        if (permissible instanceof PaperPermissible paperPermissible) {
+            return paperPermissible;
+        }
+        throw new PermissibleOverriddenException();
+    }
+
+    @Override
+    public boolean isPermissionSet(@NotNull String name) {
+        return permissible.isPermissionSet(name);
+    }
+
+    @Override
+    public boolean isPermissionSet(@NotNull Permission perm) {
+        return permissible.isPermissionSet(perm);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String name) {
+        return permissible.hasPermission(name);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull Permission perm) {
+        return permissible.hasPermission(perm);
+    }
+
+    @Override
+    public @NotNull PermissionAttachment addAttachment(@NotNull Plugin plugin, @NotNull String name, boolean value) {
+        throw new UnsupportedOperationException("Attachment cannot be added to an offline player.");
+    }
+
+    @Override
+    public @NotNull PermissionAttachment addAttachment(@NotNull Plugin plugin) {
+        throw new UnsupportedOperationException("Attachment cannot be added to an offline player.");
+    }
+
+    @Override
+    public @Nullable PermissionAttachment addAttachment(@NotNull Plugin plugin, @NotNull String name, boolean value, int ticks) {
+        throw new UnsupportedOperationException("Attachment cannot be added to an offline player.");
+    }
+
+    @Override
+    public @Nullable PermissionAttachment addAttachment(@NotNull Plugin plugin, int ticks) {
+        throw new UnsupportedOperationException("Attachment cannot be added to an offline player.");
+    }
+
+    @Override
+    public void removeAttachment(@NotNull PermissionAttachment attachment) {
+        throw new UnsupportedOperationException("Attachment cannot be added to an offline player.");
+    }
+
+    @Override
+    public void recalculatePermissions() {
+        //ignored
+    }
+
+    @Override
+    public @NotNull Set<PermissionAttachmentInfo> getEffectivePermissions() {
+        return permissible.getEffectivePermissions();
+    }
+    // KissenPaper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 249d76acac9a91cd46f0b8a477511974a75d6f4a..333738bac1b9b6625937e54909e12f12123e1d0b 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -44,6 +44,11 @@ import java.util.logging.Level;
 import java.util.logging.Logger;
 import java.util.stream.Collectors;
 import javax.imageio.ImageIO;
+
+import net.kissenpvp.core.base.KissenCore;
+import net.kissenpvp.core.message.KissenComponentSerializer;
+import net.kissenpvp.core.message.localization.KissenLocalizationImplementation;
+import net.kyori.adventure.text.Component;
 import net.minecraft.advancements.Advancement;
 import net.minecraft.commands.CommandSourceStack;
 import net.minecraft.commands.Commands;
@@ -548,7 +553,17 @@ public final class CraftServer implements Server {
 
         for (Plugin plugin : plugins) {
             if ((!plugin.isEnabled()) && (plugin.getDescription().getLoad() == type)) {
+                // KissenPaper start
+                KissenCore.getInstance()
+                        .getKissenImplementations()
+                        .forEach(kissenImplementation -> kissenImplementation.enable(plugin));
+                // KissenPaper end
                 this.enablePlugin(plugin);
+                // KissenPaper start
+                KissenCore.getInstance()
+                        .getKissenImplementations()
+                        .forEach(kissenImplementation -> kissenImplementation.postEnable(plugin));
+                // KissenPaper end
             }
         }
 
@@ -1008,10 +1023,21 @@ public final class CraftServer implements Server {
             return true;
         }
 
+        // KissenPaper start
+        KissenLocalizationImplementation localizationImplementation = KissenCore.getInstance()
+                .getImplementation(KissenLocalizationImplementation.class);
+        Component unknownCommandMessageComponent = localizationImplementation.translate("messages.unknown-command", localizationImplementation.getDefaultLocale());
+        if (sender instanceof Player player) {
+            unknownCommandMessageComponent = localizationImplementation.translate("messages.unknown-command", player.getCurrentLocale());
+        }
+        String unknownCommandMessage = KissenComponentSerializer.getInstance()
+                .getLegacySerializer()
+                .serialize(unknownCommandMessageComponent);
+        // Kissenpaper end
         // Spigot start
-        if (!org.spigotmc.SpigotConfig.unknownCommandMessage.isEmpty()) {
+        if (!/* KissenPaper */ unknownCommandMessage.isEmpty() /*org.spigotmc.SpigotConfig.unknownCommandMessage.isEmpty()*/) {
             // Paper start
-            org.bukkit.event.command.UnknownCommandEvent event = new org.bukkit.event.command.UnknownCommandEvent(sender, commandLine, net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(org.spigotmc.SpigotConfig.unknownCommandMessage));
+            org.bukkit.event.command.UnknownCommandEvent event = new org.bukkit.event.command.UnknownCommandEvent(sender, commandLine, net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize( /* KissenPaper */ unknownCommandMessage /* org.spigotmc.SpigotConfig.unknownCommandMessage */));
             Bukkit.getServer().getPluginManager().callEvent(event);
             if (event.message() != null) {
                 sender.sendMessage(event.message());
diff --git a/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java b/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java
index 4e56018b64d11f76c8da43fd8f85c6de72204e36..a33eec18be5845b269a48557d47aabba16e83ea2 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java
@@ -1,17 +1,22 @@
 package org.bukkit.craftbukkit.command;
 
 import java.util.UUID;
+
+import net.kissenpvp.core.networking.client.entity.KissenConsoleClient;
+import net.kyori.adventure.audience.Audience;
+import net.kyori.adventure.text.Component;
 import org.bukkit.ChatColor;
 import org.bukkit.command.ConsoleCommandSender;
 import org.bukkit.conversations.Conversation;
 import org.bukkit.conversations.ConversationAbandonedEvent;
 import org.bukkit.conversations.ManuallyAbandonedConversationCanceller;
 import org.bukkit.craftbukkit.conversations.ConversationTracker;
+import org.jetbrains.annotations.NotNull;
 
 /**
  * Represents CLI input from a console
  */
-public class CraftConsoleCommandSender extends ServerCommandSender implements ConsoleCommandSender {
+public class CraftConsoleCommandSender extends ServerCommandSender implements ConsoleCommandSender, /* KissenPaper */ KissenConsoleClient {
 
     protected final ConversationTracker conversationTracker = new ConversationTracker();
 
@@ -41,6 +46,13 @@ public class CraftConsoleCommandSender extends ServerCommandSender implements Co
         }
     }
 
+    // KissenPaper start
+    @Override
+    public @NotNull Audience getKyoriAudience() {
+        return this;
+    }
+    // KissenPaper end
+
     @Override
     public String getName() {
         return "CONSOLE";
@@ -103,5 +115,12 @@ public class CraftConsoleCommandSender extends ServerCommandSender implements Co
     public boolean hasPermission(org.bukkit.permissions.Permission perm) {
         return io.papermc.paper.configuration.GlobalConfiguration.get().console.hasAllPermissions || super.hasPermission(perm);
     }
+
+    // KissenPaper start
+    @Override
+    public @NotNull Component displayName() {
+        return Component.text(getName());
+    }
+    // KissenPaper end
     // Paper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
index 5fe9a0985432ac6cdd28a2a138854a24f10e42ba..85ba63cf14e591294b97b79751e6a47c43ad1f1a 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
@@ -7,6 +7,8 @@ import java.util.Arrays;
 import java.util.Collection;
 import java.util.Optional;
 import java.util.Set;
+
+import net.kissenpvp.paper.permission.KissenPaperPlayerPermissible;
 import net.minecraft.core.BlockPos;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.network.chat.Component;
@@ -62,16 +64,13 @@ import org.bukkit.inventory.ItemStack;
 import org.bukkit.inventory.MainHand;
 import org.bukkit.inventory.Merchant;
 import org.bukkit.inventory.PlayerInventory;
-import org.bukkit.permissions.PermissibleBase;
-import org.bukkit.permissions.Permission;
-import org.bukkit.permissions.PermissionAttachment;
-import org.bukkit.permissions.PermissionAttachmentInfo;
+import org.bukkit.permissions.*;
 import org.bukkit.plugin.Plugin;
 
 public class CraftHumanEntity extends CraftLivingEntity implements HumanEntity {
     private CraftInventoryPlayer inventory;
     private final CraftInventory enderChest;
-    protected final PermissibleBase perm = new PermissibleBase(this);
+    protected final Permissible perm = new KissenPaperPlayerPermissible(this); // KissenPaper
     private boolean op;
     private GameMode mode;
 
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 5bbded65095dccfadaf7576fc41b5f62974878b4..27a98fb8ec63a7db6b9574a3999f942f9d38ce38 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -7,6 +7,7 @@ import com.google.common.io.BaseEncoding;
 import com.mojang.authlib.GameProfile;
 import com.mojang.datafixers.util.Pair;
 import io.netty.buffer.Unpooled;
+import io.netty.channel.Channel;
 import it.unimi.dsi.fastutil.shorts.ShortArraySet;
 import it.unimi.dsi.fastutil.shorts.ShortSet;
 import java.io.ByteArrayOutputStream;
@@ -32,6 +33,15 @@ import java.util.WeakHashMap;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import javax.annotation.Nullable;
+
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.base.KissenCore;
+import net.kissenpvp.core.user.KissenUserImplementation;
+import net.kissenpvp.paper.api.permission.PaperPermissible;
+import net.kissenpvp.paper.api.permission.PermissibleOverriddenException;
+import net.kissenpvp.paper.networking.client.entity.KissenPaperOnlinePlayerClient;
+import net.kyori.adventure.audience.Audience;
 import net.minecraft.advancements.AdvancementProgress;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Holder;
@@ -176,7 +186,7 @@ import org.jetbrains.annotations.NotNull;
 import net.md_5.bungee.api.chat.BaseComponent; // Spigot
 
 @DelegateDeserialization(CraftOfflinePlayer.class)
-public class CraftPlayer extends CraftHumanEntity implements Player {
+public class CraftPlayer extends CraftHumanEntity implements Player, KissenPaperOnlinePlayerClient {
     private long firstPlayed = 0;
     private long lastPlayed = 0;
     private boolean hasPlayedBefore = false;
@@ -351,6 +361,13 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         }
     }
 
+    // KissenPaper start
+    @Override
+    public @NotNull Audience getKyoriAudience() {
+        return this;
+    }
+    // KissenPaper end
+
     // Paper start
     @Override
     @Deprecated
@@ -609,6 +626,18 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         }
     }
 
+    // KissenPaper start
+    @Override
+    public @NotNull Channel getConnection() {
+        return getHandle().connection.connection.channel;
+    }
+
+    @Override
+    public void sendPacket(Object o) {
+        getHandle().connection.connection.send((Packet<?>) o);
+    }
+    // KissenPaper end
+
     @Override
     public <T> T getClientOption(com.destroystokyo.paper.ClientOption<T> type) {
         if (com.destroystokyo.paper.ClientOption.SKIN_PARTS == type) {
@@ -2351,7 +2380,10 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     public void disconnect(String reason) {
         this.conversationTracker.abandonAllConversations();
-        perm.clearPermissions();
+        //TODO unsubscribe
+        // KissenPaper start
+        KissenCore.getInstance().getImplementation(KissenUserImplementation.class).logoutUser(getUser());
+        // KissenPaper end
     }
 
     @Override
@@ -2696,8 +2728,8 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     // Paper start
     @Override
-    public java.util.Locale locale() {
-        return getHandle().adventure$locale;
+    public /* KissenPaper - NotNull */ java.util.@NotNull   Locale locale() {
+        return /* getHandle().adventure$locale */ getCurrentLocale(); // KissenPaper
     }
     // Paper end
     @Override
@@ -2708,8 +2740,11 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     @Override
     public String getLocale() {
         // Paper start - Locale change event
-        final String locale = this.getHandle().locale;
-        return locale != null ? locale : "en_us";
+        // KissenPaper start
+        return this.getCurrentLocale().toString();
+        // KissenPaper end
+        /*final String locale = this.getHandle().locale;
+        return locale != null ? locale : "en_us";*/
         // Paper end
     }
 
@@ -3022,7 +3057,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     @Override
     public void openBook(final net.kyori.adventure.inventory.Book book) {
-        final java.util.Locale locale = this.getHandle().adventure$locale;
+        final java.util.Locale locale = /*this.getHandle().adventure$locale;*/ getCurrentLocale(); // KissenPaper
         final net.minecraft.world.item.ItemStack item = io.papermc.paper.adventure.PaperAdventure.asItemStack(book, locale);
         final ServerPlayer player = this.getHandle();
         final ServerGamePacketListenerImpl connection = player.connection;
@@ -3212,4 +3247,24 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         return this.spigot;
     }
     // Spigot end
+
+    // KissenPaper start
+    @Override
+    public @NotNull PaperPermissible getPermissible() throws PermissibleOverriddenException {
+        if (perm instanceof PaperPermissible permissible) {
+            return permissible;
+        }
+        System.out.println(perm.getClass().getName());
+        throw new PermissibleOverriddenException();
+    }
+
+    @Override
+    public @NotNull User getUser() {
+        return Bukkit.getKissen()
+                .getImplementation(UserImplementation.class)
+                .getOnlineUser(getUniqueId())
+                .orElseThrow(IllegalStateException::new);
+    }
+
+    // KissenPaper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/scheduler/MinecraftInternalPlugin.java b/src/main/java/org/bukkit/craftbukkit/scheduler/MinecraftInternalPlugin.java
index d96399e9bf1a58db5a4a22e58abb99e7660e0694..4d461918983c1ca0b538d50826bd41f441542a1f 100644
--- a/src/main/java/org/bukkit/craftbukkit/scheduler/MinecraftInternalPlugin.java
+++ b/src/main/java/org/bukkit/craftbukkit/scheduler/MinecraftInternalPlugin.java
@@ -1,6 +1,9 @@
 package org.bukkit.craftbukkit.scheduler;
 
 
+import net.kissenpvp.core.api.base.Kissen;
+import net.kissenpvp.core.message.localization.KissenLocalizationImplementation;
+import org.bukkit.Bukkit;
 import org.bukkit.Server;
 import org.bukkit.command.Command;
 import org.bukkit.command.CommandSender;
@@ -16,6 +19,7 @@ import org.jetbrains.annotations.Nullable;
 
 import java.io.File;
 import java.io.InputStream;
+import java.text.MessageFormat;
 import java.util.List;
 
 public class MinecraftInternalPlugin extends PluginBase {
@@ -38,6 +42,19 @@ public class MinecraftInternalPlugin extends PluginBase {
         throw new UnsupportedOperationException("Not supported.");
     }
 
+    // KissenPaper start
+    @Override
+    public @NotNull Kissen getKissen() {
+        return Bukkit.getKissen();
+    }
+
+    @Override
+    public void registerTranslation(@NotNull String s, @NotNull MessageFormat messageFormat) {
+        getKissen().getImplementation(KissenLocalizationImplementation.class)
+                .register(this, s, messageFormat);
+    }
+    // KissenPaper end
+
     @Override
     public PluginDescriptionFile getDescription() {
         return pdf;
@@ -104,6 +121,18 @@ public class MinecraftInternalPlugin extends PluginBase {
         throw new UnsupportedOperationException("Not supported.");
     }
 
+    // KissenPaper start
+    @Override
+    public @NotNull String getFullName() {
+        return "Minecraft";
+    }
+
+    @Override
+    public @NotNull String getPackage() {
+        return "net.kissenpvp";
+    }
+    // KissenPaper end
+
     @Override
     public void onLoad() {
         throw new UnsupportedOperationException("Not supported.");
diff --git a/src/main/java/org/spigotmc/SpigotConfig.java b/src/main/java/org/spigotmc/SpigotConfig.java
index 612c3169c3463d702b85975e1db79ae6e47d60d0..798627de98b71ef1e87738b02132dd8bf1135aa1 100644
--- a/src/main/java/org/spigotmc/SpigotConfig.java
+++ b/src/main/java/org/spigotmc/SpigotConfig.java
@@ -6,6 +6,7 @@ import java.io.IOException;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
+import java.text.MessageFormat;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -13,6 +14,9 @@ import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.logging.Level;
+
+import net.kissenpvp.core.base.KissenCore;
+import net.kissenpvp.core.message.localization.KissenLocalizationImplementation;
 import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.MinecraftServer;
@@ -194,9 +198,6 @@ public class SpigotConfig
         SpigotConfig.sendNamespaced = SpigotConfig.getBoolean( "commands.send-namespaced", true );
     }
 
-    public static String whitelistMessage;
-    public static String unknownCommandMessage;
-    public static String serverFullMessage;
     public static String outdatedClientMessage = "Outdated client! Please use {0}";
     public static String outdatedServerMessage = "Outdated server! I\'m still on {0}";
     private static String transform(String s)
@@ -211,9 +212,17 @@ public class SpigotConfig
             SpigotConfig.set( "messages.outdated-server", SpigotConfig.outdatedServerMessage );
         }
 
-        SpigotConfig.whitelistMessage = SpigotConfig.transform( SpigotConfig.getString( "messages.whitelist", "You are not whitelisted on this server!" ) );
-        SpigotConfig.unknownCommandMessage = SpigotConfig.transform( SpigotConfig.getString( "messages.unknown-command", "Unknown command. Type \"/help\" for help." ) );
-        SpigotConfig.serverFullMessage = SpigotConfig.transform( SpigotConfig.getString( "messages.server-full", "The server is full!" ) );
+        // KissenPaper start
+        KissenLocalizationImplementation kissenLocalizationImplementation = KissenCore.getInstance()
+                .getImplementation(KissenLocalizationImplementation.class);
+
+        kissenLocalizationImplementation.register("messages.whitelist", new MessageFormat("You are not whitelisted on this server!"));
+        kissenLocalizationImplementation.register("messages.unknown-command", new MessageFormat("Unknown command. Type \"/help\" for help."));
+        kissenLocalizationImplementation.register("messages.server-full", new MessageFormat("The server is full!"));
+        kissenLocalizationImplementation.register("messages.outdated-client", new MessageFormat(SpigotConfig.outdatedClientMessage));
+        kissenLocalizationImplementation.register("messages.outdated-server", new MessageFormat(SpigotConfig.outdatedServerMessage));
+        // KissenPaper end
+
         SpigotConfig.outdatedClientMessage = SpigotConfig.transform( SpigotConfig.getString( "messages.outdated-client", SpigotConfig.outdatedClientMessage ) );
         SpigotConfig.outdatedServerMessage = SpigotConfig.transform( SpigotConfig.getString( "messages.outdated-server", SpigotConfig.outdatedServerMessage ) );
     }
diff --git a/src/test/java/io/papermc/paper/plugin/PaperTestPlugin.java b/src/test/java/io/papermc/paper/plugin/PaperTestPlugin.java
index 1d14f530ef888102e47eeeaf0d1a6076e51871c4..bb12019415aa94e0493dd697ef15227de9660df2 100644
--- a/src/test/java/io/papermc/paper/plugin/PaperTestPlugin.java
+++ b/src/test/java/io/papermc/paper/plugin/PaperTestPlugin.java
@@ -1,6 +1,8 @@
 package io.papermc.paper.plugin;
 
 import io.papermc.paper.plugin.configuration.PluginMeta;
+import net.kissenpvp.core.api.base.Kissen;
+import org.bukkit.Bukkit;
 import org.bukkit.Server;
 import org.bukkit.command.Command;
 import org.bukkit.command.CommandSender;
@@ -11,9 +13,11 @@ import org.bukkit.plugin.PluginBase;
 import org.bukkit.plugin.PluginDescriptionFile;
 import org.bukkit.plugin.PluginLoader;
 import org.bukkit.plugin.PluginLogger;
+import org.jetbrains.annotations.NotNull;
 
 import java.io.File;
 import java.io.InputStream;
+import java.text.MessageFormat;
 import java.util.List;
 
 public class PaperTestPlugin extends PluginBase {
@@ -36,6 +40,18 @@ public class PaperTestPlugin extends PluginBase {
         throw new UnsupportedOperationException("Not supported.");
     }
 
+    // KissenPaper start
+    @Override
+    public @NotNull Kissen getKissen() {
+        return Bukkit.getKissen();
+    }
+
+    @Override
+    public void registerTranslation(@NotNull String s, @NotNull MessageFormat messageFormat) {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+    // KissenPaper end
+
     @Override
     public PluginDescriptionFile getDescription() {
         throw new UnsupportedOperationException("Not supported.");
@@ -105,6 +121,18 @@ public class PaperTestPlugin extends PluginBase {
         throw new UnsupportedOperationException("Not supported.");
     }
 
+    // KissenPaper start
+    @Override
+    public @NotNull String getFullName() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public @NotNull String getPackage() {
+        return "net.kissenpvp";
+    }
+    // KissenPaper end
+
     @Override
     public void onLoad() {
     }
