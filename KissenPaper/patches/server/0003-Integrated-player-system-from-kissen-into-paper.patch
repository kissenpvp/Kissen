From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Groldi <chniucg@gmail.com>
Date: Fri, 15 Sep 2023 22:45:32 +0200
Subject: [PATCH] Integrated player system from kissen into paper


diff --git a/src/main/java/com/destroystokyo/paper/profile/CraftPlayerProfile.java b/src/main/java/com/destroystokyo/paper/profile/CraftPlayerProfile.java
index daa157eaa021d039f9a092bea0b78f7c1f746e3b..2445edc12487678c2db1f6b274f95a77eb4663c1 100644
--- a/src/main/java/com/destroystokyo/paper/profile/CraftPlayerProfile.java
+++ b/src/main/java/com/destroystokyo/paper/profile/CraftPlayerProfile.java
@@ -31,6 +31,10 @@ public class CraftPlayerProfile implements PlayerProfile, SharedPlayerProfile {
     private GameProfile profile;
     private final PropertySet properties = new PropertySet();
 
+    // KissenPaper start
+    private net.kissenpvp.core.api.user.User cached;
+    // KissenPaper end
+
     public CraftPlayerProfile(CraftPlayer player) {
         this.profile = player.getHandle().getGameProfile();
     }
@@ -406,4 +410,12 @@ public class CraftPlayerProfile implements PlayerProfile, SharedPlayerProfile {
             }
         }
     }
+
+    // KissenPaper start
+    @Override
+    public @org.jetbrains.annotations.NotNull net.kissenpvp.core.api.user.User getUser()
+    {
+        return org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.user.UserImplementation.class).getUser(java.util.Objects.requireNonNull(getId()));
+    }
+    // KissenPaper end
 }
diff --git a/src/main/java/net/kissenpvp/paper/ban/command/PaperPunishmentParser.java b/src/main/java/net/kissenpvp/paper/ban/command/PaperPunishmentParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..55167ae5fef79f24545df34479443dbb74399a57
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/ban/command/PaperPunishmentParser.java
@@ -0,0 +1,19 @@
+package net.kissenpvp.paper.ban.command;
+
+import net.kissenpvp.paper.api.ban.PaperPunishment;
+import net.kissenpvp.paper.api.command.PaperArgumentParser;
+import org.jetbrains.annotations.NotNull;
+
+public class PaperPunishmentParser implements PaperArgumentParser<PaperPunishment>
+{
+    @Override public @NotNull String serialize(@NotNull PaperPunishment object)
+    {
+        return object.getID();
+    }
+
+    @Override public @NotNull PaperPunishment deserialize(@NotNull String input)
+    {
+        //TODO
+        return null;
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/base/KissenPaperCore.java b/src/main/java/net/kissenpvp/paper/base/KissenPaperCore.java
index cf608a90d188c853d72326b7763995f9fa72a3e4..9f054b22f0f1a8f82402f8544ed14c67d6222159 100644
--- a/src/main/java/net/kissenpvp/paper/base/KissenPaperCore.java
+++ b/src/main/java/net/kissenpvp/paper/base/KissenPaperCore.java
@@ -21,8 +21,15 @@ package net.kissenpvp.paper.base;
 import net.kissenpvp.core.api.base.Implementation;
 import net.kissenpvp.core.api.database.meta.ObjectMeta;
 import net.kissenpvp.core.api.networking.client.entitiy.ConsoleClient;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.api.user.rank.RankImplementation;
 import net.kissenpvp.core.base.KissenCore;
+import net.kissenpvp.core.permission.PermissionImplementation;
 import net.kissenpvp.paper.api.base.PaperKissen;
+import net.kissenpvp.paper.api.permission.PaperPermissionImplementation;
+import net.kissenpvp.paper.permission.KissenPaperPermissionImplementation;
+import net.kissenpvp.paper.user.KissenPaperUserImplementation;
+import net.kissenpvp.paper.user.rank.KissenPaperRankImplementation;
 import org.bukkit.Bukkit;
 import org.jetbrains.annotations.NotNull;
 import org.slf4j.Logger;
@@ -45,6 +52,12 @@ public class KissenPaperCore extends KissenCore implements PaperKissen {
     @Override
     protected void loadImplementations(@NotNull Map<Class<? extends Implementation>, Implementation> loader)
     {
+        loader.put(UserImplementation.class, new KissenPaperUserImplementation());
+        loader.put(RankImplementation.class, new KissenPaperRankImplementation());
+        KissenPaperPermissionImplementation permissionImplementation = new KissenPaperPermissionImplementation();
+        loader.put(PermissionImplementation.class, permissionImplementation);
+        loader.put(PaperPermissionImplementation.class, permissionImplementation);
+
         super.loadImplementations(loader);
     }
 
diff --git a/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperOnlinePlayerClient.java b/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperOnlinePlayerClient.java
new file mode 100644
index 0000000000000000000000000000000000000000..24dc0f73925de7b7353c9db5c2d3dc0f4d4fa67d
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperOnlinePlayerClient.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.networking.client.entity;
+
+import io.netty.channel.Channel;
+import net.kissenpvp.core.api.ban.Ban;
+import net.kissenpvp.core.api.base.KissenServer;
+import net.kissenpvp.core.api.networking.client.entitiy.ServerEntity;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.networking.client.entity.PaperOnlinePlayerClient;
+import net.kyori.adventure.audience.Audience;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.minimessage.MiniMessage;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Map;
+
+public abstract class KissenPaperOnlinePlayerClient extends KissenPaperPlayerClient implements PaperOnlinePlayerClient {
+
+    public abstract @NotNull CraftPlayer getCraftPlayer();
+
+    // Only methods based in CraftPlayer due to permission subscription
+    @Override
+    public @NotNull User getUser() {
+        return getCraftPlayer().getUser();
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull Context context) {
+        return getCraftPlayer().getUser(context);
+    }
+    //
+
+    @Override
+    public final boolean isConnected() {
+        return true;
+    }
+
+    @Override
+    public void kick(@NotNull String message) {
+        kick(MiniMessage.miniMessage().deserialize(message));
+    }
+
+    @Override
+    public void kick(@NotNull Component component) {
+        getCraftPlayer().kick(component);
+    }
+
+    @Override
+    public void killConnection() {
+        getConnection().close();
+    }
+
+    @Override
+    public @NotNull Channel getConnection() {
+        return getCraftPlayer().getHandle().connection.connection.channel;
+    }
+
+    @Override
+    public void sendPacket(@NotNull Object object) throws ClassCastException {
+        getCraftPlayer().getHandle().connection.send((Packet<?>) object);
+    }
+
+    @Override
+    public @Nullable KissenServer getCurrentServer() {
+        return MinecraftServer.getServer();
+    }
+
+    @Override
+    public @NotNull Audience getKyoriAudience() {
+        return getCraftPlayer();
+    }
+
+    @Override
+    public int warn(@NotNull Ban ban, @NotNull ServerEntity warnOperator) {
+        return warn(ban, warnOperator, null);
+    }
+
+    @Override
+    public int warn(@NotNull Ban ban, @NotNull ServerEntity warnOperator, @Nullable Component reason) {
+        Map<String, Object> storage = getUser().getStorage();
+        int warnCount = 1;
+        if (storage.containsKey("warn_count")) {
+            warnCount = (int) storage.get("warn_count") + 1;
+        }
+
+        storage.put("warn_count", warnCount);
+        getCraftPlayer().sendMessage("You were warned yk");
+
+        return warnCount;
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperPlayerClient.java b/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperPlayerClient.java
new file mode 100644
index 0000000000000000000000000000000000000000..a73d2a335e03cb38a4214814cd08a3eed6be32e4
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperPlayerClient.java
@@ -0,0 +1,153 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.networking.client.entity;
+
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.api.user.suffix.Suffix;
+import net.kissenpvp.core.database.DataWriter;
+import net.kissenpvp.core.networking.client.entity.KissenPlayerClient;
+import net.kissenpvp.core.user.rank.KissenPlayerRankNode;
+import net.kissenpvp.paper.api.ban.PaperPunishment;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.networking.client.entity.PaperOnlinePlayerClient;
+import net.kissenpvp.paper.api.networking.client.entity.PaperPlayerClient;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PermissibleOverriddenException;
+import net.kissenpvp.paper.api.user.rank.PaperPlayerRank;
+import net.kissenpvp.paper.permission.permissible.KissenPaperPermissible;
+import net.kissenpvp.paper.user.KissenPaperPublicUser;
+import net.kissenpvp.paper.user.rank.KissenPaperPlayerFallBackRank;
+import net.kissenpvp.paper.user.rank.KissenPaperPlayerRank;
+import net.kyori.adventure.text.Component;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.HashSet;
+import java.util.Optional;
+import java.util.Set;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public abstract class KissenPaperPlayerClient extends KissenPlayerClient<PaperPermission, PaperPlayerRank, PaperPunishment> implements PaperPlayerClient {
+
+    @Override
+    public @NotNull User getUser() {
+        return Bukkit.getKissen()
+                .getImplementation(UserImplementation.class)
+                .getUser(getUniqueId());
+    }
+
+    @Override
+    protected @NotNull PaperPlayerRank translateRank(@NotNull KissenPlayerRankNode kissenPlayerRankNode, @Nullable DataWriter dataWriter) {
+        return new KissenPaperPlayerRank(kissenPlayerRankNode, dataWriter);
+    }
+
+    @Override
+    protected @NotNull PaperPlayerRank fallbackRank() {
+        return new KissenPaperPlayerFallBackRank();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<@NotNull PaperOnlinePlayerClient> getOnlineAltAccounts() {
+        return Bukkit.getOnlinePlayers().stream().filter(client -> client.getTotalID().equals(getTotalID())).collect(Collectors.toSet());
+    }
+
+    @Override
+    public @NotNull Set<Suffix> getSuffixSet() {
+        return Stream.concat(getSuffixSet(Context.LOCAL).stream(), getSuffixSet(Context.GLOBAL).stream()).collect(Collectors.toSet());
+    }
+
+    @Override
+    public @NotNull Set<Suffix> getSuffixSet(@NotNull Context context) {
+        //TODO
+        return new HashSet<>();
+    }
+
+    @Override
+    public @NotNull Optional<Suffix> getSuffix(@NotNull String name) {
+        return getSuffix(name, Context.LOCAL).or(() -> super.getSuffix(name));
+    }
+
+    @Override
+    public @NotNull Optional<Suffix> getSuffix(@NotNull String name, @NotNull Context context) {
+        return Optional.empty(); //TODO
+    }
+
+
+    @Override
+    public @NotNull Optional<Suffix> setSuffix(@NotNull String name, @NotNull Component content) {
+        return setSuffix(name, content, Context.LOCAL);
+    }
+
+    @Override
+    public @NotNull Optional<Suffix> setSuffix(@NotNull String name, @NotNull Component content, @NotNull Context context) {
+        return Optional.empty(); //TODO
+    }
+
+    @Override
+    public boolean deleteSuffix(@NotNull String name) {
+        return getSuffix(name, Context.LOCAL).map((suffix) -> deleteSuffix(name, Context.LOCAL)).orElse(false) || super.deleteSuffix(name);
+    }
+
+    @Override
+    public boolean deleteSuffix(@NotNull String name, @NotNull Context context) {
+        return false; //TODO
+    }
+
+    @Override
+    public void setSelectedSuffix(@NotNull String name) throws NullPointerException {
+        setSelectedSuffix(name, Context.LOCAL);
+    }
+
+    @Override
+    public void setSelectedSuffix(@NotNull String name, @NotNull Context context) throws NullPointerException {
+        //TODO
+    }
+
+    @Override
+    public long getOnlineTime() {
+        return getOnlineTime(Context.LOCAL);
+    }
+
+    @Override
+    public long getOnlineTime(@NotNull Context context) {
+        return getOnlineTime(getUser(context));
+    }
+
+    @Override
+    public long getLastPlayed(@NotNull Context context) {
+        return getLastPlayed(getUser(context));
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull Context context) {
+        KissenPaperPublicUser kissenPublicUser = (KissenPaperPublicUser) getUser();
+        return switch (context) {
+            case GLOBAL -> kissenPublicUser;
+            case LOCAL -> kissenPublicUser.getPrivateUserEntry();
+        };
+    }
+
+    public @NotNull KissenPaperPermissible getPermissionContext() throws PermissibleOverriddenException {
+        return (KissenPaperPermissible) getPermissible();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/KissenPaperAttachmentPermission.java b/src/main/java/net/kissenpvp/paper/permission/KissenPaperAttachmentPermission.java
new file mode 100644
index 0000000000000000000000000000000000000000..b09c3c75fd962ed7aab8f694f4bea263146005c4
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/KissenPaperAttachmentPermission.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission;
+
+import net.kissenpvp.core.api.permission.Permission;
+import net.kissenpvp.core.api.permission.PermissionEntry;
+import net.kissenpvp.core.permission.KissenPermissionNode;
+import net.kissenpvp.core.time.TemporalMeasureNode;
+import org.bukkit.permissions.PermissionAttachment;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class KissenPaperAttachmentPermission extends KissenPaperPermission {
+
+    private final PermissionAttachment permissionAttachment;
+
+    public KissenPaperAttachmentPermission(@NotNull String permission, boolean value, @NotNull PermissionEntry<? extends Permission> permissionEntry, boolean immutable) {
+        this(null, permission, value, permissionEntry, immutable);
+    }
+
+    public KissenPaperAttachmentPermission(@Nullable PermissionAttachment permissionAttachment, @NotNull String permission, boolean value, @NotNull PermissionEntry<? extends Permission> permissionEntry, boolean immutable) {
+        super(new KissenPermissionNode(permission, permissionEntry, value, new TemporalMeasureNode()), permissionEntry, immutable ? null : (record) -> { /* ignored */ });
+        this.permissionAttachment = permissionAttachment;
+    }
+
+    public PermissionAttachment getPermissionAttachment() {
+        return permissionAttachment;
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/KissenPaperGroupablePermissionEntry.java b/src/main/java/net/kissenpvp/paper/permission/KissenPaperGroupablePermissionEntry.java
new file mode 100644
index 0000000000000000000000000000000000000000..2186aa7ee79dc881d5b15f11fa914f7b3a0cb299
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/KissenPaperGroupablePermissionEntry.java
@@ -0,0 +1,160 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission;
+
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.permission.GroupablePermissionEntry;
+import net.kissenpvp.core.api.permission.PermissionGroup;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.PaperGroubablePermissionEntry;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Optional;
+import java.util.Set;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public abstract class KissenPaperGroupablePermissionEntry implements PaperGroubablePermissionEntry {
+
+    @Override
+    public int wipePermissions() {
+        return getPermissionEntry(Context.LOCAL).wipePermissions() + getPermissionEntry(Context.GLOBAL).wipePermissions();
+    }
+
+    @Override
+    public int wipeGroups() {
+        return getPermissionEntry(Context.LOCAL).wipeGroups() + getPermissionEntry(Context.GLOBAL).wipeGroups();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getOwnPermissions() {
+        return Stream.concat(getPermissionEntry(Context.LOCAL).getOwnPermissions().stream(), getPermissionEntry(Context.GLOBAL).getOwnPermissions().stream()).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    @NotNull
+    public Set<PaperPermission> getOwnPermissions(@NotNull Context context) {
+        return getPermissionEntry(context).getOwnPermissions();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups() {
+        return Stream.concat(getPermissionEntry(Context.LOCAL).getPermissionGroups().stream(), getPermissionEntry(Context.GLOBAL).getPermissionGroups().stream()).collect(Collectors.toUnmodifiableSet()); //TODO
+    }
+
+
+    @Override
+    @NotNull
+    public Set<PermissionGroup<PaperPermission>> getPermissionGroups(@NotNull Context context) {
+        return getPermissionEntry(context).getPermissionGroups();
+    }
+
+    @Override
+    public boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup) {
+        return getPermissionEntry(Context.LOCAL).inGroup(permissionGroup) || getPermissionEntry(Context.GLOBAL).inGroup(permissionGroup);
+    }
+
+    @Override
+    public boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup, @NotNull Context context) {
+        return getPermissionEntry(context).inGroup(permissionGroup);
+    }
+
+    @Override
+    @NotNull
+    public PaperPermission setPermission(@NotNull String s) throws EventCancelledException {
+        return setPermission(s, Context.LOCAL);
+    }
+
+    @Override
+    @NotNull
+    public PaperPermission setPermission(@NotNull String permission, @NotNull Context context) throws EventCancelledException {
+        return getPermissionEntry(context).setPermission(permission);
+    }
+
+    @Override
+    @NotNull
+    public PaperPermission setPermission(@NotNull String s, boolean b) throws EventCancelledException {
+        return setPermission(s, b, Context.LOCAL);
+    }
+
+    @Override
+    @NotNull
+    public PaperPermission setPermission(@NotNull String permission, boolean value, @NotNull Context context) throws EventCancelledException {
+        return getPermissionEntry(context).setPermission(permission, value);
+    }
+
+    @Override
+    @NotNull
+    public PaperPermission setPermission(@NotNull PaperPermission paperPermission) throws EventCancelledException {
+        return setPermission(paperPermission, Context.LOCAL);
+    }
+
+    @Override
+    @NotNull
+    public PaperPermission setPermission(@NotNull PaperPermission permission, @NotNull Context context) throws EventCancelledException {
+        return getPermissionEntry(context).setPermission(permission);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String s) {
+        return unsetPermission(s, Context.LOCAL) || unsetPermission(s, Context.GLOBAL);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission, @NotNull Context context) {
+        return getPermissionEntry(context).unsetPermission(permission);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList() {
+        return getPermissionList(Context.GLOBAL);
+    }
+
+    @Override
+    @NotNull
+    @Unmodifiable
+    public Set<PaperPermission> getPermissionList(@NotNull Context context) {
+        return getPermissionEntry(context).getPermissionList();
+    }
+
+    @Override
+    public @NotNull Optional<PaperPermission> getPermission(@NotNull String permission) {
+        return getPermission(permission, Context.LOCAL).or(() -> getPermission(permission, Context.GLOBAL));
+    }
+
+    @Override
+    @NotNull
+    public Optional<PaperPermission> getPermission(@NotNull String permission, @NotNull Context context) {
+        return getPermissionEntry(context).getPermission(permission);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String s) {
+        return isOp() /*|| hasPermission(s, Context.LOCAL)*/ || hasPermission(s, Context.GLOBAL);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String permission, @NotNull Context context) {
+        return getPermissionEntry(context).hasPermission(permission);
+    }
+
+    @NotNull public abstract GroupablePermissionEntry<PaperPermission> getPermissionEntry(@NotNull Context context);
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermission.java b/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermission.java
new file mode 100644
index 0000000000000000000000000000000000000000..7a22a03f4c65ff2c5cb8d8362802c26f3e32a5ff
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermission.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission;
+
+import net.kissenpvp.core.api.permission.Permission;
+import net.kissenpvp.core.api.permission.PermissionEntry;
+import net.kissenpvp.core.database.DataWriter;
+import net.kissenpvp.core.permission.KissenPermission;
+import net.kissenpvp.core.permission.KissenPermissionNode;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class KissenPaperPermission extends KissenPermission implements PaperPermission {
+    public KissenPaperPermission(@NotNull KissenPermissionNode kissenPermissionNode, @NotNull PermissionEntry<? extends Permission> permissionEntry, @Nullable DataWriter dataWriter) {
+        super(kissenPermissionNode, permissionEntry, dataWriter);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermissionImplementation.java b/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermissionImplementation.java
new file mode 100644
index 0000000000000000000000000000000000000000..4a99737311bfa497edfcec80c701f7710cb81612
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermissionImplementation.java
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission;
+
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.database.meta.ObjectMeta;
+import net.kissenpvp.core.api.database.savable.SavableMap;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.event.EventImplementation;
+import net.kissenpvp.core.api.permission.PermissionGroup;
+import net.kissenpvp.core.base.KissenImplementation;
+import net.kissenpvp.core.permission.PermissionImplementation;
+import net.kissenpvp.core.permission.event.KissenPermissionGroupCreateEvent;
+import net.kissenpvp.core.permission.event.KissenPermissionGroupCreatedEvent;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.PaperPermissionGroup;
+import net.kissenpvp.paper.api.permission.PaperPermissionImplementation;
+import net.kissenpvp.paper.command.KissenPaperCommandImplementation;
+import net.kissenpvp.paper.message.localization.KissenPaperLocalizationImplementation;
+import net.kissenpvp.paper.permission.group.KissenPaperPermissionGroup;
+import net.kissenpvp.paper.permission.group.KissenPaperPublicPermissionGroup;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.text.MessageFormat;
+import java.util.*;
+
+public class KissenPaperPermissionImplementation implements PaperPermissionImplementation, PermissionImplementation, KissenImplementation {
+
+    private final Set<PaperPermissionGroup> cachedGroups;
+
+    public KissenPaperPermissionImplementation() {
+        this.cachedGroups = new HashSet<>();
+    }
+
+    @Override
+    public boolean start()
+    {
+        String prefix ="The permission entry {0}";
+        KissenPaperLocalizationImplementation localize = Bukkit.getKissen().getImplementation(
+                KissenPaperLocalizationImplementation.class);
+        localize.register("server.permission.set.success", new MessageFormat(prefix + " was successfully set {1} to {2}."));
+        localize.register("server.permission.set.failed", new MessageFormat(prefix + " has already set {1} to {2}."));
+        localize.register("server.permission.group.failed", new MessageFormat(prefix + " is already in this state within the relation to group {1}."));
+        localize.register("server.permission.group.success", new MessageFormat(prefix + " has been set to the state."));
+        localize.register("server.permission.unset.success", new MessageFormat("The permission {1} from the permission entry {0} was successfully unset."));
+        localize.register("server.permission.entity.failed", new MessageFormat(prefix + " does not have the permission {1}."));
+
+        localize.register("server.permission.info.compact", new MessageFormat("[{0}] [{1}] {2}"));
+
+        localize.register("server.permission.owner", new MessageFormat("Owner"));
+        localize.register("server.permission.info.clear", new MessageFormat(prefix + " has no permissions."));
+
+
+
+        return PaperPermissionImplementation.super.start();
+    }
+
+    @Override
+    public boolean postStart()
+    {
+        ObjectMeta publicMeta = Bukkit.getKissen().getPublicMeta();
+        publicMeta.getData(new KissenPaperPublicPermissionGroup()).thenAccept(maps ->
+        {
+            for(SavableMap map : maps.values())
+            {
+                KissenPaperPublicPermissionGroup kissenPaperPublicPermissionGroup = new KissenPaperPublicPermissionGroup();
+                kissenPaperPublicPermissionGroup.setup(map.getNotNull("id"), map);
+                kissenPaperPublicPermissionGroup.getPrivatePermissionGroup(); // cache private group
+                cachedGroups.add(new KissenPaperPermissionGroup(kissenPaperPublicPermissionGroup));
+            }
+            Bukkit.getKissen().getLogger().info("Successfully loaded {} permission group(s) from the database.", cachedGroups.size());
+        });
+
+        return PaperPermissionImplementation.super.postStart();
+    }
+
+    @Override
+    public void setupComplete()
+    {
+        Class<KissenPaperCommandImplementation> clazz = KissenPaperCommandImplementation.class;
+        KissenPaperCommandImplementation command = Bukkit.getKissen().getImplementation(clazz);
+        command.registerParser(PaperPermissionGroup.class, new PaperPermissionGroupParser());
+        command.registerParser(PermissionParser.PermissionArgument.class, new PermissionParser());
+        command.registerCommand(new PermissionCommand());
+        KissenImplementation.super.setupComplete();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermissionGroup> getGroups()
+    {
+        return Collections.unmodifiableSet(cachedGroups);
+    }
+
+    @Override
+    public @NotNull Optional<PermissionGroup<?>> getPermissionGroupSavable(@NotNull String name) {
+        return getGroup(name).map(group -> group.getContext(Context.GLOBAL));
+    }
+
+    @Override
+    public void removePermissionGroup(@NotNull String name) {
+        cachedGroups.removeIf(group -> group.getPermissionID().equals(name));
+    }
+
+    @Override
+    public @NotNull Optional<PaperPermissionGroup> getGroup(@NotNull String group)
+    {
+        return getGroups().stream().filter(currentGroup -> currentGroup.getPermissionID().equals(group)).findFirst();
+    }
+
+    @Override
+    public @NotNull PaperPermissionGroup getGroupNotNull(@NotNull String group) throws EventCancelledException
+    {
+        return getGroup(group).orElseGet(() -> create(group, null));
+    }
+
+
+    @Override
+    public @NotNull PaperPermissionGroup create(@NotNull String name, @Nullable Map<String, String> data) throws EventCancelledException
+    {
+        KissenPermissionGroupCreateEvent kissenPermissionGroupCreateEvent = new KissenPermissionGroupCreateEvent(name, data);
+        if (Bukkit.getKissen().getImplementation(EventImplementation.class).call(kissenPermissionGroupCreateEvent)) {
+            return (PaperPermissionGroup) this.createInternal(name, data);
+        }
+        throw new EventCancelledException();
+    }
+
+    public @NotNull PermissionGroup<?> createInternal(@NotNull String name, @Nullable Map<String, String> data)
+    {
+        try {
+            KissenPaperPublicPermissionGroup kissenPaperPublicPermissionGroup = new KissenPaperPublicPermissionGroup();
+            kissenPaperPublicPermissionGroup.setup(name, data);
+            PaperPermissionGroup permissionGroup = new KissenPaperPermissionGroup(kissenPaperPublicPermissionGroup);
+
+            cachedGroups.removeIf(group -> group.getPermissionID().equals(name));
+            cachedGroups.add(permissionGroup); // add public
+
+            EventImplementation eventImplementation = Bukkit.getKissen().getImplementation(EventImplementation.class);
+            eventImplementation.call(new KissenPermissionGroupCreatedEvent(permissionGroup));
+            return permissionGroup;
+        } catch (BackendException backendException)
+        {
+            throw new RuntimeException(backendException); //TODO replace with throw list
+        }
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/PaperPermissionGroupParser.java b/src/main/java/net/kissenpvp/paper/permission/PaperPermissionGroupParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..ebfef6383ddb6dc7717e29ce6d6cb7f76b2c9093
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/PaperPermissionGroupParser.java
@@ -0,0 +1,40 @@
+package net.kissenpvp.paper.permission;
+
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.core.api.permission.PermissionEntry;
+import net.kissenpvp.paper.api.command.PaperArgumentParser;
+import net.kissenpvp.paper.api.permission.PaperPermissionGroup;
+import net.kissenpvp.paper.api.permission.PaperPermissionImplementation;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collection;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+public class PaperPermissionGroupParser implements PaperArgumentParser<PaperPermissionGroup>
+{
+    @Override
+    public @NotNull String serialize(@NotNull PaperPermissionGroup object)
+    {
+        return object.getPermissionID();
+    }
+
+    @Override
+    public @NotNull PaperPermissionGroup deserialize(@NotNull String input)
+    {
+        Class<PaperPermissionImplementation> clazz = PaperPermissionImplementation.class;
+        PaperPermissionImplementation paperPermissionImplementation = Bukkit.getKissen().getImplementation(clazz);
+        return paperPermissionImplementation.getGroupNotNull(input);
+    }
+
+    @Override
+    public @NotNull Collection<String> tabCompletion(@NotNull CommandPayload<CommandSender> commandPayload)
+    {
+        Class<PaperPermissionImplementation> clazz = PaperPermissionImplementation.class;
+        PaperPermissionImplementation permissionImplementation = Bukkit.getKissen().getImplementation(clazz);
+        Set<PaperPermissionGroup> groupSet = permissionImplementation.getGroups();
+        return groupSet.stream().map(PermissionEntry::getPermissionID).collect(Collectors.toSet());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/PermissionCommand.java b/src/main/java/net/kissenpvp/paper/permission/PermissionCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..c1c3fec517bf0256524df83f29406888bb9e5172
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/PermissionCommand.java
@@ -0,0 +1,222 @@
+package net.kissenpvp.paper.permission;
+
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.core.api.command.annotations.CommandData;
+import net.kissenpvp.core.api.command.exception.ArgumentMissingException;
+import net.kissenpvp.core.api.message.ThemeProvider;
+import net.kissenpvp.core.api.util.PageBuilder;
+import net.kissenpvp.core.api.util.PageImplementation;
+import net.kissenpvp.paper.api.permission.PaperGroubablePermissionEntry;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PaperPermissionEntry;
+import net.kissenpvp.paper.api.permission.PaperPermissionGroup;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.TextComponent;
+import net.kyori.adventure.text.TranslatableComponent;
+import net.kyori.adventure.text.format.TextColor;
+import org.bukkit.Bukkit;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Comparator;
+import java.util.List;
+import java.util.Optional;
+import java.util.Set;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import java.util.stream.Stream;
+
+public class PermissionCommand
+{
+    @CommandData(value = "permission", permission = "*")
+    public void permissionGroup(CommandPayload<CommandSender> commandPayload)
+    {
+        throw new ArgumentMissingException();
+    }
+
+    @CommandData(value = "permission.user", permission = "*", runAsync = true)
+    public void permissionUser(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull OfflinePlayer offlinePlayer, @NotNull PermissionParser.PermissionArgument permission, @NotNull Optional<PermissionAction> value)
+    {
+        commandPayload.confirmRequest(() -> commandPayload.getSender().sendMessage(
+                executeAction(offlinePlayer, permission.permission(), value)));
+    }
+
+    @CommandData(value = "permission.user.group.add", permission = "*", runAsync = true)
+    public void permissionGroupAdd(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull OfflinePlayer offlinePlayer, @NotNull PaperPermissionGroup permissionGroup)
+    {
+        commandPayload.getSender().sendMessage(setGroup(true, offlinePlayer, permissionGroup));
+    }
+
+    @CommandData(value = "permission.user.group.remove", permission = "*", runAsync = true)
+    public void permissionGroupRemove(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull OfflinePlayer offlinePlayer, @NotNull PaperPermissionGroup permissionGroup)
+    {
+        commandPayload.getSender().sendMessage(setGroup(false, offlinePlayer, permissionGroup));
+    }
+
+    @CommandData(value = "permission.group.group.add", permission = "*", runAsync = true)
+    public void permissionGroupAdd(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PaperPermissionGroup group, @NotNull PaperPermissionGroup permissionGroup)
+    {
+        commandPayload.getSender().sendMessage(setGroup(true, group, permissionGroup));
+    }
+
+    @CommandData(value = "permission.group.group.remove", permission = "*", runAsync = true)
+    public void permissionGroupRemove(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PaperPermissionGroup group, @NotNull PaperPermissionGroup permissionGroup)
+    {
+        commandPayload.getSender().sendMessage(setGroup(false, group, permissionGroup));
+    }
+
+    @CommandData(value = "permission.group", permission = "*", runAsync = true)
+    public void permissionGroup(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PaperPermissionGroup paperPermissionGroup, @NotNull PermissionParser.PermissionArgument permission, @NotNull Optional<PermissionAction> value)
+    {
+        commandPayload.confirmRequest(() -> commandPayload.getSender().sendMessage(
+                executeAction(paperPermissionGroup, permission.permission(), value)));
+    }
+
+    @CommandData(value = "permissioninfo", aliases = {"peri"})
+    public void permissionInfo() {throw new ArgumentMissingException();}
+
+    @CommandData("permissioninfo.user")
+    public void permissionInfoUser(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull OfflinePlayer offlinePlayer, @NotNull Optional<Integer> page)
+    {
+        commandPayload.getSender().sendMessage(buildInfoComponent(offlinePlayer, page.orElse(1)));
+    }
+
+    @CommandData("permissioninfo.user.permission")
+    public void permissionInfoUserPermission(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull OfflinePlayer offlinePlayer, @NotNull String permission)
+    {
+        commandPayload.getSender().sendMessage(buildInfoComponent(offlinePlayer, permission));
+    }
+
+    @CommandData("permissioninfo.group")
+    public void permissionInfoGroup(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PaperPermissionGroup permissionGroup, @NotNull Optional<Integer> page)
+    {
+        commandPayload.getSender().sendMessage(buildInfoComponent(permissionGroup, page.orElse(1)));
+    }
+
+    @CommandData("permissioninfo.group.permission")
+    public void permissionInfoGroupPermission(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PaperPermissionGroup permissionGroup, @NotNull String permission)
+    {
+        commandPayload.getSender().sendMessage(buildInfoComponent(permissionGroup, permission));
+    }
+
+    private @NotNull Component buildInfoComponent(@NotNull PaperGroubablePermissionEntry permissionEntry, @NotNull String permission)
+    {
+        return permissionEntry.getPermission(permission).map(paperPermission ->
+        {
+
+            Component header = Component.translatable("server.command.general.header", permissionEntry.displayName());
+            Component footer = Component.translatable("server.command.general.footer", permissionEntry.displayName());
+            TranslatableComponent keyValue = Component.translatable("server.command.general.key.value");
+
+            Component id = Component.translatable("server.general.id").color(ThemeProvider.general());
+            Component owner = Component.translatable("server.permission.owner").color(ThemeProvider.general());
+
+            TextComponent.Builder builder = Component.text().appendNewline().append(header);
+            builder.appendNewline().append(keyValue.arguments(id, Component.text(paperPermission.getName())));
+            builder.appendNewline().append(keyValue.arguments(owner, paperPermission.getOwner().displayName()));
+            builder.appendNewline().append(footer);
+            return builder.asComponent();
+        }).orElseGet(() -> Component.translatable("server.permission.entity.failed", permissionEntry.displayName(), Component.text(permission)));
+    }
+
+    private @NotNull Component buildInfoComponent(@NotNull PaperGroubablePermissionEntry permissionEntry, int page)
+    {
+        Set<PaperPermission> permissionSet = permissionEntry.getPermissionList();
+        if(permissionSet.isEmpty())
+        {
+            return Component.translatable("server.permission.info.clear", permissionEntry.displayName());
+        }
+        PageBuilder<PaperPermission> pageBuilder = getPagedPermissions(permissionEntry, permissionSet);
+
+        int current = page;
+        if(page > pageBuilder.getLastPage())
+        {
+            current = pageBuilder.getLastPage();
+        }
+        else if (page < 1)
+        {
+            current = 1;
+        }
+
+        Component currentPageComponent = Component.text(current);
+        Component lastPageComponent = Component.text(pageBuilder.getLastPage());
+
+        Component header = Component.translatable("server.command.general.header.paged", permissionEntry.displayName(), currentPageComponent, lastPageComponent);
+        Component footer = Component.translatable("server.command.general.footer.paged", permissionEntry.displayName(), currentPageComponent, lastPageComponent);
+
+        TextComponent.Builder builder = Component.text().appendNewline().append(header);
+        pageBuilder.getEntries(current).forEach(per ->
+        {
+            TextColor statusColor = per.getValue() ? ThemeProvider.enabled() : ThemeProvider.disabled();
+            Component[] args = {Component.text(per.getValue() ? "✔" : "❌").color(statusColor), per.getOwner().displayName().color(ThemeProvider.secondary()), Component.text(per.getName()).color(ThemeProvider.general())};
+            builder.appendNewline().append(Component.translatable("server.permission.info.compact", args));
+        });
+        builder.appendNewline().append(footer);
+        return builder.asComponent();
+    }
+
+    private @NotNull PageBuilder<PaperPermission> getPagedPermissions(@NotNull PaperGroubablePermissionEntry permissionEntry, @NotNull Set<PaperPermission> permissionSet)
+    {
+        Stream<PaperPermission> stream = permissionSet.stream();
+        Comparator<PaperPermission> comparator = (a, b) -> CharSequence.compare(a.getOwner().getPermissionID(), b.getOwner().getPermissionID());
+        List<PaperPermission> sortedPermissions = stream.sorted(comparator).toList();
+        return Bukkit.getKissen().getImplementation(PageImplementation.class).createPageBuilder(sortedPermissions);
+    }
+
+    private @NotNull Component setGroup(boolean add, @NotNull PaperGroubablePermissionEntry permissionEntry, @NotNull PaperPermissionGroup permissionGroup)
+    {
+        if(!(add ? permissionGroup.addMember(permissionEntry) : permissionGroup.removeMember(permissionEntry)))
+        {
+            return Component.translatable("server.permission.group.failed", permissionEntry.displayName(), permissionGroup.displayName());
+        }
+        return Component.translatable("server.permission.group.success", permissionEntry.displayName());
+    }
+
+    private @NotNull Component executeAction(@NotNull PaperGroubablePermissionEntry permissionEntry, @NotNull String permission, @NotNull Optional<PermissionAction> value)
+    {
+        Function<PermissionAction, Boolean> mapper = permissionAction -> Boolean.parseBoolean(permissionAction.name());
+        Supplier<Component> set = () -> setPermission(permissionEntry, permission, value.map(mapper));
+        Function<PermissionAction, Component> unset = (a) -> unsetPermission(permissionEntry, permission);
+        return value.filter(action -> action.equals(PermissionAction.UNSET)).map(unset).orElseGet(set);
+    }
+
+    private @NotNull Component unsetPermission(@NotNull PaperPermissionEntry permissionEntry, @NotNull String permission)
+    {
+        Component[] args = {permissionEntry.displayName(), Component.text(permission)};
+        if(!permissionEntry.unsetPermission(permission))
+        {
+            return Component.translatable("server.permission.entity.failed", args);
+        }
+        return Component.translatable("server.permission.unset.success", args);
+    }
+
+    private @NotNull Component setPermission(@NotNull PaperGroubablePermissionEntry permissionEntry, @NotNull String permission, @NotNull Optional<Boolean> value)
+    {
+        boolean newValue = value.orElseGet(() -> permissionEntry.getOwnPermission(permission).map(paperPermission -> !paperPermission.getValue()).orElse(true));
+        Component[] args = {permissionEntry.displayName(), Component.text(permission), Component.text(newValue)};
+        Component component = Component.translatable("server.permission.set.success", args);
+        Component failed = Component.translatable("server.permission.set.failed", args);
+
+        Function<PaperPermission, Component> mapper = paperPermission -> component;
+        return setPermission(permissionEntry, permission, newValue).map(mapper).orElse(failed);
+    }
+
+    private @NotNull Optional<PaperPermission> setPermission(@NotNull PaperGroubablePermissionEntry permissionEntry, @NotNull String permission, boolean value)
+    {
+        Function<PaperPermission, Boolean> mapper = (paperPermission -> paperPermission.getValue() == value);
+        if (permissionEntry.getOwnPermission(permission).map(mapper).orElse(false))
+        {
+            return Optional.empty();
+        }
+        return Optional.of(permissionEntry.setPermission(permission, value));
+    }
+
+    public enum PermissionAction
+    {
+        TRUE,
+        FALSE,
+        UNSET
+    }
+
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/PermissionParser.java b/src/main/java/net/kissenpvp/paper/permission/PermissionParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..54e615898eec3d914fd22aec9aca6cd99ae6fbfa
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/PermissionParser.java
@@ -0,0 +1,60 @@
+package net.kissenpvp.paper.permission;
+
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.paper.api.command.PaperArgumentParser;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public class PermissionParser implements PaperArgumentParser<PermissionParser.PermissionArgument>
+{
+    @Override
+    public @NotNull String serialize(@NotNull PermissionArgument object)
+    {
+        return object.permission();
+    }
+
+    @Override
+    public @NotNull PermissionArgument deserialize(@NotNull String input)
+    {
+        return new PermissionArgument(input);
+    }
+
+    @Override
+    public @NotNull Collection<String> tabCompletion(@NotNull CommandPayload<CommandSender> commandPayload)
+    {
+        return Bukkit.getCommandMap().getKnownCommands().values().stream().flatMap(command ->
+                {
+                    if(command.getPermission() == null)
+                    {
+                        return Stream.empty();
+                    }
+                    Set<String> data = new HashSet<>();
+                    for(String current : command.getPermission().split(";"))
+                    {
+                        StringBuilder stringBuilder = new StringBuilder();
+                        String[] parts = current.split("\\.");
+                        for (int i = 0; i < parts.length - 1; i++)
+                        {
+                            if(stringBuilder.toString().endsWith(".*"))
+                            {
+                                stringBuilder.deleteCharAt(stringBuilder.length() - 1);
+                            }
+                            stringBuilder.append(parts[i]).append(".*");
+                            data.add(stringBuilder.toString());
+                        }
+                        data.add(current);
+                    }
+                    return data.stream();
+                }
+                ).collect(Collectors.toSet());
+    }
+
+    public record PermissionArgument(@Override String permission) {}
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/RemoveAttachmentRunnable.java b/src/main/java/net/kissenpvp/paper/permission/RemoveAttachmentRunnable.java
new file mode 100644
index 0000000000000000000000000000000000000000..318e2520843c49567887703a254e03a8dc4171d5
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/RemoveAttachmentRunnable.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission;
+
+import org.bukkit.permissions.PermissionAttachment;
+import org.jetbrains.annotations.NotNull;
+
+public record RemoveAttachmentRunnable(PermissionAttachment attachment) implements Runnable {
+    public RemoveAttachmentRunnable(@NotNull PermissionAttachment attachment) {
+        this.attachment = attachment;
+    }
+
+    @Override
+    public void run() {
+        attachment.remove();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperAbstractPermissionGroup.java b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperAbstractPermissionGroup.java
new file mode 100644
index 0000000000000000000000000000000000000000..017f75ffc167ce7406e64a825bbd32be31c8a341
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperAbstractPermissionGroup.java
@@ -0,0 +1,45 @@
+package net.kissenpvp.paper.permission.group;
+
+import net.kissenpvp.core.api.permission.PermissionGroup;
+import net.kissenpvp.core.database.DataWriter;
+import net.kissenpvp.core.permission.KissenPermissionGroup;
+import net.kissenpvp.core.permission.KissenPermissionNode;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PaperPermissionImplementation;
+import net.kissenpvp.paper.permission.KissenPaperPermission;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Set;
+import java.util.stream.Collectors;
+
+public abstract class KissenPaperAbstractPermissionGroup extends KissenPermissionGroup<PaperPermission>
+{
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups() {
+        PaperPermissionImplementation paperPermissionImplementation = Bukkit.getKissen()
+                .getImplementation(PaperPermissionImplementation.class);
+
+        return paperPermissionImplementation.getGroups().stream().filter(group ->
+        {
+            var evaluator = new Object()
+            {
+                private boolean isMember(@NotNull PermissionGroup<PaperPermission> permissionGroup)
+                {
+                    return permissionGroup.getMember().contains(getPermissionID());
+                }
+            };
+
+            return evaluator.isMember(group.getContext(Context.GLOBAL)) || evaluator.isMember(group.getContext(Context.LOCAL));
+        }).collect(Collectors.toSet());
+    }
+
+    @Override
+    protected @NotNull PaperPermission translatePermission(@NotNull KissenPermissionNode kissenPermissionNode, @Nullable DataWriter dataWriter) {
+        return new KissenPaperPermission(kissenPermissionNode, this, dataWriter);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPermissionGroup.java b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPermissionGroup.java
new file mode 100644
index 0000000000000000000000000000000000000000..62c0559da94cad37669cc2c55b73510c5d0082ac
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPermissionGroup.java
@@ -0,0 +1,313 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission.group;
+
+import net.kissenpvp.core.api.database.StorageImplementation;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.permission.GroupablePermissionEntry;
+import net.kissenpvp.core.api.permission.PermissionGroup;
+import net.kissenpvp.core.base.KissenCore;
+import net.kissenpvp.core.permission.KissenPermissionSet;
+import net.kissenpvp.core.permission.PermissionCollector;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PaperPermissionGroup;
+import net.kissenpvp.paper.api.permission.PaperPublicPermissionGroup;
+import net.kissenpvp.paper.permission.KissenPaperAttachmentPermission;
+import net.kissenpvp.paper.permission.permissible.KissenPaperPermissible;
+import net.kyori.adventure.text.Component;
+import org.bukkit.permissions.PermissionAttachment;
+import org.bukkit.permissions.PermissionAttachmentInfo;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.*;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public class KissenPaperPermissionGroup extends KissenPaperPermissible implements PaperPermissionGroup, PermissionCollector<PaperPermission>
+{
+    private final PaperPublicPermissionGroup permissionGroup;
+
+    public KissenPaperPermissionGroup(@NotNull PaperPublicPermissionGroup permissionGroup) {
+        this.permissionGroup = permissionGroup;
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getOwnPermissions() {
+        return Stream.concat(getOwnPermissions(Context.LOCAL).stream(), getOwnPermissions(Context.GLOBAL).stream())
+            .collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @NotNull Optional<PaperPermission> getOwnPermission(@NotNull String permission)
+    {
+        return getOwnPermission(permission, Context.GLOBAL);
+    }
+
+    @Override
+    public int wipeGroups() {
+        return getContext(Context.LOCAL).wipeGroups();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups() {
+        return Stream.concat(getPermissionGroups(Context.LOCAL).stream(), getPermissionGroups(Context.GLOBAL).stream())
+            .collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup) {
+        return getContext(Context.LOCAL).inGroup(permissionGroup) || getContext(Context.GLOBAL).inGroup(permissionGroup);
+    }
+
+    @Override
+    public @NotNull String getPermissionID() {
+        return getContext(Context.GLOBAL).getPermissionID();
+    }
+
+    @Override
+    public @NotNull Component displayName() {
+        return getContext(Context.GLOBAL).displayName();
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission) throws EventCancelledException {
+        return setPermission(permission, Context.GLOBAL);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, boolean value) throws EventCancelledException {
+        return setPermission(permission, value, Context.GLOBAL);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull PaperPermission permission) throws EventCancelledException {
+        return setPermission(permission, Context.GLOBAL);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission) {
+        return unsetPermission(permission, Context.GLOBAL);
+    }
+
+    @Override
+    public int wipePermissions() {
+        return getContext(Context.LOCAL).wipePermissions() + getContext(Context.GLOBAL).wipePermissions();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList() {
+        return Stream.concat(getPermissionList(Context.LOCAL).stream(), getPermissionList(Context.GLOBAL).stream())
+            .collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @NotNull Optional<PaperPermission> getPermission(@NotNull String permission) {
+        return Optional.ofNullable(getPermissionList(Context.LOCAL).stream()
+            .filter(paperPermission -> paperPermission.getName().equalsIgnoreCase(permission))
+            .findFirst()
+            .orElse(getPermissionList(Context.GLOBAL).stream()
+                .filter(paperPermission -> paperPermission.getName().equalsIgnoreCase(permission))
+                .findFirst()
+                .orElse(null)));
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAffectedUsers()
+    {
+        return Stream.concat(getContext(Context.LOCAL).getAffectedUsers().stream(),
+                        getContext(Context.GLOBAL).getAffectedUsers().stream())
+            .collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<GroupablePermissionEntry<PaperPermission>> getConnectedEntries()
+    {
+        return Stream.concat(getContext(Context.LOCAL).getConnectedEntries().stream(),
+                getContext(Context.GLOBAL).getConnectedEntries().stream()).collect(Collectors.toSet());
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String permission) {
+        Optional<PaperPermission> optionalPaperPermission = getPermission(permission);
+        return optionalPaperPermission.isPresent() && optionalPaperPermission.get().getValue();
+    }
+
+    @Override
+    public @NotNull Set<PermissionAttachmentInfo> getEffectivePermissions() {
+        return getPermissionList().stream().map(permission ->
+        {
+            PermissionAttachment attachment = null;
+            if (permission instanceof KissenPaperAttachmentPermission kissenPaperAttachmentPermission) {
+                attachment = kissenPaperAttachmentPermission.getPermissionAttachment();
+            }
+            return new PermissionAttachmentInfo(this, permission.getName(), attachment, permission.getValue());
+        }).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public void permissionUpdate() {
+        this.permissionGroup.permissionUpdate();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<String> getMember() {
+        return Stream.concat(getContext(Context.LOCAL).getMember()
+            .stream(), getContext(Context.GLOBAL).getMember().stream()).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public boolean addMember(@NotNull GroupablePermissionEntry<?> groupablePermissionEntry) {
+        return addMember(groupablePermissionEntry, Context.GLOBAL);
+    }
+
+    @Override
+    public boolean removeMember(@NotNull GroupablePermissionEntry<?> groupablePermissionEntry) {
+        return removeMember(groupablePermissionEntry, Context.GLOBAL);
+    }
+
+    @Override
+    public boolean addMember(@NotNull GroupablePermissionEntry<?> groupablePermissionEntry, @NotNull Context context) {
+        return getContext(context).addMember(groupablePermissionEntry);
+    }
+
+    @Override
+    public boolean removeMember(@NotNull GroupablePermissionEntry<?> groupablePermissionEntry, @NotNull Context context) {
+        return getContext(context).removeMember(groupablePermissionEntry);
+    }
+
+    @Override
+    public @NotNull PermissionGroup<PaperPermission> getContext(@NotNull Context context) {
+        return switch (context) {
+            case GLOBAL -> permissionGroup;
+            case LOCAL -> permissionGroup.getPrivatePermissionGroup();
+        };
+    }
+
+    @Override
+    public @NotNull Set<PaperPermission> getOwnPermissions(@NotNull Context context) {
+        return getContext(context).getOwnPermissions();
+    }
+
+    @Override
+    public @NotNull Optional<PaperPermission> getOwnPermission(@NotNull String permission, @NotNull Context context)
+    {
+        return getContext(context).getOwnPermission(permission);
+    }
+
+    @Override
+    public @NotNull Set<PermissionGroup<PaperPermission>> getPermissionGroups(@NotNull Context context) {
+        return getContext(context).getPermissionGroups();
+    }
+
+    @Override
+    public boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup, @NotNull Context context) {
+        return getContext(context).inGroup(permissionGroup);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, @NotNull Context context) throws EventCancelledException {
+        return getContext(context).setPermission(permission);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, boolean value, @NotNull Context context) throws EventCancelledException {
+        return getContext(context).setPermission(permission, value);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull PaperPermission permission, @NotNull Context context) throws EventCancelledException {
+        return getContext(context).setPermission(permission);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission, @NotNull Context context) {
+        return getContext(context).unsetPermission(permission);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList(@NotNull Context context) {
+        return getContext(context).getPermissionList();
+    }
+
+    @Override
+    public @NotNull Optional<PaperPermission> getPermission(@NotNull String permission, @NotNull Context context) {
+        return getContext(context).getPermission(permission);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String permission, @NotNull Context context) {
+        return getContext(context).hasPermission(permission);
+    }
+
+    @Override
+    public @NotNull GroupablePermissionEntry<PaperPermission> getPermissionEntry(@NotNull Context context) {
+        return this;
+    }
+
+    @Override
+    public @NotNull Set<PaperPermission> permissionCollector() {
+        Set<PaperPermission> permissions = new KissenPermissionSet<>();
+        permissions.addAll(((PermissionCollector<PaperPermission>) getContext(Context.GLOBAL)).permissionCollector());
+        return permissions;
+    }
+
+    @Override
+    public @NotNull Set<String> internalGroupCollector(@NotNull Set<String> blacklistedGroups) {
+        Set<String> groups = new HashSet<>(((PermissionCollector<PaperPermission>) getContext(Context.GLOBAL)).internalGroupCollector(blacklistedGroups));
+        blacklistedGroups.remove(getPermissionID()); //remove blacklist because public group will be added as well.
+        groups.addAll(((PermissionCollector<PaperPermission>) getContext(Context.GLOBAL)).internalGroupCollector(blacklistedGroups));
+        return groups;
+    }
+
+    @Override
+    public boolean isOp() {
+        return hasPermission("*");
+    }
+
+    @Override
+    public void setOp(boolean value) {
+        if (isOp() && !value) {
+            unsetPermission("*");
+            return;
+        }
+
+        try {
+            setPermission("*", value);
+        } catch (EventCancelledException eventCancelledException) {
+            throw new RuntimeException(eventCancelledException);
+        }
+    }
+
+    /**
+     * Retrieves a map containing stored data from the storage system.
+     * <p>
+     * This method fetches data from the storage implementation associated with the Kissen Core instance. The data is retrieved based on the provided storage key.
+     * The retrieved data is returned as a map of string keys to associated objects.
+     *
+     * @return A non-null map containing the retrieved data from the storage system.
+     * @throws UnsupportedOperationException If the storage system is not supported or not properly configured.
+     */
+    private @NotNull Map<String, Object> getStorage() {
+        return KissenCore.getInstance()
+            .getImplementation(StorageImplementation.class)
+            .getStorage("permissiongroupattachments");
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPublicPermissionGroup.java b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPublicPermissionGroup.java
new file mode 100644
index 0000000000000000000000000000000000000000..47a6ac2970d4713bcee00a30a6b8f7079f1c9fc9
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPublicPermissionGroup.java
@@ -0,0 +1,111 @@
+package net.kissenpvp.paper.permission.group;
+
+import net.kissenpvp.core.api.base.Kissen;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.database.meta.ObjectMeta;
+import net.kissenpvp.core.api.database.savable.Savable;
+import net.kissenpvp.core.api.networking.socket.DataPackage;
+import net.kissenpvp.core.permission.KissenPermissionSet;
+import net.kissenpvp.core.permission.PermissionCollector;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.*;
+import net.kissenpvp.paper.permission.KissenPaperPermissionImplementation;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Collections;
+import java.util.Map;
+import java.util.Set;
+
+public class KissenPaperPublicPermissionGroup extends KissenPaperAbstractPermissionGroup implements PaperPublicPermissionGroup
+{
+    @Override
+    public @NotNull String getSaveID()
+    {
+        return "publicpermissiongroup";
+    }
+
+    @Override
+    public void sendData(@NotNull DataPackage dataPackage)
+    {
+        //TODO
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getOwnPermissions()
+    {
+        KissenPermissionSet<PaperPermission> permissions = new KissenPermissionSet<>();
+        permissions.addAll(((PermissionCollector<PaperPermission>) getPrivatePermissionGroup()).permissionCollector());
+        permissions.addAll(super.getOwnPermissions());
+        return Collections.unmodifiableSet(permissions);
+    }
+
+    @Override
+    public @NotNull PaperPrivatePermissionGroup getPrivatePermissionGroup()
+    {
+        Map<String, Object> storage = getStorage();
+
+        if (!storage.containsKey(getPermissionID() + "_private"))
+        {
+            KissenPaperPrivatePermissionGroup kissenPaperPrivatePermissionGroup = new KissenPaperPrivatePermissionGroup();
+            kissenPaperPrivatePermissionGroup.setup(getPermissionID(), null);
+            storage.put(getPermissionID() + "_private", kissenPaperPrivatePermissionGroup);
+        }
+
+        return (PaperPrivatePermissionGroup) storage.get(getPermissionID() + "_private");
+    }
+
+    @Override
+    public int softDelete() throws BackendException
+    {
+        Kissen kissen = Bukkit.getKissen();
+        Class<KissenPaperPermissionImplementation> clazz = KissenPaperPermissionImplementation.class;
+        KissenPaperPermissionImplementation paperPermissionImplementation = kissen.getImplementation(clazz);
+        paperPermissionImplementation.removePermissionGroup(getPermissionID());
+        return super.softDelete();
+    }
+
+    public static class KissenPaperPrivatePermissionGroup extends KissenPaperAbstractPermissionGroup implements PaperPrivatePermissionGroup
+    {
+        @Override
+        public void sendData(@NotNull DataPackage dataPackage) { /* ignored */ }
+
+        @Override
+        public @NotNull String getSaveID()
+        {
+            return "privatepermissiongroup";
+        }
+
+        @Override
+        public @NotNull PaperPermissionGroup getPublicGroup()
+        {
+            Kissen kissen = Bukkit.getKissen();
+            Class<PaperPermissionImplementation> clazz = PaperPermissionImplementation.class;
+            PaperPermissionImplementation paperPermissionImplementation = kissen.getImplementation(clazz);
+            return paperPermissionImplementation.getGroup(getPermissionID()).orElseThrow(NullPointerException::new);
+        }
+
+        @Override
+        public @NotNull Set<PaperPermission> permissionCollector()
+        {
+            return getOwnPermissions();
+        }
+
+        @Override
+        public @NotNull ObjectMeta getMeta()
+        {
+            return Bukkit.getKissen().getPrivateMeta();
+        }
+
+        @Override
+        public int softDelete() throws BackendException
+        {
+            getSerializableSavableHandler().delete();
+            //safe cast
+            ((Savable) getPublicGroup().getContext(Context.GLOBAL)).delete();
+            return super.softDelete();
+        }
+    }
+}
+
diff --git a/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPermissible.java b/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPermissible.java
new file mode 100644
index 0000000000000000000000000000000000000000..8d1cabb6175da6bb6b05acd5f7be8e2e34e27987
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPermissible.java
@@ -0,0 +1,192 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission.permissible;
+
+import net.kissenpvp.core.api.time.TemporalObject;
+import net.kissenpvp.paper.api.permission.PaperPermissible;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.permission.KissenPaperAttachmentPermission;
+import net.kissenpvp.paper.permission.KissenPaperGroupablePermissionEntry;
+import net.kissenpvp.paper.permission.RemoveAttachmentRunnable;
+import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;
+import org.bukkit.Bukkit;
+import org.bukkit.permissions.*;
+import org.bukkit.plugin.Plugin;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.function.BiConsumer;
+import java.util.logging.Level;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public abstract class KissenPaperPermissible extends KissenPaperGroupablePermissionEntry implements PaperPermissible {
+
+    protected final Permissible parent;
+    protected final Set<PermissionAttachment> attachments;
+
+    public KissenPaperPermissible() {
+        this(null);
+    }
+
+    public KissenPaperPermissible(@Nullable Permissible parent) {
+        this.attachments = new HashSet<>();
+        this.parent = parent == null ? this : parent;
+    }
+
+    @Override
+    public void permissionUpdate() {
+        recalculatePermissions();
+    }
+
+    @Override
+    public boolean isPermissionSet(@NotNull String name) {
+        return getPermission(name).isPresent();
+    }
+
+    @Override
+    public boolean isPermissionSet(@NotNull Permission perm) {
+        return isPermissionSet(perm.getName());
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull Permission perm) {
+        return hasPermission(perm.getName());
+    }
+
+    @Override
+    public @NotNull PermissionAttachment addAttachment(@NotNull Plugin plugin) {
+        PermissionAttachment result = new PermissionAttachment(plugin, parent);
+
+        attachments.add(result);
+        permissionUpdate();
+
+        return result;
+    }
+
+    @Override
+    public @NotNull PermissionAttachment addAttachment(@NotNull Plugin plugin, @NotNull String name, boolean value) {
+        PermissionAttachment permissionAttachment = addAttachment(plugin);
+        permissionAttachment.setPermission(name, value);
+        return permissionAttachment;
+    }
+
+    @Override
+    public @Nullable PermissionAttachment addAttachment(@NotNull Plugin plugin, @NotNull String name, boolean value, int ticks) {
+        PermissionAttachment permissionAttachment = addAttachment(plugin, ticks);
+        if (permissionAttachment != null) {
+            permissionAttachment.setPermission(name, value);
+        }
+        return permissionAttachment;
+    }
+
+    @Override
+    public @Nullable PermissionAttachment addAttachment(@NotNull Plugin plugin, int ticks) {
+        PermissionAttachment result = addAttachment(plugin);
+
+        if (Bukkit.getServer()
+                .getScheduler()
+                .scheduleSyncDelayedTask(plugin, new RemoveAttachmentRunnable(result), ticks) == -1) {
+            Bukkit.getServer()
+                    .getLogger()
+                    .log(Level.WARNING, "Could not add PermissionAttachment to " + LegacyComponentSerializer.legacySection().serialize(displayName()) + " for plugin " + plugin.getPluginMeta()
+                            .getDisplayName() + ": Scheduler returned -1");
+            result.remove();
+            return null;
+        } else {
+            return result;
+        }
+    }
+
+    @Override
+    public void removeAttachment(@NotNull PermissionAttachment attachment) {
+        if (attachments.remove(attachment)) {
+            PermissionRemovedExecutor permissionRemovedExecutor = attachment.getRemovalCallback();
+
+            if (permissionRemovedExecutor != null) {
+                permissionRemovedExecutor.attachmentRemoved(attachment);
+            }
+
+            permissionUpdate();
+        } else {
+            throw new IllegalArgumentException("Given attachment is not part of Permissible object " + LegacyComponentSerializer.legacySection().serialize(displayName()));
+        }
+    }
+
+    @Override
+    public void recalculatePermissions() {
+        unsubscribe();
+
+        Bukkit.getServer().getPluginManager().subscribeToDefaultPerms(isOp() || hasPermission("*"), parent);
+        for (PaperPermission permission : getPermissionList()) {
+            Bukkit.getServer().getPluginManager().subscribeToPermission(permission.getName(), parent);
+        }
+    }
+
+    @Override
+    public @NotNull Set<PermissionAttachmentInfo> getEffectivePermissions() {
+        return getPermissionList().stream().filter(TemporalObject::isValid).map(permission -> {
+            PermissionAttachment attachment = null;
+            if (permission instanceof KissenPaperAttachmentPermission kissenPaperAttachmentPermission) {
+                attachment = kissenPaperAttachmentPermission.getPermissionAttachment();
+            }
+            return new PermissionAttachmentInfo(parent, permission.getName(), attachment, permission.getValue());
+        }).collect(Collectors.toSet());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList() {
+
+        Set<KissenPaperAttachmentPermission> permissions = new HashSet<>();
+        for (PermissionAttachment attachment : attachments)
+        {
+            BiConsumer<String, Boolean> transform = (key, value) -> permissions.add(
+                    new KissenPaperAttachmentPermission(attachment, key, value, KissenPaperPermissible.this, true));
+            attachment.getPermissions().forEach(transform);
+        }
+
+        return Stream.concat(super.getPermissionList().stream(), permissions.stream()).collect(Collectors.toSet());
+    }
+
+    /**
+     * The <code>unsubscribe</code> method is used to deregister all permissions from a parent permission holder in the Bukkit server.
+     *
+     * <p>As a result of calling this method, the permission holder specified by 'parent' would not hold the permissions anymore until re-registered.</p>
+     *
+     * <p>Note: Parent could be a Player, a Group, or any entity that can hold permissions in Bukkit.</p>
+     *
+     * <p>It is advised to call this method when you no longer need the permissions to be associated with the parent or want to clear current permissions before setting new ones.</p>
+     *
+     * @see net.kissenpvp.core.api.permission.Permission
+     * @see Permissible
+     */
+    public void unsubscribe() {
+        for (String name : getPermissionList().stream()
+                .map(net.kissenpvp.core.api.permission.Permission::getName)
+                .collect(Collectors.toSet())) {
+            Bukkit.getServer().getPluginManager().unsubscribeFromPermission(name, parent);
+        }
+
+        Bukkit.getServer().getPluginManager().unsubscribeFromDefaultPerms(false, parent);
+        Bukkit.getServer().getPluginManager().unsubscribeFromDefaultPerms(true, parent);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPlayerPermissible.java b/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPlayerPermissible.java
new file mode 100644
index 0000000000000000000000000000000000000000..ab057f031800707b1c5c4273047f913fb520120a
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPlayerPermissible.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission.permissible;
+
+import net.kissenpvp.core.api.permission.GroupablePermissionEntry;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kyori.adventure.text.Component;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.permissions.Permissible;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Collections;
+import java.util.Optional;
+import java.util.Set;
+import java.util.UUID;
+
+public class KissenPaperPlayerPermissible extends KissenPaperPermissible {
+
+    public KissenPaperPlayerPermissible(@NotNull Permissible parent) {
+        super(parent);
+    }
+
+    public @NotNull OfflinePlayer getPlayer() {
+        return (OfflinePlayer) parent; // Can be offline or online, does not matter
+    }
+
+    @Override
+    public @NotNull GroupablePermissionEntry<PaperPermission> getPermissionEntry(@NotNull Context context) {
+        return (GroupablePermissionEntry<PaperPermission>) getPlayer().getUser(context);
+    }
+
+    @Override
+    public @NotNull String getPermissionID() {
+        return getPermissionEntry(Context.GLOBAL).getPermissionID();
+    }
+
+    @Override
+    public @NotNull Component displayName() {
+        return getPlayer().displayName();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAffectedUsers() {
+        return Collections.singleton(getPlayer().getUniqueId());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<GroupablePermissionEntry<PaperPermission>> getConnectedEntries()
+    {
+        return getPlayer().isConnected() ? Collections.singleton((GroupablePermissionEntry<PaperPermission>) parent) : Collections.EMPTY_SET;
+    }
+
+    @Override
+    public boolean isOp() {
+        return getPlayer().isOp();
+    }
+
+    @Override
+    public void setOp(boolean value) {
+        getPlayer().setOp(value);
+    }
+
+    @Override
+    public @NotNull Optional<PaperPermission> getOwnPermission(@NotNull String permission)
+    {
+        return getOwnPermission(permission, Context.LOCAL).or(() -> getOwnPermission(permission, Context.GLOBAL));
+    }
+
+    @Override
+    public @NotNull Optional<PaperPermission> getOwnPermission(@NotNull String permission, @NotNull Context context)
+    {
+        return getPermissionEntry(context).getOwnPermission(permission);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenOperatorDataNode.java b/src/main/java/net/kissenpvp/paper/user/KissenOperatorDataNode.java
new file mode 100644
index 0000000000000000000000000000000000000000..6e27b52d62505e5669f8b13235aba2cca5f20457
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/KissenOperatorDataNode.java
@@ -0,0 +1,15 @@
+package net.kissenpvp.paper.user;
+
+import com.mojang.authlib.GameProfile;
+import net.minecraft.server.players.ServerOpListEntry;
+import org.jetbrains.annotations.NotNull;
+
+public record KissenOperatorDataNode(int level, boolean bypassServerLimit)
+{
+
+    public @NotNull ServerOpListEntry getServerOpListEntry(@NotNull GameProfile profile)
+    {
+        return new ServerOpListEntry(profile, level(), bypassServerLimit());
+    }
+
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenPaperProfileCache.java b/src/main/java/net/kissenpvp/paper/user/KissenPaperProfileCache.java
new file mode 100644
index 0000000000000000000000000000000000000000..1dc4273c190d512036b4257a6370d112b1670cc6
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/KissenPaperProfileCache.java
@@ -0,0 +1,95 @@
+package net.kissenpvp.paper.user;
+
+import com.mojang.authlib.GameProfile;
+import com.mojang.authlib.GameProfileRepository;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.api.user.UserInfo;
+import net.kissenpvp.core.api.user.UserRepository;
+import net.minecraft.server.players.GameProfileCache;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Optional;
+import java.util.UUID;
+import java.util.function.Function;
+
+/**
+ * KissenPaperProfileCache is a cache specifically designed for KissenPaper profiles.
+ * This cache extends the {@code GameProfileCache} class to provide additional functionalities
+ * specific to the KissenPaper profiles. It has been designed to be used in the KissenPaper game application.
+ */
+public class KissenPaperProfileCache extends GameProfileCache {
+
+    private final UserRepository userRepository;
+
+    /**
+     * Creates a new instance of KissenPaperProfileCache.
+     *
+     * @param profileRepository - a not-null instance of a GameProfileRepository which is used to fetch and cache profiles
+     * @throws IllegalArgumentException if profileRepository is null
+     */
+    public KissenPaperProfileCache(@NotNull GameProfileRepository profileRepository) {
+        //noinspection DataFlowIssue
+        super(profileRepository, null); // not file based
+        userRepository = new KissenPaperUserRepository(profileRepository);
+        KissenPaperUserImplementation.setKissenPaperProfileCache(this);
+    }
+
+    @Override
+    public void add(@NotNull GameProfile profile) { /* moved to net.kissenpvp.core.user.KissenPublicUser#setup(String, Map) */ }
+
+    @Nullable
+    @Override
+    public GameProfile getProfileIfCached(@NotNull String name) {
+        return get(name).orElse(null);
+    }
+
+    @Override
+    public @NotNull Optional<GameProfile> get(@NotNull String name) {
+        return Bukkit.getKissen().getImplementation(UserImplementation.class).getCachedUserProfile(name).map(transformUserInfo()).or(() -> getUserRepository().getUser(name).join().map(translateUser()));
+    }
+
+    @Override
+    public @NotNull Optional<GameProfile> get(@NotNull UUID uuid) {
+        return Bukkit.getKissen().getImplementation(UserImplementation.class).getCachedUserProfile(uuid).map(transformUserInfo()).or(() -> getUserRepository().getUser(uuid).join().map(translateUser()));
+    }
+
+    @Override
+    protected @NotNull List<GameProfileInfo> load() {
+        // ignored
+        return new ArrayList<>();
+    }
+
+    @Override
+    public void save(boolean asyncSave) {
+        // ignored
+    }
+
+    private @NotNull Function<UserInfo, GameProfile> transformUserInfo() {
+        return userInfo -> new GameProfile(userInfo.getUUID(), userInfo.getName());
+    }
+
+    /**
+     * Returns the UserRepository object used within this class.
+     *
+     * @return UserRepository that this class uses to perform user related operations
+     */
+    public @NotNull UserRepository getUserRepository() {
+        return userRepository;
+    }
+
+    /**
+     * Returns a Function that can be used to translate a User object into a GameProfile.
+     *
+     * @return Function that translates a User object into a GameProfile
+     */
+    @Contract(pure = true)
+    private @NotNull Function<User, GameProfile> translateUser() {
+        return user -> new GameProfile(UUID.fromString(user.getRawID()), user.getNotNull("name"));
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenPaperPublicUser.java b/src/main/java/net/kissenpvp/paper/user/KissenPaperPublicUser.java
new file mode 100644
index 0000000000000000000000000000000000000000..3aa1c85585b94525c738fc113e795185bb5f2923
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/KissenPaperPublicUser.java
@@ -0,0 +1,323 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.user;
+
+import net.kissenpvp.core.api.base.Kissen;
+import net.kissenpvp.core.api.database.StorageImplementation;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.database.meta.ObjectMeta;
+import net.kissenpvp.core.api.database.savable.SavableMap;
+import net.kissenpvp.core.api.event.EventImplementation;
+import net.kissenpvp.core.api.networking.client.entitiy.PlayerClient;
+import net.kissenpvp.core.api.networking.socket.DataPackage;
+import net.kissenpvp.core.api.permission.PermissionGroup;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.base.KissenCore;
+import net.kissenpvp.core.database.DataWriter;
+import net.kissenpvp.core.permission.KissenPermissionNode;
+import net.kissenpvp.core.permission.KissenPermissionSet;
+import net.kissenpvp.core.permission.PermissionCollector;
+import net.kissenpvp.core.user.KissenPublicUser;
+import net.kissenpvp.core.user.KissenUser;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.networking.client.entity.PaperPlayerClient;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PaperPermissionImplementation;
+import net.kissenpvp.paper.api.user.event.VisualChangeEvent;
+import net.kissenpvp.paper.permission.KissenPaperPermission;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Collections;
+import java.util.Objects;
+import java.util.Set;
+import java.util.UUID;
+import java.util.stream.Collectors;
+
+/**
+ * The {@code KissenPaperPublicUser} class extends the {@link KissenPublicUser} class with {@link PaperPermission}
+ * as its generic type. It represents a public user within the KissenPaper system.
+ * <p>
+ * While it maintains the key characteristics of a {@link KissenPublicUser}, such as a UUID and name,
+ * the {@code KissenPaperPublicUser} further enhances this with specifics for a user that has a public profile
+ * accessible across multiple servers.
+ * @see KissenPublicUser
+ */
+public class KissenPaperPublicUser extends KissenPublicUser<PaperPermission> {
+
+    /**
+     * The constructor for the {@code KissenPaperPublicUser} class.
+     * It initializes a new instance of the class with a specified UUID and name.
+     *
+     * @param uuid A unique identifier. It may be nullable, representing a user, whose unique identifier
+     *             might not be known or relevant at the time of creation.
+     * @param name A string representing the username. It may be nullable, representing a user whose name
+     *             might not be known or relevant at the time of creation.
+     * @throws BackendException If an error occurs during the creation and initialization of a KissenPaperPublicUser instance.
+     */
+    public KissenPaperPublicUser(@Nullable UUID uuid, @Nullable String name) throws BackendException {
+        super(uuid, name);
+    }
+
+    /**
+     * An alternate constructor for the {@code KissenPaperPublicUser} class which initializes a new instance
+     * of the class with a SavableMap data structure.
+     *
+     * @param data A {@link SavableMap} object that contains user details.
+     *             It is expected to be used when loading a user from saved storage.
+     * @throws BackendException If an error occurs during the creation and initialization of a KissenPaperPublicUser instance.
+     */
+    public KissenPaperPublicUser(@NotNull SavableMap data) throws BackendException
+    {
+        super(data);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups() {
+        return KissenCore.getInstance()
+            .getImplementation(PaperPermissionImplementation.class)
+            .getGroups()
+            .stream()
+            .filter(permissionGroup -> permissionGroup.getMember().contains(getPermissionID()))
+            .collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public PlayerClient<?, ?, ?> getPlayerClient() {
+        return getPrivateUserEntry().getPlayerClient();
+    }
+
+    @Override
+    protected @NotNull PaperPermission translatePermission(@NotNull KissenPermissionNode kissenPermissionNode, @Nullable DataWriter dataWriter) {
+        return new KissenPaperPermission(kissenPermissionNode, this, dataWriter);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getOwnPermissions()
+    {
+        KissenPermissionSet<PaperPermission> permissions = new KissenPermissionSet<>();
+        permissions.addAll(((PermissionCollector<PaperPermission>) getPrivateUserEntry()).permissionCollector());
+        permissions.addAll(super.getOwnPermissions());
+        return Collections.unmodifiableSet(permissions);
+    }
+
+    @Override
+    public void sendData(@NotNull DataPackage dataPackage) {
+        // TODO Networking and stuff
+    }
+
+    @Override
+    public void login() {
+        super.login();
+        getStorage().put("time_joined", System.currentTimeMillis());
+        ((KissenUser<?>) getPrivateUserEntry()).login();
+        getStorage().put("tick", true);
+    }
+
+    @Override
+    public void logout() {
+        super.logout();
+        Bukkit.getKissen().getImplementation(StorageImplementation.class).dropStorage("user" + this.getRawID());
+    }
+
+    @Override
+    public void tick() {
+        checkVisuals();
+
+        ((KissenUser<PaperPermission>) getPrivateUserEntry()).tick();
+        super.tick();
+    }
+
+    @Override
+    public int softDelete() throws BackendException {
+        return super.softDelete() + getPrivateUserEntry().delete();
+    }
+
+    /**
+     * The {@code getPrivateUserEntry} method retrieves an instance of a private user entry from the local storage.
+     * If the private user entry is not yet in the storage, it creates an entry using the 'setupPrivateUser' method.
+     * In case of an exception when creating the private user entry, an error log is produced, and the server
+     * is advised to be shut down to prevent further data problems.
+     *
+     * @return An instance of a {@link User} associated with the private user entry.
+     *         Cast is performed without check, which assumes that "private_user_entry" in the storage is always of {@link User} type.
+     */
+    public @NotNull User getPrivateUserEntry() {
+        if (!getStorage().containsKey("private_user_entry")) {
+            try {
+                getStorage().put("private_user_entry", setupPrivateUser(UUID.fromString(getRawID()), getNotNull("name")));
+            } catch (BackendException backendException) {
+                KissenCore.getInstance()
+                    .getLogger()
+                    .error("The backend was not able to create a private user entry for the user '{}' with the id '{}'. It's advised to shutdown the server to prevent further problems with the servers data.", getNotNull("name"), getRawID());
+            }
+        }
+        return (User) getStorage().get("private_user_entry");
+    }
+
+    /**
+     * The {@code setupPrivateUser} method creates a new instance of a private user, {@link KissenPaperPrivateUser}, using provided UUID and username.
+     *
+     * @param uuid The UUID for the private user to be created.
+     * @param name The username of the private user.
+     * @return An instance of a {@link KissenPaperPrivateUser} initialized with the provided UUID and username.
+     * @throws BackendException If an error occurs during the creation and initialization of a KissenPaperPrivateUser instance.
+     * @see KissenPaperPrivateUser
+     */
+    protected @NotNull KissenPaperPrivateUser setupPrivateUser(UUID uuid, String name) throws BackendException {
+        return new KissenPaperPrivateUser(uuid, name);
+    }
+
+    @Override
+    public void permissionUpdate()
+    {
+        super.permissionUpdate();
+        ((KissenPaperPrivateUser) getPrivateUserEntry()).clearCache();
+
+        PaperPlayerClient paperPlayerClient = (PaperPlayerClient) getPlayerClient();
+        if(paperPlayerClient.isConnected())
+        {
+            ServerPlayer serverPlayer = ((CraftPlayer) paperPlayerClient).getHandle();
+            MinecraftServer.getServer().getPlayerList().sendPlayerPermissionLevel(serverPlayer);
+        }
+    }
+
+    private void checkVisuals()
+    {
+        String visualHash = getVisualHash();
+        if(!Objects.equals(getStorage().get("visual_hash"), visualHash))
+        {
+            getStorage().put("visual_hash", visualHash);
+            Player player = Objects.requireNonNull(Bukkit.getPlayer(UUID.fromString(getRawID())));
+            VisualChangeEvent visualChangeEvent = new VisualChangeEvent(player);
+            Bukkit.getKissen().getImplementation(EventImplementation.class).call(visualChangeEvent);
+        }
+    }
+
+    private @NotNull String getVisualHash()
+    {
+        PlayerClient<?, ?, ?> playerClient = getPlayerClient();
+        String suffix = playerClient.getSelectedSuffix().map(component -> component.getContent().toString()).orElse("");
+        return playerClient.getRank().getID() + suffix;
+    }
+
+    /**
+     * The nested class {@code KissenPaperPrivateUser} extends the {@link KissenUser} class while specifying {@link PaperPermission}
+     * as its generic type. It represents a private user entity within the KissenPaper system.
+     * <p>
+     * While the key characteristics of a {@link KissenUser} are maintained such as a UUID and name,
+     * the KissenPaperPrivateUser further enhances this with specifics for a user that owns a private profile which only this
+     * server can access.
+     * @see KissenUser
+     */
+    public static class KissenPaperPrivateUser extends KissenUser<PaperPermission> {
+
+        /**
+         * The constructor for the {@code KissenPaperPrivateUser} class.
+         * It initializes a new instance of the class with specified UUID and name.
+         *
+         * @param uuid A unique identifier. It may be nullable, representing a user whose unique identifier
+         *             might not be known or relevant at the time of creation.
+         * @param name A string representing the username. It may be nullable, representing a user whose name
+         *             might not be known or relevant at the time of creation.
+         * @throws BackendException If an error occurs during the creation and initialization of a KissenPaperPrivateUser instance.
+         */
+        public KissenPaperPrivateUser(@Nullable UUID uuid, @Nullable String name) throws BackendException {
+            super(uuid, name);
+        }
+
+        @Override
+        public @NotNull String getSaveID() {
+            return Bukkit.getKissen().getImplementation(KissenPaperUserImplementation.class).getUserSaveID(Context.LOCAL);
+        }
+
+        @Override
+        public @NotNull ObjectMeta getMeta() {
+            return Bukkit.getKissen().getImplementation(KissenPaperUserImplementation.class).getUserMeta(Context.LOCAL);
+        }
+
+        @Override
+        public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups() {
+            return KissenCore.getInstance()
+                    .getImplementation(PaperPermissionImplementation.class)
+                    .getGroups()
+                    .stream()
+                    .filter(permissionGroup -> permissionGroup.getMember().contains(getPermissionID()))
+                    .collect(Collectors.toUnmodifiableSet());
+        }
+
+        @Override
+        public @NotNull Set<PaperPermission> permissionCollector()
+        {
+            return getOwnPermissions();
+        }
+
+        @Override
+        public PlayerClient<?, ?, ?> getPlayerClient() {
+            if (!getStorage().containsKey("player_client")) {
+                getStorage().put("player_client", injectPlayerClient());
+            }
+            return (PlayerClient<?, ?, ?>) getStorage().get("player_client");
+        }
+
+        @Override
+        protected @NotNull PaperPermission translatePermission(@NotNull KissenPermissionNode kissenPermissionNode, @Nullable DataWriter dataWriter) {
+            return new KissenPaperPermission(kissenPermissionNode, this, dataWriter);
+        }
+
+        @Override
+        public void sendData(@NotNull DataPackage dataPackage) { /* Ignored because it's private */ }
+
+        /**
+         * The 'injectPlayerClient' method is responsible for creating and returning a {@link PaperPlayerClient}.
+         * This method is used to get an instance of a user's player client (whether online or offline),
+         * crucial for various user-related functionality.
+         * <p>
+         * The method begins by obtaining the UUID of the user.
+         * It then checks if the user is currently online using Bukkit's {@link Kissen#isOnline(UUID)} method on 'Kissen' platform.
+         * If the user is online, it gets the online instance of the player using Bukkit's 'getPlayer' method.
+         * If the user is offline, it gets the offline instance of the player using Bukkit's 'getOfflinePlayer' method.
+         *
+         * @return Returns an instance of {@link PaperPlayerClient} associated with the user based on visibility status.
+         * Can be an online or offline player, depending on the user's current visibility in the game environment.
+         *
+         * @throws NullPointerException If 'getPlayer' method returns null, this exception is thrown, indicating that
+         * the user is currently marked as online but no associated online {@link PaperPlayerClient} was found.
+         * @see Kissen
+         */
+        protected @NotNull PaperPlayerClient injectPlayerClient() {
+            UUID uuid = UUID.fromString(getRawID());
+            return Bukkit.getKissen().isOnline(uuid) ? Objects.requireNonNull(Bukkit.getPlayer(uuid)) : Bukkit.getOfflinePlayer(uuid);
+        }
+
+        @Override
+        public void permissionUpdate()
+        {
+            Bukkit.getKissen().getImplementation(UserImplementation.class).getOnlineUser(UUID.fromString(getRawID())).ifPresent((player ->
+                    ((PermissionCollector<PaperPermission>) player).permissionUpdate()));
+        }
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenPaperUserImplementation.java b/src/main/java/net/kissenpvp/paper/user/KissenPaperUserImplementation.java
new file mode 100644
index 0000000000000000000000000000000000000000..32b893ede8d5413c0b5f1414326e46a5b5e56747
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/KissenPaperUserImplementation.java
@@ -0,0 +1,177 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.user;
+
+import io.papermc.paper.threadedregions.scheduler.ScheduledTask;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.database.meta.ObjectMeta;
+import net.kissenpvp.core.api.database.savable.SavableMap;
+import net.kissenpvp.core.api.networking.client.entitiy.UnknownPlayerException;
+import net.kissenpvp.core.api.permission.Permission;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.base.KissenImplementation;
+import net.kissenpvp.core.command.KissenCommandImplementation;
+import net.kissenpvp.core.message.localization.KissenLocalizationImplementation;
+import net.kissenpvp.core.message.usersettings.*;
+import net.kissenpvp.core.user.KissenUser;
+import net.kissenpvp.core.user.KissenUserImplementation;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.command.KissenPaperCommandImplementation;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.scheduler.MinecraftInternalPlugin;
+import org.jetbrains.annotations.NotNull;
+
+import java.text.MessageFormat;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Consumer;
+import java.util.function.Supplier;
+
+/**
+ * The class 'KissenPaperUserImplementation' is an extension of the 'KissenUserImplementation' in the KissenPaper system.
+ * This class is responsible for interacting with or manipulating the paper-related functionality of a Kissen user.
+ * The class holds an instance of KissenPaperProfileCache which it uses to cache profiles for efficient read operations.
+ */
+public class KissenPaperUserImplementation extends KissenUserImplementation implements KissenImplementation
+{
+
+    private static KissenPaperProfileCache kissenPaperProfileCache;
+
+
+    @Override
+    public boolean start()
+    {
+        Class<KissenCommandImplementation> clazz = KissenCommandImplementation.class;
+        KissenCommandImplementation commandImplementation = Bukkit.getKissen().getImplementation(clazz);
+        commandImplementation.registerHandler(new UserSettingCommand());
+
+        KissenLocalizationImplementation localize = Bukkit.getKissen().getImplementation(KissenLocalizationImplementation.class);
+        localize.register("server.user.setting.changed", new MessageFormat("The setting {0} has been set to {1}."));
+        localize.register("server.user.setting.value.invalid", new MessageFormat("The value {0} is not allowed in setting {1}."));
+        localize.register("server.user.setting.not.found", new MessageFormat("The setting {0} does not exists."));
+        localize.register("server.user.setting.reset", new MessageFormat("The setting {0} has been reset to its default value {1}."));
+        return super.start();
+    }
+
+    @Override
+    public void setupComplete()
+    {
+        Class<KissenPaperCommandImplementation> clazz = KissenPaperCommandImplementation.class;
+        KissenPaperCommandImplementation commandImplementation = Bukkit.getKissen().getImplementation(clazz);
+        commandImplementation.registerCommand(new UserSettingCommand());
+
+        registerUserSetting(new PrimaryUserColor());
+        registerUserSetting(new SecondaryUserColor());
+        registerUserSetting(new GeneralUserColor());
+        registerUserSetting(new EnabledUserColor());
+        registerUserSetting(new DisabledUserColor());
+
+        Consumer<ScheduledTask> runnable = (task) -> getOnlineUser().stream().filter(userEntry -> userEntry.getStorage().containsKey("tick")).forEach(user -> ((KissenUser<? extends Permission>) user).tick());
+        Bukkit.getAsyncScheduler().runAtFixedRate(new MinecraftInternalPlugin(), runnable, 0, 1, TimeUnit.SECONDS);
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull UUID uuid) {
+
+        Supplier<User> createUser = () -> kissenPaperProfileCache.getUserRepository().getUser(uuid).join().orElseThrow(() -> new UnknownPlayerException(String.valueOf(uuid)));
+        Supplier<User> loadUser = () -> {
+
+            CompletableFuture<SavableMap> future = getUserMeta().getData(getUserSaveID() + uuid);
+            return new KissenPaperPublicUser(future.handle((user, ex) ->
+            {
+                if (user != null)
+                {
+                    return user;
+                }
+                return createUser.get();
+            }).join());
+        };
+        return getOnlineUser(uuid).orElseGet(loadUser);
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull String name) throws BackendException {
+        try {
+            if (getUserProfiles().stream().noneMatch(userInfo -> userInfo.getName().equals(name))) {
+                throw new UnknownPlayerException(name);
+            }
+            return super.getUser(name);
+        } catch (UnknownPlayerException unknownPlayerException) {
+            return kissenPaperProfileCache.getUserRepository().getUser(name).join().orElseThrow(() -> new UnknownPlayerException(name));
+        }
+    }
+
+    /**
+     * Returns the User Save ID for the specified context.
+     *
+     * @param context an enum constant representing the context, either GLOBAL or LOCAL
+     * @return String representing the User Save ID. If context is GLOBAL, the ID is retrieved by getUserSaveID(),
+     * otherwise for LOCAL context, Returns the server's name concatenated with 'privateuser'.
+     */
+    public @NotNull String getUserSaveID(@NotNull Context context)
+    {
+        return switch (context)
+        {
+            case GLOBAL -> getUserSaveID();
+            case LOCAL -> "privateuser";
+        };
+    }
+
+    /**
+     * Returns the User MetaData for the specified context.
+     *
+     * @param context an enum constant indicating the context, either GLOBAL or LOCAL
+     * @return ObjectMeta instance representing User's metadata. If context is GLOBAL, the metadata is retrieved by getUserMeta(),
+     * otherwise for LOCAL context, Returns the private metadata available in Bukkit's 'Kissen'.
+     */
+    public @NotNull ObjectMeta getUserMeta(@NotNull Context context)
+    {
+        return switch (context)
+        {
+            case GLOBAL -> getUserMeta();
+            case LOCAL -> Bukkit.getKissen().getPrivateMeta();
+        };
+    }
+
+    /**
+     * This private static method retrieves the current instance of KissenPaperProfileCache.
+     *
+     * @return The current KissenPaperProfileCache instance.
+     */
+    private static KissenPaperProfileCache getKissenPaperProfileCache() {
+        return kissenPaperProfileCache;
+    }
+
+    /**
+     * This public static method sets the KissenPaperProfileCache with a new instance.
+     * The method expects to receive an instance of KissenPaperProfileCache.
+     * If the input is null, an IllegalStateException will be thrown.
+     *
+     * @param kissenPaperProfileCache A new KissenPaperProfileCache instance.
+     * @throws IllegalStateException If the provided KissenPaperProfileCache instance is null.
+     */
+    public static void setKissenPaperProfileCache(KissenPaperProfileCache kissenPaperProfileCache) {
+        if(kissenPaperProfileCache == null)
+        {
+            throw new IllegalStateException("Object already initialized.");
+        }
+        KissenPaperUserImplementation.kissenPaperProfileCache = kissenPaperProfileCache;
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenPaperUserRepository.java b/src/main/java/net/kissenpvp/paper/user/KissenPaperUserRepository.java
new file mode 100644
index 0000000000000000000000000000000000000000..671da825ee272f8ef7a02e43ca5620df939bf03c
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/KissenPaperUserRepository.java
@@ -0,0 +1,126 @@
+package net.kissenpvp.paper.user;
+
+import com.mojang.authlib.GameProfile;
+import com.mojang.authlib.GameProfileRepository;
+import com.mojang.authlib.ProfileLookupCallback;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.api.user.UserRepository;
+import net.minecraft.core.UUIDUtil;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Optional;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.atomic.AtomicReference;
+
+/**
+ * The class 'KissenPaperUserRepository' implements the 'UserRepository' interface.
+ * It represents a repository for the User entities from mojang.
+ * Compliant with the Repository pattern, this class is intended to encapsulate all
+ * data access mechanics needed for User entities.
+ * <p>
+ * It also holds a 'GameProfileRepository' which perhaps holds the source data for the
+ * Users, or is another important factor in the retrieval or manipulation of User data.
+ */
+public class KissenPaperUserRepository implements UserRepository {
+
+    private final GameProfileRepository gameProfileRepository;
+
+    /**
+     * The constructor for the 'KissenPaperUserRepository' class.
+     * It initializes a new instance of the class with a specified 'GameProfileRepository' object.
+     *
+     * @param gameProfileRepository A 'GameProfileRepository' object.
+     * Specifies the game profile repository that the user repository will work with.
+     */
+    public KissenPaperUserRepository(@NotNull GameProfileRepository gameProfileRepository) {
+        this.gameProfileRepository = gameProfileRepository;
+    }
+
+    @Override
+    public @NotNull CompletableFuture<Optional<User>> getUser(@NotNull String name) throws BackendException {
+        CompletableFuture<Optional<User>> gameProfileCompletableFuture = new CompletableFuture<>();
+        AtomicReference<Optional<GameProfile>> fetchedRef = new AtomicReference<>(Optional.empty());
+
+        gameProfileRepository.findProfilesByNames(new String[]{name}, new ProfileLookupCallback() {
+            @Override
+            public void onProfileLookupSucceeded(GameProfile gameProfile) {
+                fetchedRef.set(Optional.ofNullable(gameProfile));
+            }
+
+            @Override
+            public void onProfileLookupFailed(String s, Exception e) {
+                gameProfileCompletableFuture.completeExceptionally(e);
+            }
+        });
+
+        fetchedRef.get().ifPresentOrElse(gameProfile -> processGameProfile(gameProfileCompletableFuture, gameProfile), () -> processMissingProfile(gameProfileCompletableFuture, name));
+
+        return gameProfileCompletableFuture;
+    }
+
+    @Override
+    public @NotNull CompletableFuture<Optional<User>> getUser(@NotNull UUID uuid) {
+        return null; //TODO
+    }
+
+    /**
+     * This method is used to determine whether authorization should take place.
+     * Its behaviour may be determined by the 'GlobalConfiguration' setting 'isProxyOnlineMode'.
+     * The return value implies whether the proxy is in online mode or not,
+     * which further implies whether authentication is needed.
+     *
+     * @return A boolean value -- 'true' when proxy is in online mode implying authorization
+     * is required for network interactions, 'false' otherwise.
+     */
+    private boolean shouldAuthorize()
+    {
+        return io.papermc.paper.configuration.GlobalConfiguration.get().proxies.isProxyOnlineMode();
+    }
+
+    /**
+     * Processes a potentially missing user profile. If authentication is not required,
+     * it will generate and process a "cracked" user profile with an offline player UUID.
+     * Otherwise, the method will complete the CompletableFuture with an empty Optional.
+     *
+     * @param gameProfileFuture a CompletableFuture that will be completed with the found (or not found) User
+     * @param name the name of the user to lookup
+     */
+    private void processMissingProfile(CompletableFuture<Optional<User>> gameProfileFuture, String name) {
+        if (!shouldAuthorize()) {
+            // Create cracked user
+            UUID offlineUUID = UUIDUtil.createOfflinePlayerUUID(name);
+            processGameProfile(gameProfileFuture, new GameProfile(offlineUUID, name));
+            return;
+        }
+        gameProfileFuture.complete(Optional.empty());
+    }
+
+    /**
+     * Processes a game profile and completes the CompletableFuture with the translated User object.
+     * If any error occurs during the translation, the resulting BackendException will be completed exceptionally
+     * inside the CompletableFuture.
+     *
+     * @param gameProfileFuture a CompletableFuture that will be completed with the translated User or an Error.
+     * @param gameProfile the game profile to process.
+     */
+    private void processGameProfile(CompletableFuture<Optional<User>> gameProfileFuture, GameProfile gameProfile) {
+        try {
+            gameProfileFuture.complete(Optional.of(translate(gameProfile)));
+        } catch (BackendException backendException) {
+            gameProfileFuture.completeExceptionally(backendException);
+        }
+    }
+
+    /**
+     * Translates a game profile into a KissenPaperPublicUser object.
+     *
+     * @param gameProfile the game profile to translate.
+     * @return KissenPaperPublicUser a new user object with the id and name from the passed game profile.
+     * @throws BackendException if any error occurs during the translation process.
+     */
+    private @NotNull User translate(@NotNull GameProfile gameProfile) throws BackendException {
+        return new KissenPaperPublicUser(gameProfile.getId(), gameProfile.getName());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenUserOperatorList.java b/src/main/java/net/kissenpvp/paper/user/KissenUserOperatorList.java
new file mode 100644
index 0000000000000000000000000000000000000000..695e41b598838481405863b148c8b04813179107
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/KissenUserOperatorList.java
@@ -0,0 +1,251 @@
+package net.kissenpvp.paper.user;
+
+import com.google.gson.JsonObject;
+import com.mojang.authlib.GameProfile;
+import net.kissenpvp.core.api.database.DataImplementation;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.database.meta.ObjectMeta;
+import net.kissenpvp.core.api.database.queryapi.Column;
+import net.kissenpvp.core.api.database.queryapi.FilterType;
+import net.kissenpvp.core.api.database.queryapi.select.QuerySelect;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.paper.api.base.Context;
+import net.minecraft.server.players.ServerOpList;
+import net.minecraft.server.players.ServerOpListEntry;
+import net.minecraft.server.players.StoredUserEntry;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.File;
+import java.util.*;
+import java.util.concurrent.Executors;
+import java.util.stream.Collectors;
+
+/**
+ * This is a class that extends the functionality of StoredUserList. It provides functionality to manage a list
+ * of users and their operation permissions(data represented by type ServerOpListEntry), related to a game profile
+ * (data represented by type GameProfile).
+ * <p>
+ * An instance of it can be created by providing a file which acts as the storage medium for
+ * this user list.
+ * <p>
+ * This class may provide additions to StoredUserList, capturing behaviors specific to users
+ * who have operator permissions (as denoted by a ServerOpListEntry) linked to a specific game profile.
+ */
+public class KissenUserOperatorList extends ServerOpList {
+
+    private final Set<LinkedOperatorDataNode> cached;
+
+    /**
+     * This is a class that extends the functionality of StoredUserList. It provides functionality to manage a list
+     * of users and their operation permissions (data represented by type ServerOpListEntry), related to a game profile
+     * (data represented by type GameProfile).
+     * <p>
+     * It is initially not associated with any file storage. Thus, the user list is not loaded from any file nor
+     * does it persist between application invocations if not manually persisted.
+     * <p>
+     * This class may provide additions to StoredUserList, capturing behaviors specific to users
+     * who have operator permissions (as denoted by a ServerOpListEntry) linked to a specific game profile.
+     */
+    public KissenUserOperatorList() {
+        //noinspection DataFlowIssue
+        super(null); // not file based
+        this.cached = new HashSet<>();
+    }
+
+    @Override
+    public void add(@NotNull ServerOpListEntry entry) {
+        KissenOperatorDataNode operatorDataNode = new KissenOperatorDataNode(entry.getLevel(), entry.getBypassesPlayerLimit());
+        getCached().removeIf(linkedOperatorDataNode -> linkedOperatorDataNode.gameProfile().equals(entry.getUser()));
+        getCached().add(new LinkedOperatorDataNode(Objects.requireNonNull(entry.getUser()), operatorDataNode));
+
+        Executors.newSingleThreadExecutor().submit(() -> {
+            try {
+                getLocalUserMeta().setRecord(getLocalUserSaveID() + Objects.requireNonNull(entry.getUser()).getId(), "operator", operatorDataNode);
+            } catch (BackendException backendException) {
+                throw new RuntimeException(String.format("Something went wrong when setting the operator data from user %s.", entry.getUser().getName()), backendException);
+            }
+        });
+    }
+
+    @Nullable
+    @Override
+    public ServerOpListEntry get(@NotNull GameProfile key) {
+        return getCached().stream().filter(
+                linkedOperatorDataNode -> linkedOperatorDataNode.gameProfile().equals(key)).findFirst().map(
+                LinkedOperatorDataNode::getServerOpListEntry).orElse(null);
+    }
+
+    @Override
+    public void remove(@NotNull GameProfile key) {
+        getCached().removeIf(linkedOperatorDataNode -> linkedOperatorDataNode.gameProfile().equals(key));
+        Executors.newSingleThreadExecutor().submit(() -> {
+            try {
+                getLocalUserMeta().delete(getLocalUserSaveID() + Objects.requireNonNull(key.getId()), "operator");
+            } catch (BackendException backendException) {
+                throw new RuntimeException(String.format("An error occurred when removing operator rights from user %s.", key.getName()), backendException);
+            }
+        });
+    }
+
+    @Override
+    public void remove(@NotNull StoredUserEntry<GameProfile> entry) {
+        remove(Objects.requireNonNull(entry.getUser()));
+    }
+
+    @Override
+    public String @NotNull [] getUserList() {
+        return getCached().stream().map(
+                linkedOperatorDataNode -> linkedOperatorDataNode.gameProfile().getName()).distinct().toArray(
+                String[]::new);
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return getCached().isEmpty();
+    }
+
+    @Override
+    protected boolean contains(@NotNull GameProfile k0) {
+        return getCached().stream().anyMatch(gameProfile -> gameProfile.gameProfile().equals(k0));
+    }
+
+    @Override
+    public @NotNull Collection<ServerOpListEntry> getEntries() {
+        return getCached().stream().map(LinkedOperatorDataNode::getServerOpListEntry).collect(Collectors.toSet());
+    }
+
+    @Override
+    public void save() {
+        //ignored
+    }
+
+    @Override
+    protected @NotNull StoredUserEntry<GameProfile> createEntry(@NotNull JsonObject json) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public @NotNull File getFile() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void load() {
+        fetchOperators();
+    }
+
+    @Override
+    protected @NotNull String getKeyForUser(@NotNull GameProfile profile) {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * This method fetch operators data from the local user metadata and returns an unmodifiable set of LinkedOperatorDataNode.
+     * Each LinkedOperatorDataNode record holds a GameProfile and a KissenOperatorDataNode which correlates user information and operator data.
+     * <p>
+     * An SQL SELECT query is constructed to fetch the TOTAL_ID and VALUE columns.
+     * Filters are appended to this query to match rows starting with local user SaveID and where KEY equals 'operator'.
+     * The information is fetched into the 'data' array where every array element corresponds to a row from the result.
+     * <p>
+     * The method iterates over each row from the query result:
+     * - Extracts UUID by stripping the SaveID off TOTAL_ID
+     * - Fetches UserInfo from user profiles matching the UUID
+     * - Throws a RuntimeException if no such profile is found
+     * - Constructs KissenOperatorDataNode from the VALUE column data
+     * - The UUID and KissenOperatorDataNode are combined into a new LinkedOperatorDataNode instance and added to the resultant set.
+     * <p>
+     * If any exception is raised during the backend processing, it is wrapped in a runtime exception with an appropriate
+     * error message and thrown, thus indicating the issue with loading operators.
+     * <p>
+     * The method guarantees to return a set of LinkedOperatorDataNode or throw an exception in case of an error.
+     *
+     * @throws RuntimeException if any error occurs while fetching and processing records from the database
+     */
+    private void fetchOperators()
+    {
+        cached.clear();
+
+        QuerySelect select = getLocalUserMeta().select(Column.TOTAL_ID, Column.VALUE).where(Column.TOTAL_ID,
+                getLocalUserSaveID(), FilterType.STARTS_WITH).and(Column.KEY, "operator");
+        select.execute().thenAccept(data ->
+        {
+            UserImplementation userImplementation = Bukkit.getKissen().getImplementation(UserImplementation.class);
+            DataImplementation dataImplementation = Bukkit.getKissen().getImplementation(DataImplementation.class);
+
+            Arrays.stream(data).forEach(current ->
+            {
+                UUID uuid = UUID.fromString(current[0].substring(getLocalUserSaveID().length()));
+                userImplementation.getCachedUserProfile(uuid).map(userInfo ->
+                {
+                    KissenOperatorDataNode node = dataImplementation.fromJson(current[1], KissenOperatorDataNode.class);
+                    return new LinkedOperatorDataNode(new GameProfile(userInfo.getUUID(), userInfo.getName()), node);
+                }).ifPresent(cached::add);
+            });
+        });
+    }
+
+    /**
+     * Retrieves the local user save ID. This is typically used for persisting user data in the {@link Context#LOCAL}.
+     *
+     * @return saved ID of the local user.
+     */
+    private @NotNull String getLocalUserSaveID() {
+        return Bukkit.getKissen().getImplementation(KissenPaperUserImplementation.class).getUserSaveID(Context.LOCAL);
+    }
+
+    /**
+     * Retrieves implementation of {@link KissenPaperUserImplementation} for {@link Context#LOCAL} and gets User Metadata.
+     *
+     * @return object meta of the local user.
+     */
+    private @NotNull ObjectMeta getLocalUserMeta() {
+        return Bukkit.getKissen().getImplementation(KissenPaperUserImplementation.class).getUserMeta(Context.LOCAL);
+    }
+
+    /**
+     * Retrieves the set of LinkedOperatorDataNodes.
+     * <p>
+     * This method returns a set that contains all the LinkedOperatorDataNodes
+     * that are currently being managed.
+     *
+     * @return A Set containing all LinkedOperatorDataNodes.
+     * This returned set is not null.
+     */
+    protected @NotNull Set<LinkedOperatorDataNode> getCached()
+    {
+        return cached;
+    }
+
+    /**
+     * This is a record class that encapsulates a GameProfile and a KissenOperatorDataNode
+     * into a single entity, termed as a LinkedOperatorDataNode.
+     * <p>
+     * It provides a method `getServerOpListEntry()`, that utilizes `getServerOpListEntry`
+     * method from `kissenOperatorDataNode` and passes the `gameProfile` from this record.
+     * Resulting a ServerOpListEntry correlating user profile and operator data.
+     * <p>
+     * GameProfile part of this record is user's profile information & KissenOperatorDataNode is operator data.
+     * <p>
+     * The data items stored in a LinkedOperatorDataNode record can be accessed
+     * directly by name.
+     */
+    protected record LinkedOperatorDataNode(@NotNull GameProfile gameProfile,
+                                          @NotNull KissenOperatorDataNode kissenOperatorDataNode) {
+        /**
+         * Returns ServerOpListEntry that associates with this LinkedOperatorDataNode's operator data and game profile.
+         * The ServerOpListEntry is obtained by calling `getServerOpListEntry` method on `kissenOperatorDataNode`
+         * with `gameProfile` passed as parameter.
+         * <p>
+         * The method is expected to return a new ServerOpListEntry for every call.
+         *
+         * @return ServerOpListEntry constructed from gameProfile and kissenOperatorDataNode
+         */
+        @Contract(" -> new")
+        private @NotNull ServerOpListEntry getServerOpListEntry() {
+            return kissenOperatorDataNode.getServerOpListEntry(gameProfile);
+        }
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenUserWhiteList.java b/src/main/java/net/kissenpvp/paper/user/KissenUserWhiteList.java
new file mode 100644
index 0000000000000000000000000000000000000000..6d8ebd6fd429aa977a8ca61101938a1bd44dd89c
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/KissenUserWhiteList.java
@@ -0,0 +1,157 @@
+package net.kissenpvp.paper.user;
+
+import com.google.gson.JsonObject;
+import com.mojang.authlib.GameProfile;
+import net.kissenpvp.core.api.database.meta.Meta;
+import net.kissenpvp.core.api.database.meta.ObjectMeta;
+import net.kissenpvp.core.api.database.queryapi.Column;
+import net.kissenpvp.core.api.database.queryapi.select.QuerySelect;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.api.user.UserInfo;
+import net.kissenpvp.core.user.UserInfoNode;
+import net.kissenpvp.paper.api.base.Context;
+import net.minecraft.server.players.StoredUserEntry;
+import net.minecraft.server.players.UserWhiteList;
+import net.minecraft.server.players.UserWhiteListEntry;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.*;
+import java.util.function.Predicate;
+import java.util.function.Supplier;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+
+public class KissenUserWhiteList extends UserWhiteList {
+
+    private final Set<UserInfo> whitelisted;
+
+    public KissenUserWhiteList() {
+        //noinspection DataFlowIssue
+        super(null); // not file based
+        this.whitelisted = new HashSet<>();
+    }
+
+    @Override
+    public @NotNull File getFile() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Nullable
+    @Override
+    public UserWhiteListEntry get(@NotNull GameProfile key) {
+        return getWhitelisted().stream().filter(userInfo -> userInfo.getUUID().equals(key.getId())).map(user -> new UserWhiteListEntry(new GameProfile(user.getUUID(), user.getName()))).findFirst().orElse(null);
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return getWhitelisted().isEmpty();
+    }
+
+    @Override
+    protected boolean contains(@NotNull GameProfile k0) {
+        return getWhitelisted().stream().anyMatch(userInfo -> userInfo.getUUID().equals(k0.getId()));
+    }
+
+    @Override
+    public @NotNull Collection<UserWhiteListEntry> getEntries() {
+        return getWhitelisted().stream().map(userInfo -> new GameProfile(userInfo.getUUID(), userInfo.getName())).map(UserWhiteListEntry::new).collect(Collectors.toSet());
+    }
+
+    @Override
+    public String @NotNull [] getUserList() {
+        return getWhitelisted().stream().map(UserInfo::getName).distinct().toArray(String[]::new);
+    }
+
+    @Override
+    public void add(@NotNull UserWhiteListEntry entry) {
+        if (!new io.papermc.paper.event.server.WhitelistStateUpdateEvent(com.destroystokyo.paper.profile.CraftPlayerProfile.asBukkitCopy(Objects.requireNonNull(entry.getUser())), io.papermc.paper.event.server.WhitelistStateUpdateEvent.WhitelistStatus.ADDED).callEvent()) {
+            return;
+        }
+        UserImplementation userImplementation = Bukkit.getKissen().getImplementation(UserImplementation.class);
+
+        Supplier<UserInfo> createNew = () -> new UserInfoNode(entry.getUser().getId(), entry.getUser().getName()).getUserInfo();
+        Predicate<UserInfo> userInfoPredicate = profile -> Objects.equals(entry.getUser().getId(), profile.getUUID());
+
+        whitelisted.removeIf(userInfo -> userInfo.getUUID().equals(entry.getUser().getId()));
+        whitelisted.add(userImplementation.getUserProfiles().stream().filter(userInfoPredicate).findFirst().orElseGet(createNew));
+
+        getLocalUserMeta().setString(getLocalUserSaveID() + Objects.requireNonNull(entry.getUser()).getId(), "whitelist", "1");
+    }
+
+    @Override
+    public void remove(@NotNull GameProfile profile) {
+
+        if (!new io.papermc.paper.event.server.WhitelistStateUpdateEvent(com.destroystokyo.paper.profile.CraftPlayerProfile.asBukkitCopy(profile), io.papermc.paper.event.server.WhitelistStateUpdateEvent.WhitelistStatus.REMOVED).callEvent()) {
+            return;
+        }
+
+        whitelisted.removeIf(userInfo -> Objects.equals(profile.getId(), userInfo.getUUID()));
+        getLocalUserMeta().delete(getLocalUserSaveID() + profile.getId(), "whitelist");
+    }
+
+    @Override
+    public void save() throws IOException {
+        // ignored
+    }
+
+    @Override
+    public void load() throws IOException {
+        fetchWhitelistedUsers();
+    }
+
+    @Override
+    public void remove(@NotNull StoredUserEntry<GameProfile> entry) {
+        remove(Objects.requireNonNull(entry.getUser()));
+    }
+
+    @Override
+    protected @NotNull StoredUserEntry<GameProfile> createEntry(@NotNull JsonObject json) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    protected @NotNull String getKeyForUser(@NotNull GameProfile gameProfile) {
+        throw new UnsupportedOperationException();
+    }
+
+    protected @NotNull Set<UserInfo> getWhitelisted() {
+        return Collections.unmodifiableSet(whitelisted);
+    }
+
+    private void fetchWhitelistedUsers()
+    {
+        whitelisted.clear();
+        Meta meta = getLocalUserMeta();
+
+        QuerySelect querySelect = meta.select(Column.TOTAL_ID).where(Column.KEY, "whitelist").and(Column.VALUE, "1");
+        querySelect.execute().thenAcceptAsync(data ->
+        {
+            UserImplementation userImplementation = Bukkit.getKissen().getImplementation(UserImplementation.class);
+            Stream<UUID> userStream = Arrays.stream(data[0]).map(UUID::fromString);
+            userStream.forEach(uuid -> userImplementation.getCachedUserProfile(uuid).ifPresent(whitelisted::add));
+        });
+    }
+
+    /**
+     * Retrieves implementation of {@link KissenPaperUserImplementation} for {@link Context#LOCAL} and gets User Metadata.
+     *
+     * @return object meta of the local user.
+     */
+    private @NotNull ObjectMeta getLocalUserMeta() {
+        return Bukkit.getKissen().getImplementation(KissenPaperUserImplementation.class).getUserMeta(Context.LOCAL);
+    }
+
+    /**
+     * Retrieves the local user save ID. This is typically used for persisting user data in the {@link Context#LOCAL}.
+     *
+     * @return saved ID of the local user.
+     */
+    private @NotNull String getLocalUserSaveID() {
+        return Bukkit.getKissen().getImplementation(KissenPaperUserImplementation.class).getUserSaveID(Context.LOCAL);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/UserSettingCommand.java b/src/main/java/net/kissenpvp/paper/user/UserSettingCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..47ed5f8f8398b83c4979f3f4068ac36164b2d20d
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/UserSettingCommand.java
@@ -0,0 +1,104 @@
+package net.kissenpvp.paper.user;
+
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.core.api.command.annotations.CommandData;
+import net.kissenpvp.core.api.command.annotations.TabCompleter;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.api.user.exception.UnauthorizedException;
+import net.kissenpvp.core.api.user.usersetttings.PlayerSetting;
+import net.kissenpvp.core.api.user.usersetttings.UserValue;
+import net.kissenpvp.core.user.usersettings.IllegalSettingException;
+import net.kissenpvp.core.user.usersettings.KissenUserBoundSettings;
+import net.kissenpvp.paper.api.command.PaperCommandExceptionHandler;
+import net.kissenpvp.paper.api.networking.client.entity.PaperPlayerClient;
+import net.kyori.adventure.text.Component;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.UUID;
+import java.util.function.Predicate;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public class UserSettingCommand implements PaperCommandExceptionHandler<IllegalSettingException>
+{
+    @Override
+    public boolean handle(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull IllegalSettingException throwable)
+    {
+        Component setting = Component.text(throwable.getSettingsKey());
+        commandPayload.getSender().sendMessage(Component.translatable("server.user.setting.not.found", setting));
+        return true;
+    }
+
+    @CommandData(value = "setting", aliases = "settings")
+    public void settingCommand(@NotNull CommandPayload<CommandSender> sender, @NotNull String setting, @NotNull String value) throws UnauthorizedException
+    {
+        sender.getSender().sendMessage(setSetting(sender, deserialize(setting), value));
+    }
+
+    private <T> @NotNull Component setSetting(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PlayerSetting<T> settingsKey, @NotNull String value) throws UnauthorizedException
+    {
+        Component setting = Component.text(settingsKey.getKey());
+        try
+        {
+            boolean reset = value.equalsIgnoreCase("reset");
+            PaperPlayerClient player = (PaperPlayerClient) commandPayload.getSender();
+            UUID uuid = player.getUniqueId();
+            KissenUserBoundSettings<T> kissenUserBoundSettings = new KissenUserBoundSettings<>(settingsKey, uuid);
+
+            T newValue = reset ? settingsKey.getDefaultValue() : settingsKey.deserialize(value);
+            kissenUserBoundSettings.setValue(newValue);
+
+            String langKey = reset ? "server.user.setting.reset" : "server.user.setting.changed";
+            Component changedTo = Component.text(kissenUserBoundSettings.getUserSetting().serialize(newValue));
+            return Component.translatable(langKey, setting, changedTo);
+        }
+        catch (ClassCastException | IllegalArgumentException exception)
+        {
+            return Component.translatable("server.user.setting.value.invalid", setting, Component.text(value));
+        }
+    }
+
+    @TabCompleter(command = "setting")
+    public @NotNull Collection<String> settingCommand(@NotNull CommandPayload<CommandSender> payload)
+    {
+        try
+        {
+            if (payload.getArguments().length < 2)
+            {
+                return tabCompletion(payload);
+            }
+
+            PlayerSetting<?> playerSetting = deserialize(payload.getArguments()[0]);
+            Stream<? extends @NotNull UserValue<?>> stream = Arrays.stream(playerSetting.getPossibleValues());
+            Stream<String> possibilities = stream.map(value -> castUnknownValue(value, playerSetting));
+            return Stream.concat(Stream.of("reset"), possibilities).collect(Collectors.toSet());
+        }
+        catch (IllegalSettingException ignored) {}
+        return Collections.EMPTY_SET;
+    }
+
+    public @NotNull PlayerSetting<?> deserialize(@NotNull String input)
+    {
+        UserImplementation userImplementation = Bukkit.getKissen().getImplementation(UserImplementation.class);
+        Stream<PlayerSetting<?>> settings = userImplementation.getUserSettings().stream();
+        Predicate<PlayerSetting<?>> predicate = userSetting -> userSetting.getKey().equals(input);
+        return settings.filter(predicate).findFirst().orElseThrow(() -> new IllegalSettingException(input));
+    }
+
+    public @NotNull Collection<String> tabCompletion(@NotNull CommandPayload<CommandSender> commandPayload)
+    {
+        UserImplementation userImplementation = Bukkit.getKissen().getImplementation(UserImplementation.class);
+        Stream<PlayerSetting<?>> settings = userImplementation.getUserSettings().stream();
+        return settings.map(PlayerSetting::getKey).collect(Collectors.toSet());
+    }
+
+    private <T> @NotNull String castUnknownValue(Object value, @NotNull PlayerSetting<T> playerSetting)
+    {
+        return playerSetting.serialize(((UserValue<T>) value).value());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperFallBackRank.java b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperFallBackRank.java
new file mode 100644
index 0000000000000000000000000000000000000000..b16bca5af55d0a4b487637e52801a9c9aa8713e1
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperFallBackRank.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.user.rank;
+
+import net.kissenpvp.core.user.rank.KissenFallBackRank;
+import net.kissenpvp.paper.api.networking.client.entity.PaperPlayerClient;
+import net.kissenpvp.paper.api.user.rank.PaperRank;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Set;
+import java.util.stream.Collectors;
+
+public class KissenPaperFallBackRank extends KissenFallBackRank implements PaperRank {
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPlayerClient> getPlayers() {
+        return Bukkit.getOnlinePlayers().stream().filter(playerClient ->
+        {
+            PaperRank paperRank = playerClient.getRank().getSource();
+            return paperRank.equals(this);
+        }).collect(Collectors.toUnmodifiableSet());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperPlayerFallBackRank.java b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperPlayerFallBackRank.java
new file mode 100644
index 0000000000000000000000000000000000000000..ae0177561b38a8a5ad90084cc97a8e7b4ea3819d
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperPlayerFallBackRank.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.user.rank;
+
+import net.kissenpvp.core.user.rank.KissenPlayerFallBackRank;
+import net.kissenpvp.paper.api.user.rank.PaperPlayerRank;
+import net.kissenpvp.paper.api.user.rank.PaperRank;
+import org.jetbrains.annotations.NotNull;
+
+public class KissenPaperPlayerFallBackRank extends KissenPlayerFallBackRank<PaperRank> implements PaperPlayerRank
+{
+    @Override public @NotNull PaperRank getSource()
+    {
+        return new KissenPaperFallBackRank();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperPlayerRank.java b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperPlayerRank.java
new file mode 100644
index 0000000000000000000000000000000000000000..854aae7c2516fc405c2a1bebe205904db3cd6708
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperPlayerRank.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.user.rank;
+
+import net.kissenpvp.core.database.DataWriter;
+import net.kissenpvp.core.user.rank.KissenPlayerRank;
+import net.kissenpvp.core.user.rank.KissenPlayerRankNode;
+import net.kissenpvp.paper.api.user.rank.PaperPlayerRank;
+import net.kissenpvp.paper.api.user.rank.PaperRank;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class KissenPaperPlayerRank extends KissenPlayerRank<PaperRank> implements PaperPlayerRank {
+    public KissenPaperPlayerRank(@NotNull KissenPlayerRankNode kissenPlayerRankNode, @Nullable DataWriter dataWriter) {
+        super(kissenPlayerRankNode, dataWriter);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperRank.java b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperRank.java
new file mode 100644
index 0000000000000000000000000000000000000000..5fb36d5f5c0bb1bb26378dafcfa5b255438e5e59
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperRank.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.user.rank;
+
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.event.EventImplementation;
+import net.kissenpvp.core.api.networking.socket.DataPackage;
+import net.kissenpvp.core.user.rank.KissenRank;
+import net.kissenpvp.paper.api.networking.client.entity.PaperPlayerClient;
+import net.kissenpvp.paper.api.user.rank.PaperRank;
+import net.kissenpvp.paper.user.rank.event.KissenPaperRankSetChatColorEvent;
+import net.kissenpvp.paper.user.rank.event.KissenPaperRankSetPrefixEvent;
+import net.kissenpvp.paper.user.rank.event.KissenPaperRankSetPriorityEvent;
+import net.kissenpvp.paper.user.rank.event.KissenPaperRankSetSuffixEvent;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.TextColor;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Set;
+import java.util.stream.Collectors;
+
+public class KissenPaperRank extends KissenRank implements PaperRank
+{
+    @Override
+    public void sendData(@NotNull DataPackage dataPackage) {
+        //TODO async network and so on
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPlayerClient> getPlayers() {
+        return Bukkit.getOnlinePlayers().stream().filter(playerClient ->
+        {
+            PaperRank paperRank = playerClient.getRank().getSource();
+            return paperRank.equals(this);
+        }).collect(Collectors.toUnmodifiableSet());
+    }
+
+
+    @Override
+    public void setPriority(int priority)
+    {
+        KissenPaperRankSetPriorityEvent event = new KissenPaperRankSetPriorityEvent(this, getPriority(), priority);
+        EventImplementation eventImplementation = Bukkit.getKissen().getImplementation(EventImplementation.class);
+        if(!eventImplementation.call(event))
+        {
+            throw new EventCancelledException();
+        }
+        super.setPriority(priority);
+    }
+
+    @Override
+    public void setPrefix(@Nullable Component prefix)
+    {
+        KissenPaperRankSetPrefixEvent event = new KissenPaperRankSetPrefixEvent(this, getPrefix().orElse(null), prefix);
+        EventImplementation eventImplementation = Bukkit.getKissen().getImplementation(EventImplementation.class);
+        if(!eventImplementation.call(event))
+        {
+            throw new EventCancelledException();
+        }
+        super.setPrefix(prefix);
+    }
+
+    @Override
+    public void setChatColor(@NotNull TextColor chatColor)
+    {
+        KissenPaperRankSetChatColorEvent event = new KissenPaperRankSetChatColorEvent(this, getChatColor(), chatColor);
+        EventImplementation eventImplementation = Bukkit.getKissen().getImplementation(EventImplementation.class);
+        if(!eventImplementation.call(event))
+        {
+            throw new EventCancelledException();
+        }
+        super.setChatColor(chatColor);
+    }
+
+    @Override
+    public void setSuffix(@Nullable Component suffix)
+    {
+        KissenPaperRankSetSuffixEvent event = new KissenPaperRankSetSuffixEvent(this, getSuffix().orElse(null), suffix);
+        EventImplementation eventImplementation = Bukkit.getKissen().getImplementation(EventImplementation.class);
+        if(!eventImplementation.call(event))
+        {
+            throw new EventCancelledException();
+        }
+        super.setSuffix(suffix);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperRankImplementation.java b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperRankImplementation.java
new file mode 100644
index 0000000000000000000000000000000000000000..12a5d087414bd5040a7030ea5002a0c288a53e36
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperRankImplementation.java
@@ -0,0 +1,59 @@
+package net.kissenpvp.paper.user.rank;
+
+import net.kissenpvp.core.api.database.savable.Savable;
+import net.kissenpvp.core.base.KissenImplementation;
+import net.kissenpvp.core.command.KissenCommandImplementation;
+import net.kissenpvp.core.message.localization.KissenLocalizationImplementation;
+import net.kissenpvp.paper.command.KissenPaperCommandImplementation;
+import net.kissenpvp.core.user.rank.KissenRankImplementation;
+import net.kissenpvp.paper.api.user.rank.PaperRank;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+
+import java.text.MessageFormat;
+
+
+public class KissenPaperRankImplementation extends KissenRankImplementation<PaperRank> implements KissenImplementation
+{
+
+    @Override
+    public boolean start()
+    {
+        KissenLocalizationImplementation localize = Bukkit.getKissen().getImplementation(KissenLocalizationImplementation.class);
+        localize.register("server.rank.edit.prefix.set", new MessageFormat("The prefix from rank {0} has been set to {1}.."));
+        localize.register("server.rank.edit.suffix.set", new MessageFormat("The suffix from rank {0} has been set to {1}.."));
+        localize.register("server.rank.edit.chatcolor.set", new MessageFormat("The chatcolor from rank {0} has been set to {1}."));
+        localize.register("server.rank.edit.priority.set", new MessageFormat("The priority from rank {0} has been set to {1}."));
+
+        localize.register("server.rank.player.granted", new MessageFormat("The player {0} now has the rank {1} granted."));
+        localize.register("server.rank.player.revoked", new MessageFormat("The rank {1} from player {0} has been revoked."));
+        localize.register("server.rank.player.not.found", new MessageFormat("The player {0} does not have a rank with the id {1}."));
+
+        localize.register("server.rank.created", new MessageFormat("The rank {0} has been created with the priority {1} and the chat color {2}."));
+        localize.register("server.rank.deleted", new MessageFormat("The rank {0} has been deleted."));
+
+        Class<KissenCommandImplementation> clazz = KissenCommandImplementation.class;
+        KissenCommandImplementation commandImplementation = Bukkit.getKissen().getImplementation(clazz);
+        commandImplementation.registerParser(PaperRank.class, new PaperRankParser());
+        return super.start();
+    }
+
+    @Override
+    public void setupComplete()
+    {
+        KissenPaperCommandImplementation commandImplementation = Bukkit.getKissen().getImplementation(KissenPaperCommandImplementation.class);
+        commandImplementation.registerCommand(new RankCommand());
+    }
+
+    @Override
+    protected @NotNull Savable getSavableType()
+    {
+        return new KissenPaperRank();
+    }
+
+    @Override
+    protected @NotNull PaperRank getFallbackRank()
+    {
+        return new KissenPaperFallBackRank();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/PaperRankParser.java b/src/main/java/net/kissenpvp/paper/user/rank/PaperRankParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..6b9fa4f17f34a6dcb5c753097238e506c45d0d0a
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/PaperRankParser.java
@@ -0,0 +1,36 @@
+package net.kissenpvp.paper.user.rank;
+
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.paper.api.command.PaperArgumentParser;
+import net.kissenpvp.paper.api.user.rank.PaperRank;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collection;
+import java.util.stream.Collectors;
+
+public class PaperRankParser implements PaperArgumentParser<PaperRank>
+{
+    @Override
+    public @NotNull String serialize(@NotNull PaperRank object)
+    {
+        return object.getName();
+    }
+
+    @Override
+    public @NotNull PaperRank deserialize(@NotNull String input)
+    {
+        Class<KissenPaperRankImplementation> clazz = KissenPaperRankImplementation.class;
+        KissenPaperRankImplementation rankImplementation = Bukkit.getKissen().getImplementation(clazz);
+        return rankImplementation.getRank(input).orElseThrow(NullPointerException::new);
+    }
+
+    @Override
+    public @NotNull Collection<String> tabCompletion(@NotNull CommandPayload<CommandSender> commandPayload)
+    {
+        Class<KissenPaperRankImplementation> clazz = KissenPaperRankImplementation.class;
+        KissenPaperRankImplementation rankImplementation = Bukkit.getKissen().getImplementation(clazz);
+        return rankImplementation.getRankSet().stream().map(PaperRank::getName).collect(Collectors.toSet());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/RankCommand.java b/src/main/java/net/kissenpvp/paper/user/rank/RankCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..ee6d1b23b8a031568d71cd760dff91338390a6f6
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/RankCommand.java
@@ -0,0 +1,158 @@
+package net.kissenpvp.paper.user.rank;
+
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.core.api.command.annotations.CommandData;
+import net.kissenpvp.core.api.command.annotations.TabCompleter;
+import net.kissenpvp.core.api.command.exception.ArgumentMissingException;
+import net.kissenpvp.core.api.time.AccurateDuration;
+import net.kissenpvp.core.api.time.TemporalObject;
+import net.kissenpvp.core.api.user.rank.PlayerRank;
+import net.kissenpvp.paper.api.user.rank.PaperPlayerRank;
+import net.kissenpvp.paper.api.user.rank.PaperRank;
+import net.kissenpvp.paper.command.parser.OfflinePlayerParser;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;
+import org.bukkit.Bukkit;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+
+import java.time.Instant;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Optional;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import java.util.stream.Collectors;
+
+public class RankCommand
+{
+
+    @CommandData("rank")
+    public void rank() {
+        throw new ArgumentMissingException();
+    }
+
+    @CommandData(value = "rank.grant", runAsync = true)
+    public void rankGrant(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull OfflinePlayer offlinePlayer, @NotNull PaperRank paperRank, @NotNull Optional<AccurateDuration> accurateDuration)
+    {
+        Function<AccurateDuration, PaperPlayerRank> grant = duration -> offlinePlayer.grantRank(paperRank, duration);
+        Supplier<PaperPlayerRank> orElse = () -> offlinePlayer.grantRank(paperRank);
+        commandPayload.getSender().sendMessage(rankGrant(offlinePlayer, accurateDuration.map(grant).orElseGet(orElse)));
+    }
+
+    @CommandData(value = "rank.revoke", runAsync = true)
+    public void rankRevoke(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull OfflinePlayer offlinePlayer, @NotNull String id)
+    {
+        commandPayload.getSender().sendMessage(rankRevoke(offlinePlayer, id));
+    }
+
+    @CommandData(value = "rankedit", aliases = "re")
+    public void rankEdit()
+    {
+        throw new ArgumentMissingException();
+    }
+
+    @CommandData(value = "rankedit.prefix", runAsync = true)
+    public void rankPrefix(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PaperRank paperRank, @NotNull String[] prefix)
+    {
+        String mounted = String.join(" ", prefix).replace('&', '§');
+        Component prefixComponent = LegacyComponentSerializer.legacySection().deserialize(mounted);
+        paperRank.setPrefix(prefixComponent);
+
+        Component[] args = {Component.text(paperRank.getName()), prefixComponent};
+        commandPayload.getSender().sendMessage(Component.translatable("server.rank.edit.prefix.set", args));
+    }
+
+    @CommandData(value = "rankedit.suffix", runAsync = true)
+    public void rankSuffix(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PaperRank paperRank, @NotNull String[] suffix)
+    {
+        String mounted = String.join(" ", suffix).replace('&', '§');
+        Component suffixComponent = LegacyComponentSerializer.legacyAmpersand().deserialize(mounted);
+        paperRank.setSuffix(suffixComponent);
+
+        Component[] args = {Component.text(paperRank.getName()), suffixComponent};
+        commandPayload.getSender().sendMessage(Component.translatable("server.rank.edit.suffix.set", args));
+    }
+
+    @CommandData(value = "rankedit.priority", runAsync = true)
+    public void rankRevoke(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PaperRank paperRank, int priority)
+    {
+        paperRank.setPriority(priority);
+
+        Component[] args = {Component.text(paperRank.getName()), Component.text(priority)};
+        commandPayload.getSender().sendMessage(Component.translatable("server.rank.edit.priority.set", args));
+    }
+
+    @CommandData(value = "rankedit.chatcolor", runAsync = true)
+    public void rankRevoke(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PaperRank paperRank, @NotNull NamedTextColor namedTextColor)
+    {
+        paperRank.setChatColor(namedTextColor);
+        Component[] args = {Component.text(paperRank.getName()), Component.text(namedTextColor.toString())};
+        commandPayload.getSender().sendMessage(Component.translatable("server.rank.edit.chatcolor.set", args));
+    }
+
+    @CommandData(value = "rankcreate", aliases = "createrank", runAsync = true)
+    public void rankCreate(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull String name, int priority, @NotNull NamedTextColor namedTextColor)
+    {
+        Class<KissenPaperRankImplementation> clazz = KissenPaperRankImplementation.class;
+        KissenPaperRankImplementation rankImplementation = Bukkit.getKissen().getImplementation(clazz);
+        Map<String, String> data = new HashMap<>();
+        data.put("priority", String.valueOf(priority));
+        data.put("chat_color", namedTextColor.asHexString());
+
+        PaperRank paperRank = rankImplementation.createRank(name, data);
+        Component[] args = {Component.text(paperRank.getName()),
+                            Component.text(priority),
+                            Component.text(namedTextColor.toString())};
+        commandPayload.getSender().sendMessage(Component.translatable("server.rank.created", args));
+    }
+
+    @CommandData(value = "rankdelete", aliases = "deleterank", runAsync = true)
+    public void rankDelete(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PaperRank paperRank)
+    {
+        paperRank.delete();
+        commandPayload.getSender().sendMessage(
+                Component.translatable("server.rank.deleted", Component.text(paperRank.getName())));
+    }
+
+    private @NotNull Component rankGrant(@NotNull OfflinePlayer offlinePlayer, @NotNull PaperPlayerRank paperPlayerRank)
+    {
+        Component rankName = Component.text(paperPlayerRank.getSource().getName());
+        return Component.translatable("server.rank.granted", offlinePlayer.displayName(), rankName);
+    }
+
+    public @NotNull Component rankRevoke(@NotNull OfflinePlayer offlinePlayer, @NotNull String id)
+    {
+        Component[] args = {offlinePlayer.displayName(), Component.text(id)};
+
+        if (offlinePlayer.getRankHistory().stream().anyMatch(current ->
+        {
+            if (current.getID().equals(id) && current.isValid())
+            {
+                current.setEnd(Instant.now());
+                return true;
+            }
+            return false;
+        }))
+        {
+            return Component.translatable("server.rank.player.revoked", args);
+        }
+        return Component.translatable("server.rank.player.not.found", args);
+    }
+
+    @TabCompleter(command = "rank.revoke")
+    public @NotNull Collection<String> rankRevokeTab(@NotNull CommandPayload<CommandSender> commandPayload)
+    {
+        OfflinePlayerParser offlinePlayerParser = new OfflinePlayerParser();
+        if (commandPayload.getArguments().length < 2)
+        {
+            return offlinePlayerParser.tabCompletion(commandPayload);
+        }
+        OfflinePlayer offlinePlayer = offlinePlayerParser.deserialize(commandPayload.getArguments()[0]);
+        return offlinePlayer.getRankHistory().stream().filter(TemporalObject::isValid).map(PlayerRank::getID).collect(
+                Collectors.toSet());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetChatColorEvent.java b/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetChatColorEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..52aedab9c4f0828cca92b4f3ff6ba187085be160
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetChatColorEvent.java
@@ -0,0 +1,15 @@
+package net.kissenpvp.paper.user.rank.event;
+
+import net.kissenpvp.core.api.user.rank.event.RankSetChatColorEvent;
+import net.kissenpvp.core.user.rank.event.KissenRankSetEvent;
+import net.kissenpvp.paper.api.user.rank.PaperRank;
+import net.kyori.adventure.text.format.TextColor;
+import org.jetbrains.annotations.NotNull;
+
+public class KissenPaperRankSetChatColorEvent extends KissenRankSetEvent<PaperRank, TextColor> implements RankSetChatColorEvent<PaperRank>
+{
+    public KissenPaperRankSetChatColorEvent(@NotNull PaperRank rank, @NotNull TextColor old, @NotNull TextColor updated)
+    {
+        super(rank, old, updated);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetPrefixEvent.java b/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetPrefixEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..7f644e5a133b5f85807f7ee2ec2fb6a0d71d3d75
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetPrefixEvent.java
@@ -0,0 +1,16 @@
+package net.kissenpvp.paper.user.rank.event;
+
+import net.kissenpvp.core.api.user.rank.event.RankSetPrefixEvent;
+import net.kissenpvp.core.user.rank.event.KissenRankSetEvent;
+import net.kissenpvp.paper.api.user.rank.PaperRank;
+import net.kyori.adventure.text.Component;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class KissenPaperRankSetPrefixEvent extends KissenRankSetEvent<PaperRank, Component> implements RankSetPrefixEvent<PaperRank>
+{
+    public KissenPaperRankSetPrefixEvent(@NotNull PaperRank rank, @Nullable Component old, @Nullable Component updated)
+    {
+        super(rank, old, updated);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetPriorityEvent.java b/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetPriorityEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..b8935be5d3201d3d88e5cc51a5990a33a21ad37b
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetPriorityEvent.java
@@ -0,0 +1,14 @@
+package net.kissenpvp.paper.user.rank.event;
+
+import net.kissenpvp.core.api.user.rank.event.RankSetPriorityEvent;
+import net.kissenpvp.core.user.rank.event.KissenRankSetEvent;
+import net.kissenpvp.paper.api.user.rank.PaperRank;
+import org.jetbrains.annotations.NotNull;
+
+public class KissenPaperRankSetPriorityEvent extends KissenRankSetEvent<PaperRank, Integer> implements RankSetPriorityEvent<PaperRank>
+{
+    public KissenPaperRankSetPriorityEvent(@NotNull PaperRank rank, @NotNull Integer old, @NotNull Integer updated)
+    {
+        super(rank, old, updated);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetSuffixEvent.java b/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetSuffixEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..1fa9a490165d87b19312001931bb3dd5881ed833
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetSuffixEvent.java
@@ -0,0 +1,16 @@
+package net.kissenpvp.paper.user.rank.event;
+
+import net.kissenpvp.core.api.user.rank.event.RankSetPrefixEvent;
+import net.kissenpvp.core.user.rank.event.KissenRankSetEvent;
+import net.kissenpvp.paper.api.user.rank.PaperRank;
+import net.kyori.adventure.text.Component;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class KissenPaperRankSetSuffixEvent extends KissenRankSetEvent<PaperRank, Component> implements RankSetPrefixEvent<PaperRank>
+{
+    public KissenPaperRankSetSuffixEvent(@NotNull PaperRank rank, @Nullable Component old, @Nullable Component updated)
+    {
+        super(rank, old, updated);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Main.java b/src/main/java/net/minecraft/server/Main.java
index 7573c12a77797146c51ef2dfe4b2a636df45e21a..29784060d8b0824488a7717f1b7ebf9a55c9375c 100644
--- a/src/main/java/net/minecraft/server/Main.java
+++ b/src/main/java/net/minecraft/server/Main.java
@@ -190,15 +190,17 @@ public class Main {
             org.spigotmc.SpigotConfig.disabledAdvancements = spigotConfiguration.getStringList("advancements.disabled"); // Paper - fix SPIGOT-5885, must be set early in init
             // Paper start - fix SPIGOT-5824
             File file;
-            File userCacheFile = new File(Services.USERID_CACHE_FILE);
+            /* KissenPaper - remove cache file
+             * File userCacheFile = new File(Services.USERID_CACHE_FILE);
+             */
             if (optionset.has("universe")) {
                 file = (File) optionset.valueOf("universe"); // CraftBukkit
-                userCacheFile = new File(file, Services.USERID_CACHE_FILE);
+                //userCacheFile = new File(file, Services.USERID_CACHE_FILE); // KissenPaper
             } else {
                 file = new File(bukkitConfiguration.getString("settings.world-container", "."));
             }
             // Paper end - fix SPIGOT-5824
-            Services services = Services.create(new com.destroystokyo.paper.profile.PaperAuthenticationService(Proxy.NO_PROXY), file, userCacheFile, optionset); // Paper
+            Services services = Services.create(new com.destroystokyo.paper.profile.PaperAuthenticationService(Proxy.NO_PROXY), file/*, userCacheFile KissenPaper - remove cache file*/, optionset); // Paper
             // CraftBukkit start
             String s = (String) Optional.ofNullable((String) optionset.valueOf("world")).orElse(dedicatedserversettings.getProperties().levelName);
             LevelStorageSource convertable = LevelStorageSource.createDefault(file.toPath());
diff --git a/src/main/java/net/minecraft/server/Services.java b/src/main/java/net/minecraft/server/Services.java
index a5450eeeab5a6b0ab273810063806d11107d6b26..8c7b227a5a50d13181c2d80f788e23cd2dca1471 100644
--- a/src/main/java/net/minecraft/server/Services.java
+++ b/src/main/java/net/minecraft/server/Services.java
@@ -24,10 +24,10 @@ public record Services(MinecraftSessionService sessionService, ServicesKeySet se
     // Paper end
     public static final String USERID_CACHE_FILE = "usercache.json"; // Paper - private -> public
 
-    public static Services create(YggdrasilAuthenticationService authenticationService, File rootDirectory, File userCacheFile, joptsimple.OptionSet optionSet) throws Exception { // Paper
+    public static Services create(YggdrasilAuthenticationService authenticationService, File rootDirectory /*, File userCacheFile KissenPaper - remove file*/, joptsimple.OptionSet optionSet) throws Exception { // Paper
         MinecraftSessionService minecraftSessionService = authenticationService.createMinecraftSessionService();
         GameProfileRepository gameProfileRepository = authenticationService.createProfileRepository();
-        GameProfileCache gameProfileCache = new GameProfileCache(gameProfileRepository, userCacheFile); // Paper
+        GameProfileCache gameProfileCache = /*new GameProfileCache(gameProfileRepository, userCacheFile); // Paper*/ new net.kissenpvp.paper.user.KissenPaperProfileCache(gameProfileRepository); // KissenPaper
         // Paper start
         final java.nio.file.Path legacyConfigPath = ((File) optionSet.valueOf("paper-settings")).toPath();
         final java.nio.file.Path configDirPath = ((File) optionSet.valueOf("paper-settings-directory")).toPath();
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedPlayerList.java b/src/main/java/net/minecraft/server/dedicated/DedicatedPlayerList.java
index 935dac757280731bfeb0a8f033cbe315ecac46da..932c83a9d41ddff73d38e87ac7d97fadf5c5b8c2 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedPlayerList.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedPlayerList.java
@@ -30,7 +30,7 @@ public class DedicatedPlayerList extends PlayerList {
         this.loadOps();
         this.loadWhiteList();
         this.saveOps();
-        if (!this.getWhiteList().getFile().exists()) {
+        if (/*!this.getWhiteList().getFile().exists()*/ true) { // KissenPaper
             this.saveWhiteList();
         }
 
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index be05a52be037042c6158100e2ce880b8ed415d53..0f3758071754eef2c9bd8a464a20b210bcd8149f 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -2084,17 +2084,22 @@ public class ServerPlayer extends Player {
 
     public void sendSystemMessage(Component message, boolean overlay) {
         if (this.acceptsSystemMessages(overlay)) {
-            this.connection.send(new ClientboundSystemChatPacket(message, overlay), PacketSendListener.exceptionallySend(() -> {
-                if (this.acceptsSystemMessages(false)) {
-                    boolean flag1 = true;
-                    String s = message.getString(256);
-                    MutableComponent ichatmutablecomponent = Component.literal(s).withStyle(ChatFormatting.YELLOW);
-
-                    return new ClientboundSystemChatPacket(Component.translatable("multiplayer.message_not_delivered", ichatmutablecomponent).withStyle(ChatFormatting.RED), false);
-                } else {
-                    return null;
-                }
-            }));
+            // KissenPaper start - add custom renderer
+            net.kyori.adventure.text.Component component = PaperAdventure.asAdventure(message);
+            Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.message.ChatImplementation.class).prepareMessage(Bukkit.getConsoleSender(), getBukkitEntity(), component).ifPresent(styled ->
+                this.connection.send(new ClientboundSystemChatPacket(styled, overlay), PacketSendListener.exceptionallySend(() -> {
+                    if (this.acceptsSystemMessages(false)) {
+                        boolean flag1 = true;
+                        String s = message.getString(256);
+                        MutableComponent ichatmutablecomponent = Component.literal(s).withStyle(ChatFormatting.YELLOW);
+
+                        return new ClientboundSystemChatPacket(PaperAdventure.asAdventure(Component.translatable("multiplayer.message_not_delivered", ichatmutablecomponent).withStyle(ChatFormatting.RED)), false);
+                    } else {
+                        return null;
+                    }
+                }))
+            );
+            // KissenPaper end
         }
     }
 
diff --git a/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
index 8ce2fd887d9c2cf86fa4ec0332b70681f1572911..fa53db3e5ba305212878bc04334f628f2f9ca88b 100644
--- a/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
@@ -45,6 +45,13 @@ import org.bukkit.event.player.AsyncPlayerPreLoginEvent;
 import org.bukkit.event.player.PlayerPreLoginEvent;
 // CraftBukkit end
 
+// KissenPaper start
+import org.bukkit.Bukkit;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.user.KissenUserImplementation;
+import net.kissenpvp.paper.user.KissenPaperPublicUser;
+// KissenPaper end
+
 public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener, TickablePacketListener {
 
     private static final AtomicInteger UNIQUE_THREAD_ID = new AtomicInteger(0);
@@ -302,6 +309,16 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener,
                             disconnect("This server requires you to connect with Velocity.");
                             return;
                         }
+
+                        // KissenPaper start
+                        KissenPaperPublicUser kissenPaperPublicUser = new KissenPaperPublicUser(gameprofile.getId(), gameprofile.getName());
+                        if (!loginUser(kissenPaperPublicUser, gameprofile))
+                        {
+                            kissenPaperPublicUser.logout();
+                            return;
+                        }
+                        // KissenPaper end
+
                         // Paper end
                         String playerName = gameprofile.getName();
                         java.net.InetAddress address = ((java.net.InetSocketAddress) ServerLoginPacketListenerImpl.this.connection.getRemoteAddress()).getAddress();
@@ -347,6 +364,47 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener,
                         ServerLoginPacketListenerImpl.LOGGER.info("UUID of player {} is {}", gameprofile.getName(), gameprofile.getId());
                         ServerLoginPacketListenerImpl.this.startClientVerification(gameprofile);
         }
+
+        // KissenPaper start
+        /**
+         * Attempts to log in a user represented by a GameProfile object. This includes loading the KissenPaperPublicUser via a
+         * KissenUserImplementation, checking the user's ban status, and if not banned, loading the user's
+         * private data.
+         *
+         * <p>If the user cannot be loaded, or they have an outstanding punishment, the method
+         * will disconnect them with an appropriate message and return false. If an exception occurs in the process,
+         * the user is also disconnected and false is returned. If the user is loaded successfully and has no
+         * outstanding punishments, true is returned.</p>
+         *
+         * @param gameProfile The GameProfile of the user attempting to log in. This parameter must not be null.
+         * @return true if the user was successfully logged in, false otherwise.
+         * @throws NullPointerException If gameProfile is null.
+         *
+         * @see KissenPaperPublicUser
+         * @see net.kissenpvp.paper.api.ban.PaperBanImplementation
+         * @see net.kissenpvp.paper.api.ban.PaperPunishment
+         * @see GameProfile
+         */
+        private boolean loginUser(@org.jetbrains.annotations.NotNull KissenPaperPublicUser kissenPaperPublicUser, @org.jetbrains.annotations.NotNull GameProfile gameProfile) {
+            try {
+                if(!Bukkit.getKissen().getImplementation(KissenUserImplementation.class).loadUser(kissenPaperPublicUser))
+                {
+                    disconnect(Component.translatable("multiplayer.disconnect.unverified_username"));
+                    return false;
+                }
+
+                if(Bukkit.hasWhitelist() && !MinecraftServer.getServer().getPlayerList().isWhiteListed(gameProfile))
+                {
+                    disconnect(Component.translatable("multiplayer.disconnect.not_whitelisted"));
+                    return false;
+                }
+            } catch (BackendException backendException) {
+                disconnect(Component.translatable("multiplayer.disconnect.unverified_username")); // maybe better message
+                return false;
+            }
+            return true;
+        }
+        // KissenPaper end
     }
     // Spigot end
 
diff --git a/src/main/java/net/minecraft/server/players/GameProfileCache.java b/src/main/java/net/minecraft/server/players/GameProfileCache.java
index 452fbb0aa44157225d8a9064e3eae2db7771b27d..4bcf963cf96d8443bc38f0a2d554b4d3d72e8802 100644
--- a/src/main/java/net/minecraft/server/players/GameProfileCache.java
+++ b/src/main/java/net/minecraft/server/players/GameProfileCache.java
@@ -230,7 +230,7 @@ public class GameProfileCache {
         return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z", Locale.ROOT);
     }
 
-    public List<GameProfileCache.GameProfileInfo> load() {
+    protected List<GameProfileCache.GameProfileInfo> load() { // KissenPaper - private -> protected
         ArrayList arraylist = Lists.newArrayList();
 
         try {
@@ -401,7 +401,7 @@ public class GameProfileCache {
         }
     }
 
-    private static class GameProfileInfo {
+    protected static class GameProfileInfo { // KissenPaper - private -> protected
 
         private final GameProfile profile;
         final Date expirationDate;
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index e98a455b6bca9d094d0da323bddd7b3f2c07bb23..b85198a78cacd4c4d553542be7bdfd9e58a38bfa 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -165,8 +165,8 @@ public abstract class PlayerList {
 
         this.bans = new UserBanList(PlayerList.USERBANLIST_FILE);
         this.ipBans = new IpBanList(PlayerList.IPBANLIST_FILE);
-        this.ops = new ServerOpList(PlayerList.OPLIST_FILE);
-        this.whitelist = new UserWhiteList(PlayerList.WHITELIST_FILE);
+        this.ops = /*new ServerOpList(PlayerList.OPLIST_FILE);*/ new net.kissenpvp.paper.user.KissenUserOperatorList(); // KissenPaper
+        this.whitelist = /*new UserWhiteList(PlayerList.WHITELIST_FILE);*/ new net.kissenpvp.paper.user.KissenUserWhiteList(); // KissenPaper
         // CraftBukkit start
         // this.stats = Maps.newHashMap();
         // this.advancements = Maps.newHashMap();
@@ -340,6 +340,13 @@ public abstract class PlayerList {
         // Ensure that player inventory is populated with its viewer
         player.containerMenu.transferTo(player.containerMenu, bukkitPlayer);
 
+        // KissenPaper start
+        if(!org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.core.user.KissenUserImplementation.class).loginUser(bukkitPlayer.getUser()))
+        {
+            //TODO disconnect player
+        }
+        // KissenPaper end
+
         PlayerJoinEvent playerJoinEvent = new PlayerJoinEvent(bukkitPlayer, io.papermc.paper.adventure.PaperAdventure.asAdventure(ichatmutablecomponent)); // Paper - Adventure
         this.cserver.getPluginManager().callEvent(playerJoinEvent);
 
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java b/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java
index 2bbc39c257965ad91ee360cdfcd3538a0f041c7e..8d26d3416f8fde9b70fa4e0bd9469cc0c51f1d3d 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java
@@ -9,6 +9,8 @@ import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.UUID;
+
+import net.kissenpvp.core.api.networking.client.entitiy.ServerEntity;
 import net.minecraft.core.GlobalPos;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.NbtOps;
@@ -27,12 +29,47 @@ import org.bukkit.ban.ProfileBanList;
 import org.bukkit.configuration.serialization.ConfigurationSerializable;
 import org.bukkit.configuration.serialization.SerializableAs;
 import org.bukkit.craftbukkit.entity.memory.CraftMemoryMapper;
-import org.bukkit.craftbukkit.profile.CraftPlayerProfile;
 import org.bukkit.entity.EntityType;
 import org.bukkit.entity.Player;
 import org.bukkit.metadata.MetadataValue;
 import org.bukkit.plugin.Plugin;
-import org.bukkit.profile.PlayerProfile;
+
+// KissenPaper start
+import org.bukkit.permissions.Permission;
+import org.bukkit.permissions.Permissible;
+import org.bukkit.permissions.PermissionAttachment;
+import org.bukkit.permissions.PermissionAttachmentInfo;
+
+import java.util.Optional;
+import java.util.Set;
+import java.util.Locale;
+
+import net.kissenpvp.core.api.ban.Ban;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.message.Theme;
+import net.kissenpvp.core.api.permission.PermissionGroup;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.api.user.rank.Rank;
+import net.kissenpvp.core.api.user.suffix.Suffix;
+import net.kissenpvp.core.api.user.usersetttings.PlayerSetting;
+import net.kissenpvp.core.api.user.usersetttings.UserSetting;
+import net.kissenpvp.paper.api.ban.PaperPunishment;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.networking.client.entity.PaperOnlinePlayerClient;
+import net.kissenpvp.paper.api.permission.PaperPermissible;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PermissibleOverriddenException;
+import net.kissenpvp.paper.api.user.rank.PaperPlayerRank;
+import net.kissenpvp.paper.networking.client.entity.KissenPaperPlayerClient;
+import net.kissenpvp.paper.permission.permissible.KissenPaperPlayerPermissible;
+import net.kyori.adventure.text.Component;
+import net.kissenpvp.core.api.time.AccurateDuration;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+// KissenPaper end
 
 @SerializableAs("Player")
 public class CraftOfflinePlayer implements OfflinePlayer, ConfigurationSerializable {
@@ -41,6 +78,14 @@ public class CraftOfflinePlayer implements OfflinePlayer, ConfigurationSerializa
     private final CraftServer server;
     private final PlayerDataStorage storage;
 
+    // KissenPaper start
+    private final Permissible permissible = new KissenPaperPlayerPermissible(this) {
+        @Override public void permissionUpdate() { /* ignored */ }
+        @Override public void unsubscribe() { /* ignored */ }
+    };
+    private KissenPaperPlayerClient kissenPaperPlayerClient;
+    // KissenPaper end
+
     protected CraftOfflinePlayer(CraftServer server, GameProfile profile) {
         this.server = server;
         this.profile = profile;
@@ -567,4 +612,403 @@ public class CraftOfflinePlayer implements OfflinePlayer, ConfigurationSerializa
             manager.save();
         }
     }
+
+    // KissenPaper start - integrate kissen user
+
+    private @NotNull KissenPaperPlayerClient getKissenPaperPlayerClient()
+    {
+        if(kissenPaperPlayerClient == null) {
+            kissenPaperPlayerClient = new KissenPaperPlayerClient() {
+
+                private User cachedUser;
+
+                @Override
+                public @NotNull User getUser() {
+                    return Optional.ofNullable(cachedUser).orElseGet(() ->
+                    {
+                        cachedUser = super.getUser();
+                        return cachedUser;
+                    });
+                }
+
+                @Override
+                public @NotNull PaperPermissible getPermissible() throws PermissibleOverriddenException {
+                    return (PaperPermissible) permissible;
+                }
+
+                @Override
+                public @NotNull UUID getUniqueId() {
+                    return CraftOfflinePlayer.this.getUniqueId();
+                }
+
+                @Override
+                public boolean isConnected() {
+                    return false;
+                }
+            };
+        }
+        return kissenPaperPlayerClient;
+    }
+
+    @Override
+    public final boolean isClient() {
+        return true;
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAltAccounts() throws BackendException {
+        return getKissenPaperPlayerClient().getAltAccounts();
+    }
+
+    @Override
+    public @NotNull UUID getTotalID() {
+        return getKissenPaperPlayerClient().getTotalID();
+    }
+
+    @Override
+    public @NotNull PaperPunishment punish(@NotNull Ban ban, @NotNull ServerEntity banOperator) throws BackendException {
+        return getKissenPaperPlayerClient().punish(ban, banOperator);
+    }
+
+    @Override
+    public @NotNull PaperPunishment punish(@NotNull Ban ban, @NotNull ServerEntity banOperator, @Nullable Component reason) throws BackendException {
+        return getKissenPaperPlayerClient().punish(ban, banOperator, reason);
+    }
+
+    @Override
+    public @NotNull Optional<PaperPunishment> getPunishment(@NotNull String id) throws BackendException {
+        return getKissenPaperPlayerClient().getPunishment(id);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<PaperPunishment> getPunishmentHistory() throws BackendException {
+        return getKissenPaperPlayerClient().getPunishmentHistory();
+    }
+
+    @Override
+    public @NotNull Component displayName() {
+        return getKissenPaperPlayerClient().displayName();
+    }
+
+    @Override
+    public @NotNull Component styledRankName() {
+        return getKissenPaperPlayerClient().styledRankName();
+    }
+
+    @Override
+    public @NotNull Set<Suffix> getSuffixSet() {
+        return getKissenPaperPlayerClient().getSuffixSet();
+    }
+
+    @Override
+    public @NotNull Optional<Suffix> getSuffix(@NotNull String name) {
+        return getKissenPaperPlayerClient().getSuffix(name);
+    }
+
+    @Override
+    public @NotNull Optional<Suffix> setSuffix(@NotNull String name, @NotNull Component content) {
+        return getKissenPaperPlayerClient().setSuffix(name, content);
+    }
+
+    @Override
+    public boolean deleteSuffix(@NotNull String name) {
+        return getKissenPaperPlayerClient().deleteSuffix(name);
+    }
+
+    @Override
+    public @NotNull Optional<Suffix> getSelectedSuffix() {
+        return getKissenPaperPlayerClient().getSelectedSuffix();
+    }
+
+    @Override
+    public void setSelectedSuffix(@NotNull String name) throws NullPointerException {
+        getKissenPaperPlayerClient().setSelectedSuffix(name);
+    }
+
+    @Override
+    public long getOnlineTime() {
+        return getKissenPaperPlayerClient().getOnlineTime();
+    }
+
+    @Override
+    public @NotNull User getUser() {
+        return getKissenPaperPlayerClient().getUser();
+    }
+
+    @Override
+    public @NotNull <X> UserSetting<X> getUserSetting(Class<? extends PlayerSetting<X>> settingClass) {
+        return getKissenPaperPlayerClient().getUserSetting(settingClass);
+    }
+
+    @Override
+    public @NotNull Theme getTheme() {
+        return getKissenPaperPlayerClient().getTheme();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<PaperPlayerRank> getRankHistory() {
+        return getKissenPaperPlayerClient().getRankHistory();
+    }
+
+    @Override
+    public @NotNull PaperPlayerRank getRank() {
+        return getKissenPaperPlayerClient().getRank();
+    }
+
+    @Override
+    public @NotNull PaperPlayerRank grantRank(@NotNull Rank rank) {
+        return getKissenPaperPlayerClient().grantRank(rank);
+    }
+
+    @Override
+    public @NotNull PaperPlayerRank grantRank(@NotNull Rank rank, @Nullable AccurateDuration accurateDuration) {
+        return getKissenPaperPlayerClient().grantRank(rank, accurateDuration);
+    }
+
+    @Override
+    public @NotNull Locale getCurrentLocale() {
+        return getKissenPaperPlayerClient().getCurrentLocale();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<@NotNull PaperOnlinePlayerClient> getOnlineAltAccounts() {
+        return getKissenPaperPlayerClient().getOnlineAltAccounts();
+    }
+
+    @Override
+    public @NotNull Set<Suffix> getSuffixSet(@NotNull Context context) {
+        return getKissenPaperPlayerClient().getSuffixSet(context);
+    }
+
+    @Override
+    public @NotNull Optional<Suffix> getSuffix(@NotNull String name, @NotNull Context context) {
+        return getKissenPaperPlayerClient().getSuffix(name, context);
+    }
+
+    @Override
+    public @NotNull Optional<Suffix> setSuffix(@NotNull String name, @NotNull Component content, @NotNull Context context) {
+        return getKissenPaperPlayerClient().setSuffix(name, content, context);
+    }
+
+    @Override
+    public boolean deleteSuffix(@NotNull String name, @NotNull Context context) {
+        return getKissenPaperPlayerClient().deleteSuffix(name, context);
+    }
+
+    @Override
+    public void setSelectedSuffix(@NotNull String name, @NotNull Context context) throws NullPointerException {
+        getKissenPaperPlayerClient().setSelectedSuffix(name, context);
+    }
+
+    @Override
+    public long getOnlineTime(@NotNull Context context) {
+        return getKissenPaperPlayerClient().getOnlineTime(context);
+    }
+
+    @Override
+    public long getLastPlayed(@NotNull Context context) {
+        return getKissenPaperPlayerClient().getLastPlayed(context);
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull Context context) {
+        return getKissenPaperPlayerClient().getUser(context);
+    }
+
+    @Override
+    public @NotNull PaperPermissible getPermissible() throws PermissibleOverriddenException {
+        return getKissenPaperPlayerClient().getPermissible();
+    }
+
+    @Override
+    public boolean isPermissionSet(@NotNull String name) {
+        return getKissenPaperPlayerClient().getPermissionContext().isPermissionSet(name);
+    }
+
+    @Override
+    public boolean isPermissionSet(@NotNull Permission perm) {
+        return getKissenPaperPlayerClient().getPermissionContext().isPermissionSet(perm);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String name) {
+        return getKissenPaperPlayerClient().getPermissionContext().hasPermission(name);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull Permission perm) {
+        return getKissenPaperPlayerClient().getPermissionContext().hasPermission(perm);
+    }
+
+    @Override
+    public @NotNull PermissionAttachment addAttachment(@NotNull Plugin plugin, @NotNull String name, boolean value) {
+        return getKissenPaperPlayerClient().getPermissionContext().addAttachment(plugin, name, value);
+    }
+
+    @Override
+    public @NotNull PermissionAttachment addAttachment(@NotNull Plugin plugin) {
+        return getKissenPaperPlayerClient().getPermissionContext().addAttachment(plugin);
+    }
+
+    @Override
+    public @Nullable PermissionAttachment addAttachment(@NotNull Plugin plugin, @NotNull String name, boolean value, int ticks) {
+        return getKissenPaperPlayerClient().getPermissionContext().addAttachment(plugin, name, value, ticks);
+    }
+
+    @Override
+    public @Nullable PermissionAttachment addAttachment(@NotNull Plugin plugin, int ticks) {
+        return getKissenPaperPlayerClient().getPermissionContext().addAttachment(plugin, ticks);
+    }
+
+    @Override
+    public void removeAttachment(@NotNull PermissionAttachment attachment) {
+        getKissenPaperPlayerClient().getPermissionContext().removeAttachment(attachment);
+    }
+
+    @Override
+    public void recalculatePermissions() {
+        getKissenPaperPlayerClient().getPermissionContext().recalculatePermissions();
+    }
+
+    @Override
+    public @NotNull Set<PermissionAttachmentInfo> getEffectivePermissions() {
+        return getKissenPaperPlayerClient().getPermissionContext().getEffectivePermissions();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getOwnPermissions() {
+        return getKissenPaperPlayerClient().getPermissionContext().getOwnPermissions();
+    }
+
+    @Override
+    public int wipeGroups() {
+        return getKissenPaperPlayerClient().getPermissionContext().wipeGroups();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups() {
+        return getKissenPaperPlayerClient().getPermissionContext().getPermissionGroups();
+    }
+
+    @Override
+    public boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup) {
+        return getKissenPaperPlayerClient().getPermissionContext().inGroup(permissionGroup);
+    }
+
+    @Override
+    public @NotNull String getPermissionID() {
+        return getKissenPaperPlayerClient().getPermissionContext().getPermissionID();
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission) throws EventCancelledException {
+        return getKissenPaperPlayerClient().getPermissionContext().setPermission(permission);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, boolean value) throws EventCancelledException {
+        return getKissenPaperPlayerClient().getPermissionContext().setPermission(permission, value);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull PaperPermission permission) throws EventCancelledException {
+        return getKissenPaperPlayerClient().getPermissionContext().setPermission(permission);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission) {
+        return getKissenPaperPlayerClient().getPermissionContext().unsetPermission(permission);
+    }
+
+    @Override
+    public int wipePermissions() {
+        return getKissenPaperPlayerClient().getPermissionContext().wipePermissions();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList() {
+        return getKissenPaperPlayerClient().getPermissionContext().getPermissionList();
+    }
+
+    @Override
+    public @NotNull Optional<PaperPermission> getPermission(@NotNull String permission) {
+        return getKissenPaperPlayerClient().getPermissionContext().getPermission(permission);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAffectedUsers() {
+        return java.util.Collections.EMPTY_SET;
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<net.kissenpvp.core.api.permission.GroupablePermissionEntry<PaperPermission>> getConnectedEntries()
+    {
+        return java.util.Collections.EMPTY_SET;
+    }
+
+    @Override
+    public void permissionUpdate() {/* ignored */ }
+
+    @Override
+    public @NotNull Optional<PaperPermission> getOwnPermission(@NotNull String permission)
+    {
+        return getKissenPaperPlayerClient().getPermissionContext().getOwnPermission(permission);
+    }
+
+    @Override
+    public @NotNull Optional<PaperPermission> getOwnPermission(@NotNull String permission, @NotNull Context context)
+    {
+        return getKissenPaperPlayerClient().getPermissionContext().getOwnPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getOwnPermissions(@NotNull Context context) {
+        return getKissenPaperPlayerClient().getPermissionContext().getOwnPermissions(context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups(@NotNull Context context) {
+        return getKissenPaperPlayerClient().getPermissionContext().getPermissionGroups(context);
+    }
+
+    @Override
+    public boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup, @NotNull Context context) {
+        return getKissenPaperPlayerClient().getPermissionContext().inGroup(permissionGroup, context);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, @NotNull Context context) throws EventCancelledException {
+        return getKissenPaperPlayerClient().getPermissionContext().setPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, boolean value, @NotNull Context context) throws EventCancelledException {
+        return getKissenPaperPlayerClient().getPermissionContext().setPermission(permission, value, context);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull PaperPermission permission, @NotNull Context context) throws EventCancelledException {
+        return getKissenPaperPlayerClient().getPermissionContext().setPermission(permission, context);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission, @NotNull Context context) {
+        return getKissenPaperPlayerClient().getPermissionContext().unsetPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList(@NotNull Context context) {
+        return getKissenPaperPlayerClient().getPermissionContext().getPermissionList(context);
+    }
+
+    @Override
+    public @NotNull Optional<PaperPermission> getPermission(@NotNull String permission, @NotNull Context context) {
+        return getKissenPaperPlayerClient().getPermissionContext().getPermission(permission, context);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String permission, @NotNull Context context) {
+        return getKissenPaperPlayerClient().getPermissionContext().hasPermission(permission, context);
+    }
+    // KissenPaper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java b/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java
index 4e56018b64d11f76c8da43fd8f85c6de72204e36..ddee5b265dae0dc986d7d51ffb1989387ea6a5f6 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java
@@ -104,4 +104,16 @@ public class CraftConsoleCommandSender extends ServerCommandSender implements Co
         return io.papermc.paper.configuration.GlobalConfiguration.get().console.hasAllPermissions || super.hasPermission(perm);
     }
     // Paper end
+
+    // KissenPaper start
+    @Override
+    public net.kissenpvp.core.api.message.@org.jetbrains.annotations.NotNull Theme getTheme() {
+        return org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.message.MessageImplementation.class).getDefaultTheme();
+    }
+
+    @Override
+    public net.kyori.adventure.audience.@org.jetbrains.annotations.NotNull Audience getKyoriAudience() {
+        return this;
+    }
+    // KissenPaper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/command/ProxiedNativeCommandSender.java b/src/main/java/org/bukkit/craftbukkit/command/ProxiedNativeCommandSender.java
index 3e7d14564f11a3ed0b0766444e9d681804597e9a..95eb776fe864240e0fd3c3a744082ec5c1405c05 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/ProxiedNativeCommandSender.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/ProxiedNativeCommandSender.java
@@ -146,4 +146,32 @@ public class ProxiedNativeCommandSender implements ProxiedCommandSender {
        return this.getCaller().spigot();
     }
     // Spigot end
+
+    // KissenPaper start
+    @org.jetbrains.annotations.NotNull
+    @Override
+    public net.kissenpvp.core.api.message.Theme getTheme() {
+        return org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.message.MessageImplementation.class).getDefaultTheme();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull java.util.Locale getCurrentLocale() {
+        return this.getCaller().getCurrentLocale();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull net.kyori.adventure.text.Component displayName() {
+        return this.getCaller().displayName();
+    }
+
+    @Override
+    public boolean isConnected() {
+        return this.getCaller().isConnected();
+    }
+
+    @Override
+    public boolean isClient() {
+        return this.getCaller().isClient();
+    }
+    // KissenPaper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/command/ServerCommandSender.java b/src/main/java/org/bukkit/craftbukkit/command/ServerCommandSender.java
index 1e3091687735b461d3b6a313ab8761127981d3e8..b2fbbc140c22d5016339a072af23938edcfaa53a 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/ServerCommandSender.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/ServerCommandSender.java
@@ -145,4 +145,27 @@ public abstract class ServerCommandSender implements CommandSender {
         return this.adventure$pointers;
     }
     // Paper end
+
+    // KissenPaper start
+    @org.jetbrains.annotations.NotNull
+    @Override
+    public net.kissenpvp.core.api.message.Theme getTheme() {
+        return Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.message.MessageImplementation.class).getDefaultTheme();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull java.util.Locale getCurrentLocale() {
+        return Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.message.localization.LocalizationImplementation.class).getDefaultLocale();
+    }
+
+    @Override
+    public final boolean isConnected() {
+        return true;
+    }
+
+    @Override
+    public final boolean isClient() {
+        return false;
+    }
+    // KissenPaper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index 1c3e1153d08b59d29b3613fc3b50a4780aa7a3ac..6f85f5da0b2b52686c72ede0f2d43ff8077e2031 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -1227,4 +1227,27 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         return this.getHandle().getScoreboardName();
     }
     // Paper end - entity scoreboard name
+
+    // KissenPaper start
+    @org.jetbrains.annotations.NotNull
+    @Override
+    public net.kissenpvp.core.api.message.Theme getTheme() {
+        return org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.message.MessageImplementation.class).getDefaultTheme();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull java.util.Locale getCurrentLocale() {
+        return org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.message.localization.LocalizationImplementation.class).getDefaultLocale();
+    }
+
+    @Override
+    public boolean isConnected() {
+        return true;
+    }
+
+    @Override
+    public final boolean isClient() { // Kinda useless for this use case
+        return true;
+    }
+    // KissenPaper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
index c3dbcb317b7d366feb31f707ad1199c60169f07f..8b92f1f4969e28c67dae7a25e9cc778abb84124e 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
@@ -71,7 +71,7 @@ import org.bukkit.plugin.Plugin;
 public class CraftHumanEntity extends CraftLivingEntity implements HumanEntity {
     private CraftInventoryPlayer inventory;
     private final CraftInventory enderChest;
-    protected final PermissibleBase perm = new PermissibleBase(this);
+    protected final /* PermissibleBase */ org.bukkit.permissions.Permissible perm = new net.kissenpvp.paper.permission.permissible.KissenPaperPlayerPermissible(this); // KissenPaper
     private boolean op;
     private GameMode mode;
 
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index da63b4050be25dcb91d04df8c2fcc643cbb0751d..0611ce87b063b58362d1abc35bacf9713867560c 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -174,6 +174,35 @@ import org.jetbrains.annotations.NotNull;
 
 import net.md_5.bungee.api.chat.BaseComponent; // Spigot
 
+// KissenPaper start
+import net.kissenpvp.core.api.ban.Ban;
+import net.kissenpvp.core.api.base.KissenServer;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.message.Theme;
+import net.kissenpvp.core.api.networking.client.entitiy.ServerEntity;
+import net.kissenpvp.core.api.permission.PermissionGroup;
+import net.kissenpvp.core.api.time.AccurateDuration;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.api.user.rank.Rank;
+import net.kissenpvp.core.api.user.suffix.Suffix;
+import net.kissenpvp.core.api.user.usersetttings.PlayerSetting;
+import net.kissenpvp.core.api.user.usersetttings.UserSetting;
+import net.kissenpvp.core.user.KissenUserImplementation;
+import net.kissenpvp.paper.api.ban.PaperPunishment;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.networking.client.entity.PaperOnlinePlayerClient;
+import net.kissenpvp.paper.api.permission.PaperPermissible;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PermissibleOverriddenException;
+import net.kissenpvp.paper.api.user.rank.PaperPlayerRank;
+import net.kissenpvp.paper.networking.client.entity.KissenPaperOnlinePlayerClient;
+import net.kissenpvp.paper.permission.permissible.KissenPaperPermissible;
+import net.kissenpvp.paper.user.KissenPaperPublicUser;
+import org.jetbrains.annotations.Unmodifiable;
+// KissenPaper stop
+
 @DelegateDeserialization(CraftOfflinePlayer.class)
 public class CraftPlayer extends CraftHumanEntity implements Player {
     private long firstPlayed = 0;
@@ -194,6 +223,10 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     private static final boolean DISABLE_CHANNEL_LIMIT = System.getProperty("paper.disableChannelLimit") != null; // Paper - add a flag to disable the channel limit
     private long lastSaveTime; // Paper - getLastPlayed replacement API
 
+    // KissenPaper start
+    private KissenPaperOnlinePlayerClient kissenPaperPlayer;
+    // KissenPaper end
+
     public CraftPlayer(CraftServer server, ServerPlayer entity) {
         super(server, entity);
 
@@ -2547,7 +2580,19 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     public void disconnect(String reason) {
         this.conversationTracker.abandonAllConversations();
-        this.perm.clearPermissions();
+        // KissenPaper start
+        try {
+            ((KissenPaperPermissible) getPermissible()).unsubscribe();
+        } catch (PermissibleOverriddenException ignored) {
+            if (this.perm instanceof org.bukkit.permissions.PermissibleBase permissibleBase) {
+                permissibleBase.clearPermissions();
+            }
+        }
+        if(!Bukkit.getKissen().getImplementation(KissenUserImplementation.class).logoutUser(getUser()))
+        {
+            Bukkit.getKissen().getLogger().warn("Player {} was on the server but was not recognized by the system.", getName());
+        }
+        // KissenPaper end
     }
 
     @Override
@@ -2894,7 +2939,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     // Paper start
     @Override
     public java.util.Locale locale() {
-        return getHandle().adventure$locale;
+        return /* getHandle().adventure$locale; */ getCurrentLocale(); // KissenPaper
     }
     // Paper end
     @Override
@@ -3029,7 +3074,14 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     public void sendMessage(final net.kyori.adventure.identity.Identity identity, final net.kyori.adventure.text.Component message, final net.kyori.adventure.audience.MessageType type) {
         if (getHandle().connection == null) return;
         final net.minecraft.core.Registry<net.minecraft.network.chat.ChatType> chatTypeRegistry = this.getHandle().level().registryAccess().registryOrThrow(net.minecraft.core.registries.Registries.CHAT_TYPE);
-        this.getHandle().connection.send(new net.minecraft.network.protocol.game.ClientboundSystemChatPacket(message, false));
+
+        // KissenPaper start - add custom renderer
+        Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.message.ChatImplementation.class).prepareMessage(Bukkit.getConsoleSender(), this, message).ifPresent(styled ->
+
+            this.getHandle().connection.send(new net.minecraft.network.protocol.game.ClientboundSystemChatPacket(styled, false))
+
+        );
+        // KissenPaper end
     }
 
     @Override
@@ -3295,7 +3347,15 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         public void sendMessage(net.md_5.bungee.api.ChatMessageType position, UUID sender, BaseComponent... components) {
             if ( CraftPlayer.this.getHandle().connection == null ) return;
 
-            CraftPlayer.this.getHandle().connection.send(new net.minecraft.network.protocol.game.ClientboundSystemChatPacket(components, position == net.md_5.bungee.api.ChatMessageType.ACTION_BAR));
+            // KissenPaper start - add custom renderer
+            net.kyori.adventure.text.Component[] componentData = java.util.Arrays.stream(components).map(net.md_5.bungee.chat.ComponentSerializer::toString).map(json ->
+                net.kyori.adventure.text.serializer.json.JSONComponentSerializer.json().deserialize(json)
+            ).toList().toArray(new net.kyori.adventure.text.Component[0]);
+
+            Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.message.ChatImplementation.class).prepareMessage(Bukkit.getConsoleSender(), CraftPlayer.this, componentData).ifPresent(styled ->
+                CraftPlayer.this.getHandle().connection.send(new net.minecraft.network.protocol.game.ClientboundSystemChatPacket(styled, position == net.md_5.bungee.api.ChatMessageType.ACTION_BAR))
+            );
+            // KissenPaper end
         }
 
         // Paper start
@@ -3373,4 +3433,380 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         return this.spigot;
     }
     // Spigot end
+
+    // KissenPaper start - integrate user methods provided by the kissen implementation
+
+    private @NotNull KissenPaperOnlinePlayerClient getKissenPaperOnlinePlayerClient() {
+        if (kissenPaperPlayer == null) {
+            kissenPaperPlayer = new KissenPaperOnlinePlayerClient() {
+                @Override
+                public @NotNull CraftPlayer getCraftPlayer() {
+                    return CraftPlayer.this;
+                }
+
+                @Override
+                public @NotNull PaperPermissible getPermissible() throws PermissibleOverriddenException {
+                    if (!(perm instanceof PaperPermissible permissible)) {
+                        throw new PermissibleOverriddenException();
+                    }
+                    return permissible;
+                }
+
+                @Override
+                public @NotNull UUID getUniqueId() {
+                    return CraftPlayer.this.getUniqueId();
+                }
+            };
+        }
+        return kissenPaperPlayer;
+    }
+
+    @Override
+    public @NotNull User getUser() {
+        return getUser(Context.GLOBAL);
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull Context context) {
+        KissenPaperPublicUser kissenPublicUser = (KissenPaperPublicUser) Bukkit.getKissen()
+                .getImplementation(UserImplementation.class)
+                .getOnlineUser(getUniqueId())
+                .orElseThrow(IllegalStateException::new);
+        return switch (context)
+        {
+            case GLOBAL -> kissenPublicUser;
+            case LOCAL -> kissenPublicUser.getPrivateUserEntry();
+        };
+    }
+
+    @Override
+    public @NotNull io.netty.channel.Channel getConnection() {
+        return getHandle().connection.connection.channel;
+    }
+
+    @Override
+    public void sendPacket(@NotNull Object object) throws ClassNotFoundException, ClassCastException {
+        getHandle().connection.send((net.minecraft.network.protocol.Packet<?>) object);
+    }
+
+    @Override
+    public @NotNull net.kyori.adventure.audience.Audience getKyoriAudience() {
+        return this;
+    }
+
+    @Override
+    public @NotNull java.util.Locale getCurrentLocale() {
+        return getKissenPaperOnlinePlayerClient().getCurrentLocale();
+    }
+
+    // -
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAltAccounts() throws BackendException {
+        return getKissenPaperOnlinePlayerClient().getAltAccounts();
+    }
+
+    @Override
+    public @NotNull UUID getTotalID() {
+        return getKissenPaperOnlinePlayerClient().getTotalID();
+    }
+
+    @Override
+    public @NotNull PaperPunishment punish(@NotNull Ban ban, @NotNull ServerEntity banOperator) throws BackendException {
+        return getKissenPaperOnlinePlayerClient().punish(ban, banOperator);
+    }
+
+    @Override
+    public @NotNull PaperPunishment punish(@NotNull Ban ban, @NotNull ServerEntity banOperator, net.kyori.adventure.text.@org.jetbrains.annotations.Nullable Component reason) throws BackendException {
+        return getKissenPaperOnlinePlayerClient().punish(ban, banOperator, reason);
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable PaperPunishment> getPunishment(@NotNull String id) throws BackendException {
+        return getKissenPaperOnlinePlayerClient().getPunishment(id);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<PaperPunishment> getPunishmentHistory() throws BackendException {
+        return getKissenPaperOnlinePlayerClient().getPunishmentHistory();
+    }
+
+    @Override
+    public net.kyori.adventure.text.@NotNull Component styledRankName() {
+        return getKissenPaperOnlinePlayerClient().styledRankName();
+    }
+
+    @Override
+    public @NotNull Set<Suffix> getSuffixSet() {
+        return getKissenPaperOnlinePlayerClient().getSuffixSet();
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable Suffix> getSuffix(@NotNull String name) {
+        return getKissenPaperOnlinePlayerClient().getSuffix(name);
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable Suffix> setSuffix(@NotNull String name, net.kyori.adventure.text.@NotNull Component content) {
+        return getKissenPaperOnlinePlayerClient().setSuffix(name, content);
+    }
+
+    @Override
+    public boolean deleteSuffix(@NotNull String name) {
+        return getKissenPaperOnlinePlayerClient().deleteSuffix(name);
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable Suffix> getSelectedSuffix() {
+        return getKissenPaperOnlinePlayerClient().getSelectedSuffix();
+    }
+
+    @Override
+    public void setSelectedSuffix(@NotNull String name) throws NullPointerException {
+        getKissenPaperOnlinePlayerClient().setSelectedSuffix(name);
+    }
+
+    @Override
+    public long getOnlineTime() {
+        return getKissenPaperOnlinePlayerClient().getOnlineTime();
+    }
+
+    @Override
+    public @NotNull <X> UserSetting<X> getUserSetting(Class<? extends PlayerSetting<X>> settingClass) {
+        return getKissenPaperOnlinePlayerClient().getUserSetting(settingClass);
+    }
+
+    @Override
+    public @NotNull Theme getTheme() {
+        return getKissenPaperOnlinePlayerClient().getTheme();
+    }
+
+    @Override
+    public void kick(@NotNull String message) {
+        getKissenPaperOnlinePlayerClient().kick(message);
+    }
+
+    @Override
+    public void killConnection() {
+        getKissenPaperOnlinePlayerClient().killConnection();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.Nullable KissenServer getCurrentServer() {
+        return getKissenPaperOnlinePlayerClient().getCurrentServer();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<PaperPlayerRank> getRankHistory() {
+        return getKissenPaperOnlinePlayerClient().getRankHistory();
+    }
+
+    @Override
+    public @NotNull PaperPlayerRank getRank() {
+        return getKissenPaperOnlinePlayerClient().getRank();
+    }
+
+    @Override
+    public @NotNull PaperPlayerRank grantRank(@NotNull Rank rank) {
+        return getKissenPaperOnlinePlayerClient().grantRank(rank);
+    }
+
+    @Override
+    public @NotNull PaperPlayerRank grantRank(@NotNull Rank rank, @org.jetbrains.annotations.Nullable AccurateDuration accurateDuration) {
+        return getKissenPaperOnlinePlayerClient().grantRank(rank, accurateDuration);
+    }
+
+    @Override
+    public int warn(@NotNull Ban ban, @NotNull ServerEntity warnOperator) {
+        return getKissenPaperOnlinePlayerClient().warn(ban, warnOperator);
+    }
+
+    @Override
+    public int warn(@NotNull Ban ban, @NotNull ServerEntity warnOperator, net.kyori.adventure.text.@org.jetbrains.annotations.Nullable Component reason) {
+        return getKissenPaperOnlinePlayerClient().warn(ban, warnOperator, reason);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<@NotNull PaperOnlinePlayerClient> getOnlineAltAccounts() {
+        return getKissenPaperOnlinePlayerClient().getOnlineAltAccounts();
+    }
+
+    @Override
+    public @NotNull Set<Suffix> getSuffixSet(@NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getSuffixSet(context);
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable Suffix> getSuffix(@NotNull String name, @NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getSuffix(name, context);
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable Suffix> setSuffix(@NotNull String name, net.kyori.adventure.text.@NotNull Component content, @NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().setSuffix(name, content);
+    }
+
+    @Override
+    public boolean deleteSuffix(@NotNull String name, @NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().deleteSuffix(name, context);
+    }
+
+    @Override
+    public void setSelectedSuffix(@NotNull String name, @NotNull Context context) throws NullPointerException {
+        getKissenPaperOnlinePlayerClient().setSelectedSuffix(name, context);
+    }
+
+    @Override
+    public long getOnlineTime(@NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getOnlineTime(context);
+    }
+
+    @Override
+    public long getLastPlayed(@NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getLastPlayed(context);
+    }
+
+    @Override
+    public @NotNull PaperPermissible getPermissible() throws PermissibleOverriddenException {
+        return getKissenPaperOnlinePlayerClient().getPermissible();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getOwnPermissions() {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getOwnPermissions();
+    }
+
+    @Override
+    public int wipeGroups() {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().wipeGroups();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups() {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getPermissionGroups();
+    }
+
+    @Override
+    public boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup) {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().inGroup(permissionGroup);
+    }
+
+    @Override
+    public @NotNull String getPermissionID() {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getPermissionID();
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission) throws EventCancelledException {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().setPermission(permission);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, boolean value) throws EventCancelledException {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().setPermission(permission, value);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull PaperPermission permission) throws EventCancelledException {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().setPermission(permission);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission) {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().unsetPermission(permission);
+    }
+
+    @Override
+    public int wipePermissions() {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().wipePermissions();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList() {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getPermissionList();
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable PaperPermission> getPermission(@NotNull String permission) {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getPermission(permission);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAffectedUsers() {
+        return java.util.Collections.singleton(getUniqueId());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<net.kissenpvp.core.api.permission.GroupablePermissionEntry<PaperPermission>> getConnectedEntries()
+    {
+        return java.util.Collections.singleton(this);
+    }
+
+    @Override
+    public void permissionUpdate() {
+        ((net.kissenpvp.core.api.permission.PermissionEntry<?>) getUser()).permissionUpdate();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getOwnPermissions(@NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getOwnPermissions(context);
+    }
+
+    @Override
+    public @NotNull Optional<PaperPermission> getOwnPermission(@NotNull String permission)
+    {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getOwnPermission(permission);
+    }
+
+    @Override
+    public @NotNull Optional<PaperPermission> getOwnPermission(@NotNull String permission, @NotNull Context context)
+    {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getOwnPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups(@NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getPermissionGroups(context);
+    }
+
+    @Override
+    public boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup, @NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().inGroup(permissionGroup, context);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, @NotNull Context context) throws EventCancelledException {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().setPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, boolean value, @NotNull Context context) throws EventCancelledException {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().setPermission(permission, value, context);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull PaperPermission permission, @NotNull Context context) throws EventCancelledException {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().setPermission(permission, context);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission, @NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().unsetPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList(@NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getPermissionList(context);
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable PaperPermission> getPermission(@NotNull String permission, @NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getPermission(permission, context);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String permission, @NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().hasPermission(permission, context);
+    }
+    // KissenPaper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/profile/CraftPlayerProfile.java b/src/main/java/org/bukkit/craftbukkit/profile/CraftPlayerProfile.java
index bc6151cfeb7ace4755414614723ee830081094af..867e1828a3dd45c962018b317446af46ae487658 100644
--- a/src/main/java/org/bukkit/craftbukkit/profile/CraftPlayerProfile.java
+++ b/src/main/java/org/bukkit/craftbukkit/profile/CraftPlayerProfile.java
@@ -51,6 +51,10 @@ public final class CraftPlayerProfile implements PlayerProfile, com.destroystoky
     private final PropertyMap properties = new PropertyMap();
     private final CraftPlayerTextures textures = new CraftPlayerTextures(this);
 
+    // KissenPaper start
+    private net.kissenpvp.core.api.user.User cached;
+    // KissenPaper end
+
     public CraftPlayerProfile(UUID uniqueId, String name) {
         Preconditions.checkArgument((uniqueId != null) || !StringUtils.isBlank(name), "uniqueId is null or name is blank");
         this.uniqueId = (uniqueId == null) ? Util.NIL_UUID : uniqueId;
@@ -344,4 +348,13 @@ public final class CraftPlayerProfile implements PlayerProfile, com.destroystoky
     public boolean complete(final boolean textures, final boolean onlineMode) {
         throw new UnsupportedOperationException("Do not cast to com.destroystokyo.paper.profile.PlayerProfile");
     }
+
+
+    // KissenPaper start
+    @Override
+    public @org.jetbrains.annotations.NotNull net.kissenpvp.core.api.user.User getUser()
+    {
+        return org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.user.UserImplementation.class).getUser(getId());
+    }
+    // KissenPaper end
 }
