From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Groldi <chniucg@gmail.com>
Date: Fri, 15 Sep 2023 22:45:32 +0200
Subject: [PATCH] Integrated player system from kissen into paper


diff --git a/src/main/java/com/destroystokyo/paper/profile/CraftPlayerProfile.java b/src/main/java/com/destroystokyo/paper/profile/CraftPlayerProfile.java
index daa157eaa021d039f9a092bea0b78f7c1f746e3b..2445edc12487678c2db1f6b274f95a77eb4663c1 100644
--- a/src/main/java/com/destroystokyo/paper/profile/CraftPlayerProfile.java
+++ b/src/main/java/com/destroystokyo/paper/profile/CraftPlayerProfile.java
@@ -31,6 +31,10 @@ public class CraftPlayerProfile implements PlayerProfile, SharedPlayerProfile {
     private GameProfile profile;
     private final PropertySet properties = new PropertySet();
 
+    // KissenPaper start
+    private net.kissenpvp.core.api.user.User cached;
+    // KissenPaper end
+
     public CraftPlayerProfile(CraftPlayer player) {
         this.profile = player.getHandle().getGameProfile();
     }
@@ -406,4 +410,12 @@ public class CraftPlayerProfile implements PlayerProfile, SharedPlayerProfile {
             }
         }
     }
+
+    // KissenPaper start
+    @Override
+    public @org.jetbrains.annotations.NotNull net.kissenpvp.core.api.user.User getUser()
+    {
+        return org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.user.UserImplementation.class).getUser(java.util.Objects.requireNonNull(getId()));
+    }
+    // KissenPaper end
 }
diff --git a/src/main/java/io/papermc/paper/plugin/manager/PaperPluginManagerImpl.java b/src/main/java/io/papermc/paper/plugin/manager/PaperPluginManagerImpl.java
index 6f194869251e6eed67264152f7c36daa43757094..f97d54d30e952c6d501f28ce48fd899190709884 100644
--- a/src/main/java/io/papermc/paper/plugin/manager/PaperPluginManagerImpl.java
+++ b/src/main/java/io/papermc/paper/plugin/manager/PaperPluginManagerImpl.java
@@ -245,5 +245,9 @@ public class PaperPluginManagerImpl implements PluginManager, DependencyContext
     {
         org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.config.ConfigurationImplementation.class).registerSetting(plugin, setting);
     }
-    // KissenPaper end
+    @Override
+    public void registerPlayerSetting(@NotNull net.kissenpvp.core.api.user.usersetttings.PlayerSetting<?> playerSetting, @NotNull Plugin plugin) {
+        org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.user.UserImplementation.class).registerPlayerSetting(plugin, playerSetting);
+    }
+    // KissenPaper start
 }
diff --git a/src/main/java/net/kissenpvp/paper/base/KissenPaperCore.java b/src/main/java/net/kissenpvp/paper/base/KissenPaperCore.java
index 9f62dc952ce4984e45d69c393ad9cc4fde3736e7..e3e4fd170caaf4726c44f303ced029df4427c739 100644
--- a/src/main/java/net/kissenpvp/paper/base/KissenPaperCore.java
+++ b/src/main/java/net/kissenpvp/paper/base/KissenPaperCore.java
@@ -22,10 +22,17 @@ import net.kissenpvp.core.api.base.Implementation;
 import net.kissenpvp.core.api.base.plugin.KissenPlugin;
 import net.kissenpvp.core.api.database.meta.ObjectMeta;
 import net.kissenpvp.core.api.networking.client.entitiy.ConsoleClient;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.api.user.rank.RankImplementation;
 import net.kissenpvp.core.base.KissenCore;
 import net.kissenpvp.core.event.EventImplementation;
 import net.kissenpvp.paper.api.base.PaperKissen;
 import net.kissenpvp.paper.event.KissenEventImplementation;
+import net.kissenpvp.core.permission.PermissionImplementation;
+import net.kissenpvp.paper.api.permission.PaperPermissionImplementation;
+import net.kissenpvp.paper.permission.KissenPaperPermissionImplementation;
+import net.kissenpvp.paper.user.KissenPaperUserImplementation;
+import net.kissenpvp.paper.user.rank.KissenPaperRankImplementation;
 import org.bukkit.Bukkit;
 import org.bukkit.craftbukkit.scheduler.CraftScheduler;
 import org.bukkit.plugin.Plugin;
@@ -51,6 +58,11 @@ public class KissenPaperCore extends KissenCore implements PaperKissen {
     protected void loadImplementations(@NotNull Map<Class<? extends Implementation>, Implementation> loader)
     {
         loader.put(EventImplementation.class, new KissenEventImplementation());
+        loader.put(UserImplementation.class, new KissenPaperUserImplementation());
+        loader.put(RankImplementation.class, new KissenPaperRankImplementation());
+        KissenPaperPermissionImplementation permissionImplementation = new KissenPaperPermissionImplementation();
+        loader.put(PermissionImplementation.class, permissionImplementation);
+        loader.put(PaperPermissionImplementation.class, permissionImplementation);
         super.loadImplementations(loader);
     }
 
diff --git a/src/main/java/net/kissenpvp/paper/command/KissenPaperInternalCommandHandler.java b/src/main/java/net/kissenpvp/paper/command/KissenPaperInternalCommandHandler.java
deleted file mode 100644
index 466f4168cf90923e692ad0dc4a062e4d2f8825f9..0000000000000000000000000000000000000000
--- a/src/main/java/net/kissenpvp/paper/command/KissenPaperInternalCommandHandler.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package net.kissenpvp.paper.command;
-
-import net.kissenpvp.core.command.handler.InternalCommandHandler;
-import net.kissenpvp.paper.command.command.system.KissenPaperCommand;
-import org.bukkit.Bukkit;
-import org.bukkit.command.CommandSender;
-import org.bukkit.craftbukkit.CraftServer;
-import org.jetbrains.annotations.NotNull;
-
-public class KissenPaperInternalCommandHandler extends InternalCommandHandler<CommandSender, KissenPaperCommand>
-{
-    @Override
-    protected void registerCommand(@NotNull KissenPaperCommand command)
-    {
-        if(Bukkit.getCommandMap().register("kissenpaper", command))
-        {
-            ((CraftServer) Bukkit.getServer()).syncCommands();
-        }
-    }
-
-    @Override
-    protected @NotNull KissenPaperCommand buildCommand(@NotNull String name)
-    {
-        String rootName = name.split("\\.")[0];
-        KissenPaperCommand command = getCommand(rootName).orElseGet(() ->
-        {
-            KissenPaperCommand kissenCommand = new KissenPaperCommand(rootName, 0, this);
-            getCommands().add(kissenCommand);
-            return kissenCommand;
-        });
-
-        if (!name.equals(rootName))
-        {
-            command = (KissenPaperCommand) command.createRecursive(name);
-            getCommands().add(command);
-        }
-        return command;
-    }
-}
diff --git a/src/main/java/net/kissenpvp/paper/command/KissenPaperPluginHandler.java b/src/main/java/net/kissenpvp/paper/command/KissenPaperPluginHandler.java
deleted file mode 100644
index 8439a8f619b889999ec3d19f3db49c82da561d77..0000000000000000000000000000000000000000
--- a/src/main/java/net/kissenpvp/paper/command/KissenPaperPluginHandler.java
+++ /dev/null
@@ -1,50 +0,0 @@
-package net.kissenpvp.paper.command;
-
-import net.kissenpvp.core.api.base.plugin.KissenPlugin;
-import net.kissenpvp.core.api.command.executor.CommandExecutor;
-import net.kissenpvp.core.command.handler.PluginCommandHandler;
-import net.kissenpvp.paper.command.command.plugin.KissenPaperPluginCommand;
-import org.bukkit.Bukkit;
-import org.bukkit.command.CommandSender;
-import org.bukkit.craftbukkit.CraftServer;
-import org.bukkit.plugin.Plugin;
-import org.jetbrains.annotations.NotNull;
-
-import java.lang.reflect.Method;
-import java.util.Objects;
-
-public class KissenPaperPluginHandler extends PluginCommandHandler<CommandSender, KissenPaperPluginCommand>
-{
-    public KissenPaperPluginHandler(@NotNull KissenPlugin plugin)
-    {
-        super(plugin);
-    }
-
-    @Override
-    protected void registerCommand(@NotNull KissenPaperPluginCommand command)
-    {
-        if(Bukkit.getCommandMap().register(getPlugin().getName(), command))
-        {
-            ((CraftServer) Bukkit.getServer()).syncCommands();
-        }
-    }
-
-    @Override
-    protected @NotNull KissenPaperPluginCommand buildCommand(@NotNull String name)
-    {
-        String rootName = name.split("\\.")[0];
-        KissenPaperPluginCommand command = getCommand(rootName).orElseGet(() ->
-        {
-            KissenPaperPluginCommand kissenCommand = new KissenPaperPluginCommand((Plugin) getPlugin(), rootName, 0, this);
-            getCommands().add(kissenCommand);
-            return kissenCommand;
-        });
-
-        if (!Objects.equals(name, rootName))
-        {
-            command = (KissenPaperPluginCommand) command.createRecursive(name);
-            getCommands().add(command);
-        }
-        return command;
-    }
-}
diff --git a/src/main/java/net/kissenpvp/paper/command/PaperCommandImplementation.java b/src/main/java/net/kissenpvp/paper/command/PaperCommandImplementation.java
deleted file mode 100644
index a2bfb1547286a1817305196df63cf5479662eb88..0000000000000000000000000000000000000000
--- a/src/main/java/net/kissenpvp/paper/command/PaperCommandImplementation.java
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- * Copyright (C) 2023 KissenPvP
- *
- * This program is licensed under the Apache License, Version 2.0.
- *
- * This software may be redistributed and/or modified under the terms
- * of the Apache License as published by the Apache Software Foundation,
- * either version 2 of the License, or (at your option) any later version.
- *
- * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
- * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
- * License, Version 2.0 for the specific language governing permissions
- * and limitations under the License.
- *
- * You should have received a copy of the Apache License, Version 2.0
- * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
- */
-
-package net.kissenpvp.paper.command;
-
-import net.kissenpvp.core.api.base.plugin.KissenPlugin;
-import net.kissenpvp.core.api.command.CommandHandler;
-import net.kissenpvp.core.command.CommandImplementation;
-import net.kissenpvp.core.command.TargetValidator;
-import net.kissenpvp.core.command.argument.MethodEvaluator;
-import net.kissenpvp.core.command.handler.InternalCommandHandler;
-import net.kissenpvp.core.command.handler.PluginCommandHandler;
-import net.kissenpvp.core.message.localization.KissenLocalizationImplementation;
-import net.kissenpvp.paper.api.command.KissenCommand;
-import net.kissenpvp.paper.command.handler.CompletionExceptionHandler;
-import net.kissenpvp.paper.command.handler.PlayerExceptionHandler;
-import net.kissenpvp.paper.command.handler.ProfileNotFoundExceptionHandler;
-import net.kissenpvp.paper.command.parser.OfflinePlayerParser;
-import net.kissenpvp.paper.command.parser.PlayerParser;
-import net.kyori.adventure.text.Component;
-import net.kyori.adventure.text.minimessage.MiniMessage;
-import org.bukkit.Bukkit;
-import org.bukkit.OfflinePlayer;
-import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Player;
-import org.jetbrains.annotations.NotNull;
-
-import java.text.MessageFormat;
-import java.util.Optional;
-
-/**
- * Represents a Kissen Paper command implementation that extends the functionality of the Kissen command framework
- * and is compatible with the Paper server platform.
- * <p>
- * This class extends {@link CommandImplementation} and implements the {@link net.kissenpvp.paper.api.command.PaperCommandImplementation} interface
- * to provide specialized command handling and execution functionality tailored for the Paper server platform.
- * It integrates seamlessly with the Kissen command framework and enhances it with Paper-specific features.
- */
-public class PaperCommandImplementation extends CommandImplementation<CommandSender> implements net.kissenpvp.paper.api.command.PaperCommandImplementation
-{
-
-
-    /**
-     * Constructs a new instance of {@link PaperCommandImplementation}.
-     * <p>
-     * This constructor initializes the {@link MethodEvaluator} and {@link TargetValidator} instances used by this
-     * Kissen Paper command implementation for evaluating command methods and validating command execution targets.
-     */
-    public PaperCommandImplementation()
-    {
-        super();
-
-        // Advanced
-        getInternalHandler().registerParser(Player.class, new PlayerParser());
-        getInternalHandler().registerParser(OfflinePlayer.class, new OfflinePlayerParser());
-
-        //Exception handler
-        getInternalHandler().registerExceptionHandler(new PlayerExceptionHandler());
-        getInternalHandler().registerExceptionHandler(new CompletionExceptionHandler());
-        getInternalHandler().registerExceptionHandler(new ProfileNotFoundExceptionHandler());
-    }
-
-    @Override
-    public boolean start()
-    {
-        KissenLocalizationImplementation kissenLocalizationImplementation = Bukkit.getKissen().getImplementation(
-                KissenLocalizationImplementation.class);
-        kissenLocalizationImplementation.register("server.command.mojang.profile.invalid",
-                new MessageFormat("Mojangs repository does not contain the specified profile."));
-        kissenLocalizationImplementation.register("server.command.player.offline",
-                new MessageFormat("The player {0} seems to be offline."));
-        kissenLocalizationImplementation.register("server.command.failed",
-                new MessageFormat(MiniMessage.miniMessage().serialize(Component.translatable("commands.help.failed"))));
-
-        kissenLocalizationImplementation.register("server.command.general.header",
-                new MessageFormat("===== [ {0} ] ====="));
-        kissenLocalizationImplementation.register("server.command.general.header.paged",
-                new MessageFormat("===== [ {0} ({1}/{2}) ] ====="));
-        kissenLocalizationImplementation.register("server.command.general.footer",
-                new MessageFormat("===== [ {0} ] ====="));
-        kissenLocalizationImplementation.register("server.command.general.footer.paged",
-                new MessageFormat("===== [ {0} ({1}/{2}) ] ====="));
-
-        kissenLocalizationImplementation.register("server.command.general.key.value", new MessageFormat("{0}: {1}"));
-
-        return super.start();
-    }
-
-    @Override
-    protected InternalCommandHandler<CommandSender, ?> constructInternalHandler()
-    {
-        return new KissenPaperInternalCommandHandler();
-    }
-
-    @Override
-    protected @NotNull PluginCommandHandler<CommandSender, ?> constructHandler(@NotNull KissenPlugin kissenPlugin)
-    {
-        return new KissenPaperPluginHandler(kissenPlugin);
-    }
-
-
-    @Override
-    public @NotNull Optional<CommandHandler<CommandSender, KissenCommand>> getPluginHandler(@NotNull KissenPlugin kissenPlugin)
-    {
-        return getHandler().stream().filter(handler -> handler.getPlugin().equals(kissenPlugin)).map(handler -> (CommandHandler<CommandSender, KissenCommand>) handler).findFirst();
-    }
-}
diff --git a/src/main/java/net/kissenpvp/paper/entity/KissenPaperOnlinePlayerClient.java b/src/main/java/net/kissenpvp/paper/entity/KissenPaperOnlinePlayerClient.java
new file mode 100644
index 0000000000000000000000000000000000000000..de1b3676b9fed8b0dc5b5507e9582332f0f99cc0
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/entity/KissenPaperOnlinePlayerClient.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.entity;
+
+import io.netty.channel.Channel;
+import net.kissenpvp.core.api.ban.Ban;
+import net.kissenpvp.core.api.base.KissenServer;
+import net.kissenpvp.core.api.message.ThemeProvider;
+import net.kissenpvp.core.api.networking.client.entitiy.ServerEntity;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.paper.api.ban.warn.PaperWarn;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.networking.client.entity.PaperOnlinePlayerClient;
+import net.kissenpvp.paper.networking.client.entity.KissenPaperPlayerClient;
+import net.kyori.adventure.audience.Audience;
+import net.kyori.adventure.key.Key;
+import net.kyori.adventure.sound.Sound;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.kyori.adventure.text.minimessage.MiniMessage;
+import net.kyori.adventure.title.Title;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.entity.Player;
+import org.bukkit.potion.PotionEffect;
+import org.bukkit.potion.PotionEffectType;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public abstract class KissenPaperOnlinePlayerClient extends KissenPaperPlayerClient implements PaperOnlinePlayerClient {
+
+    public abstract @NotNull CraftPlayer getCraftPlayer();
+
+    @Override
+    public @NotNull User getUser() {
+        return getCraftPlayer().getUser();
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull Context context) {
+        return getCraftPlayer().getUser(context);
+    }
+
+    @Override
+    public @NotNull PaperWarn warn(@NotNull Ban ban, @NotNull ServerEntity warnOperator, @Nullable Component reason)
+    {
+        Component title = Component.translatable("server.ban.player.warned.target", Component.text(ban.getName()).color(ThemeProvider.primary())).color(NamedTextColor.RED);
+
+        Player player = Bukkit.getPlayer(getUniqueId());
+        assert player != null;
+        player.showTitle(Title.title(getTheme().style(title), getTheme().style(reason == null ? Component.empty() : reason)));
+        player.playSound(Sound.sound(Key.key("minecraft:block.anvil.destroy"), Sound.Source.MASTER, .5f, 1f));
+        player.addPotionEffect(new PotionEffect(PotionEffectType.BLINDNESS, 100, 255));
+
+        return super.warn(ban, warnOperator, reason);
+    }
+
+    @Override
+    public final boolean isConnected() {
+        return true;
+    }
+
+    @Override
+    public void kick(@NotNull String message) {
+        kick(MiniMessage.miniMessage().deserialize(message));
+    }
+
+    @Override
+    public void kick(@NotNull Component component) {
+        getCraftPlayer().kick(component);
+    }
+
+    @Override
+    public void killConnection() {
+        getConnection().close();
+    }
+
+    @Override
+    public @NotNull Channel getConnection() {
+        return getCraftPlayer().getHandle().connection.connection.channel;
+    }
+
+    @Override
+    public void sendPacket(@NotNull Object object) throws ClassCastException {
+        getCraftPlayer().getHandle().connection.send((Packet<?>) object);
+    }
+
+    @Override
+    public @Nullable KissenServer getCurrentServer() {
+        return MinecraftServer.getServer();
+    }
+
+    @Override
+    public @NotNull Audience getKyoriAudience() {
+        return getCraftPlayer();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/entity/KissenPaperPlayerClient.java b/src/main/java/net/kissenpvp/paper/entity/KissenPaperPlayerClient.java
new file mode 100644
index 0000000000000000000000000000000000000000..48f5e30a9c2269a50decd24ab41fdef55586b24c
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/entity/KissenPaperPlayerClient.java
@@ -0,0 +1,244 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.entity;
+
+import net.kissenpvp.core.api.ban.Ban;
+import net.kissenpvp.core.api.database.savable.list.KissenList;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.networking.client.entitiy.ServerEntity;
+import net.kissenpvp.core.api.time.AccurateDuration;
+import net.kissenpvp.core.api.time.TemporalObject;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.api.user.suffix.Suffix;
+import net.kissenpvp.core.api.user.usersetttings.BoundPlayerSetting;
+import net.kissenpvp.core.api.user.usersetttings.PlayerSetting;
+import net.kissenpvp.core.ban.warn.WarnNode;
+import net.kissenpvp.core.database.DataWriter;
+import net.kissenpvp.core.networking.client.entity.KissenPlayerClient;
+import net.kissenpvp.core.time.KissenAccurateDuration;
+import net.kissenpvp.core.time.TemporalMeasureNode;
+import net.kissenpvp.core.user.rank.PlayerRankNode;
+import net.kissenpvp.core.user.suffix.KissenSuffix;
+import net.kissenpvp.core.user.suffix.SuffixNode;
+import net.kissenpvp.core.user.suffix.SuffixSetting;
+import net.kissenpvp.paper.api.ban.PaperPunishment;
+import net.kissenpvp.paper.api.ban.warn.PaperWarn;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.networking.client.entity.PaperOnlinePlayerClient;
+import net.kissenpvp.paper.api.networking.client.entity.PaperPlayerClient;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PermissibleOverriddenException;
+import net.kissenpvp.paper.api.user.rank.PaperPlayerRank;
+import net.kissenpvp.paper.ban.warn.KissenPaperWarn;
+import net.kissenpvp.paper.permission.permissible.KissenPaperPermissible;
+import net.kissenpvp.paper.user.KissenPaperPublicUser;
+import net.kissenpvp.paper.user.rank.KissenPaperPlayerFallBackRank;
+import net.kissenpvp.paper.user.rank.KissenPaperPlayerRank;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.serializer.json.JSONComponentSerializer;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.time.Instant;
+import java.time.Period;
+import java.util.*;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public abstract class KissenPaperPlayerClient extends KissenPlayerClient<PaperPermission, PaperPlayerRank, PaperPunishment> implements PaperPlayerClient {
+
+    @Override
+    public @NotNull User getUser() {
+        return Bukkit.getKissen()
+                .getImplementation(UserImplementation.class)
+                .getUser(getUniqueId());
+    }
+
+    @Override
+    protected @NotNull PaperPlayerRank translateRank(@NotNull PlayerRankNode playerRankNode, @Nullable DataWriter<PlayerRankNode> dataWriter) {
+        return new KissenPaperPlayerRank(playerRankNode, dataWriter);
+    }
+
+    @Override
+    protected @NotNull PaperPlayerRank fallbackRank() {
+        return new KissenPaperPlayerFallBackRank();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<@NotNull PaperOnlinePlayerClient> getOnlineAltAccounts() {
+        return Bukkit.getOnlinePlayers().stream().filter(client -> client.getTotalID().equals(getTotalID())).collect(Collectors.toSet());
+    }
+
+    @Override
+    public @NotNull Set<Suffix> getSuffixSet() {
+        Stream<Suffix> suffixes = Stream.concat(getSuffixSet(Context.LOCAL).stream(), super.getSuffixSet().stream());
+        return suffixes.collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @NotNull Set<Suffix> getSuffixSet(@NotNull Context context) {
+        KissenList<SuffixNode> suffixStream = getUser(context).getListNotNull("suffix_list", SuffixNode.class);
+        return suffixStream.stream().map(transformSuffix(context)).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @NotNull Optional<Suffix> getSuffix(@NotNull String name) {
+        return getSuffix(name, Context.LOCAL).or(() -> super.getSuffix(name));
+    }
+
+    @Override
+    public @NotNull Optional<Suffix> getSuffix(@NotNull String name, @NotNull Context context) {
+        KissenList<SuffixNode> suffixList = getUser(context).getListNotNull("suffix_list", SuffixNode.class);
+        return suffixList.stream().filter(suffix -> suffix.name().equals(name)).findFirst().map(transformSuffix(context));
+    }
+
+
+    @Override
+    public @NotNull Suffix grantSuffix(@NotNull String name, @NotNull Component content)
+    {
+        return grantSuffix(name, content, Context.LOCAL);
+    }
+
+    @Override
+    public @NotNull Suffix grantSuffix(@NotNull String name, @NotNull Component content, @NotNull Context context) throws EventCancelledException
+    {
+        if(name.equals("rank") || name.equals("none"))
+        {
+            throw new EventCancelledException();
+        }
+        SuffixNode suffixNode = new SuffixNode(name, content);
+        KissenList<SuffixNode> suffixes = getUser(context).getListNotNull("suffix_list", SuffixNode.class);
+        if (suffixes.replace(suffix -> suffix.name().equals(name), suffixNode) == 0)
+        {
+            suffixes.add(suffixNode);
+        }
+
+        return transformSuffix(context).apply(suffixNode);
+    }
+
+    @Override
+    public @NotNull Optional<Suffix> getSelectedSuffix()
+    {
+        String local = getUserSetting(SuffixSetting.class, Context.LOCAL).getValue();
+        if(!local.equals("none"))
+        {
+            return getSuffix(local).filter(TemporalObject::isValid);
+        }
+        return super.getSelectedSuffix();
+    }
+
+    @Override
+    public boolean revokeSuffix(@NotNull String name) {
+        return revokeSuffix(name, Context.LOCAL) || super.revokeSuffix(name);
+    }
+
+    @Override
+    public boolean revokeSuffix(@NotNull String name, @NotNull Context context) {
+        return getSuffix(name, context).filter(TemporalObject::isValid).map(suffix ->
+        {
+            suffix.setEnd(Instant.now());
+            return true;
+        }).orElse(false);
+    }
+
+    @Override
+    public long getOnlineTime() {
+        return getOnlineTime(Context.LOCAL);
+    }
+
+    @Override
+    public long getOnlineTime(@NotNull Context context) {
+        return getOnlineTime(getUser(context));
+    }
+
+    @Override
+    public long getLastPlayed(@NotNull Context context) {
+        return getLastPlayed(getUser(context));
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<PaperWarn> getWarnHistory()
+    {
+        return getUser().getListNotNull("warn_list", WarnNode.class).stream().map(transformWarn()).toList();
+    }
+
+    @Override
+    public void clearActiveWarns()
+    {
+        List<WarnNode> nodes = new ArrayList<>(getUser().getListNotNull("warn_list", WarnNode.class));
+        nodes.forEach(warn -> warn.temporalMeasure().end().setValue(System.currentTimeMillis()));
+        getUser().setList("warn_list", nodes);
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull Context context) {
+        KissenPaperPublicUser kissenPublicUser = (KissenPaperPublicUser) getUser();
+        return switch (context) {
+            case GLOBAL -> kissenPublicUser;
+            case LOCAL -> kissenPublicUser.getPrivateUserEntry();
+        };
+    }
+
+    @Override
+    public @NotNull <X> BoundPlayerSetting<X> getUserSetting(@NotNull Class<? extends PlayerSetting<X>> settingClass, @NotNull Context context)
+    {
+        return getUserSetting(getUser(context), settingClass);
+    }
+
+    @Override
+    public @NotNull PaperWarn warn(@NotNull Ban ban, @NotNull ServerEntity warnOperator)
+    {
+        return warn(ban, warnOperator, null);
+    }
+
+    @Override
+    public @NotNull PaperWarn warn(@NotNull Ban ban, @NotNull ServerEntity warnOperator, @Nullable Component reason)
+    {
+        Map<String, Object> storage = getUser().getStorage();
+        KissenList<WarnNode> nodes = getUser().getListNotNull("warn_list", WarnNode.class);
+
+        AccurateDuration duration = new KissenAccurateDuration(Period.ofWeeks(1));
+        TemporalMeasureNode temporalMeasureNode = new TemporalMeasureNode(duration);
+
+        WarnNode node = new WarnNode(ban.getID(), warnOperator.getName(), reason, temporalMeasureNode);
+        nodes.add(node);
+        return transformWarn().apply(node);
+    }
+
+    public @NotNull KissenPaperPermissible getPermissionContext() throws PermissibleOverriddenException {
+        return (KissenPaperPermissible) getPermissible();
+    }
+
+    private @NotNull Function<SuffixNode, KissenSuffix> transformSuffix(@NotNull Context context)
+    {
+        return suffix -> new KissenSuffix(suffix, suffixDataWriter(getUser(context)));
+    }
+
+
+    @Contract(pure = true, value = "-> new")
+    protected @NotNull Function<WarnNode, PaperWarn> transformWarn()
+    {
+        return KissenPaperWarn::new;
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperOnlinePlayerClient.java b/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperOnlinePlayerClient.java
new file mode 100644
index 0000000000000000000000000000000000000000..1c3d7977d447f1beb6ae470bde9f190f16070570
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperOnlinePlayerClient.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.networking.client.entity;
+
+import io.netty.channel.Channel;
+import net.kissenpvp.core.api.ban.Ban;
+import net.kissenpvp.core.api.base.KissenServer;
+import net.kissenpvp.core.api.message.ThemeProvider;
+import net.kissenpvp.core.api.networking.client.entitiy.ServerEntity;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.paper.api.ban.warn.PaperWarn;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.networking.client.entity.PaperOnlinePlayerClient;
+import net.kyori.adventure.audience.Audience;
+import net.kyori.adventure.key.Key;
+import net.kyori.adventure.sound.Sound;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.kyori.adventure.text.minimessage.MiniMessage;
+import net.kyori.adventure.title.Title;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.entity.Player;
+import org.bukkit.potion.PotionEffect;
+import org.bukkit.potion.PotionEffectType;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public abstract class KissenPaperOnlinePlayerClient extends KissenPaperPlayerClient implements PaperOnlinePlayerClient {
+
+    public abstract @NotNull CraftPlayer getCraftPlayer();
+
+    @Override
+    public @NotNull User getUser() {
+        return getCraftPlayer().getUser();
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull Context context) {
+        return getCraftPlayer().getUser(context);
+    }
+
+    @Override
+    public @NotNull PaperWarn warn(@NotNull Ban ban, @NotNull ServerEntity warnOperator, @Nullable Component reason)
+    {
+        Component title = Component.translatable("server.ban.player.warned.target", Component.text(ban.getName()).color(ThemeProvider.primary())).color(NamedTextColor.RED);
+
+        Player player = Bukkit.getPlayer(getUniqueId());
+        assert player != null;
+        player.showTitle(Title.title(getTheme().style(title), getTheme().style(reason == null ? Component.empty() : reason)));
+        player.playSound(Sound.sound(Key.key("minecraft:block.anvil.destroy"), Sound.Source.MASTER, .5f, 1f));
+        player.addPotionEffect(new PotionEffect(PotionEffectType.BLINDNESS, 100, 255));
+
+        return super.warn(ban, warnOperator, reason);
+    }
+
+    @Override
+    public final boolean isConnected() {
+        return true;
+    }
+
+    @Override
+    public void kick(@NotNull String message) {
+        kick(MiniMessage.miniMessage().deserialize(message));
+    }
+
+    @Override
+    public void kick(@NotNull Component component) {
+        getCraftPlayer().kick(component);
+    }
+
+    @Override
+    public void killConnection() {
+        getConnection().close();
+    }
+
+    @Override
+    public @NotNull Channel getConnection() {
+        return getCraftPlayer().getHandle().connection.connection.channel;
+    }
+
+    @Override
+    public void sendPacket(@NotNull Object object) throws ClassCastException {
+        getCraftPlayer().getHandle().connection.send((Packet<?>) object);
+    }
+
+    @Override
+    public @Nullable KissenServer getCurrentServer() {
+        return MinecraftServer.getServer();
+    }
+
+    @Override
+    public @NotNull Audience getKyoriAudience() {
+        return getCraftPlayer();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperPlayerClient.java b/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperPlayerClient.java
new file mode 100644
index 0000000000000000000000000000000000000000..b139462f6e3ffaca0b5d13e3e3149d90ecc4d0c8
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperPlayerClient.java
@@ -0,0 +1,244 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.networking.client.entity;
+
+import net.kissenpvp.core.api.ban.Ban;
+import net.kissenpvp.core.api.database.savable.list.KissenList;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.networking.client.entitiy.ServerEntity;
+import net.kissenpvp.core.api.time.AccurateDuration;
+import net.kissenpvp.core.api.time.TemporalObject;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.api.user.suffix.Suffix;
+import net.kissenpvp.core.api.user.usersetttings.PlayerSetting;
+import net.kissenpvp.core.api.user.usersetttings.BoundPlayerSetting;
+import net.kissenpvp.core.ban.warn.WarnNode;
+import net.kissenpvp.core.database.DataWriter;
+import net.kissenpvp.core.networking.client.entity.KissenPlayerClient;
+import net.kissenpvp.core.time.KissenAccurateDuration;
+import net.kissenpvp.core.time.TemporalMeasureNode;
+import net.kissenpvp.core.user.rank.PlayerRankNode;
+import net.kissenpvp.core.user.suffix.KissenSuffix;
+import net.kissenpvp.core.user.suffix.SuffixNode;
+import net.kissenpvp.core.user.suffix.SuffixSetting;
+import net.kissenpvp.paper.api.ban.PaperPunishment;
+import net.kissenpvp.paper.api.ban.warn.PaperWarn;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.networking.client.entity.PaperOnlinePlayerClient;
+import net.kissenpvp.paper.api.networking.client.entity.PaperPlayerClient;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PermissibleOverriddenException;
+import net.kissenpvp.paper.api.user.rank.PaperPlayerRank;
+import net.kissenpvp.paper.ban.warn.KissenPaperWarn;
+import net.kissenpvp.paper.permission.permissible.KissenPaperPermissible;
+import net.kissenpvp.paper.user.KissenPaperPublicUser;
+import net.kissenpvp.paper.user.rank.KissenPaperPlayerFallBackRank;
+import net.kissenpvp.paper.user.rank.KissenPaperPlayerRank;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.serializer.json.JSONComponentSerializer;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.time.Instant;
+import java.time.Period;
+import java.util.*;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public abstract class KissenPaperPlayerClient extends KissenPlayerClient<PaperPermission, PaperPlayerRank, PaperPunishment> implements PaperPlayerClient {
+
+    @Override
+    public @NotNull User getUser() {
+        return Bukkit.getKissen()
+                .getImplementation(UserImplementation.class)
+                .getUser(getUniqueId());
+    }
+
+    @Override
+    protected @NotNull PaperPlayerRank translateRank(@NotNull PlayerRankNode playerRankNode, @Nullable DataWriter<PlayerRankNode> dataWriter) {
+        return new KissenPaperPlayerRank(playerRankNode, dataWriter);
+    }
+
+    @Override
+    protected @NotNull PaperPlayerRank fallbackRank() {
+        return new KissenPaperPlayerFallBackRank();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<@NotNull PaperOnlinePlayerClient> getOnlineAltAccounts() {
+        return Bukkit.getOnlinePlayers().stream().filter(client -> client.getTotalID().equals(getTotalID())).collect(Collectors.toSet());
+    }
+
+    @Override
+    public @NotNull Set<Suffix> getSuffixSet() {
+        Stream<Suffix> suffixes = Stream.concat(getSuffixSet(Context.LOCAL).stream(), super.getSuffixSet().stream());
+        return suffixes.collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @NotNull Set<Suffix> getSuffixSet(@NotNull Context context) {
+        KissenList<SuffixNode> suffixStream = getUser(context).getListNotNull("suffix_list", SuffixNode.class);
+        return suffixStream.stream().map(transformSuffix(context)).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @NotNull Optional<Suffix> getSuffix(@NotNull String name) {
+        return getSuffix(name, Context.LOCAL).or(() -> super.getSuffix(name));
+    }
+
+    @Override
+    public @NotNull Optional<Suffix> getSuffix(@NotNull String name, @NotNull Context context) {
+        KissenList<SuffixNode> suffixList = getUser(context).getListNotNull("suffix_list", SuffixNode.class);
+        return suffixList.stream().filter(suffix -> suffix.name().equals(name)).findFirst().map(transformSuffix(context));
+    }
+
+
+    @Override
+    public @NotNull Suffix grantSuffix(@NotNull String name, @NotNull Component content)
+    {
+        return grantSuffix(name, content, Context.LOCAL);
+    }
+
+    @Override
+    public @NotNull Suffix grantSuffix(@NotNull String name, @NotNull Component content, @NotNull Context context) throws EventCancelledException
+    {
+        if(name.equals("rank") || name.equals("none"))
+        {
+            throw new EventCancelledException();
+        }
+        SuffixNode suffixNode = new SuffixNode(name, content);
+        KissenList<SuffixNode> suffixes = getUser(context).getListNotNull("suffix_list", SuffixNode.class);
+        if (suffixes.replace(suffix -> suffix.name().equals(name), suffixNode) == 0)
+        {
+            suffixes.add(suffixNode);
+        }
+
+        return transformSuffix(context).apply(suffixNode);
+    }
+
+    @Override
+    public @NotNull Optional<Suffix> getSelectedSuffix()
+    {
+        String local = getUserSetting(SuffixSetting.class, Context.LOCAL).getValue();
+        if(!local.equals("none"))
+        {
+            return getSuffix(local).filter(TemporalObject::isValid);
+        }
+        return super.getSelectedSuffix();
+    }
+
+    @Override
+    public boolean revokeSuffix(@NotNull String name) {
+        return revokeSuffix(name, Context.LOCAL) || super.revokeSuffix(name);
+    }
+
+    @Override
+    public boolean revokeSuffix(@NotNull String name, @NotNull Context context) {
+        return getSuffix(name, context).filter(TemporalObject::isValid).map(suffix ->
+        {
+            suffix.setEnd(Instant.now());
+            return true;
+        }).orElse(false);
+    }
+
+    @Override
+    public long getOnlineTime() {
+        return getOnlineTime(Context.LOCAL);
+    }
+
+    @Override
+    public long getOnlineTime(@NotNull Context context) {
+        return getOnlineTime(getUser(context));
+    }
+
+    @Override
+    public long getLastPlayed(@NotNull Context context) {
+        return getLastPlayed(getUser(context));
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<PaperWarn> getWarnHistory()
+    {
+        return getUser().getListNotNull("warn_list", WarnNode.class).stream().map(transformWarn()).toList();
+    }
+
+    @Override
+    public void clearActiveWarns()
+    {
+        List<WarnNode> nodes = new ArrayList<>(getUser().getListNotNull("warn_list", WarnNode.class));
+        nodes.forEach(warn -> warn.temporalMeasure().end().setValue(System.currentTimeMillis()));
+        getUser().setList("warn_list", nodes);
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull Context context) {
+        KissenPaperPublicUser kissenPublicUser = (KissenPaperPublicUser) getUser();
+        return switch (context) {
+            case GLOBAL -> kissenPublicUser;
+            case LOCAL -> kissenPublicUser.getPrivateUserEntry();
+        };
+    }
+
+    @Override
+    public @NotNull <X> BoundPlayerSetting<X> getUserSetting(@NotNull Class<? extends PlayerSetting<X>> settingClass, @NotNull Context context)
+    {
+        return getUserSetting(getUser(context), settingClass);
+    }
+
+    @Override
+    public @NotNull PaperWarn warn(@NotNull Ban ban, @NotNull ServerEntity warnOperator)
+    {
+        return warn(ban, warnOperator, null);
+    }
+
+    @Override
+    public @NotNull PaperWarn warn(@NotNull Ban ban, @NotNull ServerEntity warnOperator, @Nullable Component reason)
+    {
+        Map<String, Object> storage = getUser().getStorage();
+        KissenList<WarnNode> nodes = getUser().getListNotNull("warn_list", WarnNode.class);
+
+        AccurateDuration duration = new KissenAccurateDuration(Period.ofWeeks(1));
+        TemporalMeasureNode temporalMeasureNode = new TemporalMeasureNode(duration);
+
+        WarnNode node = new WarnNode(ban.getID(), warnOperator.getName(), reason, temporalMeasureNode);
+        nodes.add(node);
+        return transformWarn().apply(node);
+    }
+
+    public @NotNull KissenPaperPermissible getPermissionContext() throws PermissibleOverriddenException {
+        return (KissenPaperPermissible) getPermissible();
+    }
+
+    private @NotNull Function<SuffixNode, KissenSuffix> transformSuffix(@NotNull Context context)
+    {
+        return suffix -> new KissenSuffix(suffix, suffixDataWriter(getUser(context)));
+    }
+
+
+    @Contract(pure = true, value = "-> new")
+    protected @NotNull Function<WarnNode, PaperWarn> transformWarn()
+    {
+        return KissenPaperWarn::new;
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/KissenPaperAttachmentPermission.java b/src/main/java/net/kissenpvp/paper/permission/KissenPaperAttachmentPermission.java
new file mode 100644
index 0000000000000000000000000000000000000000..8af2f558f4c7413e2b5cc5a3eed9a29b1fa36712
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/KissenPaperAttachmentPermission.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission;
+
+import net.kissenpvp.core.api.permission.Permission;
+import net.kissenpvp.core.api.permission.PermissionEntry;
+import net.kissenpvp.core.permission.PermissionNode;
+import net.kissenpvp.core.time.TemporalMeasureNode;
+import org.bukkit.permissions.PermissionAttachment;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class KissenPaperAttachmentPermission extends KissenPaperPermission {
+
+    private final PermissionAttachment permissionAttachment;
+
+    public KissenPaperAttachmentPermission(@NotNull String permission, boolean value, @NotNull PermissionEntry<? extends Permission> permissionEntry, boolean immutable) {
+        this(null, permission, value, permissionEntry, immutable);
+    }
+
+    public KissenPaperAttachmentPermission(@Nullable PermissionAttachment permissionAttachment, @NotNull String permission, boolean value, @NotNull PermissionEntry<? extends Permission> permissionEntry, boolean immutable) {
+        super(new PermissionNode(permission, permissionEntry, value, new TemporalMeasureNode()), permissionEntry, immutable ? null : (record) -> { /* ignored */ });
+        this.permissionAttachment = permissionAttachment;
+    }
+
+    public PermissionAttachment getPermissionAttachment() {
+        return permissionAttachment;
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/KissenPaperGroupablePermissionEntry.java b/src/main/java/net/kissenpvp/paper/permission/KissenPaperGroupablePermissionEntry.java
new file mode 100644
index 0000000000000000000000000000000000000000..8e273ff5c125a54de435c43460e5c2d9bfe2c092
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/KissenPaperGroupablePermissionEntry.java
@@ -0,0 +1,301 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission;
+
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.permission.GroupablePermissionEntry;
+import net.kissenpvp.core.api.permission.PermissionEntry;
+import net.kissenpvp.core.api.permission.PermissionGroup;
+import net.kissenpvp.core.permission.KissenGroupablePermissionEntry;
+import net.kissenpvp.core.permission.KissenPermissionSet;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.PaperGroupablePermissionEntry;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kyori.adventure.text.Component;
+import org.bukkit.permissions.PermissionAttachment;
+import org.bukkit.permissions.PermissionAttachmentInfo;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.*;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public abstract class KissenPaperGroupablePermissionEntry implements PaperGroupablePermissionEntry
+{
+    @Override
+    public @NotNull Component displayName()
+    {
+        return getContext(Context.LOCAL).map(PermissionEntry::displayName).orElseGet(() -> getContext(Context.GLOBAL).map(
+                PermissionEntry::displayName).orElseThrow());
+    }
+
+    @Override
+    public int wipePermissions()
+    {
+        return wipePermissions(Context.LOCAL) + wipePermissions(Context.GLOBAL);
+    }
+
+    @Override
+    public int wipeGroups()
+    {
+        int local = getContext(Context.LOCAL).map(GroupablePermissionEntry::wipeGroups).orElse(0);
+        int global = getContext(Context.GLOBAL).map(GroupablePermissionEntry::wipeGroups).orElse(0);
+        return local + global;
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<PermissionGroup<PaperPermission>> getOwnPermissionGroups()
+    {
+        LinkedHashSet<PermissionGroup<PaperPermission>> groups = new LinkedHashSet<>(getOwnPermissionsGroups(Context.LOCAL));
+        groups.addAll(getOwnPermissionsGroups(Context.GLOBAL));
+        return groups.stream().toList();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<PermissionGroup<PaperPermission>> getPermissionGroups()
+    {
+        LinkedHashSet<PermissionGroup<PaperPermission>> groups = new LinkedHashSet<>(getPermissionGroups(Context.LOCAL));
+        groups.addAll(getPermissionGroups(Context.GLOBAL));
+        return groups.stream().toList();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getOwnPermissions()
+    {
+
+        Stream<PaperPermission> local = getOwnPermissions(Context.LOCAL).stream();
+        Stream<PaperPermission> global = getOwnPermissions(Context.GLOBAL).stream();
+
+        return Stream.concat(local, global).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @NotNull Optional<PaperPermission> getOwnPermission(@NotNull String permission)
+    {
+        return getOwnPermission(permission, Context.LOCAL).or(() -> getOwnPermission(permission, Context.GLOBAL));
+    }
+
+    @Override
+    @NotNull
+    public Set<PaperPermission> getOwnPermissions(@NotNull Context context)
+    {
+
+        return getContext(context).map(GroupablePermissionEntry::getOwnPermissions).orElse(Collections.emptySet());
+    }
+
+    @Override
+    public @NotNull Optional<PaperPermission> getOwnPermission(@NotNull String permission, @NotNull Context context)
+    {
+        return getContextNotNull(context).getOwnPermission(permission);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<PermissionGroup<PaperPermission>> getOwnPermissionsGroups(@NotNull Context context)
+    {
+        return getContext(context).map(GroupablePermissionEntry::getOwnPermissionGroups).orElse(Collections.emptyList());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<PermissionGroup<PaperPermission>> getPermissionGroups(@NotNull Context context)
+    {
+        return getContext(context).map(GroupablePermissionEntry::getPermissionGroups).orElse(Collections.emptyList());
+    }
+
+    @Override
+    public boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup)
+    {
+        return inGroup(permissionGroup, Context.LOCAL) || inGroup(permissionGroup, Context.GLOBAL);
+    }
+
+    @Override
+    public boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup, @NotNull Context context)
+    {
+        return getContext(context).map(group -> group.inGroup(permissionGroup)).orElse(false);
+    }
+
+    @Override
+    public int wipeGroups(@NotNull Context context)
+    {
+        return getContext(context).map(PermissionEntry::wipePermissions).orElse(0);
+    }
+
+    @Override
+    @NotNull
+    public PaperPermission setPermission(@NotNull String s) throws EventCancelledException
+    {
+        return setPermission(s, Context.LOCAL);
+    }
+
+    @Override
+    @NotNull
+    public PaperPermission setPermission(@NotNull String permission, @NotNull Context context) throws EventCancelledException
+    {
+        return getContextNotNull(context).setPermission(permission);
+    }
+
+    @Override
+    @NotNull
+    public PaperPermission setPermission(@NotNull String permission, boolean value) throws EventCancelledException
+    {
+        return setPermission(permission, value, Context.LOCAL);
+    }
+
+    @Override
+    @NotNull
+    public PaperPermission setPermission(@NotNull String permission, boolean value, @NotNull Context context) throws EventCancelledException
+    {
+        return getContextNotNull(context).setPermission(permission, value);
+    }
+
+    @Override
+    @NotNull
+    public PaperPermission setPermission(@NotNull PaperPermission paperPermission) throws EventCancelledException
+    {
+        return setPermission(paperPermission, Context.LOCAL);
+    }
+
+    @Override
+    @NotNull
+    public PaperPermission setPermission(@NotNull PaperPermission permission, @NotNull Context context) throws EventCancelledException
+    {
+        return getContextNotNull(context).setPermission(permission);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String s)
+    {
+        return unsetPermission(s, Context.LOCAL) || unsetPermission(s, Context.GLOBAL);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission, @NotNull Context context)
+    {
+        return getContext(context).map(group -> group.unsetPermission(permission)).orElse(false);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList()
+    {
+        KissenPermissionSet<PaperPermission> permission = new KissenPermissionSet<>(getOwnPermissions(Context.LOCAL));
+        permission.addAll(getPermissionList(Context.GLOBAL));
+        return permission;
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList(@NotNull Context context)
+    {
+        return getContext(context).map(PermissionEntry::getPermissionList).orElse(Collections.emptySet());
+    }
+
+    @Override
+    public @NotNull Optional<PaperPermission> getPermission(@NotNull String permission)
+    {
+        return getPermission(permission, Context.LOCAL).or(() -> getPermission(permission, Context.GLOBAL));
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAffectedUsers()
+    {
+        Function<GroupablePermissionEntry<PaperPermission>, Stream<UUID>> toStream = entry -> entry.getAffectedUsers().stream();
+        Stream<UUID> local = getContext(Context.LOCAL).map(toStream).orElse(Stream.empty());
+        Stream<UUID> global = getContext(Context.GLOBAL).map(toStream).orElse(Stream.empty());
+
+        return Stream.concat(local, global).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<GroupablePermissionEntry<PaperPermission>> getConnectedEntries()
+    {
+        var stream = new Object()
+        {
+            private @NotNull Stream<GroupablePermissionEntry<PaperPermission>> getStream(@NotNull Context context)
+            {
+                return getContext(context).map(entry -> entry.getConnectedEntries().stream()).orElseGet(Stream::empty);
+            }
+        };
+
+        Stream<GroupablePermissionEntry<PaperPermission>> local = stream.getStream(Context.LOCAL);
+        Stream<GroupablePermissionEntry<PaperPermission>> global = stream.getStream(Context.GLOBAL);
+
+        return Stream.concat(local, global).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    @NotNull
+    public Optional<PaperPermission> getPermission(@NotNull String permission, @NotNull Context context)
+    {
+        return getContext(context).flatMap(group -> group.getPermission(permission));
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String permission)
+    {
+        return hasPermission(permission, Context.LOCAL) || hasPermission(permission, Context.GLOBAL);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String permission, @NotNull Context context)
+    {
+        return getContext(context).flatMap(group -> hasInternalPermission(permission, context)).orElse(isOp());
+    }
+
+    @Override
+    public void permissionUpdate()
+    {
+        getContext(Context.LOCAL).ifPresent(PermissionEntry::permissionUpdate);
+        getContext(Context.GLOBAL).ifPresent(PermissionEntry::permissionUpdate);
+        getConnectedEntries().forEach(PermissionEntry::permissionUpdate);
+    }
+
+    @Override
+    public int wipePermissions(@NotNull Context context)
+    {
+        return getContext(Context.LOCAL).map(PermissionEntry::wipePermissions).orElse(0);
+    }
+
+    @NotNull
+    public abstract Optional<? extends GroupablePermissionEntry<PaperPermission>> getContext(@NotNull Context context);
+
+    @NotNull
+    public abstract GroupablePermissionEntry<PaperPermission> getContextNotNull(@NotNull Context context);
+
+    public @NotNull @Unmodifiable Set<PermissionAttachmentInfo> getEffectivePermissions()
+    {
+        return getPermissionList().stream().map(permission ->
+        {
+            PermissionAttachment attachment = null;
+            if (permission instanceof KissenPaperAttachmentPermission kissenPaperAttachmentPermission)
+            {
+                attachment = kissenPaperAttachmentPermission.getPermissionAttachment();
+            }
+            return new PermissionAttachmentInfo(this, permission.getName(), attachment, permission.getValue());
+        }).collect(Collectors.toUnmodifiableSet());
+    }
+
+    private @NotNull Optional<Boolean> hasInternalPermission(@NotNull String permission, @NotNull Context context)
+    {
+        return getContext(context).flatMap(group ->
+        {
+            KissenGroupablePermissionEntry<PaperPermission> internal = (KissenGroupablePermissionEntry<PaperPermission>) group;
+            return internal.getInternalPermission(permission);
+        });
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermission.java b/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermission.java
new file mode 100644
index 0000000000000000000000000000000000000000..2d7a6561e5ae2c40e1160f5a8109bcf6f0010b7d
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermission.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission;
+
+import net.kissenpvp.core.api.permission.Permission;
+import net.kissenpvp.core.api.permission.PermissionEntry;
+import net.kissenpvp.core.database.DataWriter;
+import net.kissenpvp.core.permission.KissenPermission;
+import net.kissenpvp.core.permission.PermissionNode;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class KissenPaperPermission extends KissenPermission implements PaperPermission {
+    public KissenPaperPermission(@NotNull PermissionNode permissionNode, @NotNull PermissionEntry<? extends Permission> permissionEntry, @Nullable DataWriter<PermissionNode> dataWriter) {
+        super(permissionNode, permissionEntry, dataWriter);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermissionImplementation.java b/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermissionImplementation.java
new file mode 100644
index 0000000000000000000000000000000000000000..59d1b417baf60f2087b25fbed0d495adbf24f038
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermissionImplementation.java
@@ -0,0 +1,339 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission;
+
+import net.kissenpvp.core.api.database.savable.SavableMap;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.permission.PermissionGroup;
+import net.kissenpvp.core.base.KissenCore;
+import net.kissenpvp.core.base.KissenImplementation;
+import net.kissenpvp.core.command.CommandImplementation;
+import net.kissenpvp.core.event.EventImplementation;
+import net.kissenpvp.core.message.localization.KissenLocalizationImplementation;
+import net.kissenpvp.core.permission.PermissionImplementation;
+import net.kissenpvp.core.permission.event.KissenPermissionGroupCreateEvent;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PaperPermissionGroup;
+import net.kissenpvp.paper.api.permission.PaperPermissionImplementation;
+import net.kissenpvp.paper.permission.command.PermissionCommand;
+import net.kissenpvp.paper.permission.group.KissenPaperAbstractPermissionGroup;
+import net.kissenpvp.paper.permission.group.KissenPaperPermissionGroup;
+import net.kissenpvp.paper.permission.group.KissenPaperPrivatePermissionGroup;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.bukkit.permissions.Permission;
+import org.bukkit.permissions.PermissionDefault;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.text.MessageFormat;
+import java.util.*;
+import java.util.stream.Collectors;
+
+public class KissenPaperPermissionImplementation implements PaperPermissionImplementation, PermissionImplementation<PaperPermission>, KissenImplementation {
+
+    private final Set<GroupHolder> cachedHolder;
+
+    public KissenPaperPermissionImplementation() {
+        this.cachedHolder = new HashSet<>();
+    }
+
+    @Override
+    public boolean start() {
+        String prefix = "The permission entry {0}";
+
+        Class<KissenLocalizationImplementation> clazz = KissenLocalizationImplementation.class;
+        KissenLocalizationImplementation localize = Bukkit.getKissen().getImplementation(clazz);
+
+        localize.register("server.permission.set.success", new MessageFormat(prefix + " was successfully set {1} to {2}."));
+        localize.register("server.permission.set.failed", new MessageFormat(prefix + " has already set {1} to {2}."));
+        localize.register("server.permission.group.failed", new MessageFormat(prefix + " is already in this state within the relation to group {1}."));
+        localize.register("server.permission.group.success", new MessageFormat(prefix + " has been set to the state."));
+        localize.register("server.permission.unset.success", new MessageFormat("The permission {1} from the permission entry {0} was successfully unset."));
+        localize.register("server.permission.entity.failed", new MessageFormat(prefix + " does not have the permission {1}."));
+
+        localize.register("server.permission.group.created", new MessageFormat(prefix + " has been created."));
+        localize.register("server.permission.group.deleted", new MessageFormat(prefix + " has been deleted."));
+
+        localize.register("server.permission.info.compact", new MessageFormat("[{0}] [{1}] {2}"));
+
+        localize.register("server.permission.owner", new MessageFormat("Owner"));
+        localize.register("server.permission.info.clear", new MessageFormat(prefix + " has no permissions."));
+
+        localize.register("server.permission.groups.clear", new MessageFormat(prefix + " is no part of any groups ({1} groups removed)."));
+        localize.register("server.permission.permissions.clear", new MessageFormat(prefix + " has no more permissions ({1} permissions removed)."));
+
+        CommandImplementation<CommandSender> command = Bukkit.getKissen().getImplementation(CommandImplementation.class);
+        command.getInternalHandler().registerParser(PaperPermissionGroup.class, new PaperPermissionGroupParser());
+        command.getInternalHandler().registerParser(PermissionParser.PermissionArgument.class, new PermissionParser());
+        return PaperPermissionImplementation.super.start();
+    }
+
+    @Override
+    public boolean postStart() {
+        var injector = new Object() {
+            private void inject(@NotNull Map<String, SavableMap> data, @NotNull Context context, int saveIDLength) {
+                for (Map.Entry<String, SavableMap> entry : data.entrySet()) {
+                    createInternal(entry.getKey().substring(saveIDLength), entry.getValue(), context);
+                }
+            }
+        };
+
+        KissenPaperPrivatePermissionGroup.KissenPaperPublicPermissionGroup publicGroup = new KissenPaperPrivatePermissionGroup.KissenPaperPublicPermissionGroup();
+        publicGroup.getMeta().getData(publicGroup).thenAccept(map -> {
+            int saveID = publicGroup.getSaveID().length();
+            injector.inject(map, Context.GLOBAL, saveID);
+        }).join();
+
+        KissenPaperPrivatePermissionGroup privateGroup = new KissenPaperPrivatePermissionGroup();
+        privateGroup.getMeta().getData(privateGroup).thenAccept(map -> {
+            int saveID = privateGroup.getSaveID().length();
+            injector.inject(map, Context.LOCAL, saveID);
+        }).join();
+
+        KissenCore.getInstance().getLogger().info("Successfully loaded {} permission group(s) from the database.", cachedHolder.size());
+        return PaperPermissionImplementation.super.postStart();
+    }
+
+    @Override
+    public void setupComplete() {
+        CommandImplementation<CommandSender> command = Bukkit.getKissen().getImplementation(CommandImplementation.class);
+        command.getInternalHandler().registerCommand(new PermissionCommand());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermissionGroup> getGroups() {
+        return cachedHolder.stream().map(GroupHolder::toGroup).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getInternalGroups() {
+        return getGroups().stream().collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @NotNull Optional<PermissionGroup<?>> getPermissionGroupSavable(@NotNull String name) {
+        return getGroup(name).flatMap(group -> ((KissenPaperPermissionGroup) group).getContext(Context.GLOBAL));
+    }
+
+    @Override
+    public void removePermissionGroup(@NotNull String name) {
+        cachedHolder.removeIf(group -> group.getPermissionID().equals(name));
+    }
+
+    @Override
+    public @NotNull Optional<PaperPermissionGroup> getGroup(@NotNull String group) {
+        return getGroups().stream().filter(currentGroup -> currentGroup.getPermissionID().equals(group)).findFirst();
+    }
+
+    @Override
+    public @NotNull PaperPermissionGroup getGroupNotNull(@NotNull String group) throws EventCancelledException {
+        return getGroup(group).orElseGet(() -> create(group, null, Context.LOCAL));
+    }
+
+    @Override
+    public void addPermission(@NotNull String permission) {
+        if (Bukkit.getPluginManager().getPermission(permission)==null) {
+            Bukkit.getPluginManager().addPermission(new Permission(permission, PermissionDefault.OP));
+        }
+    }
+
+    @Override
+    public @NotNull PaperPermissionGroup create(@NotNull String name, @Nullable Map<String, Object> data) throws EventCancelledException {
+        return create(name, data, Context.GLOBAL);
+    }
+
+    /**
+     * Creates and returns a non-null {@link PaperPermissionGroup} associated with the specified name, data, and context.
+     * The creation process includes triggering a {@link KissenPermissionGroupCreateEvent}, and the group is only
+     * created if the event is not cancelled.
+     *
+     * @param name    The name of the permission group to create.
+     * @param data    Additional data for setting up the group, can be {@code null}.
+     * @param context The context in which to create the permission group.
+     * @return The created {@link PaperPermissionGroup}.
+     * @throws EventCancelledException If the creation event is cancelled.
+     * @throws NullPointerException    If either the 'name' or 'context' parameters are {@code null}.
+     */
+    public @NotNull PaperPermissionGroup create(@NotNull String name, @Nullable Map<String, Object> data, @NotNull Context context) throws EventCancelledException {
+        KissenPermissionGroupCreateEvent kissenPermissionGroupCreateEvent = new KissenPermissionGroupCreateEvent(name, data);
+        if (Bukkit.getKissen().getImplementation(EventImplementation.class).call(kissenPermissionGroupCreateEvent)) {
+            return this.createInternal(name, data, context).toGroup();
+        }
+        throw new EventCancelledException();
+    }
+
+    /**
+     * Retrieves an optional {@link PermissionGroup} of type {@link PaperPermission} associated with the specified name
+     * and context. The result is wrapped in an {@link Optional} to handle cases where the group is not present.
+     *
+     * @param name    The name of the permission group to retrieve.
+     * @param context The context in which to retrieve the permission group.
+     * @return An {@link Optional} containing the requested {@link PermissionGroup}, or an empty {@link Optional}
+     * if the group is not found.
+     * @throws NullPointerException If either the 'name' or 'context' parameters are {@code null}.
+     */
+    public @NotNull Optional<PermissionGroup<PaperPermission>> getGroup(@NotNull String name, @NotNull Context context) {
+        return getHolder(name).flatMap(groupHolder -> groupHolder.getGroup(context));
+    }
+
+    /**
+     * Retrieves a non-null {@link PermissionGroup} of type {@link PaperPermission} associated with the specified name
+     * and context. If the group is not present, it creates a new group using the {@code createInternal} method and returns it.
+     *
+     * @param name    The name of the permission group to retrieve.
+     * @param context The context in which to retrieve the permission group.
+     * @return The requested {@link PermissionGroup}, either existing or newly created.
+     * @throws NullPointerException If either the 'name' or 'context' parameters are {@code null}.
+     */
+    public @NotNull PermissionGroup<PaperPermission> getGroupNotNull(@NotNull String name, @NotNull Context context) {
+        return getGroup(name, context).orElseGet(() -> createInternal(name, null, context).getGroupOrThrow(context));
+    }
+
+    /**
+     * Retrieves an optional {@link GroupHolder} associated with the specified name from the cached holders.
+     * The result is wrapped in an {@link Optional} to handle cases where the holder is not present.
+     *
+     * @param name The name of the group holder to retrieve.
+     * @return An {@link Optional} containing the requested {@link GroupHolder}, or an empty {@link Optional}
+     * if the holder is not found.
+     * @throws NullPointerException If the 'name' parameter is {@code null}.
+     */
+    private @NotNull Optional<GroupHolder> getHolder(@NotNull String name) {
+        return cachedHolder.stream().filter(groupHolder -> groupHolder.getPermissionID().equals(name)).findFirst();
+    }
+
+    /**
+     * Retrieves a non-null {@link GroupHolder} associated with the specified name from the cached holders.
+     * If the holder is not present, it creates a new one, adds it to the cache, and returns the new holder.
+     *
+     * @param name The name of the group holder to retrieve.
+     * @return The requested {@link GroupHolder}, either existing or newly created.
+     * @throws NullPointerException If the 'name' parameter is {@code null}.
+     */
+    private @NotNull GroupHolder getHolderNotNull(@NotNull String name) {
+        return getHolder(name).orElseGet(() -> {
+            GroupHolder groupHolder = new GroupHolder(name);
+            cachedHolder.add(groupHolder);
+            return groupHolder;
+        });
+    }
+
+    /**
+     * Creates and returns a non-null {@link GroupHolder} associated with the specified name, data, and context.
+     * If a holder with the specified name already exists, it retrieves and returns the existing one.
+     * Otherwise, it creates a new holder, sets up the group based on the provided context, and returns the new holder.
+     *
+     * @param name    The name of the group holder to create or retrieve.
+     * @param data    Additional data for setting up the group, can be {@code null}.
+     * @param context The context in which to set up the group.
+     * @return The created or retrieved {@link GroupHolder} with the associated group set up.
+     * @throws NullPointerException If either the 'name' or 'context' parameters are {@code null}.
+     */
+    private @NotNull GroupHolder createInternal(@NotNull String name, @Nullable Map<String, Object> data, @NotNull Context context) {
+        GroupHolder holder = getHolderNotNull(name);
+        holder.setGroup(switch (context) {
+            case GLOBAL -> new KissenPaperPrivatePermissionGroup.KissenPaperPublicPermissionGroup();
+            case LOCAL -> new KissenPaperPrivatePermissionGroup();
+        }, context).setup(name, data);
+
+        return holder;
+    }
+
+    /**
+     * A static nested class representing a holder for a permission group.
+     * It contains methods for retrieving, setting up, and converting the associated permission group.
+     */
+    private static final class GroupHolder {
+        private final String permissionID;
+        private KissenPaperPrivatePermissionGroup privateGroup;
+        private KissenPaperPrivatePermissionGroup.KissenPaperPublicPermissionGroup publicGroup;
+
+        /**
+         * Constructs a new GroupHolder with the specified permission ID.
+         *
+         * @param permissionID The unique identifier for the permission group held by this holder.
+         */
+        private GroupHolder(@NotNull String permissionID) {
+            this.permissionID = permissionID;
+        }
+
+        /**
+         * Retrieves the permission ID associated with this GroupHolder.
+         *
+         * @return The permission ID.
+         */
+        private @NotNull String getPermissionID() {
+            return permissionID;
+        }
+
+        /**
+         * Retrieves an optional {@link KissenPaperAbstractPermissionGroup} associated with the specified context.
+         *
+         * @param context The context in which to retrieve the permission group.
+         * @return An {@link Optional} containing the requested {@link KissenPaperAbstractPermissionGroup},
+         * or an empty {@link Optional} if the group is not found.
+         * @throws NullPointerException If the 'context' parameter is {@code null}.
+         */
+        private @NotNull Optional<KissenPaperAbstractPermissionGroup> getGroup(@NotNull Context context) {
+            return Optional.ofNullable(switch (context) {
+                case GLOBAL -> publicGroup;
+                case LOCAL -> privateGroup;
+            });
+        }
+
+        /**
+         * Retrieves the associated {@link KissenPaperAbstractPermissionGroup} for the specified context.
+         * Throws {@link NullPointerException} if the group is not present.
+         *
+         * @param context The context in which to retrieve the permission group.
+         * @return The requested {@link KissenPaperAbstractPermissionGroup}.
+         * @throws NoSuchElementException If the 'context' parameter is {@code null} or the group is not found.
+         */
+        private @NotNull KissenPaperAbstractPermissionGroup getGroupOrThrow(@NotNull Context context) {
+            return getGroup(context).orElseThrow();
+        }
+
+        /**
+         * Sets the associated permission group for the specified context.
+         *
+         * @param group   The permission group to set.
+         * @param context The context in which to set the permission group.
+         * @return The set permission group.
+         */
+        private @NotNull KissenPaperAbstractPermissionGroup setGroup(@NotNull KissenPaperAbstractPermissionGroup group, @NotNull Context context) {
+            switch (context) {
+                case GLOBAL -> publicGroup = (KissenPaperPrivatePermissionGroup.KissenPaperPublicPermissionGroup) group;
+                case LOCAL -> privateGroup = (KissenPaperPrivatePermissionGroup) group;
+            }
+            return group;
+        }
+
+        /**
+         * Converts the GroupHolder to a non-null {@link PaperPermissionGroup}.
+         *
+         * @return A {@link PaperPermissionGroup} representation of the GroupHolder.
+         */
+        private @NotNull PaperPermissionGroup toGroup() {
+            return new KissenPaperPermissionGroup(getPermissionID());
+        }
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/PaperPermissionGroupParser.java b/src/main/java/net/kissenpvp/paper/permission/PaperPermissionGroupParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..0098e317437e60571f5b4320743c0b33615bc2f4
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/PaperPermissionGroupParser.java
@@ -0,0 +1,47 @@
+package net.kissenpvp.paper.permission;
+
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.core.api.permission.PermissionEntry;
+import net.kissenpvp.paper.api.command.PaperArgumentParser;
+import net.kissenpvp.paper.api.permission.PaperPermissionGroup;
+import net.kissenpvp.paper.api.permission.PaperPermissionImplementation;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Collection;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+public class PaperPermissionGroupParser implements PaperArgumentParser<PaperPermissionGroup>
+{
+    @Override
+    public @NotNull String serialize(@NotNull PaperPermissionGroup object)
+    {
+        return object.getPermissionID();
+    }
+
+    @Override
+    public @NotNull PaperPermissionGroup deserialize(@NotNull String input)
+    {
+        Class<PaperPermissionImplementation> clazz = PaperPermissionImplementation.class;
+        PaperPermissionImplementation paperPermissionImplementation = Bukkit.getKissen().getImplementation(clazz);
+        return paperPermissionImplementation.getGroupNotNull(input);
+    }
+
+    @Override
+    public @Nullable String argumentName()
+    {
+        return "group";
+    }
+
+    @Override
+    public @NotNull Collection<String> tabCompletion(@NotNull CommandPayload<CommandSender> commandPayload)
+    {
+        Class<PaperPermissionImplementation> clazz = PaperPermissionImplementation.class;
+        PaperPermissionImplementation permissionImplementation = Bukkit.getKissen().getImplementation(clazz);
+        Set<PaperPermissionGroup> groupSet = permissionImplementation.getGroups();
+        return groupSet.stream().map(PermissionEntry::getPermissionID).collect(Collectors.toSet());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/PermissionParser.java b/src/main/java/net/kissenpvp/paper/permission/PermissionParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..fe9dd0086c3d744d3fdbfaa3b8e3669e0c327349
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/PermissionParser.java
@@ -0,0 +1,63 @@
+package net.kissenpvp.paper.permission;
+
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.paper.api.command.PaperArgumentParser;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.bukkit.permissions.Permission;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+public class PermissionParser implements PaperArgumentParser<PermissionParser.PermissionArgument>
+{
+    @Override
+    public @NotNull String serialize(@NotNull PermissionArgument object)
+    {
+        return object.permission();
+    }
+
+    @Override
+    public @NotNull PermissionArgument deserialize(@NotNull String input)
+    {
+        return new PermissionArgument(input);
+    }
+
+    @Override
+    public @Nullable String argumentName()
+    {
+        return "permission";
+    }
+
+    @Override
+    public @NotNull Collection<String> tabCompletion(@NotNull CommandPayload<CommandSender> commandPayload)
+    {
+        return Bukkit.getPluginManager().getPermissions().stream().map(Permission::getName).flatMap(currentPermission ->
+                {
+                    Set<String> data = new HashSet<>(currentPermission.length());
+                    for (String current : currentPermission.split(";"))
+                    {
+                        StringBuilder stringBuilder = new StringBuilder();
+                        String[] parts = current.split("\\.");
+                        for (int i = 0; i < parts.length - 1; i++) {
+
+                            if (!stringBuilder.isEmpty() && stringBuilder.charAt(stringBuilder.length() - 1) == '*') {
+                                stringBuilder.deleteCharAt(stringBuilder.length() - 1);
+                            }
+
+                            stringBuilder.append(parts[i]).append(".*");
+                            data.add(stringBuilder.toString());
+                        }
+                        data.add(current);
+                    }
+                    return data.stream();
+                }
+                ).collect(Collectors.toSet());
+    }
+
+    public record PermissionArgument(@Override String permission) {}
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/RemoveAttachmentRunnable.java b/src/main/java/net/kissenpvp/paper/permission/RemoveAttachmentRunnable.java
new file mode 100644
index 0000000000000000000000000000000000000000..318e2520843c49567887703a254e03a8dc4171d5
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/RemoveAttachmentRunnable.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission;
+
+import org.bukkit.permissions.PermissionAttachment;
+import org.jetbrains.annotations.NotNull;
+
+public record RemoveAttachmentRunnable(PermissionAttachment attachment) implements Runnable {
+    public RemoveAttachmentRunnable(@NotNull PermissionAttachment attachment) {
+        this.attachment = attachment;
+    }
+
+    @Override
+    public void run() {
+        attachment.remove();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/command/PermissionCommand.java b/src/main/java/net/kissenpvp/paper/permission/command/PermissionCommand.java
index 4b96b6a41ca3ba9c0fce327cabcb02dcd10d6e6d..6a42898142a3a92c0ffe07c88cc4d056bcaf5964 100644
--- a/src/main/java/net/kissenpvp/paper/permission/command/PermissionCommand.java
+++ b/src/main/java/net/kissenpvp/paper/permission/command/PermissionCommand.java
@@ -20,7 +20,6 @@ import net.kyori.adventure.text.format.TextColor;
 import org.bukkit.Bukkit;
 import org.bukkit.OfflinePlayer;
 import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Player;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
@@ -40,8 +39,11 @@ public class PermissionCommand
     @CommandData(value = "permission.user", permission = "*", runAsync = true)
     public void permissionUser(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull OfflinePlayer player, @NotNull PermissionParser.PermissionArgument permission, @NotNull @ArgumentName("value") Optional<PermissionAction> value)
     {
-        commandPayload.confirmRequest(() -> commandPayload.getSender().sendMessage(
-                execute(player, permission.permission(), value.orElse(null))));
+        commandPayload.confirmRequest(() ->
+        {
+            Component response = execute(player, permission.permission(), value.orElse(null));
+            commandPayload.getSender().sendMessage(response);
+        }).send();
     }
 
     @CommandData(value = "permission.user.wipe", permission = "*", runAsync = true)
@@ -53,8 +55,11 @@ public class PermissionCommand
     @CommandData(value = "permission.group", permission = "*", runAsync = true)
     public void permissionGroup(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PaperPermissionGroup group, @NotNull PermissionParser.PermissionArgument permission, @NotNull @ArgumentName("value") Optional<PermissionAction> value)
     {
-        commandPayload.confirmRequest(() -> commandPayload.getSender().sendMessage(
-                execute(group, permission.permission(), value.orElse(null))));
+        commandPayload.confirmRequest(() ->
+        {
+            Component response = execute(group, permission.permission(), value.orElse(null));
+            commandPayload.getSender().sendMessage(response);
+        }).send();
     }
 
     @CommandData(value = "permission.group.create", permission = "*", runAsync = true)
diff --git a/src/main/java/net/kissenpvp/paper/permission/command/PermissionCommandExecutor.java b/src/main/java/net/kissenpvp/paper/permission/command/PermissionCommandExecutor.java
new file mode 100644
index 0000000000000000000000000000000000000000..d7ba9e479bc17461f8ef36b1e6330fdf963c806e
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/command/PermissionCommandExecutor.java
@@ -0,0 +1,108 @@
+package net.kissenpvp.paper.permission.command;
+
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.PaperGroupablePermissionEntry;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PaperPermissionEntry;
+import net.kissenpvp.paper.api.permission.PaperPermissionGroup;
+import net.kyori.adventure.text.Component;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Optional;
+import java.util.function.Function;
+
+/**
+ * The {@code PermissionCommandExecutor} class provides methods for executing permission-related commands
+ * within the context of a server. It is designed to handle operations such as setting or unsetting
+ * permissions for a given {@link PaperGroupablePermissionEntry} and interacting with a {@link PaperPermissionGroup}.
+ * This class is part of a broader system for managing permissions in a server environment.
+ *
+ * @param context The {@link Context} object representing the execution context of the commands.
+ */
+public record PermissionCommandExecutor(@NotNull Context context)
+{
+    /**
+     * Sets or removes a {@link PaperGroupablePermissionEntry} from a {@link PaperPermissionGroup}.
+     *
+     * @param add              {@code true} to add the entry to the group, {@code false} to remove it.
+     * @param permissionEntry The {@link PaperGroupablePermissionEntry} to be added or removed.
+     * @param permissionGroup The target {@link PaperPermissionGroup} for the operation.
+     * @return A {@link Component} indicating the success or failure of the operation.
+     */
+    public @NotNull Component setGroup(boolean add, @NotNull PaperGroupablePermissionEntry permissionEntry, @NotNull PaperPermissionGroup permissionGroup)
+    {
+        if (!(add ? permissionGroup.addMember(permissionEntry, context()) : permissionGroup.removeMember(permissionEntry, context())))
+        {
+            return Component.translatable("server.permission.group.failed", permissionEntry.displayName(),
+                    permissionGroup.displayName());
+        }
+        return Component.translatable("server.permission.group.success", permissionEntry.displayName());
+    }
+
+    /**
+     * Sets a permission for a {@link PaperGroupablePermissionEntry}.
+     *
+     * @param permissionEntry The {@link PaperGroupablePermissionEntry} for which the permission is set.
+     * @param permission      The name of the permission.
+     * @param unparsedBoolean An optional boolean value. If {@code null}, the opposite of the current value is used.
+     * @return A {@link Component} indicating the success or failure of the operation.
+     */
+    public @NotNull Component setPermission(@NotNull PaperGroupablePermissionEntry permissionEntry, @NotNull String permission, @Nullable Boolean unparsedBoolean)
+    {
+        boolean value = Optional.ofNullable(unparsedBoolean).orElseGet(
+                () -> permissionEntry.getOwnPermission(permission, context()).map(current -> !current.getValue()).orElse(true));
+
+        Component[] args = {
+                permissionEntry.displayName(),
+                Component.text(permission),
+                Component.text(value)
+        };
+
+        Component component = Component.translatable("server.permission.set.success", args);
+        Component failed = Component.translatable("server.permission.set.failed", args);
+
+        Function<PaperPermission, Component> mapper = paperPermission -> component;
+        return setPermission(permissionEntry, permission, value).map(mapper).orElse(failed);
+    }
+
+    /**
+     * Unsets a permission for a {@link PaperPermissionEntry}.
+     *
+     * @param permissionEntry The {@link PaperPermissionEntry} for which the permission is unset.
+     * @param permission      The name of the permission.
+     * @return A {@link Component} indicating the success or failure of the operation.
+     */
+    public @NotNull Component unsetPermission(@NotNull PaperPermissionEntry permissionEntry, @NotNull String permission)
+    {
+        Component[] args = {
+                permissionEntry.displayName(),
+                Component.text(permission)
+        };
+        if (!permissionEntry.unsetPermission(permission, context()))
+        {
+            return Component.translatable("server.permission.entity.failed", args);
+        }
+        return Component.translatable("server.permission.unset.success", args);
+    }
+
+    /**
+     * Sets a permission for a {@link PaperGroupablePermissionEntry} and returns an Optional result.
+     * This method is used internally to perform the permission setting operation.
+     *
+     * @param permissionEntry The {@link PaperGroupablePermissionEntry} for which the permission is set.
+     * @param permission      The name of the permission.
+     * @param value           The boolean value to set for the permission.
+     * @return An {@link Optional} containing the resulting {@link PaperPermission} if the operation is successful;
+     *         empty otherwise.
+     */
+    private @NotNull Optional<PaperPermission> setPermission(@NotNull PaperGroupablePermissionEntry permissionEntry, @NotNull String permission, boolean value)
+    {
+        Function<PaperPermission, Boolean> mapper = (paperPermission -> paperPermission.getValue() == value);
+        if (permissionEntry.getOwnPermission(permission).map(mapper).orElse(false))
+        {
+            return Optional.empty();
+        }
+        return Optional.of(permissionEntry.setPermission(permission, value, context()));
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperAbstractPermissionGroup.java b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperAbstractPermissionGroup.java
new file mode 100644
index 0000000000000000000000000000000000000000..70111d15131529d45c96f44ee163b582dd6436c4
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperAbstractPermissionGroup.java
@@ -0,0 +1,38 @@
+package net.kissenpvp.paper.permission.group;
+
+import net.kissenpvp.core.api.permission.PermissionEntry;
+import net.kissenpvp.core.database.DataWriter;
+import net.kissenpvp.core.permission.KissenPermissionGroup;
+import net.kissenpvp.core.permission.PermissionNode;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PaperPermissionImplementation;
+import net.kissenpvp.paper.permission.KissenPaperPermission;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public abstract class KissenPaperAbstractPermissionGroup extends KissenPermissionGroup<PaperPermission>
+{
+
+    @Override
+    public void permissionUpdate()
+    {
+        // instead update paper permission group
+        Class<PaperPermissionImplementation> clazz = PaperPermissionImplementation.class;
+        PaperPermissionImplementation permission = Bukkit.getKissen().getImplementation(clazz);
+        permission.getGroup(getPermissionID()).ifPresent(PermissionEntry::permissionUpdate);
+    }
+
+    public void internalPermissionUpdate()
+    {
+        super.permissionUpdate();
+    }
+
+    @Override
+    protected @NotNull PaperPermission translatePermission(@NotNull PermissionNode permissionNode, @Nullable DataWriter<PermissionNode> dataWriter) {
+        return new KissenPaperPermission(permissionNode, this, dataWriter);
+    }
+
+    protected abstract @NotNull Context getContext();
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPermissionGroup.java b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPermissionGroup.java
new file mode 100644
index 0000000000000000000000000000000000000000..42633597684d9817a7a5c80b493fd45fee4a87d0
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPermissionGroup.java
@@ -0,0 +1,163 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission.group;
+
+import net.kissenpvp.core.api.database.savable.Savable;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.permission.GroupablePermissionEntry;
+import net.kissenpvp.core.api.permission.PermissionEntry;
+import net.kissenpvp.core.api.permission.PermissionGroup;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PaperPermissionGroup;
+import net.kissenpvp.paper.permission.KissenPaperPermissionImplementation;
+import net.kissenpvp.paper.permission.permissible.KissenPaperPermissible;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Collections;
+import java.util.Optional;
+import java.util.Set;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public class KissenPaperPermissionGroup extends KissenPaperPermissible implements PaperPermissionGroup
+{
+    @Override
+    public void permissionUpdate()
+    {
+        Consumer<PermissionGroup<PaperPermission>> internalUpdate = entry ->
+        {
+            if(entry instanceof KissenPaperAbstractPermissionGroup abstractPermissionGroup)
+            {
+                abstractPermissionGroup.internalPermissionUpdate();
+            }
+        };
+
+        getContext(Context.LOCAL).ifPresent(internalUpdate);
+        getContext(Context.GLOBAL).ifPresent(internalUpdate);
+
+        getConnectedEntries().forEach(PermissionEntry::permissionUpdate);
+    }
+
+    private final String permissionID;
+
+    public KissenPaperPermissionGroup(@NotNull String permissionID)
+    {
+        this.permissionID = permissionID;
+    }
+
+    @Override
+    public @NotNull String getPermissionID() {
+        return permissionID;
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<String> getMember() {
+        Stream<String> local = getMember(Context.LOCAL).stream(), global = getMember(Context.GLOBAL).stream();
+        return Stream.concat(local, global).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<String> getOwnMember()
+    {
+        Stream<String> local = getOwnMember(Context.LOCAL).stream(), global = getOwnMember(Context.GLOBAL).stream();
+        return Stream.concat(local, global).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<String> getMember(@NotNull Context context)
+    {
+        return getContext(context).map(PermissionGroup::getMember).orElse(Collections.emptySet());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<String> getOwnMember(@NotNull Context context)
+    {
+        return getContext(context).map(PermissionGroup::getOwnMember).orElse(Collections.emptySet());
+    }
+
+    @Override
+    public boolean addMember(@NotNull GroupablePermissionEntry<?> groupablePermissionEntry) {
+        return addMember(groupablePermissionEntry, Context.GLOBAL);
+    }
+
+    @Override
+    public boolean addMember(@NotNull GroupablePermissionEntry<?> groupablePermissionEntry, @NotNull Context context) {
+        return getContext(context).map(group -> group.addMember(groupablePermissionEntry)).orElse(false);
+    }
+
+    @Override
+    public boolean removeMember(@NotNull GroupablePermissionEntry<?> groupablePermissionEntry) {
+        return removeMember(groupablePermissionEntry, Context.GLOBAL);
+    }
+
+    @Override
+    public int delete()
+    {
+        KissenPaperPermissionImplementation implementation = Bukkit.getKissen().getImplementation(KissenPaperPermissionImplementation.class);
+        implementation.removePermissionGroup(getPermissionID());
+
+        Function<GroupablePermissionEntry<PaperPermission>, Integer> delete = group -> ((Savable) group).delete();
+        return getContext(Context.LOCAL).map(delete).orElse(0) + getContext(Context.GLOBAL).map(delete).orElse(0);
+    }
+
+    @Override
+    public boolean removeMember(@NotNull GroupablePermissionEntry<?> groupablePermissionEntry, @NotNull Context context) {
+        return getContext(context).map(group -> group.removeMember(groupablePermissionEntry)).orElse(false);
+    }
+
+    @Override
+    public @NotNull Optional<PermissionGroup<PaperPermission>> getContext(@NotNull Context context)
+    {
+        Class<KissenPaperPermissionImplementation> clazz = KissenPaperPermissionImplementation.class;
+        KissenPaperPermissionImplementation permissionImplementation = Bukkit.getKissen().getImplementation(clazz);
+        return permissionImplementation.getGroup(getPermissionID(), context);
+    }
+
+    @Override
+    public @NotNull GroupablePermissionEntry<PaperPermission> getContextNotNull(@NotNull Context context)
+    {
+        Class<KissenPaperPermissionImplementation> clazz = KissenPaperPermissionImplementation.class;
+        KissenPaperPermissionImplementation permissionImplementation = Bukkit.getKissen().getImplementation(clazz);
+        return permissionImplementation.getGroupNotNull(getPermissionID(), context);
+    }
+
+    @Override
+    public boolean isOp() {
+        return hasPermission("*");
+    }
+
+    @Override
+    public void setOp(boolean value) {
+        if (isOp() && !value) {
+            unsetPermission("*");
+            return;
+        }
+
+        try {
+            setPermission("*", value);
+        } catch (EventCancelledException eventCancelledException) {
+            throw new RuntimeException(eventCancelledException);
+        }
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPrivatePermissionGroup.java b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPrivatePermissionGroup.java
new file mode 100644
index 0000000000000000000000000000000000000000..b91a5912871cb50d1f44e8c7eb0cb2df91205706
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPrivatePermissionGroup.java
@@ -0,0 +1,76 @@
+package net.kissenpvp.paper.permission.group;
+
+import net.kissenpvp.core.api.base.Kissen;
+import net.kissenpvp.core.api.database.meta.ObjectMeta;
+import net.kissenpvp.core.api.networking.socket.DataPackage;
+import net.kissenpvp.core.api.permission.PermissionGroup;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PaperPrivatePermissionGroup;
+import net.kissenpvp.paper.api.permission.PaperPublicPermissionGroup;
+import net.kissenpvp.paper.permission.KissenPaperPermissionImplementation;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Optional;
+
+public class KissenPaperPrivatePermissionGroup extends KissenPaperAbstractPermissionGroup implements PaperPrivatePermissionGroup
+{
+    @Override
+    public void sendData(@NotNull DataPackage dataPackage) { /* ignored */ }
+
+    @Override
+    public @NotNull String getSaveID()
+    {
+        return "privatepermissiongroup";
+    }
+
+    @Override
+    public @NotNull Optional<PermissionGroup<PaperPermission>> getPublicGroup()
+    {
+        Kissen kissen = Bukkit.getKissen();
+        KissenPaperPermissionImplementation implementation = kissen.getImplementation(KissenPaperPermissionImplementation.class);
+        return implementation.getGroup(getPermissionID(), Context.GLOBAL);
+    }
+
+    @Override
+    public @NotNull ObjectMeta getMeta()
+    {
+        return Bukkit.getKissen().getPrivateMeta();
+    }
+
+    @Override
+    protected @NotNull Context getContext()
+    {
+        return Context.LOCAL;
+    }
+
+    public static class KissenPaperPublicPermissionGroup extends KissenPaperAbstractPermissionGroup implements PaperPublicPermissionGroup
+    {
+        @Override
+        public @NotNull String getSaveID()
+        {
+            return "publicpermissiongroup";
+        }
+
+        @Override
+        public void sendData(@NotNull DataPackage dataPackage)
+        {
+            //TODO
+        }
+
+        @Override
+        public @NotNull Optional<PermissionGroup<PaperPermission>> getPrivateGroup()
+        {
+            Kissen kissen = Bukkit.getKissen();
+            KissenPaperPermissionImplementation implementation = kissen.getImplementation(KissenPaperPermissionImplementation.class);
+            return implementation.getGroup(getPermissionID(), Context.LOCAL);
+        }
+
+        @Override
+        protected @NotNull Context getContext()
+        {
+            return Context.GLOBAL;
+        }
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPermissible.java b/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPermissible.java
new file mode 100644
index 0000000000000000000000000000000000000000..65a085580c0428e02332643abce4ab1953386d8c
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPermissible.java
@@ -0,0 +1,183 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission.permissible;
+
+import net.kissenpvp.paper.api.permission.PaperPermissible;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.permission.KissenPaperAttachmentPermission;
+import net.kissenpvp.paper.permission.KissenPaperGroupablePermissionEntry;
+import net.kissenpvp.paper.permission.RemoveAttachmentRunnable;
+import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;
+import org.bukkit.Bukkit;
+import org.bukkit.permissions.Permissible;
+import org.bukkit.permissions.Permission;
+import org.bukkit.permissions.PermissionAttachment;
+import org.bukkit.permissions.PermissionRemovedExecutor;
+import org.bukkit.plugin.Plugin;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.function.BiConsumer;
+import java.util.logging.Level;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public abstract class KissenPaperPermissible extends KissenPaperGroupablePermissionEntry implements PaperPermissible {
+
+    protected final Permissible parent;
+    protected final Set<PermissionAttachment> attachments;
+    private boolean initialized;
+
+    public KissenPaperPermissible() {
+        this(null);
+    }
+
+    public KissenPaperPermissible(@Nullable Permissible parent) {
+        this.attachments = new HashSet<>();
+        this.parent = parent == null ? this : parent;
+        this.initialized = false;
+    }
+
+    @Override
+    public boolean isPermissionSet(@NotNull String name) {
+        return getPermission(name).isPresent();
+    }
+
+    @Override
+    public boolean isPermissionSet(@NotNull Permission perm) {
+        return isPermissionSet(perm.getName());
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull Permission perm) {
+        return hasPermission(perm.getName());
+    }
+
+    @Override
+    public @NotNull PermissionAttachment addAttachment(@NotNull Plugin plugin) {
+        PermissionAttachment result = new PermissionAttachment(plugin, parent);
+
+        attachments.add(result);
+        permissionUpdate();
+
+        return result;
+    }
+
+    @Override
+    public @NotNull PermissionAttachment addAttachment(@NotNull Plugin plugin, @NotNull String name, boolean value) {
+        PermissionAttachment permissionAttachment = addAttachment(plugin);
+        permissionAttachment.setPermission(name, value);
+        return permissionAttachment;
+    }
+
+    @Override
+    public @Nullable PermissionAttachment addAttachment(@NotNull Plugin plugin, @NotNull String name, boolean value, int ticks) {
+        PermissionAttachment permissionAttachment = addAttachment(plugin, ticks);
+        if (permissionAttachment != null) {
+            permissionAttachment.setPermission(name, value);
+        }
+        return permissionAttachment;
+    }
+
+    @Override
+    public @Nullable PermissionAttachment addAttachment(@NotNull Plugin plugin, int ticks) {
+        PermissionAttachment result = addAttachment(plugin);
+
+        if (Bukkit.getServer()
+                .getScheduler()
+                .scheduleSyncDelayedTask(plugin, new RemoveAttachmentRunnable(result), ticks) == -1) {
+            Bukkit.getServer()
+                    .getLogger()
+                    .log(Level.WARNING, "Could not add PermissionAttachment to " + LegacyComponentSerializer.legacySection().serialize(displayName()) + " for plugin " + plugin.getPluginMeta()
+                            .getDisplayName() + ": Scheduler returned -1");
+            result.remove();
+            return null;
+        } else {
+            return result;
+        }
+    }
+
+    @Override
+    public void removeAttachment(@NotNull PermissionAttachment attachment) {
+        if (attachments.remove(attachment)) {
+            PermissionRemovedExecutor permissionRemovedExecutor = attachment.getRemovalCallback();
+
+            if (permissionRemovedExecutor != null) {
+                permissionRemovedExecutor.attachmentRemoved(attachment);
+            }
+
+            permissionUpdate();
+        } else {
+            throw new IllegalArgumentException("Given attachment is not part of Permissible object " + LegacyComponentSerializer.legacySection().serialize(displayName()));
+        }
+    }
+
+    @Override
+    public void recalculatePermissions() {
+        if(initialized)
+        {
+            unsubscribe();
+        }
+
+        Bukkit.getServer().getPluginManager().subscribeToDefaultPerms(isOp() || hasPermission("*"), parent);
+        for (PaperPermission permission : getPermissionList()) {
+            Bukkit.getServer().getPluginManager().subscribeToPermission(permission.getName(), parent);
+        }
+        initialized = true;
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList() {
+        Set<KissenPaperAttachmentPermission> permissions = new HashSet<>();
+        for (PermissionAttachment attachment : attachments)
+        {
+            BiConsumer<String, Boolean> transform = (key, value) -> permissions.add(
+                    new KissenPaperAttachmentPermission(attachment, key, value, KissenPaperPermissible.this, true));
+            attachment.getPermissions().forEach(transform);
+        }
+
+        return Stream.concat(super.getPermissionList().stream(), permissions.stream()).collect(Collectors.toSet());
+    }
+
+    /**
+     * The <code>unsubscribe</code> method is used to deregister all permissions from a parent permission holder in the Bukkit server.
+     *
+     * <p>As a result of calling this method, the permission holder specified by 'parent' would not hold the permissions anymore until re-registered.</p>
+     *
+     * <p>Note: Parent could be a Player, a Group, or any entity that can hold permissions in Bukkit.</p>
+     *
+     * <p>It is advised to call this method when you no longer need the permissions to be associated with the parent or want to clear current permissions before setting new ones.</p>
+     *
+     * @see net.kissenpvp.core.api.permission.Permission
+     * @see Permissible
+     */
+    public void unsubscribe() {
+        for (String name : getPermissionList().stream()
+                .map(net.kissenpvp.core.api.permission.Permission::getName)
+                .collect(Collectors.toSet())) {
+            Bukkit.getServer().getPluginManager().unsubscribeFromPermission(name, parent);
+        }
+
+        Bukkit.getServer().getPluginManager().unsubscribeFromDefaultPerms(false, parent);
+        Bukkit.getServer().getPluginManager().unsubscribeFromDefaultPerms(true, parent);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPlayerPermissible.java b/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPlayerPermissible.java
new file mode 100644
index 0000000000000000000000000000000000000000..2218bac468aeaed0795749697105f5cda5f375e7
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPlayerPermissible.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission.permissible;
+
+import net.kissenpvp.core.api.permission.GroupablePermissionEntry;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kyori.adventure.text.Component;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.permissions.Permissible;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Collections;
+import java.util.Optional;
+import java.util.Set;
+import java.util.UUID;
+
+public class KissenPaperPlayerPermissible extends KissenPaperPermissible {
+
+    public KissenPaperPlayerPermissible(@NotNull Permissible parent) {
+        super(parent);
+    }
+
+    @Override
+    public void unsubscribe()
+    {
+        if (getPlayer().isConnected())
+        {
+            super.unsubscribe();
+        }
+    }
+
+    public @NotNull OfflinePlayer getPlayer() {
+        return (OfflinePlayer) parent; // Can be offline or online, does not matter
+    }
+
+    @Override
+    public @NotNull String getPermissionID() {
+        return getContextNotNull(Context.GLOBAL).getPermissionID();
+    }
+
+    @Override
+    public @NotNull Component displayName() {
+        return getPlayer().displayName();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAffectedUsers() {
+        return Collections.singleton(getPlayer().getUniqueId());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<GroupablePermissionEntry<PaperPermission>> getConnectedEntries()
+    {
+        return getPlayer().isConnected() ? Collections.singleton((GroupablePermissionEntry<PaperPermission>) parent) : Collections.EMPTY_SET;
+    }
+
+    @Override
+    public void permissionUpdate()
+    {
+        OfflinePlayer player = getPlayer();
+        if (player.isConnected())
+        {
+            ServerPlayer serverPlayer = ((CraftPlayer) player).getHandle();
+            MinecraftServer.getServer().getPlayerList().sendPlayerPermissionLevel(serverPlayer, true);
+        }
+    }
+
+    @Override
+    public @NotNull Optional<GroupablePermissionEntry<PaperPermission>> getContext(@NotNull Context context)
+    {
+        return Optional.of(getContextNotNull(context));
+    }
+
+    @Override
+    public boolean isOp() {
+        return getPlayer().isOp();
+    }
+
+    @Override
+    public void setOp(boolean value) {
+        getPlayer().setOp(value);
+    }
+
+    @Override
+    public @NotNull GroupablePermissionEntry<PaperPermission> getContextNotNull(@NotNull Context context)
+    {
+        return (GroupablePermissionEntry<PaperPermission>) getPlayer().getUser(context);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenOperatorDataNode.java b/src/main/java/net/kissenpvp/paper/user/KissenOperatorDataNode.java
new file mode 100644
index 0000000000000000000000000000000000000000..6e27b52d62505e5669f8b13235aba2cca5f20457
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/KissenOperatorDataNode.java
@@ -0,0 +1,15 @@
+package net.kissenpvp.paper.user;
+
+import com.mojang.authlib.GameProfile;
+import net.minecraft.server.players.ServerOpListEntry;
+import org.jetbrains.annotations.NotNull;
+
+public record KissenOperatorDataNode(int level, boolean bypassServerLimit)
+{
+
+    public @NotNull ServerOpListEntry getServerOpListEntry(@NotNull GameProfile profile)
+    {
+        return new ServerOpListEntry(profile, level(), bypassServerLimit());
+    }
+
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenPaperProfileCache.java b/src/main/java/net/kissenpvp/paper/user/KissenPaperProfileCache.java
new file mode 100644
index 0000000000000000000000000000000000000000..76bee84e10d7f9f311de61e5ea198e323e857a40
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/KissenPaperProfileCache.java
@@ -0,0 +1,101 @@
+package net.kissenpvp.paper.user;
+
+import com.mojang.authlib.GameProfile;
+import com.mojang.authlib.GameProfileRepository;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.api.user.UserInfo;
+import net.kissenpvp.core.api.user.UserRepository;
+import net.minecraft.server.players.GameProfileCache;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Optional;
+import java.util.UUID;
+import java.util.function.Function;
+
+/**
+ * KissenPaperProfileCache is a cache specifically designed for KissenPaper profiles.
+ * This cache extends the {@code GameProfileCache} class to provide additional functionalities
+ * specific to the KissenPaper profiles. It has been designed to be used in the KissenPaper game application.
+ */
+public class KissenPaperProfileCache extends GameProfileCache {
+
+    private final UserRepository userRepository;
+
+    /**
+     * Creates a new instance of KissenPaperProfileCache.
+     *
+     * @param profileRepository - a not-null instance of a GameProfileRepository which is used to fetch and cache profiles
+     * @throws IllegalArgumentException if profileRepository is null
+     */
+    public KissenPaperProfileCache(@NotNull GameProfileRepository profileRepository) {
+        //noinspection DataFlowIssue
+        super(profileRepository, null); // not file based
+        userRepository = new KissenPaperUserRepository(profileRepository);
+        KissenPaperUserImplementation.setKissenPaperProfileCache(this);
+    }
+
+    @Override
+    public void add(@NotNull GameProfile profile) { /* moved to net.kissenpvp.core.user.KissenPublicUser#setup(String, Map) */ }
+
+    @Nullable
+    @Override
+    public GameProfile getProfileIfCached(@NotNull String name) {
+        return get(name).orElse(null);
+    }
+
+    @Override
+    public @NotNull Optional<GameProfile> get(@NotNull String name) {
+        return Bukkit.getKissen().getImplementation(UserImplementation.class).getCachedUserProfile(name).map(transformUserInfo()).or(() ->
+        {
+            return getUserRepository().getUser(name).join().map(translateUser());
+        });
+    }
+
+    @Override
+    public @NotNull Optional<GameProfile> get(@NotNull UUID uuid) {
+        return Bukkit.getKissen().getImplementation(UserImplementation.class).getCachedUserProfile(uuid).map(transformUserInfo()).or(() ->
+        {
+            return getUserRepository().getUser(uuid).join().map(translateUser());
+        });
+    }
+
+    @Override
+    protected @NotNull List<GameProfileInfo> load() {
+        // ignored
+        return new ArrayList<>();
+    }
+
+    @Override
+    public void save(boolean asyncSave) {
+        // ignored
+    }
+
+    private @NotNull Function<UserInfo, GameProfile> transformUserInfo() {
+        return userInfo -> new GameProfile(userInfo.getUUID(), userInfo.getName());
+    }
+
+    /**
+     * Returns the UserRepository object used within this class.
+     *
+     * @return UserRepository that this class uses to perform user related operations
+     */
+    public @NotNull UserRepository getUserRepository() {
+        return userRepository;
+    }
+
+    /**
+     * Returns a Function that can be used to translate a User object into a GameProfile.
+     *
+     * @return Function that translates a User object into a GameProfile
+     */
+    @Contract(pure = true)
+    private @NotNull Function<User, GameProfile> translateUser() {
+        return user -> new GameProfile(UUID.fromString(user.getRawID()), user.getNotNull("name", String.class));
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenPaperPublicUser.java b/src/main/java/net/kissenpvp/paper/user/KissenPaperPublicUser.java
new file mode 100644
index 0000000000000000000000000000000000000000..c04c5a7dd979cfb56d6dcbabf32973a67b972481
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/KissenPaperPublicUser.java
@@ -0,0 +1,239 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.user;
+
+import net.kissenpvp.core.api.database.StorageImplementation;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.database.meta.ObjectMeta;
+import net.kissenpvp.core.api.database.savable.SavableMap;
+import net.kissenpvp.core.api.networking.client.entitiy.PlayerClient;
+import net.kissenpvp.core.api.networking.socket.DataPackage;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.base.KissenCore;
+import net.kissenpvp.core.database.DataWriter;
+import net.kissenpvp.core.event.EventImplementation;
+import net.kissenpvp.core.permission.PermissionNode;
+import net.kissenpvp.core.user.KissenPublicUser;
+import net.kissenpvp.core.user.KissenUser;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.user.event.VisualChangeEvent;
+import net.kissenpvp.paper.permission.KissenPaperPermission;
+import org.bukkit.Bukkit;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Objects;
+import java.util.UUID;
+
+/**
+ * The {@code KissenPaperPublicUser} class extends the {@link KissenPublicUser} class with {@link PaperPermission}
+ * as its generic type. It represents a public user within the KissenPaper system.
+ * <p>
+ * While it maintains the key characteristics of a {@link KissenPublicUser}, such as a UUID and name,
+ * the {@code KissenPaperPublicUser} further enhances this with specifics for a user that has a public profile
+ * accessible across multiple servers.
+ * @see KissenPublicUser
+ */
+public class KissenPaperPublicUser extends KissenPublicUser<PaperPermission> {
+
+    /**
+     * The constructor for the {@code KissenPaperPublicUser} class.
+     * It initializes a new instance of the class with a specified UUID and name.
+     *
+     * @param uuid A unique identifier. It may be nullable, representing a user, whose unique identifier
+     *             might not be known or relevant at the expire of creation.
+     * @param name A string representing the username. It may be nullable, representing a user whose name
+     *             might not be known or relevant at the expire of creation.
+     * @throws BackendException If an error occurs during the creation and initialization of a KissenPaperPublicUser instance.
+     */
+    public KissenPaperPublicUser(@Nullable UUID uuid, @Nullable String name) throws BackendException {
+        super(uuid, name);
+    }
+
+    /**
+     * An alternate constructor for the {@code KissenPaperPublicUser} class which initializes a new instance
+     * of the class with a SavableMap data structure.
+     *
+     * @param data A {@link SavableMap} object that contains user details.
+     *             It is expected to be used when loading a user from saved storage.
+     * @throws BackendException If an error occurs during the creation and initialization of a KissenPaperPublicUser instance.
+     */
+    public KissenPaperPublicUser(@NotNull SavableMap data) throws BackendException
+    {
+        super(data);
+    }
+
+    @Override
+    public PlayerClient<?, ?, ?> getPlayerClient() {
+        return getPrivateUserEntry().getPlayerClient();
+    }
+
+    @Override
+    protected @NotNull PaperPermission translatePermission(@NotNull PermissionNode permissionNode, @Nullable DataWriter<PermissionNode> dataWriter) {
+        return new KissenPaperPermission(permissionNode, this, dataWriter);
+    }
+
+    @Override
+    public void sendData(@NotNull DataPackage dataPackage) {
+        // TODO Networking and stuff
+    }
+
+    @Override
+    public void login() {
+        super.login();
+
+        getStorage().put("time_joined", System.currentTimeMillis());
+        ((KissenUser<?>) getPrivateUserEntry()).login();
+        getStorage().put("tick", true);
+    }
+
+    @Override
+    public void logout() {
+        super.logout();
+        Bukkit.getKissen().getImplementation(StorageImplementation.class).dropStorage(getDatabaseID());
+    }
+
+    @Override
+    public void tick() {
+        super.tick();
+        checkVisuals();
+
+        ((KissenUser<PaperPermission>) getPrivateUserEntry()).tick();
+    }
+
+    @Override
+    public int softDelete() throws BackendException {
+        return super.softDelete() + getPrivateUserEntry().delete();
+    }
+
+    /**
+     * The {@code getPrivateUserEntry} method retrieves an instance of a private user entry from the local storage.
+     * If the private user entry is not yet in the storage, it creates an entry using the 'setupPrivateUser' method.
+     * In case of an exception when creating the private user entry, an error log is produced, and the server
+     * is advised to be shut down to prevent further data problems.
+     *
+     * @return An instance of a {@link User} associated with the private user entry.
+     *         Cast is performed without check, which assumes that "private_user_entry" in the storage is always of {@link User} type.
+     */
+    public @NotNull User getPrivateUserEntry() {
+        if (!getStorage().containsKey("private_user_entry")) {
+            try {
+                KissenPaperPrivateUser privateUser = setupPrivateUser(UUID.fromString(getRawID()), getNotNull("name", String.class));
+                getStorage().put("private_user_entry", privateUser);
+                return privateUser; // If offline still return actual private entity
+            } catch (BackendException backendException) {
+                KissenCore.getInstance()
+                    .getLogger()
+                    .error("The backend was not able to create a private user entry for the user '{}' with the id '{}'. It's advised to shutdown the server to prevent further problems with the servers data.", getNotNull("name", String.class), getRawID());
+            }
+        }
+        return (User) getStorage().get("private_user_entry");
+    }
+
+    /**
+     * The {@code setupPrivateUser} method creates a new instance of a private user, {@link KissenPaperPrivateUser}, using provided UUID and username.
+     *
+     * @param uuid The UUID for the private user to be created.
+     * @param name The username of the private user.
+     * @return An instance of a {@link KissenPaperPrivateUser} initialized with the provided UUID and username.
+     * @throws BackendException If an error occurs during the creation and initialization of a KissenPaperPrivateUser instance.
+     * @see KissenPaperPrivateUser
+     */
+    protected @NotNull KissenPaperPrivateUser setupPrivateUser(UUID uuid, String name) throws BackendException {
+        return new KissenPaperPrivateUser(uuid, name);
+    }
+
+    private void checkVisuals()
+    {
+        int visualHash = getVisualHash();
+        if(!Objects.equals(getStorage().get("visual_hash"), visualHash))
+        {
+            getStorage().put("visual_hash", visualHash);
+
+            if (getStorage().containsKey("tick"))
+            {
+                ((KissenUser<?>) getPrivateUserEntry()).clearCache();
+                permissionUpdate();
+            }
+
+            Player player = Objects.requireNonNull(Bukkit.getPlayer(UUID.fromString(getRawID())));
+            VisualChangeEvent visualChangeEvent = new VisualChangeEvent(player);
+            Bukkit.getKissen().getImplementation(EventImplementation.class).call(visualChangeEvent);
+        }
+    }
+
+    private int getVisualHash()
+    {
+        PlayerClient<?, ?, ?> playerClient = getPlayerClient();
+        String suffix = playerClient.getSelectedSuffix().map(component -> component.getContent().toString()).orElse("");
+        return playerClient.getRank().hashCode() + suffix.hashCode();
+    }
+
+    /**
+     * The nested class {@code KissenPaperPrivateUser} extends the {@link KissenUser} class while specifying {@link PaperPermission}
+     * as its generic type. It represents a private user entity within the KissenPaper system.
+     * <p>
+     * While the key characteristics of a {@link KissenUser} are maintained such as a UUID and name,
+     * the KissenPaperPrivateUser further enhances this with specifics for a user that owns a private profile which only this
+     * server can access.
+     * @see KissenUser
+     */
+    public static class KissenPaperPrivateUser extends KissenUser<PaperPermission> {
+
+        /**
+         * The constructor for the {@code KissenPaperPrivateUser} class.
+         * It initializes a new instance of the class with specified UUID and name.
+         *
+         * @param uuid A unique identifier. It may be nullable, representing a user whose unique identifier
+         *             might not be known or relevant at the expire of creation.
+         * @param name A string representing the username. It may be nullable, representing a user whose name
+         *             might not be known or relevant at the expire of creation.
+         * @throws BackendException If an error occurs during the creation and initialization of a KissenPaperPrivateUser instance.
+         */
+        public KissenPaperPrivateUser(@Nullable UUID uuid, @Nullable String name) throws BackendException {
+            super(uuid, name);
+        }
+
+        @Override
+        public @NotNull String getSaveID() {
+            return Bukkit.getKissen().getImplementation(KissenPaperUserImplementation.class).getUserSaveID(Context.LOCAL);
+        }
+
+        @Override
+        public @NotNull ObjectMeta getMeta() {
+            return Bukkit.getKissen().getImplementation(KissenPaperUserImplementation.class).getUserMeta(Context.LOCAL);
+        }
+
+        @Override
+        public PlayerClient<?, ?, ?> getPlayerClient() {
+            UUID uuid = UUID.fromString(getRawID());
+            return Objects.requireNonNullElse(Bukkit.getPlayer(uuid), Bukkit.getOfflinePlayer(uuid));
+        }
+
+        @Override
+        protected @NotNull PaperPermission translatePermission(@NotNull PermissionNode permissionNode, @Nullable DataWriter<PermissionNode> dataWriter) {
+            return new KissenPaperPermission(permissionNode, this, dataWriter);
+        }
+
+        @Override
+        public void sendData(@NotNull DataPackage dataPackage) { /* Ignored because it's private */ }
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenPaperUserImplementation.java b/src/main/java/net/kissenpvp/paper/user/KissenPaperUserImplementation.java
new file mode 100644
index 0000000000000000000000000000000000000000..888ec31a0d24fba31ae859e0a39a6a82c560110e
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/KissenPaperUserImplementation.java
@@ -0,0 +1,166 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.user;
+
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.database.meta.ObjectMeta;
+import net.kissenpvp.core.api.database.savable.SavableMap;
+import net.kissenpvp.core.api.networking.client.entitiy.UnknownPlayerException;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.base.KissenImplementation;
+import net.kissenpvp.core.command.CommandImplementation;
+import net.kissenpvp.core.message.localization.KissenLocalizationImplementation;
+import net.kissenpvp.core.user.KissenUserImplementation;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.user.suffix.SuffixCommand;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+
+import java.text.MessageFormat;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.function.Supplier;
+
+/**
+ * The class 'KissenPaperUserImplementation' is an extension of the 'KissenUserImplementation' in the KissenPaper system.
+ * This class is responsible for interacting with or manipulating the paper-related functionality of a Kissen user.
+ * The class holds an instance of KissenPaperProfileCache which it uses to cache profiles for efficient read operations.
+ */
+public class KissenPaperUserImplementation extends KissenUserImplementation implements KissenImplementation
+{
+
+    private static KissenPaperProfileCache kissenPaperProfileCache;
+
+
+    @Override
+    public boolean start()
+    {
+        CommandImplementation<?> commandImplementation = Bukkit.getKissen().getImplementation(CommandImplementation.class);
+        commandImplementation.getInternalHandler().registerExceptionHandler(new UserSettingCommand());
+
+        KissenLocalizationImplementation localize = Bukkit.getKissen().getImplementation(KissenLocalizationImplementation.class);
+        localize.register("server.user.setting.changed", new MessageFormat("The setting {0} has been set to {1}."));
+        localize.register("server.user.setting.value.invalid", new MessageFormat("The value {0} is not allowed in setting {1}."));
+        localize.register("server.user.setting.not.found", new MessageFormat("The setting {0} does not exists."));
+        localize.register("server.user.setting.reset", new MessageFormat("The setting {1} has been reset to its default value {0}."));
+
+        localize.register("server.user.suffix.granted", new MessageFormat("The suffix {0} was granted to {1}."));
+        localize.register("server.user.suffix.received", new MessageFormat("You have received the suffix {0}."));
+        localize.register("server.user.suffix.revoked", new MessageFormat("The suffix {0} from player {1} was revoked."));
+        localize.register("server.user.suffix.not.found", new MessageFormat("The suffix {0} from player {1} was not found."));
+
+        return super.start();
+    }
+
+    @Override
+    public void setupComplete()
+    {
+        CommandImplementation<?> commandImplementation = Bukkit.getKissen().getImplementation(CommandImplementation.class);
+        commandImplementation.getInternalHandler().registerCommand(new UserSettingCommand());
+        commandImplementation.getInternalHandler().registerCommand(new SuffixCommand());
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull UUID uuid) {
+
+        Supplier<User> createUser = () -> kissenPaperProfileCache.getUserRepository().getUser(uuid).join().orElseThrow(() -> new UnknownPlayerException(String.valueOf(uuid)));
+        Supplier<User> loadUser = () -> {
+
+            CompletableFuture<SavableMap> future = getUserMeta().getData(getUserSaveID() + uuid);
+            return new KissenPaperPublicUser(future.handle((user, ex) ->
+            {
+                if (user != null)
+                {
+                    return user;
+                }
+                return createUser.get();
+            }).join());
+        };
+        return getOnlineUser(uuid).orElseGet(loadUser);
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull String name) throws BackendException {
+        try {
+            if (getUserProfiles().stream().noneMatch(userInfo -> userInfo.getName().equals(name))) {
+                throw new UnknownPlayerException(name);
+            }
+            return super.getUser(name);
+        } catch (UnknownPlayerException unknownPlayerException) {
+            return kissenPaperProfileCache.getUserRepository().getUser(name).join().orElseThrow(() -> new UnknownPlayerException(name));
+        }
+    }
+
+    /**
+     * Returns the User Save ID for the specified context.
+     *
+     * @param context an enum constant representing the context, either GLOBAL or LOCAL
+     * @return String representing the User Save ID. If context is GLOBAL, the ID is retrieved by getUserSaveID(),
+     * otherwise for LOCAL context, Returns the server's name concatenated with 'privateuser'.
+     */
+    public @NotNull String getUserSaveID(@NotNull Context context)
+    {
+        return switch (context)
+        {
+            case GLOBAL -> getUserSaveID();
+            case LOCAL -> "privateuser";
+        };
+    }
+
+    /**
+     * Returns the User MetaData for the specified context.
+     *
+     * @param context an enum constant indicating the context, either GLOBAL or LOCAL
+     * @return ObjectMeta instance representing User's metadata. If context is GLOBAL, the metadata is retrieved by getUserMeta(),
+     * otherwise for LOCAL context, Returns the private metadata available in Bukkit's 'Kissen'.
+     */
+    public @NotNull ObjectMeta getUserMeta(@NotNull Context context)
+    {
+        return switch (context)
+        {
+            case GLOBAL -> getUserMeta();
+            case LOCAL -> Bukkit.getKissen().getPrivateMeta();
+        };
+    }
+
+    /**
+     * This private static method retrieves the current instance of KissenPaperProfileCache.
+     *
+     * @return The current KissenPaperProfileCache instance.
+     */
+    private static KissenPaperProfileCache getKissenPaperProfileCache() {
+        return kissenPaperProfileCache;
+    }
+
+    /**
+     * This public static method sets the KissenPaperProfileCache with a new instance.
+     * The method expects to receive an instance of KissenPaperProfileCache.
+     * If the input is null, an IllegalStateException will be thrown.
+     *
+     * @param kissenPaperProfileCache A new KissenPaperProfileCache instance.
+     * @throws IllegalStateException If the provided KissenPaperProfileCache instance is null.
+     */
+    public static void setKissenPaperProfileCache(KissenPaperProfileCache kissenPaperProfileCache) {
+        if(kissenPaperProfileCache == null)
+        {
+            throw new IllegalStateException("Object already initialized.");
+        }
+        KissenPaperUserImplementation.kissenPaperProfileCache = kissenPaperProfileCache;
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenPaperUserRepository.java b/src/main/java/net/kissenpvp/paper/user/KissenPaperUserRepository.java
new file mode 100644
index 0000000000000000000000000000000000000000..74477d0a2bdd4df9f09bab3cbaec1ce7a7e749a5
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/KissenPaperUserRepository.java
@@ -0,0 +1,132 @@
+package net.kissenpvp.paper.user;
+
+import com.mojang.authlib.GameProfile;
+import com.mojang.authlib.GameProfileRepository;
+import com.mojang.authlib.ProfileLookupCallback;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.api.user.UserRepository;
+import net.minecraft.core.UUIDUtil;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Optional;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.atomic.AtomicReference;
+
+/**
+ * The class 'KissenPaperUserRepository' implements the 'UserRepository' interface.
+ * It represents a repository for the User entities from mojang.
+ * Compliant with the Repository pattern, this class is intended to encapsulate all
+ * data access mechanics needed for User entities.
+ * <p>
+ * It also holds a 'GameProfileRepository' which perhaps holds the source data for the
+ * Users, or is another important factor in the retrieval or manipulation of User data.
+ */
+public class KissenPaperUserRepository implements UserRepository {
+
+    private final GameProfileRepository gameProfileRepository;
+
+    /**
+     * The constructor for the 'KissenPaperUserRepository' class.
+     * It initializes a new instance of the class with a specified 'GameProfileRepository' object.
+     *
+     * @param gameProfileRepository A 'GameProfileRepository' object.
+     * Specifies the game profile repository that the user repository will work with.
+     */
+    public KissenPaperUserRepository(@NotNull GameProfileRepository gameProfileRepository) {
+        this.gameProfileRepository = gameProfileRepository;
+    }
+
+    @Override
+    public @NotNull CompletableFuture<Optional<User>> getUser(@NotNull String name) throws BackendException {
+
+        if(!shouldAuthorize())
+        {
+
+        }
+
+        CompletableFuture<Optional<User>> gameProfileCompletableFuture = new CompletableFuture<>();
+        AtomicReference<Optional<GameProfile>> fetchedRef = new AtomicReference<>(Optional.empty());
+
+        gameProfileRepository.findProfilesByNames(new String[]{name}, new ProfileLookupCallback() {
+            @Override
+            public void onProfileLookupSucceeded(GameProfile gameProfile) {
+                fetchedRef.set(Optional.ofNullable(gameProfile));
+            }
+
+            @Override
+            public void onProfileLookupFailed(String s, Exception e) {
+                gameProfileCompletableFuture.completeExceptionally(e);
+            }
+        });
+
+        fetchedRef.get().ifPresentOrElse(gameProfile -> processGameProfile(gameProfileCompletableFuture, gameProfile), () -> processMissingProfile(gameProfileCompletableFuture, name));
+
+        return gameProfileCompletableFuture;
+    }
+
+    @Override
+    public @NotNull CompletableFuture<Optional<User>> getUser(@NotNull UUID uuid) {
+        return null; //TODO
+    }
+
+    /**
+     * This method is used to determine whether authorization should take place.
+     * Its behaviour may be determined by the 'GlobalConfiguration' setting 'isProxyOnlineMode'.
+     * The return value implies whether the proxy is in online mode or not,
+     * which further implies whether authentication is needed.
+     *
+     * @return A boolean value -- 'true' when proxy is in online mode implying authorization
+     * is required for network interactions, 'false' otherwise.
+     */
+    private boolean shouldAuthorize()
+    {
+        return io.papermc.paper.configuration.GlobalConfiguration.get().proxies.isProxyOnlineMode();
+    }
+
+    /**
+     * Processes a potentially missing user profile. If authentication is not required,
+     * it will generate and process a "cracked" user profile with an offline player UUID.
+     * Otherwise, the method will complete the CompletableFuture with an empty Optional.
+     *
+     * @param gameProfileFuture a CompletableFuture that will be completed with the found (or not found) User
+     * @param name the name of the user to lookup
+     */
+    private void processMissingProfile(CompletableFuture<Optional<User>> gameProfileFuture, String name) {
+        if (!shouldAuthorize()) {
+            // Create cracked user
+            UUID offlineUUID = UUIDUtil.createOfflinePlayerUUID(name);
+            processGameProfile(gameProfileFuture, new GameProfile(offlineUUID, name));
+            return;
+        }
+        gameProfileFuture.complete(Optional.empty());
+    }
+
+    /**
+     * Processes a game profile and completes the CompletableFuture with the translated User object.
+     * If any error occurs during the translation, the resulting BackendException will be completed exceptionally
+     * inside the CompletableFuture.
+     *
+     * @param gameProfileFuture a CompletableFuture that will be completed with the translated User or an Error.
+     * @param gameProfile the game profile to process.
+     */
+    private void processGameProfile(CompletableFuture<Optional<User>> gameProfileFuture, GameProfile gameProfile) {
+        try {
+            gameProfileFuture.complete(Optional.of(translate(gameProfile)));
+        } catch (BackendException backendException) {
+            gameProfileFuture.completeExceptionally(backendException);
+        }
+    }
+
+    /**
+     * Translates a game profile into a KissenPaperPublicUser object.
+     *
+     * @param gameProfile the game profile to translate.
+     * @return KissenPaperPublicUser a new user object with the id and name from the passed game profile.
+     * @throws BackendException if any error occurs during the translation process.
+     */
+    private @NotNull User translate(@NotNull GameProfile gameProfile) throws BackendException {
+        return new KissenPaperPublicUser(gameProfile.getId(), gameProfile.getName());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenUserOperatorList.java b/src/main/java/net/kissenpvp/paper/user/KissenUserOperatorList.java
new file mode 100644
index 0000000000000000000000000000000000000000..f7a26a524f5d83dfd445b1228382508ee4d16ae5
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/KissenUserOperatorList.java
@@ -0,0 +1,250 @@
+package net.kissenpvp.paper.user;
+
+import com.google.gson.JsonObject;
+import com.mojang.authlib.GameProfile;
+import net.kissenpvp.core.api.database.DataImplementation;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.database.meta.ObjectMeta;
+import net.kissenpvp.core.api.database.queryapi.Column;
+import net.kissenpvp.core.api.database.queryapi.FilterType;
+import net.kissenpvp.core.api.database.queryapi.select.QuerySelect;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.paper.api.base.Context;
+import net.minecraft.server.players.ServerOpList;
+import net.minecraft.server.players.ServerOpListEntry;
+import net.minecraft.server.players.StoredUserEntry;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.File;
+import java.util.*;
+import java.util.concurrent.Executors;
+import java.util.stream.Collectors;
+
+/**
+ * This is a class that extends the functionality of StoredUserList. It provides functionality to manage a list
+ * of users and their operation permissions(data represented by type ServerOpListEntry), related to a game profile
+ * (data represented by type GameProfile).
+ * <p>
+ * An instance of it can be created by providing a file which acts as the storage medium for
+ * this user list.
+ * <p>
+ * This class may provide additions to StoredUserList, capturing behaviors specific to users
+ * who have operator permissions (as denoted by a ServerOpListEntry) linked to a specific game profile.
+ */
+public class KissenUserOperatorList extends ServerOpList {
+
+    private final Set<LinkedOperatorDataNode> cached;
+
+    /**
+     * This is a class that extends the functionality of StoredUserList. It provides functionality to manage a list
+     * of users and their operation permissions (data represented by type ServerOpListEntry), related to a game profile
+     * (data represented by type GameProfile).
+     * <p>
+     * It is initially not associated with any file storage. Thus, the user list is not loaded from any file nor
+     * does it persist between application invocations if not manually persisted.
+     * <p>
+     * This class may provide additions to StoredUserList, capturing behaviors specific to users
+     * who have operator permissions (as denoted by a ServerOpListEntry) linked to a specific game profile.
+     */
+    public KissenUserOperatorList() {
+        //noinspection DataFlowIssue
+        super(null); // not file based
+        this.cached = new HashSet<>();
+    }
+
+    @Override
+    public void add(@NotNull ServerOpListEntry entry) {
+        KissenOperatorDataNode operatorDataNode = new KissenOperatorDataNode(entry.getLevel(), entry.getBypassesPlayerLimit());
+        getCached().removeIf(linkedOperatorDataNode -> linkedOperatorDataNode.gameProfile().equals(entry.getUser()));
+        getCached().add(new LinkedOperatorDataNode(Objects.requireNonNull(entry.getUser()), operatorDataNode));
+
+        Executors.newSingleThreadExecutor().submit(() -> {
+            try {
+                getLocalUserMeta().setObject(getLocalUserSaveID() + Objects.requireNonNull(entry.getUser()).getId(), "operator", operatorDataNode);
+            } catch (BackendException backendException) {
+                throw new RuntimeException(String.format("Something went wrong when setting the operator data from user %s.", entry.getUser().getName()), backendException);
+            }
+        });
+    }
+
+    @Nullable
+    @Override
+    public ServerOpListEntry get(@NotNull GameProfile key) {
+        return getCached().stream().filter(
+                operators -> operators.gameProfile().equals(key)).findFirst().map(
+                LinkedOperatorDataNode::getServerOpListEntry).orElse(null);
+    }
+
+    @Override
+    public void remove(@NotNull GameProfile key) {
+        getCached().removeIf(linkedOperatorDataNode -> linkedOperatorDataNode.gameProfile().equals(key));
+        Executors.newSingleThreadExecutor().submit(() -> {
+            try {
+                getLocalUserMeta().delete(getLocalUserSaveID() + Objects.requireNonNull(key.getId()), "operator");
+            } catch (BackendException backendException) {
+                throw new RuntimeException(String.format("An error occurred when removing operator rights from user %s.", key.getName()), backendException);
+            }
+        });
+    }
+
+    @Override
+    public void remove(@NotNull StoredUserEntry<GameProfile> entry) {
+        remove(Objects.requireNonNull(entry.getUser()));
+    }
+
+    @Override
+    public String @NotNull [] getUserList() {
+        return getCached().stream().map(
+                linkedOperatorDataNode -> linkedOperatorDataNode.gameProfile().getName()).distinct().toArray(
+                String[]::new);
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return getCached().isEmpty();
+    }
+
+    @Override
+    protected boolean contains(@NotNull GameProfile k0) {
+        return getCached().stream().anyMatch(gameProfile -> gameProfile.gameProfile().equals(k0));
+    }
+
+    @Override
+    public @NotNull Collection<ServerOpListEntry> getEntries() {
+        return getCached().stream().map(LinkedOperatorDataNode::getServerOpListEntry).collect(Collectors.toSet());
+    }
+
+    @Override
+    public void save() {
+        //ignored
+    }
+
+    @Override
+    protected @NotNull StoredUserEntry<GameProfile> createEntry(@NotNull JsonObject json) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public @NotNull File getFile() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void load() {
+        fetchOperators();
+    }
+
+    @Override
+    protected @NotNull String getKeyForUser(@NotNull GameProfile profile) {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * This method fetch operators data from the local user metadata and returns an unmodifiable set of LinkedOperatorDataNode.
+     * Each LinkedOperatorDataNode record holds a GameProfile and a KissenOperatorDataNode which correlates user information and operator data.
+     * <p>
+     * An SQL SELECT query is constructed to fetch the TOTAL_ID and VALUE columns.
+     * Filters are appended to this query to match rows starting with local user SaveID and where KEY equals 'operator'.
+     * The information is fetched into the 'data' array where every array element corresponds to a row from the result.
+     * <p>
+     * The method iterates over each row from the query result:
+     * - Extracts UUID by stripping the SaveID off TOTAL_ID
+     * - Fetches UserInfo from user profiles matching the UUID
+     * - Throws a RuntimeException if no such profile is found
+     * - Constructs KissenOperatorDataNode from the VALUE column data
+     * - The UUID and KissenOperatorDataNode are combined into a new LinkedOperatorDataNode instance and added to the resultant set.
+     * <p>
+     * If any exception is raised during the backend processing, it is wrapped in a runtime exception with an appropriate
+     * error message and thrown, thus indicating the issue with loading operators.
+     * <p>
+     * The method guarantees to return a set of LinkedOperatorDataNode or throw an exception in case of an error.
+     *
+     * @throws RuntimeException if any error occurs while fetching and processing records from the database
+     */
+    private void fetchOperators()
+    {
+        cached.clear();
+
+        QuerySelect select = getLocalUserMeta().select(Column.TOTAL_ID, Column.VALUE).where(Column.TOTAL_ID, getLocalUserSaveID(), FilterType.STARTS_WITH).and(Column.KEY, "operator");
+        select.execute().thenAccept(data ->
+        {
+            UserImplementation userImplementation = Bukkit.getKissen().getImplementation(UserImplementation.class);
+            DataImplementation dataImplementation = Bukkit.getKissen().getImplementation(DataImplementation.class);
+
+            Arrays.stream(data).forEach(current ->
+            {
+                UUID uuid = UUID.fromString(current[0].toString().substring(getLocalUserSaveID().length()));
+                userImplementation.getCachedUserProfile(uuid).map(userInfo ->
+                {
+                    KissenOperatorDataNode node = (KissenOperatorDataNode) current[1];
+                    return new LinkedOperatorDataNode(new GameProfile(userInfo.getUUID(), userInfo.getName()), node);
+                }).ifPresent(cached::add);
+            });
+        });
+    }
+
+    /**
+     * Retrieves the local user save ID. This is typically used for persisting user data in the {@link Context#LOCAL}.
+     *
+     * @return saved ID of the local user.
+     */
+    private @NotNull String getLocalUserSaveID() {
+        return Bukkit.getKissen().getImplementation(KissenPaperUserImplementation.class).getUserSaveID(Context.LOCAL);
+    }
+
+    /**
+     * Retrieves implementation of {@link KissenPaperUserImplementation} for {@link Context#LOCAL} and gets User Metadata.
+     *
+     * @return object meta of the local user.
+     */
+    private @NotNull ObjectMeta getLocalUserMeta() {
+        return Bukkit.getKissen().getImplementation(KissenPaperUserImplementation.class).getUserMeta(Context.LOCAL);
+    }
+
+    /**
+     * Retrieves the set of LinkedOperatorDataNodes.
+     * <p>
+     * This method returns a set that contains all the LinkedOperatorDataNodes
+     * that are currently being managed.
+     *
+     * @return A Set containing all LinkedOperatorDataNodes.
+     * This returned set is not null.
+     */
+    protected @NotNull Set<LinkedOperatorDataNode> getCached()
+    {
+        return cached;
+    }
+
+    /**
+     * This is a record class that encapsulates a GameProfile and a KissenOperatorDataNode
+     * into a single entity, termed as a LinkedOperatorDataNode.
+     * <p>
+     * It provides a method `getServerOpListEntry()`, that utilizes `getServerOpListEntry`
+     * method from `kissenOperatorDataNode` and passes the `gameProfile` from this record.
+     * Resulting a ServerOpListEntry correlating user profile and operator data.
+     * <p>
+     * GameProfile part of this record is user's profile information & KissenOperatorDataNode is operator data.
+     * <p>
+     * The data items stored in a LinkedOperatorDataNode record can be accessed
+     * directly by name.
+     */
+    protected record LinkedOperatorDataNode(@NotNull GameProfile gameProfile,
+                                          @NotNull KissenOperatorDataNode kissenOperatorDataNode) {
+        /**
+         * Returns ServerOpListEntry that associates with this LinkedOperatorDataNode's operator data and game profile.
+         * The ServerOpListEntry is obtained by calling `getServerOpListEntry` method on `kissenOperatorDataNode`
+         * with `gameProfile` passed as parameter.
+         * <p>
+         * The method is expected to return a new ServerOpListEntry for every call.
+         *
+         * @return ServerOpListEntry constructed from gameProfile and kissenOperatorDataNode
+         */
+        @Contract(" -> new")
+        private @NotNull ServerOpListEntry getServerOpListEntry() {
+            return kissenOperatorDataNode.getServerOpListEntry(gameProfile);
+        }
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenUserWhiteList.java b/src/main/java/net/kissenpvp/paper/user/KissenUserWhiteList.java
new file mode 100644
index 0000000000000000000000000000000000000000..9fe1fcb004464e361a30e6f8cf126a0d53e2082f
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/KissenUserWhiteList.java
@@ -0,0 +1,157 @@
+package net.kissenpvp.paper.user;
+
+import com.google.gson.JsonObject;
+import com.mojang.authlib.GameProfile;
+import net.kissenpvp.core.api.database.meta.Meta;
+import net.kissenpvp.core.api.database.meta.ObjectMeta;
+import net.kissenpvp.core.api.database.queryapi.Column;
+import net.kissenpvp.core.api.database.queryapi.select.QuerySelect;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.api.user.UserInfo;
+import net.kissenpvp.core.user.UserInfoNode;
+import net.kissenpvp.paper.api.base.Context;
+import net.minecraft.server.players.StoredUserEntry;
+import net.minecraft.server.players.UserWhiteList;
+import net.minecraft.server.players.UserWhiteListEntry;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.*;
+import java.util.function.Predicate;
+import java.util.function.Supplier;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+
+public class KissenUserWhiteList extends UserWhiteList {
+
+    private final Set<UserInfo> whitelisted;
+
+    public KissenUserWhiteList() {
+        //noinspection DataFlowIssue
+        super(null); // not file based
+        this.whitelisted = new HashSet<>();
+    }
+
+    @Override
+    public @NotNull File getFile() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Nullable
+    @Override
+    public UserWhiteListEntry get(@NotNull GameProfile key) {
+        return getWhitelisted().stream().filter(userInfo -> userInfo.getUUID().equals(key.getId())).map(user -> new UserWhiteListEntry(new GameProfile(user.getUUID(), user.getName()))).findFirst().orElse(null);
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return getWhitelisted().isEmpty();
+    }
+
+    @Override
+    protected boolean contains(@NotNull GameProfile k0) {
+        return getWhitelisted().stream().anyMatch(userInfo -> userInfo.getUUID().equals(k0.getId()));
+    }
+
+    @Override
+    public @NotNull Collection<UserWhiteListEntry> getEntries() {
+        return getWhitelisted().stream().map(userInfo -> new GameProfile(userInfo.getUUID(), userInfo.getName())).map(UserWhiteListEntry::new).collect(Collectors.toSet());
+    }
+
+    @Override
+    public String @NotNull [] getUserList() {
+        return getWhitelisted().stream().map(UserInfo::getName).distinct().toArray(String[]::new);
+    }
+
+    @Override
+    public void add(@NotNull UserWhiteListEntry entry) {
+        if (!new io.papermc.paper.event.server.WhitelistStateUpdateEvent(com.destroystokyo.paper.profile.CraftPlayerProfile.asBukkitCopy(Objects.requireNonNull(entry.getUser())), io.papermc.paper.event.server.WhitelistStateUpdateEvent.WhitelistStatus.ADDED).callEvent()) {
+            return;
+        }
+        UserImplementation userImplementation = Bukkit.getKissen().getImplementation(UserImplementation.class);
+
+        Supplier<UserInfo> createNew = () -> new UserInfoNode(entry.getUser().getId(), entry.getUser().getName()).getUserInfo();
+        Predicate<UserInfo> userInfoPredicate = profile -> Objects.equals(entry.getUser().getId(), profile.getUUID());
+
+        whitelisted.removeIf(userInfo -> userInfo.getUUID().equals(entry.getUser().getId()));
+        whitelisted.add(userImplementation.getUserProfiles().stream().filter(userInfoPredicate).findFirst().orElseGet(createNew));
+
+        getLocalUserMeta().setInt(getLocalUserSaveID() + Objects.requireNonNull(entry.getUser()).getId(), "whitelist", 1);
+    }
+
+    @Override
+    public void remove(@NotNull GameProfile profile) {
+
+        if (!new io.papermc.paper.event.server.WhitelistStateUpdateEvent(com.destroystokyo.paper.profile.CraftPlayerProfile.asBukkitCopy(profile), io.papermc.paper.event.server.WhitelistStateUpdateEvent.WhitelistStatus.REMOVED).callEvent()) {
+            return;
+        }
+
+        whitelisted.removeIf(userInfo -> Objects.equals(profile.getId(), userInfo.getUUID()));
+        getLocalUserMeta().delete(getLocalUserSaveID() + profile.getId(), "whitelist");
+    }
+
+    @Override
+    public void save() throws IOException {
+        // ignored
+    }
+
+    @Override
+    public void load() throws IOException {
+        fetchWhitelistedUsers();
+    }
+
+    @Override
+    public void remove(@NotNull StoredUserEntry<GameProfile> entry) {
+        remove(Objects.requireNonNull(entry.getUser()));
+    }
+
+    @Override
+    protected @NotNull StoredUserEntry<GameProfile> createEntry(@NotNull JsonObject json) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    protected @NotNull String getKeyForUser(@NotNull GameProfile gameProfile) {
+        throw new UnsupportedOperationException();
+    }
+
+    protected @NotNull Set<UserInfo> getWhitelisted() {
+        return Collections.unmodifiableSet(whitelisted);
+    }
+
+    private void fetchWhitelistedUsers()
+    {
+        whitelisted.clear();
+        Meta meta = getLocalUserMeta();
+
+        QuerySelect querySelect = meta.select(Column.TOTAL_ID).where(Column.KEY, "whitelist");
+        querySelect.execute().thenAcceptAsync(data ->
+        {
+            UserImplementation userImplementation = Bukkit.getKissen().getImplementation(UserImplementation.class);
+            Stream<UUID> userStream = Arrays.stream(data[0]).map(Object::toString).map(UUID::fromString); //TODO more efficient
+            userStream.forEach(uuid -> userImplementation.getCachedUserProfile(uuid).ifPresent(whitelisted::add));
+        });
+    }
+
+    /**
+     * Retrieves implementation of {@link KissenPaperUserImplementation} for {@link Context#LOCAL} and gets User Metadata.
+     *
+     * @return object meta of the local user.
+     */
+    private @NotNull ObjectMeta getLocalUserMeta() {
+        return Bukkit.getKissen().getImplementation(KissenPaperUserImplementation.class).getUserMeta(Context.LOCAL);
+    }
+
+    /**
+     * Retrieves the local user save ID. This is typically used for persisting user data in the {@link Context#LOCAL}.
+     *
+     * @return saved ID of the local user.
+     */
+    private @NotNull String getLocalUserSaveID() {
+        return Bukkit.getKissen().getImplementation(KissenPaperUserImplementation.class).getUserSaveID(Context.LOCAL);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/UserSettingCommand.java b/src/main/java/net/kissenpvp/paper/user/UserSettingCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..7981e4082fd9c59035d0f47e3c1cb94395eddb1a
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/UserSettingCommand.java
@@ -0,0 +1,106 @@
+package net.kissenpvp.paper.user;
+
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.core.api.command.CommandTarget;
+import net.kissenpvp.core.api.command.annotations.ArgumentName;
+import net.kissenpvp.core.api.command.annotations.CommandData;
+import net.kissenpvp.core.api.command.annotations.TabCompleter;
+import net.kissenpvp.core.api.networking.client.entitiy.PlayerClient;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.api.user.exception.UnauthorizedException;
+import net.kissenpvp.core.api.user.usersetttings.PlayerSetting;
+import net.kissenpvp.core.api.user.usersetttings.UserValue;
+import net.kissenpvp.core.user.usersettings.IllegalSettingException;
+import net.kissenpvp.core.user.usersettings.KissenBoundPlayerSetting;
+import net.kissenpvp.paper.api.command.PaperCommandExceptionHandler;
+import net.kissenpvp.paper.api.networking.client.entity.PaperPlayerClient;
+import net.kyori.adventure.text.Component;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.function.Predicate;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public class UserSettingCommand implements PaperCommandExceptionHandler<IllegalSettingException>
+{
+    @Override
+    public boolean handle(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull IllegalSettingException throwable)
+    {
+        Component setting = Component.text(throwable.getSettingsKey());
+        commandPayload.getSender().sendMessage(Component.translatable("server.user.setting.not.found", setting));
+        return true;
+    }
+
+    @CommandData(value = "setting", runAsync = true, aliases = "settings", target = CommandTarget.PLAYER)
+    public void settingCommand(@NotNull CommandPayload<CommandSender> sender, @NotNull @ArgumentName("setting") String setting, @NotNull @ArgumentName("value") String... value) throws UnauthorizedException
+    {
+        sender.getSender().sendMessage(setSetting(sender, deserialize(setting), String.join(" ", value)));
+    }
+
+    private <T> @NotNull Component setSetting(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PlayerSetting<T> settingsKey, @NotNull String value) throws UnauthorizedException
+    {
+        Component setting = Component.text(settingsKey.getKey());
+        try
+        {
+            boolean reset = value.equalsIgnoreCase("reset");
+            PaperPlayerClient player = (PaperPlayerClient) commandPayload.getSender();
+            KissenBoundPlayerSetting<T> stetting = new KissenBoundPlayerSetting<>(settingsKey, player.getUser());
+
+            T newValue = reset ? settingsKey.getDefaultValue(player) : settingsKey.deserialize(value);
+            stetting.setValue(newValue);
+
+            String langKey = reset ? "server.user.setting.reset" : "server.user.setting.changed";
+            Component changedTo = Component.text(stetting.getUserSetting().serialize(newValue));
+            return Component.translatable(langKey, setting, changedTo);
+        }
+        catch (ClassCastException | IllegalArgumentException exception)
+        {
+            return Component.translatable("server.user.setting.value.invalid", setting, Component.text(value));
+        }
+    }
+
+    @TabCompleter("setting")
+    public @NotNull Collection<String> settingCommand(@NotNull CommandPayload<CommandSender> payload)
+    {
+        try
+        {
+            if (payload.getArguments().length < 2)
+            {
+                return tabCompletion(payload);
+            }
+
+            PlayerSetting<?> playerSetting = deserialize(payload.getArguments()[0]);
+            Stream<? extends @NotNull UserValue<?>> stream = Arrays.stream(playerSetting.getPossibleValues(
+                    (PlayerClient<?, ?, ?>) payload.getSender()));
+            Stream<String> possibilities = stream.map(value -> castUnknownValue(value, playerSetting));
+            return Stream.concat(Stream.of("reset"), possibilities).collect(Collectors.toSet());
+        }
+        catch (IllegalSettingException ignored) {}
+        return Collections.EMPTY_SET;
+    }
+
+    public @NotNull PlayerSetting<?> deserialize(@NotNull String input)
+    {
+        UserImplementation userImplementation = Bukkit.getKissen().getImplementation(UserImplementation.class);
+        Stream<PlayerSetting<?>> settings = userImplementation.getPlayerSettings().stream();
+        Predicate<PlayerSetting<?>> predicate = userSetting -> userSetting.getKey().equals(input);
+        return settings.filter(predicate).findFirst().orElseThrow(() -> new IllegalSettingException(input));
+    }
+
+    public @NotNull Collection<String> tabCompletion(@NotNull CommandPayload<CommandSender> commandPayload)
+    {
+        UserImplementation userImplementation = Bukkit.getKissen().getImplementation(UserImplementation.class);
+        Stream<PlayerSetting<?>> settings = userImplementation.getPlayerSettings().stream();
+        return settings.map(PlayerSetting::getKey).collect(Collectors.toSet());
+    }
+
+    private <T> @NotNull String castUnknownValue(Object value, @NotNull PlayerSetting<T> playerSetting)
+    {
+        return playerSetting.serialize(((UserValue<T>) value).value());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperFallBackRank.java b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperFallBackRank.java
new file mode 100644
index 0000000000000000000000000000000000000000..b16bca5af55d0a4b487637e52801a9c9aa8713e1
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperFallBackRank.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.user.rank;
+
+import net.kissenpvp.core.user.rank.KissenFallBackRank;
+import net.kissenpvp.paper.api.networking.client.entity.PaperPlayerClient;
+import net.kissenpvp.paper.api.user.rank.PaperRank;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Set;
+import java.util.stream.Collectors;
+
+public class KissenPaperFallBackRank extends KissenFallBackRank implements PaperRank {
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPlayerClient> getPlayers() {
+        return Bukkit.getOnlinePlayers().stream().filter(playerClient ->
+        {
+            PaperRank paperRank = playerClient.getRank().getSource();
+            return paperRank.equals(this);
+        }).collect(Collectors.toUnmodifiableSet());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperPlayerFallBackRank.java b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperPlayerFallBackRank.java
new file mode 100644
index 0000000000000000000000000000000000000000..ae0177561b38a8a5ad90084cc97a8e7b4ea3819d
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperPlayerFallBackRank.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.user.rank;
+
+import net.kissenpvp.core.user.rank.KissenPlayerFallBackRank;
+import net.kissenpvp.paper.api.user.rank.PaperPlayerRank;
+import net.kissenpvp.paper.api.user.rank.PaperRank;
+import org.jetbrains.annotations.NotNull;
+
+public class KissenPaperPlayerFallBackRank extends KissenPlayerFallBackRank<PaperRank> implements PaperPlayerRank
+{
+    @Override public @NotNull PaperRank getSource()
+    {
+        return new KissenPaperFallBackRank();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperPlayerRank.java b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperPlayerRank.java
new file mode 100644
index 0000000000000000000000000000000000000000..62690a93c5fd063380a0328847b8e37830827d64
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperPlayerRank.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.user.rank;
+
+import net.kissenpvp.core.database.DataWriter;
+import net.kissenpvp.core.user.rank.KissenPlayerRank;
+import net.kissenpvp.core.user.rank.PlayerRankNode;
+import net.kissenpvp.paper.api.user.rank.PaperPlayerRank;
+import net.kissenpvp.paper.api.user.rank.PaperRank;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class KissenPaperPlayerRank extends KissenPlayerRank<PaperRank> implements PaperPlayerRank {
+    public KissenPaperPlayerRank(@NotNull PlayerRankNode playerRankNode, @Nullable DataWriter<PlayerRankNode> dataWriter) {
+        super(playerRankNode, dataWriter);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperRank.java b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperRank.java
new file mode 100644
index 0000000000000000000000000000000000000000..419844684b827bbbc4edeb6293bcbc75793067d5
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperRank.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.user.rank;
+
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.networking.socket.DataPackage;
+import net.kissenpvp.core.event.EventImplementation;
+import net.kissenpvp.core.user.rank.KissenRank;
+import net.kissenpvp.paper.api.networking.client.entity.PaperPlayerClient;
+import net.kissenpvp.paper.api.user.rank.PaperRank;
+import net.kissenpvp.paper.user.rank.event.KissenPaperRankSetChatColorEvent;
+import net.kissenpvp.paper.user.rank.event.KissenPaperRankSetPrefixEvent;
+import net.kissenpvp.paper.user.rank.event.KissenPaperRankSetPriorityEvent;
+import net.kissenpvp.paper.user.rank.event.KissenPaperRankSetSuffixEvent;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.TextColor;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Set;
+import java.util.stream.Collectors;
+
+public class KissenPaperRank extends KissenRank implements PaperRank
+{
+    @Override
+    public void sendData(@NotNull DataPackage dataPackage) {
+        //TODO async network and so on
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPlayerClient> getPlayers() {
+        return Bukkit.getOnlinePlayers().stream().filter(playerClient ->
+        {
+            PaperRank paperRank = playerClient.getRank().getSource();
+            return paperRank.equals(this);
+        }).collect(Collectors.toUnmodifiableSet());
+    }
+
+
+    @Override
+    public void setPriority(int priority)
+    {
+        KissenPaperRankSetPriorityEvent event = new KissenPaperRankSetPriorityEvent(this, getPriority(), priority);
+        EventImplementation eventImplementation = Bukkit.getKissen().getImplementation(EventImplementation.class);
+        if(!eventImplementation.call(event))
+        {
+            throw new EventCancelledException();
+        }
+        super.setPriority(priority);
+    }
+
+    @Override
+    public void setPrefix(@Nullable Component prefix)
+    {
+        KissenPaperRankSetPrefixEvent event = new KissenPaperRankSetPrefixEvent(this, getPrefix().orElse(null), prefix);
+        EventImplementation eventImplementation = Bukkit.getKissen().getImplementation(EventImplementation.class);
+        if(!eventImplementation.call(event))
+        {
+            throw new EventCancelledException();
+        }
+        super.setPrefix(prefix);
+    }
+
+    @Override
+    public void setChatColor(@NotNull TextColor chatColor)
+    {
+        KissenPaperRankSetChatColorEvent event = new KissenPaperRankSetChatColorEvent(this, getChatColor(), chatColor);
+        EventImplementation eventImplementation = Bukkit.getKissen().getImplementation(EventImplementation.class);
+        if(!eventImplementation.call(event))
+        {
+            throw new EventCancelledException();
+        }
+        super.setChatColor(chatColor);
+    }
+
+    @Override
+    public void setSuffix(@Nullable Component suffix)
+    {
+        KissenPaperRankSetSuffixEvent event = new KissenPaperRankSetSuffixEvent(this, getSuffix().orElse(null), suffix);
+        EventImplementation eventImplementation = Bukkit.getKissen().getImplementation(EventImplementation.class);
+        if(!eventImplementation.call(event))
+        {
+            throw new EventCancelledException();
+        }
+        super.setSuffix(suffix);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperRankImplementation.java b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperRankImplementation.java
new file mode 100644
index 0000000000000000000000000000000000000000..312543ea9fe0f7e3ad06765d46fba7f7e61bf30a
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperRankImplementation.java
@@ -0,0 +1,58 @@
+package net.kissenpvp.paper.user.rank;
+
+import net.kissenpvp.core.api.database.savable.Savable;
+import net.kissenpvp.core.base.KissenImplementation;
+import net.kissenpvp.core.command.CommandImplementation;
+import net.kissenpvp.core.message.localization.KissenLocalizationImplementation;
+import net.kissenpvp.core.user.rank.KissenRankImplementation;
+import net.kissenpvp.paper.api.user.rank.PaperRank;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+
+import java.text.MessageFormat;
+
+public class KissenPaperRankImplementation extends KissenRankImplementation<PaperRank> implements KissenImplementation
+{
+
+    @Override
+    public boolean start()
+    {
+        KissenLocalizationImplementation localize = Bukkit.getKissen().getImplementation(KissenLocalizationImplementation.class);
+        localize.register("server.rank.edit.prefix.set", new MessageFormat("The prefix from rank {0} has been set to {1}.."));
+        localize.register("server.rank.edit.suffix.set", new MessageFormat("The suffix from rank {0} has been set to {1}.."));
+        localize.register("server.rank.edit.chatcolor.set", new MessageFormat("The chatcolor from rank {0} has been set to {1}."));
+        localize.register("server.rank.edit.priority.set", new MessageFormat("The priority from rank {0} has been set to {1}."));
+
+        localize.register("server.rank.player.granted", new MessageFormat("The player {0} now has the rank {1} granted."));
+        localize.register("server.rank.player.revoked", new MessageFormat("The rank {1} from player {0} has been revoked."));
+        localize.register("server.rank.player.not.found", new MessageFormat("The player {0} does not have a rank with the id {1}."));
+
+        localize.register("server.rank.created", new MessageFormat("The rank {0} has been created with the priority {1} and the chat color {2}."));
+        localize.register("server.rank.deleted", new MessageFormat("The rank {0} has been deleted."));
+
+        CommandImplementation<CommandSender> commandImplementation = Bukkit.getKissen().getImplementation(
+                CommandImplementation.class);
+        commandImplementation.getInternalHandler().registerParser(PaperRank.class, new PaperRankParser());
+        return super.start();
+    }
+
+    @Override
+    public void setupComplete()
+    {
+        CommandImplementation<CommandSender> commandImplementation = Bukkit.getKissen().getImplementation(CommandImplementation.class);
+        commandImplementation.getInternalHandler().registerCommand(new RankCommand());
+    }
+
+    @Override
+    protected @NotNull Savable getSavableType()
+    {
+        return new KissenPaperRank();
+    }
+
+    @Override
+    protected @NotNull PaperRank getFallbackRank()
+    {
+        return new KissenPaperFallBackRank();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/PaperRankParser.java b/src/main/java/net/kissenpvp/paper/user/rank/PaperRankParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..f8a3c48622f620f1ffbebbfddd0a1cd623e650ff
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/PaperRankParser.java
@@ -0,0 +1,43 @@
+package net.kissenpvp.paper.user.rank;
+
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.paper.api.command.PaperArgumentParser;
+import net.kissenpvp.paper.api.user.rank.PaperRank;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Collection;
+import java.util.stream.Collectors;
+
+public class PaperRankParser implements PaperArgumentParser<PaperRank>
+{
+    @Override
+    public @NotNull String serialize(@NotNull PaperRank object)
+    {
+        return object.getName();
+    }
+
+    @Override
+    public @NotNull PaperRank deserialize(@NotNull String input)
+    {
+        Class<KissenPaperRankImplementation> clazz = KissenPaperRankImplementation.class;
+        KissenPaperRankImplementation rankImplementation = Bukkit.getKissen().getImplementation(clazz);
+        return rankImplementation.getRank(input).orElseThrow(NullPointerException::new);
+    }
+
+    @Override
+    public @Nullable String argumentName()
+    {
+        return "rank";
+    }
+
+    @Override
+    public @NotNull Collection<String> tabCompletion(@NotNull CommandPayload<CommandSender> commandPayload)
+    {
+        Class<KissenPaperRankImplementation> clazz = KissenPaperRankImplementation.class;
+        KissenPaperRankImplementation rankImplementation = Bukkit.getKissen().getImplementation(clazz);
+        return rankImplementation.getRankSet().stream().map(PaperRank::getName).collect(Collectors.toSet());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/RankCommand.java b/src/main/java/net/kissenpvp/paper/user/rank/RankCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..698c9227b5e612e74e5b3560e28fd0cd042b1e44
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/RankCommand.java
@@ -0,0 +1,157 @@
+package net.kissenpvp.paper.user.rank;
+
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.core.api.command.annotations.ArgumentName;
+import net.kissenpvp.core.api.command.annotations.CommandData;
+import net.kissenpvp.core.api.command.annotations.TabCompleter;
+import net.kissenpvp.core.api.command.exception.ArgumentMissingException;
+import net.kissenpvp.core.api.time.AccurateDuration;
+import net.kissenpvp.core.api.time.TemporalObject;
+import net.kissenpvp.core.api.user.rank.PlayerRank;
+import net.kissenpvp.paper.api.user.rank.PaperPlayerRank;
+import net.kissenpvp.paper.api.user.rank.PaperRank;
+import net.kissenpvp.paper.command.parser.OfflinePlayerParser;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;
+import org.bukkit.Bukkit;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+
+import java.time.Instant;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Optional;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import java.util.stream.Collectors;
+
+public class RankCommand {
+
+    @CommandData("rank")
+    public void rank() {
+        throw new ArgumentMissingException();
+    }
+
+    @CommandData(value = "rank.grant", runAsync = true)
+    public void rankGrant(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull OfflinePlayer offlinePlayer, @NotNull @ArgumentName("rank") PaperRank paperRank, @NotNull @ArgumentName("duration") Optional<AccurateDuration> accurateDuration) {
+        Function<AccurateDuration, PaperPlayerRank> grant = duration -> offlinePlayer.grantRank(paperRank, duration);
+        Supplier<PaperPlayerRank> orElse = () -> offlinePlayer.grantRank(paperRank);
+        commandPayload.getSender().sendMessage(rankGrant(offlinePlayer, accurateDuration.map(grant).orElseGet(orElse)));
+    }
+
+    @CommandData(value = "rank.revoke", runAsync = true)
+    public void rankRevoke(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull OfflinePlayer offlinePlayer, @ArgumentName("playerrankid") @NotNull String id) {
+        commandPayload.getSender().sendMessage(rankRevoke(offlinePlayer, id));
+    }
+
+    @CommandData(value = "rankedit", aliases = "re")
+    public void rankEdit(@NotNull CommandPayload<?> commandPayload) {
+        throw new ArgumentMissingException();
+    }
+
+    @CommandData(value = "rankedit.prefix", runAsync = true)
+    public void rankPrefix(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PaperRank paperRank, @NotNull @ArgumentName("prefix") String[] prefix) {
+        String mounted = String.join(" ", prefix).replace('&', '');
+        if (mounted.replaceAll("&.", "").isBlank()) {
+            throw new ArgumentMissingException();
+        }
+        Component prefixComponent = LegacyComponentSerializer.legacySection().deserialize(mounted);
+        paperRank.setPrefix(prefixComponent);
+
+        Component[] args = {Component.text(paperRank.getName()), prefixComponent};
+        commandPayload.getSender().sendMessage(Component.translatable("server.rank.edit.prefix.set", args));
+    }
+
+    @CommandData(value = "rankedit.prefix.none", runAsync = true)
+    public void rankPrefix(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PaperRank paperRank) {
+        paperRank.setPrefix(null);
+        commandPayload.getSender().sendMessage(Component.translatable("server.rank.edit.prefix.set", Component.text(paperRank.getName()), Component.text("none")));
+    }
+
+    @CommandData(value = "rankedit.suffix", runAsync = true)
+    public void rankSuffix(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PaperRank paperRank, @NotNull @ArgumentName("suffix") String[] suffix) {
+        String mounted = String.join(" ", suffix).replace('&', '');
+        if (mounted.replaceAll("&.", "").isBlank()) {
+            throw new ArgumentMissingException();
+        }
+
+        Component suffixComponent = LegacyComponentSerializer.legacySection().deserialize(mounted);
+        paperRank.setSuffix(suffixComponent);
+
+        Component[] args = {Component.text(paperRank.getName()), suffixComponent};
+        commandPayload.getSender().sendMessage(Component.translatable("server.rank.edit.suffix.set", args));
+    }
+
+    @CommandData(value = "rankedit.suffix.none", runAsync = true)
+    public void rankSuffix(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PaperRank paperRank) {
+        paperRank.setSuffix(null);
+        commandPayload.getSender().sendMessage(Component.translatable("server.rank.edit.suffix.set", Component.text(paperRank.getName()), Component.text("none")));
+    }
+
+    @CommandData(value = "rankedit.priority", runAsync = true)
+    public void rankRevoke(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PaperRank paperRank, @ArgumentName("priority") int priority) {
+        paperRank.setPriority(priority);
+
+        Component[] args = {Component.text(paperRank.getName()), Component.text(priority)};
+        commandPayload.getSender().sendMessage(Component.translatable("server.rank.edit.priority.set", args));
+    }
+
+    @CommandData(value = "rankedit.chatcolor", runAsync = true)
+    public void rankRevoke(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PaperRank paperRank, @NotNull NamedTextColor namedTextColor) {
+        paperRank.setChatColor(namedTextColor);
+        Component[] args = {Component.text(paperRank.getName()), Component.text(namedTextColor.toString())};
+        commandPayload.getSender().sendMessage(Component.translatable("server.rank.edit.chatcolor.set", args));
+    }
+
+    @CommandData(value = "rankcreate", aliases = "createrank", runAsync = true)
+    public void rankCreate(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull @ArgumentName("name") String name, @ArgumentName("priority") int priority, @NotNull NamedTextColor namedTextColor) {
+        Class<KissenPaperRankImplementation> clazz = KissenPaperRankImplementation.class;
+        KissenPaperRankImplementation rankImplementation = Bukkit.getKissen().getImplementation(clazz);
+        Map<String, Object> data = new HashMap<>();
+        data.put("priority", priority);
+        data.put("chat_color", namedTextColor);
+
+        PaperRank paperRank = rankImplementation.createRank(name, data);
+        Component[] args = {Component.text(paperRank.getName()), Component.text(priority), Component.text(namedTextColor.toString())};
+        commandPayload.getSender().sendMessage(Component.translatable("server.rank.created", args));
+    }
+
+    @CommandData(value = "rankdelete", aliases = "deleterank", runAsync = true)
+    public void rankDelete(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PaperRank paperRank) {
+        paperRank.delete();
+        commandPayload.getSender().sendMessage(Component.translatable("server.rank.player.deleted", Component.text(paperRank.getName())));
+    }
+
+    private @NotNull Component rankGrant(@NotNull OfflinePlayer offlinePlayer, @NotNull PaperPlayerRank paperPlayerRank) {
+        Component rankName = Component.text(paperPlayerRank.getSource().getName());
+        return Component.translatable("server.rank.player.granted", offlinePlayer.displayName(), rankName);
+    }
+
+    public @NotNull Component rankRevoke(@NotNull OfflinePlayer offlinePlayer, @NotNull String id) {
+        Component[] args = {offlinePlayer.displayName(), Component.text(id)};
+
+        if (offlinePlayer.getRankHistory().stream().anyMatch(current -> {
+            if (current.getID().equals(id) && current.isValid()) {
+                current.setEnd(Instant.now());
+                return true;
+            }
+            return false;
+        })) {
+            return Component.translatable("server.rank.player.revoked", args);
+        }
+        return Component.translatable("server.rank.player.not.found", args);
+    }
+
+    @TabCompleter(value = "rank.revoke")
+    public @NotNull Collection<String> rankRevokeTab(@NotNull CommandPayload<CommandSender> commandPayload) {
+        OfflinePlayerParser offlinePlayerParser = new OfflinePlayerParser();
+        if (commandPayload.getArguments().length < 2) {
+            return offlinePlayerParser.tabCompletion(commandPayload);
+        }
+        OfflinePlayer offlinePlayer = offlinePlayerParser.deserialize(commandPayload.getArguments()[0]);
+        return offlinePlayer.getRankHistory().stream().filter(TemporalObject::isValid).map(PlayerRank::getID).collect(Collectors.toSet());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetChatColorEvent.java b/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetChatColorEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..52aedab9c4f0828cca92b4f3ff6ba187085be160
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetChatColorEvent.java
@@ -0,0 +1,15 @@
+package net.kissenpvp.paper.user.rank.event;
+
+import net.kissenpvp.core.api.user.rank.event.RankSetChatColorEvent;
+import net.kissenpvp.core.user.rank.event.KissenRankSetEvent;
+import net.kissenpvp.paper.api.user.rank.PaperRank;
+import net.kyori.adventure.text.format.TextColor;
+import org.jetbrains.annotations.NotNull;
+
+public class KissenPaperRankSetChatColorEvent extends KissenRankSetEvent<PaperRank, TextColor> implements RankSetChatColorEvent<PaperRank>
+{
+    public KissenPaperRankSetChatColorEvent(@NotNull PaperRank rank, @NotNull TextColor old, @NotNull TextColor updated)
+    {
+        super(rank, old, updated);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetPrefixEvent.java b/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetPrefixEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..7f644e5a133b5f85807f7ee2ec2fb6a0d71d3d75
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetPrefixEvent.java
@@ -0,0 +1,16 @@
+package net.kissenpvp.paper.user.rank.event;
+
+import net.kissenpvp.core.api.user.rank.event.RankSetPrefixEvent;
+import net.kissenpvp.core.user.rank.event.KissenRankSetEvent;
+import net.kissenpvp.paper.api.user.rank.PaperRank;
+import net.kyori.adventure.text.Component;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class KissenPaperRankSetPrefixEvent extends KissenRankSetEvent<PaperRank, Component> implements RankSetPrefixEvent<PaperRank>
+{
+    public KissenPaperRankSetPrefixEvent(@NotNull PaperRank rank, @Nullable Component old, @Nullable Component updated)
+    {
+        super(rank, old, updated);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetPriorityEvent.java b/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetPriorityEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..b8935be5d3201d3d88e5cc51a5990a33a21ad37b
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetPriorityEvent.java
@@ -0,0 +1,14 @@
+package net.kissenpvp.paper.user.rank.event;
+
+import net.kissenpvp.core.api.user.rank.event.RankSetPriorityEvent;
+import net.kissenpvp.core.user.rank.event.KissenRankSetEvent;
+import net.kissenpvp.paper.api.user.rank.PaperRank;
+import org.jetbrains.annotations.NotNull;
+
+public class KissenPaperRankSetPriorityEvent extends KissenRankSetEvent<PaperRank, Integer> implements RankSetPriorityEvent<PaperRank>
+{
+    public KissenPaperRankSetPriorityEvent(@NotNull PaperRank rank, @NotNull Integer old, @NotNull Integer updated)
+    {
+        super(rank, old, updated);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetSuffixEvent.java b/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetSuffixEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..1fa9a490165d87b19312001931bb3dd5881ed833
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetSuffixEvent.java
@@ -0,0 +1,16 @@
+package net.kissenpvp.paper.user.rank.event;
+
+import net.kissenpvp.core.api.user.rank.event.RankSetPrefixEvent;
+import net.kissenpvp.core.user.rank.event.KissenRankSetEvent;
+import net.kissenpvp.paper.api.user.rank.PaperRank;
+import net.kyori.adventure.text.Component;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class KissenPaperRankSetSuffixEvent extends KissenRankSetEvent<PaperRank, Component> implements RankSetPrefixEvent<PaperRank>
+{
+    public KissenPaperRankSetSuffixEvent(@NotNull PaperRank rank, @Nullable Component old, @Nullable Component updated)
+    {
+        super(rank, old, updated);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/suffix/SuffixCommand.java b/src/main/java/net/kissenpvp/paper/user/suffix/SuffixCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..ba3a05bd5f97af18c06bd81670a64eed0544c678
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/suffix/SuffixCommand.java
@@ -0,0 +1,96 @@
+package net.kissenpvp.paper.user.suffix;
+
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.core.api.command.annotations.ArgumentName;
+import net.kissenpvp.core.api.command.annotations.CommandData;
+import net.kissenpvp.core.api.command.annotations.TabCompleter;
+import net.kissenpvp.core.api.command.exception.ArgumentMissingException;
+import net.kissenpvp.core.api.time.TemporalObject;
+import net.kissenpvp.core.api.time.TimeImplementation;
+import net.kissenpvp.core.api.user.suffix.Suffix;
+import net.kissenpvp.paper.command.parser.OfflinePlayerParser;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;
+import org.bukkit.Bukkit;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Collection;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public class SuffixCommand
+{
+
+    @CommandData("suffix")
+    public void suffix(@NotNull CommandPayload<CommandSender> commandPayload)
+    {
+        throw new ArgumentMissingException();
+    }
+
+    @CommandData("suffix.grant")
+    public void grantSuffix(@NotNull CommandPayload<CommandSender> payload, @NotNull @ArgumentName("player") OfflinePlayer offlinePlayer, @NotNull @ArgumentName("name") String name, @NotNull @ArgumentName("suffix") String[] suffix)
+    {
+        Runnable setSuffix =     () ->
+        {
+            String mounted = String.join(" ", suffix).replace('&', '');
+            Component suffixComponent = LegacyComponentSerializer.legacySection().deserialize(mounted);
+
+            TimeImplementation timeImplementation = Bukkit.getKissen().getImplementation(TimeImplementation.class);
+            offlinePlayer.grantSuffix(name, suffixComponent);
+
+            Component suffixName = Component.text(name);
+
+            payload.getSender().sendMessage(Component.translatable("server.user.suffix.granted", suffixName, offlinePlayer.displayName()));
+            if(offlinePlayer.isOnline())
+            {
+                ((Player) offlinePlayer).sendMessage(Component.translatable("server.user.suffix.received", suffixComponent));
+            }
+        };
+
+        if (offlinePlayer.getSuffix(name).filter(TemporalObject::isValid).isPresent())
+        {
+            payload.confirmRequest(setSuffix).send();
+            return;
+        }
+        setSuffix.run();
+    }
+
+    @CommandData("suffix.revoke")
+    public void revokeSuffix(@NotNull CommandPayload<CommandSender> payload, @NotNull @ArgumentName("player") OfflinePlayer offlinePlayer, @NotNull @ArgumentName("name") String name)
+    {
+        Component[] arguments = {
+                Component.text(name),
+                offlinePlayer.displayName()
+        };
+        if(offlinePlayer.revokeSuffix(name))
+        {
+            payload.getSender().sendMessage(Component.translatable("server.user.suffix.revoked", arguments));
+            return;
+        }
+        payload.getSender().sendMessage(Component.translatable("server.user.suffix.not.found", arguments));
+    }
+
+    @TabCompleter("suffix.revoke")
+    public @NotNull @Unmodifiable Collection<String> revokeSuffixTab(@NotNull CommandPayload<CommandSender> commandPayload)
+    {
+        OfflinePlayerParser parser = new OfflinePlayerParser();
+        if(commandPayload.getArguments().length < 2)
+        {
+            return parser.tabCompletion(commandPayload);
+        }
+
+        Stream<Suffix> suffixes = parser.deserialize(commandPayload.getArguments()[0]).getSuffixSet().stream();
+        return suffixes.filter(suffix ->
+        {
+            if(suffix.getName().equals("rank"))
+            {
+                return false;
+            }
+            return suffix.isValid();
+        }).map(Suffix::getName).collect(Collectors.toUnmodifiableSet());
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Main.java b/src/main/java/net/minecraft/server/Main.java
index 61840cfd64caba6595dfc99c91c76a195638d4ee..ea772cb2288726632fb5d8ab8f1b5fd07990236a 100644
--- a/src/main/java/net/minecraft/server/Main.java
+++ b/src/main/java/net/minecraft/server/Main.java
@@ -190,15 +190,17 @@ public class Main {
             org.spigotmc.SpigotConfig.disabledAdvancements = spigotConfiguration.getStringList("advancements.disabled"); // Paper - fix SPIGOT-5885, must be set early in init
             // Paper start - fix SPIGOT-5824
             File file;
-            File userCacheFile = new File(Services.USERID_CACHE_FILE);
+            /* KissenPaper - remove cache file
+             * File userCacheFile = new File(Services.USERID_CACHE_FILE);
+             */
             if (optionset.has("universe")) {
                 file = (File) optionset.valueOf("universe"); // CraftBukkit
-                userCacheFile = new File(file, Services.USERID_CACHE_FILE);
+                //userCacheFile = new File(file, Services.USERID_CACHE_FILE); // KissenPaper
             } else {
                 file = new File(bukkitConfiguration.getString("settings.world-container", "."));
             }
             // Paper end - fix SPIGOT-5824
-            Services services = Services.create(new com.destroystokyo.paper.profile.PaperAuthenticationService(Proxy.NO_PROXY), file, userCacheFile, optionset); // Paper - pass OptionSet to load paper config files; override authentication service; fix world-container
+            Services services = Services.create(new com.destroystokyo.paper.profile.PaperAuthenticationService(Proxy.NO_PROXY), file/*, userCacheFile KissenPaper - remove cache file*/, optionset); // Paper - pass OptionSet to load paper config files; override authentication service; fix world-container
             // CraftBukkit start
             String s = (String) Optional.ofNullable((String) optionset.valueOf("world")).orElse(dedicatedserversettings.getProperties().levelName);
             LevelStorageSource convertable = LevelStorageSource.createDefault(file.toPath());
diff --git a/src/main/java/net/minecraft/server/Services.java b/src/main/java/net/minecraft/server/Services.java
index d89c624554ab08bd1b33a3f62b52aa57aaafb8b4..bcf7dae94dd64b06d55dc4e7a5e6cb10ed35220f 100644
--- a/src/main/java/net/minecraft/server/Services.java
+++ b/src/main/java/net/minecraft/server/Services.java
@@ -24,10 +24,10 @@ public record Services(MinecraftSessionService sessionService, ServicesKeySet se
     // Paper end - add paper configuration files
     public static final String USERID_CACHE_FILE = "usercache.json"; // Paper - private -> public
 
-    public static Services create(YggdrasilAuthenticationService authenticationService, File rootDirectory, File userCacheFile, joptsimple.OptionSet optionSet) throws Exception { // Paper - add optionset to load paper config files; add userCacheFile parameter
+    public static Services create(YggdrasilAuthenticationService authenticationService, File rootDirectory, /* File userCacheFile KissenPaper - remove cache file,*/ joptsimple.OptionSet optionSet) throws Exception { // Paper - add optionset to load paper config files; add userCacheFile parameter
         MinecraftSessionService minecraftSessionService = authenticationService.createMinecraftSessionService();
         GameProfileRepository gameProfileRepository = authenticationService.createProfileRepository();
-        GameProfileCache gameProfileCache = new GameProfileCache(gameProfileRepository, userCacheFile); // Paper - use specified user cache file
+        GameProfileCache gameProfileCache = /*new GameProfileCache(gameProfileRepository, userCacheFile);*/  new net.kissenpvp.paper.user.KissenPaperProfileCache(gameProfileRepository); // Paper - use specified user cache file  // KissenPaper - use database instead
         // Paper start - load paper config files from cli options
         final java.nio.file.Path legacyConfigPath = ((File) optionSet.valueOf("paper-settings")).toPath();
         final java.nio.file.Path configDirPath = ((File) optionSet.valueOf("paper-settings-directory")).toPath();
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedPlayerList.java b/src/main/java/net/minecraft/server/dedicated/DedicatedPlayerList.java
index 1c9cf5e1c4ee05724ffcdbd77a19bca1ab2be4d3..f66c5066683cd51f31fc97894af04ac1189521b5 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedPlayerList.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedPlayerList.java
@@ -30,7 +30,7 @@ public class DedicatedPlayerList extends PlayerList {
         this.loadOps();
         this.loadWhiteList();
         this.saveOps();
-        if (!this.getWhiteList().getFile().exists()) {
+        if (/*!this.getWhiteList().getFile().exists()*/ true) { // KissenPaper
             this.saveWhiteList();
         }
 
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index 58591bf2f63b9c5e97d9ce4188dff3366968a178..bdba9fa1b597bfb4bbef1accdfa605b3af8d2b43 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -2084,17 +2084,22 @@ public class ServerPlayer extends Player {
 
     public void sendSystemMessage(Component message, boolean overlay) {
         if (this.acceptsSystemMessages(overlay)) {
-            this.connection.send(new ClientboundSystemChatPacket(message, overlay), PacketSendListener.exceptionallySend(() -> {
-                if (this.acceptsSystemMessages(false)) {
-                    boolean flag1 = true;
-                    String s = message.getString(256);
-                    MutableComponent ichatmutablecomponent = Component.literal(s).withStyle(ChatFormatting.YELLOW);
-
-                    return new ClientboundSystemChatPacket(Component.translatable("multiplayer.message_not_delivered", ichatmutablecomponent).withStyle(ChatFormatting.RED), false);
-                } else {
-                    return null;
-                }
-            }));
+            // KissenPaper start - add custom renderer
+            net.kyori.adventure.text.Component component = PaperAdventure.asAdventure(message);
+            Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.message.ChatImplementation.class).prepareMessage(Bukkit.getConsoleSender(), getBukkitEntity(), component).ifPresent(styled ->
+                this.connection.send(new ClientboundSystemChatPacket(styled, overlay), PacketSendListener.exceptionallySend(() -> {
+                    if (this.acceptsSystemMessages(false)) {
+                        boolean flag1 = true;
+                        String s = message.getString(256);
+                        MutableComponent ichatmutablecomponent = Component.literal(s).withStyle(ChatFormatting.YELLOW);
+
+                        return new ClientboundSystemChatPacket(PaperAdventure.asAdventure(Component.translatable("multiplayer.message_not_delivered", ichatmutablecomponent).withStyle(ChatFormatting.RED)), false);
+                    } else {
+                        return null;
+                    }
+                }))
+            );
+            // KissenPaper end
         }
     }
 
diff --git a/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
index c5fa9f4d28f9a7f64a50a902ee5e631bfc00119c..1c1efc5a493b57e2913d40389edc19109dc4bb5c 100644
--- a/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
@@ -45,6 +45,13 @@ import org.bukkit.event.player.AsyncPlayerPreLoginEvent;
 import org.bukkit.event.player.PlayerPreLoginEvent;
 // CraftBukkit end
 
+// KissenPaper start
+import org.bukkit.Bukkit;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.user.KissenUserImplementation;
+import net.kissenpvp.paper.user.KissenPaperPublicUser;
+// KissenPaper end
+
 public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener, TickablePacketListener {
 
     private static final AtomicInteger UNIQUE_THREAD_ID = new AtomicInteger(0);
@@ -308,6 +315,17 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener,
             return gameprofile;
         }
         // Paper end - Add Velocity IP Forwarding Support
+
+        // KissenPaper start
+        KissenPaperPublicUser kissenPaperPublicUser = new KissenPaperPublicUser(gameprofile.getId(), gameprofile.getName());
+        if (!loginUser(kissenPaperPublicUser, gameprofile))
+        {
+            kissenPaperPublicUser.logout();
+            return gameprofile;
+        }
+        // KissenPaper end
+
+        // Paper end - Velocity support
         String playerName = gameprofile.getName();
         java.net.InetAddress address = ((java.net.InetSocketAddress) this.connection.getRemoteAddress()).getAddress();
         java.util.UUID uniqueId = gameprofile.getId();
@@ -351,6 +369,47 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener,
     }
     // CraftBukkit end
 
+    // KissenPaper start
+    /**
+     * Attempts to log in a user represented by a GameProfile object. This includes loading the KissenPaperPublicUser via a
+     * KissenUserImplementation, checking the user's ban status, and if not banned, loading the user's
+     * private data.
+     *
+     * <p>If the user cannot be loaded, or they have an outstanding punishment, the method
+     * will disconnect them with an appropriate message and return false. If an exception occurs in the process,
+     * the user is also disconnected and false is returned. If the user is loaded successfully and has no
+     * outstanding punishments, true is returned.</p>
+     *
+     * @param gameProfile The GameProfile of the user attempting to log in. This parameter must not be null.
+     * @return true if the user was successfully logged in, false otherwise.
+     * @throws NullPointerException If gameProfile is null.
+     *
+     * @see KissenPaperPublicUser
+     * @see net.kissenpvp.paper.api.ban.PaperBanImplementation
+     * @see net.kissenpvp.paper.api.ban.PaperPunishment
+     * @see GameProfile
+     */
+    private boolean loginUser(@org.jetbrains.annotations.NotNull KissenPaperPublicUser kissenPaperPublicUser, @org.jetbrains.annotations.NotNull GameProfile gameProfile) {
+        try {
+            if(!Bukkit.getKissen().getImplementation(KissenUserImplementation.class).loadUser(kissenPaperPublicUser))
+            {
+                disconnect(Component.translatable("multiplayer.disconnect.unverified_username"));
+                return false;
+            }
+
+            if(Bukkit.hasWhitelist() && !MinecraftServer.getServer().getPlayerList().isWhiteListed(gameProfile))
+            {
+                disconnect(Component.translatable("multiplayer.disconnect.not_whitelisted"));
+                return false;
+            }
+        } catch (BackendException backendException) {
+            disconnect(Component.translatable("multiplayer.disconnect.unverified_username")); // maybe better message
+            return false;
+        }
+        return true;
+    }
+    // KissenPaper end
+
     @Override
     public void handleCustomQueryPacket(ServerboundCustomQueryAnswerPacket packet) {
         // Paper start - Add Velocity IP Forwarding Support
diff --git a/src/main/java/net/minecraft/server/players/GameProfileCache.java b/src/main/java/net/minecraft/server/players/GameProfileCache.java
index d45fe762941dd6da45c890706bc9e4c0438522c3..38fbe24db74b7f297945dea442ec8d659a220885 100644
--- a/src/main/java/net/minecraft/server/players/GameProfileCache.java
+++ b/src/main/java/net/minecraft/server/players/GameProfileCache.java
@@ -230,7 +230,7 @@ public class GameProfileCache {
         return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z", Locale.ROOT);
     }
 
-    public List<GameProfileCache.GameProfileInfo> load() {
+    protected List<GameProfileCache.GameProfileInfo> load() { // KissenPaper - private -> protected
         ArrayList arraylist = Lists.newArrayList();
 
         try {
@@ -401,7 +401,7 @@ public class GameProfileCache {
         }
     }
 
-    private static class GameProfileInfo {
+    protected static class GameProfileInfo { // KissenPaper - private -> protected
 
         private final GameProfile profile;
         final Date expirationDate;
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 1e5f709115007ff19901c0a6c3cf884d9e4d3a6c..21519967a792b76c61af753a430ad5fa638ec919 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -166,8 +166,8 @@ public abstract class PlayerList {
 
         this.bans = new UserBanList(PlayerList.USERBANLIST_FILE);
         this.ipBans = new IpBanList(PlayerList.IPBANLIST_FILE);
-        this.ops = new ServerOpList(PlayerList.OPLIST_FILE);
-        this.whitelist = new UserWhiteList(PlayerList.WHITELIST_FILE);
+        this.ops = /*new ServerOpList(PlayerList.OPLIST_FILE);*/ new net.kissenpvp.paper.user.KissenUserOperatorList(); // KissenPaper
+        this.whitelist = /*new UserWhiteList(PlayerList.WHITELIST_FILE);*/ new net.kissenpvp.paper.user.KissenUserWhiteList(); // KissenPaper
         // CraftBukkit start
         // this.stats = Maps.newHashMap();
         // this.advancements = Maps.newHashMap();
@@ -312,7 +312,6 @@ public abstract class PlayerList {
         } else {
             ichatmutablecomponent = Component.translatable("multiplayer.player.joined.renamed", player.getDisplayName(), s);
         }
-        // CraftBukkit start
         ichatmutablecomponent.withStyle(ChatFormatting.YELLOW);
         Component joinMessage = ichatmutablecomponent; // Paper - Adventure
 
@@ -341,6 +340,13 @@ public abstract class PlayerList {
         // Ensure that player inventory is populated with its viewer
         player.containerMenu.transferTo(player.containerMenu, bukkitPlayer);
 
+        // KissenPaper start
+        if(!org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.core.user.KissenUserImplementation.class).loginUser(bukkitPlayer.getUser()))
+        {
+            //TODO disconnect player
+        }
+        // KissenPaper end
+
         PlayerJoinEvent playerJoinEvent = new PlayerJoinEvent(bukkitPlayer, io.papermc.paper.adventure.PaperAdventure.asAdventure(ichatmutablecomponent)); // Paper - Adventure
         this.cserver.getPluginManager().callEvent(playerJoinEvent);
 
@@ -689,6 +695,12 @@ public abstract class PlayerList {
         this.cserver.getScoreboardManager().removePlayer(entityplayer.getBukkitEntity());
         // CraftBukkit end
 
+        // KissenPaper start - logout user
+        if(!org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.core.user.KissenUserImplementation.class).logoutUser(entityplayer.getBukkitEntity().getUser()))
+        {
+            org.bukkit.Bukkit.getKissen().getLogger().warn("Player {} was on the server but was not recognized by the system.", entityplayer.getName());
+        }
+
         return playerQuitEvent.quitMessage(); // Paper - Adventure
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java b/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java
index 4a875bce9563f3b9351ebecde9b0eb1287beb50e..df1e1df7acc8f65bd9f59544308942e56e59e183 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java
@@ -4,11 +4,9 @@ import com.mojang.authlib.GameProfile;
 import java.io.File;
 import java.time.Duration;
 import java.time.Instant;
-import java.util.Date;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.UUID;
+import java.util.*;
+
+import net.kissenpvp.core.api.networking.client.entitiy.ServerEntity;
 import net.minecraft.core.GlobalPos;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.ListTag;
@@ -28,12 +26,43 @@ import org.bukkit.ban.ProfileBanList;
 import org.bukkit.configuration.serialization.ConfigurationSerializable;
 import org.bukkit.configuration.serialization.SerializableAs;
 import org.bukkit.craftbukkit.entity.memory.CraftMemoryMapper;
-import org.bukkit.craftbukkit.profile.CraftPlayerProfile;
 import org.bukkit.entity.EntityType;
 import org.bukkit.entity.Player;
 import org.bukkit.metadata.MetadataValue;
 import org.bukkit.plugin.Plugin;
-import org.bukkit.profile.PlayerProfile;
+
+// KissenPaper start
+import org.bukkit.permissions.Permission;
+import org.bukkit.permissions.Permissible;
+import org.bukkit.permissions.PermissionAttachment;
+import org.bukkit.permissions.PermissionAttachmentInfo;
+
+import net.kissenpvp.core.api.ban.Ban;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.message.Theme;
+import net.kissenpvp.core.api.permission.PermissionGroup;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.api.user.rank.Rank;
+import net.kissenpvp.core.api.user.suffix.Suffix;
+import net.kissenpvp.core.api.user.usersetttings.PlayerSetting;
+import net.kissenpvp.core.api.user.usersetttings.BoundPlayerSetting;
+import net.kissenpvp.paper.api.ban.PaperPunishment;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.networking.client.entity.PaperOnlinePlayerClient;
+import net.kissenpvp.paper.api.permission.PaperPermissible;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PermissibleOverriddenException;
+import net.kissenpvp.paper.api.user.rank.PaperPlayerRank;
+import net.kissenpvp.paper.networking.client.entity.KissenPaperPlayerClient;
+import net.kissenpvp.paper.permission.permissible.KissenPaperPlayerPermissible;
+import net.kyori.adventure.text.Component;
+import net.kissenpvp.core.api.time.AccurateDuration;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+// KissenPaper end
 
 @SerializableAs("Player")
 public class CraftOfflinePlayer implements OfflinePlayer, ConfigurationSerializable {
@@ -42,6 +71,11 @@ public class CraftOfflinePlayer implements OfflinePlayer, ConfigurationSerializa
     private final CraftServer server;
     private final PlayerDataStorage storage;
 
+    // KissenPaper start
+    private final Permissible permissible = new KissenPaperPlayerPermissible(this);
+    private net.kissenpvp.paper.networking.client.entity.KissenPaperPlayerClient kissenPaperPlayerClient;
+    // KissenPaper end
+
     protected CraftOfflinePlayer(CraftServer server, GameProfile profile) {
         this.server = server;
         this.profile = profile;
@@ -598,4 +632,454 @@ public class CraftOfflinePlayer implements OfflinePlayer, ConfigurationSerializa
             manager.save();
         }
     }
+
+    // KissenPaper start - integrate kissen user
+
+    private @NotNull KissenPaperPlayerClient getKissenPaperPlayerClient()
+    {
+        if(kissenPaperPlayerClient == null) {
+            kissenPaperPlayerClient = new KissenPaperPlayerClient() {
+
+                private User cachedUser;
+
+                @Override
+                public @NotNull User getUser() {
+                    return Optional.ofNullable(cachedUser).orElseGet(() ->
+                    {
+                        cachedUser = super.getUser();
+                        return cachedUser;
+                    });
+                }
+
+                @Override
+                public @NotNull PaperPermissible getPermissible() throws PermissibleOverriddenException {
+                    return (PaperPermissible) permissible;
+                }
+
+                @Override
+                public @NotNull UUID getUniqueId() {
+                    return CraftOfflinePlayer.this.getUniqueId();
+                }
+
+                @Override
+                public boolean isConnected() {
+                    return false;
+                }
+            };
+        }
+        return kissenPaperPlayerClient;
+    }
+
+    @Override
+    public final boolean isClient() {
+        return true;
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAltAccounts() throws BackendException {
+        return getKissenPaperPlayerClient().getAltAccounts();
+    }
+
+    @Override
+    public @NotNull UUID getTotalID() {
+        return getKissenPaperPlayerClient().getTotalID();
+    }
+
+    @Override
+    public @NotNull PaperPunishment punish(@NotNull Ban ban, @NotNull ServerEntity banOperator) throws BackendException {
+        return getKissenPaperPlayerClient().punish(ban, banOperator);
+    }
+
+    @Override
+    public @NotNull PaperPunishment punish(@NotNull Ban ban, @NotNull ServerEntity banOperator, @Nullable Component reason) throws BackendException {
+        return getKissenPaperPlayerClient().punish(ban, banOperator, reason);
+    }
+
+    @Override
+    public @NotNull Optional<PaperPunishment> getPunishment(@NotNull String id) throws BackendException {
+        return getKissenPaperPlayerClient().getPunishment(id);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<PaperPunishment> getPunishmentHistory() throws BackendException {
+        return getKissenPaperPlayerClient().getPunishmentHistory();
+    }
+
+    @Override
+    public @NotNull Component displayName() {
+        return getKissenPaperPlayerClient().displayName();
+    }
+
+    @Override
+    public @NotNull Component styledRankName() {
+        return getKissenPaperPlayerClient().styledRankName();
+    }
+
+    @Override
+    public @NotNull Set<Suffix> getSuffixSet() {
+        return getKissenPaperPlayerClient().getSuffixSet();
+    }
+
+    @Override
+    public @NotNull Optional<Suffix> getSuffix(@NotNull String name) {
+        return getKissenPaperPlayerClient().getSuffix(name);
+    }
+
+    @Override
+    public @NotNull Suffix grantSuffix(@NotNull String name, @NotNull Component content) {
+        return getKissenPaperPlayerClient().grantSuffix(name, content);
+    }
+
+    @Override
+    public @NotNull Suffix grantSuffix(@NotNull String name, @NotNull Component content, @Nullable AccurateDuration accurateDuration) throws EventCancelledException
+    {
+        return getKissenPaperPlayerClient().grantSuffix(name, content, accurateDuration);
+    }
+
+    @Override
+    public boolean revokeSuffix(@NotNull String name) {
+        return getKissenPaperPlayerClient().revokeSuffix(name);
+    }
+
+    @Override
+    public @NotNull Optional<Suffix> getSelectedSuffix() {
+        return getKissenPaperPlayerClient().getSelectedSuffix();
+    }
+
+    @Override
+    public long getOnlineTime() {
+        return getKissenPaperPlayerClient().getOnlineTime();
+    }
+
+    @Override
+    public @NotNull User getUser() {
+        return getKissenPaperPlayerClient().getUser();
+    }
+
+    @Override
+    public @NotNull <X> BoundPlayerSetting<X> getUserSetting(@NotNull Class<? extends PlayerSetting<X>> settingClass) {
+        return getKissenPaperPlayerClient().getUserSetting(settingClass);
+    }
+
+    @Override
+    public @NotNull Theme getTheme() {
+        return getKissenPaperPlayerClient().getTheme();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<PaperPlayerRank> getRankHistory() {
+        return getKissenPaperPlayerClient().getRankHistory();
+    }
+
+    @Override
+    public @NotNull PaperPlayerRank getRank() {
+        return getKissenPaperPlayerClient().getRank();
+    }
+
+    @Override
+    public @NotNull PaperPlayerRank grantRank(@NotNull Rank rank) {
+        return getKissenPaperPlayerClient().grantRank(rank);
+    }
+
+    @Override
+    public @NotNull PaperPlayerRank grantRank(@NotNull Rank rank, @Nullable AccurateDuration accurateDuration) {
+        return getKissenPaperPlayerClient().grantRank(rank, accurateDuration);
+    }
+
+    @Override
+    public @NotNull Locale getCurrentLocale() {
+        return getKissenPaperPlayerClient().getCurrentLocale();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<@NotNull PaperOnlinePlayerClient> getOnlineAltAccounts() {
+        return getKissenPaperPlayerClient().getOnlineAltAccounts();
+    }
+
+    @Override
+    public @NotNull Set<Suffix> getSuffixSet(@NotNull Context context) {
+        return getKissenPaperPlayerClient().getSuffixSet(context);
+    }
+
+    @Override
+    public @NotNull Optional<Suffix> getSuffix(@NotNull String name, @NotNull Context context) {
+        return getKissenPaperPlayerClient().getSuffix(name, context);
+    }
+
+    @Override
+    public @NotNull Suffix grantSuffix(@NotNull String name, @NotNull Component content, @NotNull Context context) {
+        return getKissenPaperPlayerClient().grantSuffix(name, content, context);
+    }
+
+    @Override
+    public boolean revokeSuffix(@NotNull String name, @NotNull Context context) {
+        return getKissenPaperPlayerClient().revokeSuffix(name, context);
+    }
+
+    @Override
+    public long getOnlineTime(@NotNull Context context) {
+        return getKissenPaperPlayerClient().getOnlineTime(context);
+    }
+
+    @Override
+    public long getLastPlayed(@NotNull Context context) {
+        return getKissenPaperPlayerClient().getLastPlayed(context);
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull Context context) {
+        return getKissenPaperPlayerClient().getUser(context);
+    }
+
+    @Override
+    public @NotNull PaperPermissible getPermissible() throws PermissibleOverriddenException {
+        return getKissenPaperPlayerClient().getPermissible();
+    }
+
+    @Override
+    public @NotNull <X> BoundPlayerSetting<X> getUserSetting(@NotNull Class<? extends PlayerSetting<X>> settingClass, @NotNull Context context)
+    {
+        return getKissenPaperPlayerClient().getUserSetting(settingClass, context);
+    }
+
+    @Override
+    public @NotNull net.kissenpvp.paper.api.ban.warn.PaperWarn warn(@NotNull Ban ban, @NotNull ServerEntity warnOperator)
+    {
+        return getKissenPaperPlayerClient().warn(ban, warnOperator);
+    }
+
+    @Override
+    public @NotNull net.kissenpvp.paper.api.ban.warn.PaperWarn warn(@NotNull Ban ban, @NotNull ServerEntity warnOperator, @Nullable Component reason)
+    {
+        return getKissenPaperPlayerClient().warn(ban, warnOperator, reason);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<net.kissenpvp.paper.api.ban.warn.PaperWarn> getWarnHistory()
+    {
+        return getKissenPaperPlayerClient().getWarnHistory();
+    }
+
+    @Override
+    public void clearActiveWarns()
+    {
+        getKissenPaperPlayerClient().clearActiveWarns();
+    }
+
+    @Override
+    public boolean isPermissionSet(@NotNull String name) {
+        return getKissenPaperPlayerClient().getPermissionContext().isPermissionSet(name);
+    }
+
+    @Override
+    public boolean isPermissionSet(@NotNull Permission perm) {
+        return getKissenPaperPlayerClient().getPermissionContext().isPermissionSet(perm);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String name) {
+        return getKissenPaperPlayerClient().getPermissionContext().hasPermission(name);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull Permission perm) {
+        return getKissenPaperPlayerClient().getPermissionContext().hasPermission(perm);
+    }
+
+    @Override
+    public @NotNull PermissionAttachment addAttachment(@NotNull Plugin plugin, @NotNull String name, boolean value) {
+        return getKissenPaperPlayerClient().getPermissionContext().addAttachment(plugin, name, value);
+    }
+
+    @Override
+    public @NotNull PermissionAttachment addAttachment(@NotNull Plugin plugin) {
+        return getKissenPaperPlayerClient().getPermissionContext().addAttachment(plugin);
+    }
+
+    @Override
+    public @Nullable PermissionAttachment addAttachment(@NotNull Plugin plugin, @NotNull String name, boolean value, int ticks) {
+        return getKissenPaperPlayerClient().getPermissionContext().addAttachment(plugin, name, value, ticks);
+    }
+
+    @Override
+    public @Nullable PermissionAttachment addAttachment(@NotNull Plugin plugin, int ticks) {
+        return getKissenPaperPlayerClient().getPermissionContext().addAttachment(plugin, ticks);
+    }
+
+    @Override
+    public void removeAttachment(@NotNull PermissionAttachment attachment) {
+        getKissenPaperPlayerClient().getPermissionContext().removeAttachment(attachment);
+    }
+
+    @Override
+    public void recalculatePermissions() {
+        getKissenPaperPlayerClient().getPermissionContext().recalculatePermissions();
+    }
+
+    @Override
+    public @NotNull Set<PermissionAttachmentInfo> getEffectivePermissions() {
+        return getKissenPaperPlayerClient().getPermissionContext().getEffectivePermissions();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getOwnPermissions() {
+        return getKissenPaperPlayerClient().getPermissionContext().getOwnPermissions();
+    }
+
+    @Override
+    public int wipeGroups() {
+        return getKissenPaperPlayerClient().getPermissionContext().wipeGroups();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<PermissionGroup<PaperPermission>> getOwnPermissionGroups()
+    {
+        return getKissenPaperPlayerClient().getPermissionContext().getOwnPermissionGroups();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<PermissionGroup<PaperPermission>> getPermissionGroups() {
+        return getKissenPaperPlayerClient().getPermissionContext().getPermissionGroups();
+    }
+
+    @Override
+    public boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup) {
+        return getKissenPaperPlayerClient().getPermissionContext().inGroup(permissionGroup);
+    }
+
+    @Override
+    public @NotNull String getPermissionID() {
+        return getKissenPaperPlayerClient().getPermissionContext().getPermissionID();
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission) throws EventCancelledException {
+        return getKissenPaperPlayerClient().getPermissionContext().setPermission(permission);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, boolean value) throws EventCancelledException {
+        return getKissenPaperPlayerClient().getPermissionContext().setPermission(permission, value);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull PaperPermission permission) throws EventCancelledException {
+        return getKissenPaperPlayerClient().getPermissionContext().setPermission(permission);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission) {
+        return getKissenPaperPlayerClient().getPermissionContext().unsetPermission(permission);
+    }
+
+    @Override
+    public int wipePermissions() {
+        return getKissenPaperPlayerClient().getPermissionContext().wipePermissions();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList() {
+        return getKissenPaperPlayerClient().getPermissionContext().getPermissionList();
+    }
+
+    @Override
+    public @NotNull Optional<PaperPermission> getPermission(@NotNull String permission) {
+        return getKissenPaperPlayerClient().getPermissionContext().getPermission(permission);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAffectedUsers() {
+        return java.util.Collections.EMPTY_SET;
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<net.kissenpvp.core.api.permission.GroupablePermissionEntry<PaperPermission>> getConnectedEntries()
+    {
+        return java.util.Collections.EMPTY_SET;
+    }
+
+    @Override
+    public void permissionUpdate() {/* ignored */ }
+
+    @Override
+    public @NotNull Optional<PaperPermission> getOwnPermission(@NotNull String permission)
+    {
+        return getKissenPaperPlayerClient().getPermissionContext().getOwnPermission(permission);
+    }
+
+    @Override
+    public @NotNull Optional<PaperPermission> getOwnPermission(@NotNull String permission, @NotNull Context context)
+    {
+        return getKissenPaperPlayerClient().getPermissionContext().getOwnPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<PermissionGroup<PaperPermission>> getOwnPermissionsGroups(@NotNull Context context)
+    {
+        return getKissenPaperPlayerClient().getPermissionContext().getOwnPermissionsGroups(context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<PermissionGroup<PaperPermission>> getPermissionGroups(@NotNull Context context)
+    {
+        return getKissenPaperPlayerClient().getPermissionContext().getPermissionGroups(context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getOwnPermissions(@NotNull Context context) {
+        return getKissenPaperPlayerClient().getPermissionContext().getOwnPermissions(context);
+    }
+
+    @Override
+    public boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup, @NotNull Context context) {
+        return getKissenPaperPlayerClient().getPermissionContext().inGroup(permissionGroup, context);
+    }
+
+    @Override
+    public int wipeGroups(@NotNull Context context)
+    {
+        return getKissenPaperPlayerClient().getPermissionContext().wipeGroups(context);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, @NotNull Context context) throws EventCancelledException {
+        return getKissenPaperPlayerClient().getPermissionContext().setPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, boolean value, @NotNull Context context) throws EventCancelledException {
+        return getKissenPaperPlayerClient().getPermissionContext().setPermission(permission, value, context);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull PaperPermission permission, @NotNull Context context) throws EventCancelledException {
+        return getKissenPaperPlayerClient().getPermissionContext().setPermission(permission, context);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission, @NotNull Context context) {
+        return getKissenPaperPlayerClient().getPermissionContext().unsetPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList(@NotNull Context context) {
+        return getKissenPaperPlayerClient().getPermissionContext().getPermissionList(context);
+    }
+
+    @Override
+    public @NotNull Optional<PaperPermission> getPermission(@NotNull String permission, @NotNull Context context) {
+        return getKissenPaperPlayerClient().getPermissionContext().getPermission(permission, context);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String permission, @NotNull Context context) {
+        return getKissenPaperPlayerClient().getPermissionContext().hasPermission(permission, context);
+    }
+
+    @Override
+    public int wipePermissions(@NotNull Context context)
+    {
+        return getKissenPaperPlayerClient().getPermissionContext().wipePermissions(context);
+    }
+    // KissenPaper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java b/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java
index 4e56018b64d11f76c8da43fd8f85c6de72204e36..ddee5b265dae0dc986d7d51ffb1989387ea6a5f6 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java
@@ -104,4 +104,16 @@ public class CraftConsoleCommandSender extends ServerCommandSender implements Co
         return io.papermc.paper.configuration.GlobalConfiguration.get().console.hasAllPermissions || super.hasPermission(perm);
     }
     // Paper end
+
+    // KissenPaper start
+    @Override
+    public net.kissenpvp.core.api.message.@org.jetbrains.annotations.NotNull Theme getTheme() {
+        return org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.message.MessageImplementation.class).getDefaultTheme();
+    }
+
+    @Override
+    public net.kyori.adventure.audience.@org.jetbrains.annotations.NotNull Audience getKyoriAudience() {
+        return this;
+    }
+    // KissenPaper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/command/ProxiedNativeCommandSender.java b/src/main/java/org/bukkit/craftbukkit/command/ProxiedNativeCommandSender.java
index 3e7d14564f11a3ed0b0766444e9d681804597e9a..95eb776fe864240e0fd3c3a744082ec5c1405c05 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/ProxiedNativeCommandSender.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/ProxiedNativeCommandSender.java
@@ -146,4 +146,32 @@ public class ProxiedNativeCommandSender implements ProxiedCommandSender {
        return this.getCaller().spigot();
     }
     // Spigot end
+
+    // KissenPaper start
+    @org.jetbrains.annotations.NotNull
+    @Override
+    public net.kissenpvp.core.api.message.Theme getTheme() {
+        return org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.message.MessageImplementation.class).getDefaultTheme();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull java.util.Locale getCurrentLocale() {
+        return this.getCaller().getCurrentLocale();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull net.kyori.adventure.text.Component displayName() {
+        return this.getCaller().displayName();
+    }
+
+    @Override
+    public boolean isConnected() {
+        return this.getCaller().isConnected();
+    }
+
+    @Override
+    public boolean isClient() {
+        return this.getCaller().isClient();
+    }
+    // KissenPaper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/command/ServerCommandSender.java b/src/main/java/org/bukkit/craftbukkit/command/ServerCommandSender.java
index 1e3091687735b461d3b6a313ab8761127981d3e8..b2fbbc140c22d5016339a072af23938edcfaa53a 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/ServerCommandSender.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/ServerCommandSender.java
@@ -145,4 +145,27 @@ public abstract class ServerCommandSender implements CommandSender {
         return this.adventure$pointers;
     }
     // Paper end
+
+    // KissenPaper start
+    @org.jetbrains.annotations.NotNull
+    @Override
+    public net.kissenpvp.core.api.message.Theme getTheme() {
+        return Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.message.MessageImplementation.class).getDefaultTheme();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull java.util.Locale getCurrentLocale() {
+        return Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.message.localization.LocalizationImplementation.class).getDefaultLocale();
+    }
+
+    @Override
+    public final boolean isConnected() {
+        return true;
+    }
+
+    @Override
+    public final boolean isClient() {
+        return false;
+    }
+    // KissenPaper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index 0b5a31477e3b76833fb97a455842316193663c8e..f3ebc2e62e745dc017c9d35dafe669994a94fcad 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -1228,4 +1228,27 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         return this.getHandle().getScoreboardName();
     }
     // Paper end - entity scoreboard name
+
+    // KissenPaper start
+    @org.jetbrains.annotations.NotNull
+    @Override
+    public net.kissenpvp.core.api.message.Theme getTheme() {
+        return org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.message.MessageImplementation.class).getDefaultTheme();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull java.util.Locale getCurrentLocale() {
+        return org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.message.localization.LocalizationImplementation.class).getDefaultLocale();
+    }
+
+    @Override
+    public boolean isConnected() {
+        return true;
+    }
+
+    @Override
+    public final boolean isClient() { // Kinda useless for this use case
+        return true;
+    }
+    // KissenPaper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
index acbb64010cd59668aa1bcb52ff1220789cadb1d3..56383900e594602dbaa5223aeb0a1616e31e4c5c 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
@@ -71,7 +71,7 @@ import org.bukkit.plugin.Plugin;
 public class CraftHumanEntity extends CraftLivingEntity implements HumanEntity {
     private CraftInventoryPlayer inventory;
     private final CraftInventory enderChest;
-    protected final PermissibleBase perm = new PermissibleBase(this);
+    protected final /* PermissibleBase */ org.bukkit.permissions.Permissible perm = new net.kissenpvp.paper.permission.permissible.KissenPaperPlayerPermissible(this); // KissenPaper
     private boolean op;
     private GameMode mode;
 
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 616d2e479d91673695ade0db151a0099b568904f..a73b589784a91fd97b9c304e56172b858a32bcc2 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -180,6 +180,35 @@ import org.jetbrains.annotations.NotNull;
 
 import net.md_5.bungee.api.chat.BaseComponent; // Spigot
 
+// KissenPaper start
+import net.kissenpvp.core.api.ban.Ban;
+import net.kissenpvp.core.api.base.KissenServer;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.message.Theme;
+import net.kissenpvp.core.api.networking.client.entitiy.ServerEntity;
+import net.kissenpvp.core.api.permission.PermissionGroup;
+import net.kissenpvp.core.api.time.AccurateDuration;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.api.user.rank.Rank;
+import net.kissenpvp.core.api.user.suffix.Suffix;
+import net.kissenpvp.core.api.user.usersetttings.PlayerSetting;
+import net.kissenpvp.core.api.user.usersetttings.BoundPlayerSetting;
+import net.kissenpvp.core.user.KissenUserImplementation;
+import net.kissenpvp.paper.api.ban.PaperPunishment;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.networking.client.entity.PaperOnlinePlayerClient;
+import net.kissenpvp.paper.api.permission.PaperPermissible;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PermissibleOverriddenException;
+import net.kissenpvp.paper.api.user.rank.PaperPlayerRank;
+import net.kissenpvp.paper.networking.client.entity.KissenPaperOnlinePlayerClient;
+import net.kissenpvp.paper.permission.permissible.KissenPaperPermissible;
+import net.kissenpvp.paper.user.KissenPaperPublicUser;
+import org.jetbrains.annotations.Unmodifiable;
+// KissenPaper stop
+
 @DelegateDeserialization(CraftOfflinePlayer.class)
 public class CraftPlayer extends CraftHumanEntity implements Player {
     private long firstPlayed = 0;
@@ -200,6 +229,10 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     private static final boolean DISABLE_CHANNEL_LIMIT = System.getProperty("paper.disableChannelLimit") != null; // Paper - add a flag to disable the channel limit
     private long lastSaveTime; // Paper - getLastPlayed replacement API
 
+    // KissenPaper start
+    private KissenPaperOnlinePlayerClient kissenPaperPlayer;
+    // KissenPaper end
+
     public CraftPlayer(CraftServer server, ServerPlayer entity) {
         super(server, entity);
 
@@ -2571,7 +2604,15 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     public void disconnect(String reason) {
         this.conversationTracker.abandonAllConversations();
-        this.perm.clearPermissions();
+        // KissenPaper start - logout user
+        try {
+            ((KissenPaperPermissible) getPermissible()).unsubscribe();
+        } catch (PermissibleOverriddenException overridden) {
+            if (this.perm instanceof org.bukkit.permissions.PermissibleBase permissibleBase) {
+                permissibleBase.clearPermissions();
+            }
+        }
+        // KissenPaper end - logout user
     }
 
     @Override
@@ -2918,7 +2959,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     // Paper start
     @Override
     public java.util.Locale locale() {
-        return getHandle().adventure$locale;
+        return /* getHandle().adventure$locale; */ getCurrentLocale(); // KissenPaper
     }
     // Paper end
     @Override
@@ -3053,7 +3094,14 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     public void sendMessage(final net.kyori.adventure.identity.Identity identity, final net.kyori.adventure.text.Component message, final net.kyori.adventure.audience.MessageType type) {
         if (getHandle().connection == null) return;
         final net.minecraft.core.Registry<net.minecraft.network.chat.ChatType> chatTypeRegistry = this.getHandle().level().registryAccess().registryOrThrow(net.minecraft.core.registries.Registries.CHAT_TYPE);
-        this.getHandle().connection.send(new net.minecraft.network.protocol.game.ClientboundSystemChatPacket(message, false));
+
+        // KissenPaper start - add custom renderer
+        Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.message.ChatImplementation.class).prepareMessage(Bukkit.getConsoleSender(), this, message).ifPresent(styled ->
+
+            this.getHandle().connection.send(new net.minecraft.network.protocol.game.ClientboundSystemChatPacket(styled, false))
+
+        );
+        // KissenPaper end
     }
 
     @Override
@@ -3319,7 +3367,15 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         public void sendMessage(net.md_5.bungee.api.ChatMessageType position, UUID sender, BaseComponent... components) {
             if ( CraftPlayer.this.getHandle().connection == null ) return;
 
-            CraftPlayer.this.getHandle().connection.send(new net.minecraft.network.protocol.game.ClientboundSystemChatPacket(components, position == net.md_5.bungee.api.ChatMessageType.ACTION_BAR));
+            // KissenPaper start - add custom renderer
+            net.kyori.adventure.text.Component[] componentData = java.util.Arrays.stream(components).map(net.md_5.bungee.chat.ComponentSerializer::toString).map(json ->
+                net.kyori.adventure.text.serializer.json.JSONComponentSerializer.json().deserialize(json)
+            ).toList().toArray(new net.kyori.adventure.text.Component[0]);
+
+            Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.message.ChatImplementation.class).prepareMessage(Bukkit.getConsoleSender(), CraftPlayer.this, componentData).ifPresent(styled ->
+                CraftPlayer.this.getHandle().connection.send(new net.minecraft.network.protocol.game.ClientboundSystemChatPacket(styled, position == net.md_5.bungee.api.ChatMessageType.ACTION_BAR))
+            );
+            // KissenPaper end
         }
 
         // Paper start
@@ -3427,4 +3483,425 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     public void setSendViewDistance(final int viewDistance) {
         this.getHandle().setSendViewDistance(viewDistance);
     }
+
+    // KissenPaper start - integrate user methods provided by the kissen implementation
+
+    private @NotNull KissenPaperOnlinePlayerClient getKissenPaperOnlinePlayerClient() {
+        if (kissenPaperPlayer == null) {
+            kissenPaperPlayer = new KissenPaperOnlinePlayerClient() {
+                @Override
+                public @NotNull CraftPlayer getCraftPlayer() {
+                    return CraftPlayer.this;
+                }
+
+                @Override
+                public @NotNull PaperPermissible getPermissible() throws PermissibleOverriddenException {
+                    if (!(perm instanceof PaperPermissible permissible)) {
+                        throw new PermissibleOverriddenException();
+                    }
+                    return permissible;
+                }
+
+                @Override
+                public @NotNull UUID getUniqueId() {
+                    return CraftPlayer.this.getUniqueId();
+                }
+            };
+        }
+        return kissenPaperPlayer;
+    }
+
+    @Override
+    public @NotNull User getUser() {
+        return getUser(Context.GLOBAL);
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull Context context) {
+        KissenPaperPublicUser kissenPublicUser = (KissenPaperPublicUser) Bukkit.getKissen()
+                .getImplementation(UserImplementation.class)
+                .getOnlineUser(getUniqueId())
+                .orElseThrow(IllegalStateException::new);
+        return switch (context)
+        {
+            case GLOBAL -> kissenPublicUser;
+            case LOCAL -> kissenPublicUser.getPrivateUserEntry();
+        };
+    }
+
+    @Override
+    public @NotNull io.netty.channel.Channel getConnection() {
+        return getHandle().connection.connection.channel;
+    }
+
+    @Override
+    public void sendPacket(@NotNull Object object) throws ClassNotFoundException, ClassCastException {
+        getHandle().connection.send((net.minecraft.network.protocol.Packet<?>) object);
+    }
+
+    @Override
+    public @NotNull net.kyori.adventure.audience.Audience getKyoriAudience() {
+        return this;
+    }
+
+    @Override
+    public @NotNull java.util.Locale getCurrentLocale() {
+        return getKissenPaperOnlinePlayerClient().getCurrentLocale();
+    }
+
+    // -
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAltAccounts() throws BackendException {
+        return getKissenPaperOnlinePlayerClient().getAltAccounts();
+    }
+
+    @Override
+    public @NotNull UUID getTotalID() {
+        return getKissenPaperOnlinePlayerClient().getTotalID();
+    }
+
+    @Override
+    public @NotNull PaperPunishment punish(@NotNull Ban ban, @NotNull ServerEntity banOperator) throws BackendException {
+        return getKissenPaperOnlinePlayerClient().punish(ban, banOperator);
+    }
+
+    @Override
+    public @NotNull PaperPunishment punish(@NotNull Ban ban, @NotNull ServerEntity banOperator, net.kyori.adventure.text.@org.jetbrains.annotations.Nullable Component reason) throws BackendException {
+        return getKissenPaperOnlinePlayerClient().punish(ban, banOperator, reason);
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable PaperPunishment> getPunishment(@NotNull String id) throws BackendException {
+        return getKissenPaperOnlinePlayerClient().getPunishment(id);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<PaperPunishment> getPunishmentHistory() throws BackendException {
+        return getKissenPaperOnlinePlayerClient().getPunishmentHistory();
+    }
+
+    @Override
+    public net.kyori.adventure.text.@NotNull Component styledRankName() {
+        return getKissenPaperOnlinePlayerClient().styledRankName();
+    }
+
+    @Override
+    public @NotNull Set<Suffix> getSuffixSet() {
+        return getKissenPaperOnlinePlayerClient().getSuffixSet();
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable Suffix> getSuffix(@NotNull String name) {
+        return getKissenPaperOnlinePlayerClient().getSuffix(name);
+    }
+
+    @Override
+    public @NotNull Suffix grantSuffix(@NotNull String name, net.kyori.adventure.text.@NotNull Component content) throws EventCancelledException
+    {
+        return getKissenPaperOnlinePlayerClient().grantSuffix(name, content);
+    }
+
+    @Override
+    public @NotNull Suffix grantSuffix(@NotNull String name, net.kyori.adventure.text.@NotNull Component content, @org.jetbrains.annotations.Nullable AccurateDuration accurateDuration) throws EventCancelledException
+    {
+        return getKissenPaperOnlinePlayerClient().grantSuffix(name, content, accurateDuration);
+    }
+
+    @Override
+    public boolean revokeSuffix(@NotNull String name)
+    {
+        return getKissenPaperOnlinePlayerClient().revokeSuffix(name);
+    }
+
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable Suffix> getSelectedSuffix() {
+        return getKissenPaperOnlinePlayerClient().getSelectedSuffix();
+    }
+
+    @Override
+    public long getOnlineTime() {
+        return getKissenPaperOnlinePlayerClient().getOnlineTime();
+    }
+
+    @Override
+    public @NotNull <X> BoundPlayerSetting<X> getUserSetting(Class<? extends PlayerSetting<X>> settingClass) {
+        return getKissenPaperOnlinePlayerClient().getUserSetting(settingClass);
+    }
+
+    @Override
+    public @NotNull Theme getTheme() {
+        return getKissenPaperOnlinePlayerClient().getTheme();
+    }
+
+    @Override
+    public void kick(@NotNull String message) {
+        getKissenPaperOnlinePlayerClient().kick(message);
+    }
+
+    @Override
+    public void killConnection() {
+        getKissenPaperOnlinePlayerClient().killConnection();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.Nullable KissenServer getCurrentServer() {
+        return getKissenPaperOnlinePlayerClient().getCurrentServer();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<PaperPlayerRank> getRankHistory() {
+        return getKissenPaperOnlinePlayerClient().getRankHistory();
+    }
+
+    @Override
+    public @NotNull PaperPlayerRank getRank() {
+        return getKissenPaperOnlinePlayerClient().getRank();
+    }
+
+    @Override
+    public @NotNull PaperPlayerRank grantRank(@NotNull Rank rank) {
+        return getKissenPaperOnlinePlayerClient().grantRank(rank);
+    }
+
+    @Override
+    public @NotNull PaperPlayerRank grantRank(@NotNull Rank rank, @org.jetbrains.annotations.Nullable AccurateDuration accurateDuration) {
+        return getKissenPaperOnlinePlayerClient().grantRank(rank, accurateDuration);
+    }
+
+    @Override
+    public @NotNull net.kissenpvp.paper.api.ban.warn.PaperWarn warn(@NotNull Ban ban, @NotNull ServerEntity warnOperator) {
+        return getKissenPaperOnlinePlayerClient().warn(ban, warnOperator);
+    }
+
+    @Override
+    public @NotNull net.kissenpvp.paper.api.ban.warn.PaperWarn warn(@NotNull Ban ban, @NotNull ServerEntity warnOperator, net.kyori.adventure.text.@org.jetbrains.annotations.Nullable Component reason) {
+        return getKissenPaperOnlinePlayerClient().warn(ban, warnOperator, reason);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<net.kissenpvp.paper.api.ban.warn.PaperWarn> getWarnHistory()
+    {
+        return getKissenPaperOnlinePlayerClient().getWarnHistory();
+    }
+
+    @Override
+    public void clearActiveWarns()
+    {
+        getKissenPaperOnlinePlayerClient().clearActiveWarns();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<@NotNull PaperOnlinePlayerClient> getOnlineAltAccounts() {
+        return getKissenPaperOnlinePlayerClient().getOnlineAltAccounts();
+    }
+
+    @Override
+    public @NotNull Set<Suffix> getSuffixSet(@NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getSuffixSet(context);
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable Suffix> getSuffix(@NotNull String name, @NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getSuffix(name, context);
+    }
+
+    @Override
+    public @NotNull Suffix grantSuffix(@NotNull String name, net.kyori.adventure.text.@NotNull Component content, @NotNull Context context) throws EventCancelledException
+    {
+        return getKissenPaperOnlinePlayerClient().grantSuffix(name, content, context);
+    }
+
+    @Override
+    public boolean revokeSuffix(@NotNull String name, @NotNull Context context)
+    {
+        return getKissenPaperOnlinePlayerClient().revokeSuffix(name, context);
+    }
+
+
+    @Override
+    public long getOnlineTime(@NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getOnlineTime(context);
+    }
+
+    @Override
+    public long getLastPlayed(@NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getLastPlayed(context);
+    }
+
+    @Override
+    public @NotNull PaperPermissible getPermissible() throws PermissibleOverriddenException {
+        return getKissenPaperOnlinePlayerClient().getPermissible();
+    }
+
+    @Override
+    public @NotNull <X> BoundPlayerSetting<X> getUserSetting(@NotNull Class<? extends PlayerSetting<X>> settingClass, @NotNull Context context)
+    {
+        return getKissenPaperOnlinePlayerClient().getUserSetting(settingClass, context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getOwnPermissions() {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getOwnPermissions();
+    }
+
+    @Override
+    public int wipeGroups() {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().wipeGroups();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<PermissionGroup<PaperPermission>> getOwnPermissionGroups()
+    {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getOwnPermissionGroups();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<PermissionGroup<PaperPermission>> getPermissionGroups() {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getPermissionGroups();
+    }
+
+    @Override
+    public boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup) {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().inGroup(permissionGroup);
+    }
+
+    @Override
+    public @NotNull String getPermissionID() {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getPermissionID();
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission) throws EventCancelledException {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().setPermission(permission);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, boolean value) throws EventCancelledException {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().setPermission(permission, value);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull PaperPermission permission) throws EventCancelledException {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().setPermission(permission);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission) {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().unsetPermission(permission);
+    }
+
+    @Override
+    public int wipePermissions() {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().wipePermissions();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList() {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getPermissionList();
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable PaperPermission> getPermission(@NotNull String permission) {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getPermission(permission);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAffectedUsers() {
+        return java.util.Collections.singleton(getUniqueId());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<net.kissenpvp.core.api.permission.GroupablePermissionEntry<PaperPermission>> getConnectedEntries()
+    {
+        return java.util.Collections.singleton(this);
+    }
+
+    @Override
+    public void permissionUpdate() {
+        getPermissible().permissionUpdate();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getOwnPermissions(@NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getOwnPermissions(context);
+    }
+
+    @Override
+    public @NotNull Optional<PaperPermission> getOwnPermission(@NotNull String permission)
+    {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getOwnPermission(permission);
+    }
+
+    @Override
+    public @NotNull Optional<PaperPermission> getOwnPermission(@NotNull String permission, @NotNull Context context)
+    {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getOwnPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<PermissionGroup<PaperPermission>> getOwnPermissionsGroups(@NotNull Context context)
+    {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getOwnPermissionsGroups(context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<PermissionGroup<PaperPermission>> getPermissionGroups(@NotNull Context context)
+    {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getPermissionGroups(context);
+    }
+
+    @Override
+    public boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup, @NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().inGroup(permissionGroup, context);
+    }
+
+    @Override
+    public int wipeGroups(@NotNull Context context)
+    {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().wipeGroups(context);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, @NotNull Context context) throws EventCancelledException {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().setPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, boolean value, @NotNull Context context) throws EventCancelledException {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().setPermission(permission, value, context);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull PaperPermission permission, @NotNull Context context) throws EventCancelledException {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().setPermission(permission, context);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission, @NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().unsetPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList(@NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getPermissionList(context);
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable PaperPermission> getPermission(@NotNull String permission, @NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getPermission(permission, context);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String permission, @NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().hasPermission(permission, context);
+    }
+
+    @Override
+    public int wipePermissions(@NotNull Context context)
+    {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().wipePermissions(context);
+    }
+    // KissenPaper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/profile/CraftPlayerProfile.java b/src/main/java/org/bukkit/craftbukkit/profile/CraftPlayerProfile.java
index 41336821d4e0430e19f2fc021f09430d7a1302f6..a1cd752e0952d58e30cae6249ad92e20f2d4652e 100644
--- a/src/main/java/org/bukkit/craftbukkit/profile/CraftPlayerProfile.java
+++ b/src/main/java/org/bukkit/craftbukkit/profile/CraftPlayerProfile.java
@@ -51,6 +51,10 @@ public final class CraftPlayerProfile implements PlayerProfile, com.destroystoky
     private final PropertyMap properties = new PropertyMap();
     private final CraftPlayerTextures textures = new CraftPlayerTextures(this);
 
+    // KissenPaper start
+    private net.kissenpvp.core.api.user.User cached;
+    // KissenPaper end
+
     public CraftPlayerProfile(UUID uniqueId, String name) {
         Preconditions.checkArgument((uniqueId != null) || !StringUtils.isBlank(name), "uniqueId is null or name is blank");
         this.uniqueId = (uniqueId == null) ? Util.NIL_UUID : uniqueId;
@@ -344,4 +348,13 @@ public final class CraftPlayerProfile implements PlayerProfile, com.destroystoky
     public boolean complete(final boolean textures, final boolean onlineMode) {
         throw new UnsupportedOperationException("Do not cast to com.destroystokyo.paper.profile.PlayerProfile");
     }
+
+
+    // KissenPaper start
+    @Override
+    public @org.jetbrains.annotations.NotNull net.kissenpvp.core.api.user.User getUser()
+    {
+        return org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.user.UserImplementation.class).getUser(getId());
+    }
+    // KissenPaper end
 }
