From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Groldi <chniucg@gmail.com>
Date: Fri, 15 Sep 2023 22:45:32 +0200
Subject: [PATCH] Integrated player system from kissen into paper

Signed-off-by: Ivo <chniucg@gmail.com>

diff --git a/src/main/java/com/destroystokyo/paper/profile/CraftPlayerProfile.java b/src/main/java/com/destroystokyo/paper/profile/CraftPlayerProfile.java
index daa157eaa021d039f9a092bea0b78f7c1f746e3b..2445edc12487678c2db1f6b274f95a77eb4663c1 100644
--- a/src/main/java/com/destroystokyo/paper/profile/CraftPlayerProfile.java
+++ b/src/main/java/com/destroystokyo/paper/profile/CraftPlayerProfile.java
@@ -31,6 +31,10 @@ public class CraftPlayerProfile implements PlayerProfile, SharedPlayerProfile {
     private GameProfile profile;
     private final PropertySet properties = new PropertySet();
 
+    // KissenPaper start
+    private net.kissenpvp.core.api.user.User cached;
+    // KissenPaper end
+
     public CraftPlayerProfile(CraftPlayer player) {
         this.profile = player.getHandle().getGameProfile();
     }
@@ -406,4 +410,12 @@ public class CraftPlayerProfile implements PlayerProfile, SharedPlayerProfile {
             }
         }
     }
+
+    // KissenPaper start
+    @Override
+    public @org.jetbrains.annotations.NotNull net.kissenpvp.core.api.user.User getUser()
+    {
+        return org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.user.UserImplementation.class).getUser(java.util.Objects.requireNonNull(getId()));
+    }
+    // KissenPaper end
 }
diff --git a/src/main/java/net/kissenpvp/paper/ban/command/PaperPunishmentParser.java b/src/main/java/net/kissenpvp/paper/ban/command/PaperPunishmentParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..55167ae5fef79f24545df34479443dbb74399a57
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/ban/command/PaperPunishmentParser.java
@@ -0,0 +1,19 @@
+package net.kissenpvp.paper.ban.command;
+
+import net.kissenpvp.paper.api.ban.PaperPunishment;
+import net.kissenpvp.paper.api.command.PaperArgumentParser;
+import org.jetbrains.annotations.NotNull;
+
+public class PaperPunishmentParser implements PaperArgumentParser<PaperPunishment>
+{
+    @Override public @NotNull String serialize(@NotNull PaperPunishment object)
+    {
+        return object.getID();
+    }
+
+    @Override public @NotNull PaperPunishment deserialize(@NotNull String input)
+    {
+        //TODO
+        return null;
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperOnlinePlayerClient.java b/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperOnlinePlayerClient.java
new file mode 100644
index 0000000000000000000000000000000000000000..153b5031f087ef3caec0d9a36fa410dc3e3946db
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperOnlinePlayerClient.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.networking.client.entity;
+
+import io.netty.channel.Channel;
+import net.kissenpvp.core.api.ban.Ban;
+import net.kissenpvp.core.api.base.KissenServer;
+import net.kissenpvp.core.api.networking.client.entitiy.ServerEntity;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.message.KissenComponentSerializer;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.networking.client.entity.PaperOnlinePlayerClient;
+import net.kyori.adventure.audience.Audience;
+import net.kyori.adventure.text.Component;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Map;
+
+public abstract class KissenPaperOnlinePlayerClient extends KissenPaperPlayerClient implements PaperOnlinePlayerClient {
+
+    public abstract @NotNull CraftPlayer getCraftPlayer();
+
+    // Only methods based in CraftPlayer due to permission subscription
+    @Override
+    public @NotNull User getUser() {
+        return getCraftPlayer().getUser();
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull Context context) {
+        return getCraftPlayer().getUser(context);
+    }
+    //
+
+    @Override
+    public final boolean isConnected() {
+        return true;
+    }
+
+    @Override
+    public void kick(@NotNull String message) {
+        kick(KissenComponentSerializer.getInstance().getMiniSerializer().deserialize(message));
+    }
+
+    @Override
+    public void kick(@NotNull Component component) {
+        getCraftPlayer().kick(component);
+    }
+
+    @Override
+    public void killConnection() {
+        getConnection().close();
+    }
+
+    @Override
+    public @NotNull Channel getConnection() {
+        return getCraftPlayer().getHandle().connection.connection.channel;
+    }
+
+    @Override
+    public void sendPacket(@NotNull Object object) throws ClassCastException {
+        getCraftPlayer().getHandle().connection.send((Packet<?>) object);
+    }
+
+    @Override
+    public @Nullable KissenServer getCurrentServer() {
+        return MinecraftServer.getServer();
+    }
+
+    @Override
+    public @NotNull Audience getKyoriAudience() {
+        return getCraftPlayer();
+    }
+
+    @Override
+    public int warn(@NotNull Ban ban, @NotNull ServerEntity warnOperator) {
+        return warn(ban, warnOperator, null);
+    }
+
+    @Override
+    public int warn(@NotNull Ban ban, @NotNull ServerEntity warnOperator, @Nullable Component reason) {
+        Map<String, Object> storage = getUser().getStorage();
+        int warnCount = 1;
+        if (storage.containsKey("warn_count")) {
+            warnCount = (int) storage.get("warn_count") + 1;
+        }
+
+        storage.put("warn_count", warnCount);
+        getCraftPlayer().sendMessage("You were warned yk");
+
+        return warnCount;
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperPlayerClient.java b/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperPlayerClient.java
new file mode 100644
index 0000000000000000000000000000000000000000..aad926d0bcdbe079fa86adc043a297c33ad4d918
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperPlayerClient.java
@@ -0,0 +1,345 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.networking.client.entity;
+
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.permission.PermissionGroup;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.api.user.suffix.Suffix;
+import net.kissenpvp.core.database.DataWriter;
+import net.kissenpvp.core.networking.client.entity.KissenPlayerClient;
+import net.kissenpvp.core.user.rank.KissenPlayerRankNode;
+import net.kissenpvp.paper.api.ban.PaperPunishment;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.networking.client.entity.PaperOnlinePlayerClient;
+import net.kissenpvp.paper.api.networking.client.entity.PaperPlayerClient;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PermissibleOverriddenException;
+import net.kissenpvp.paper.api.user.rank.PaperPlayerRank;
+import net.kissenpvp.paper.permission.permissible.KissenPaperPermissible;
+import net.kissenpvp.paper.user.KissenPaperPublicUser;
+import net.kissenpvp.paper.user.rank.KissenPaperPlayerFallBackRank;
+import net.kissenpvp.paper.user.rank.KissenPaperPlayerRank;
+import net.kyori.adventure.text.Component;
+import org.bukkit.Bukkit;
+import org.bukkit.permissions.Permission;
+import org.bukkit.permissions.PermissionAttachment;
+import org.bukkit.permissions.PermissionAttachmentInfo;
+import org.bukkit.plugin.Plugin;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.HashSet;
+import java.util.Optional;
+import java.util.Set;
+import java.util.UUID;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public abstract class KissenPaperPlayerClient extends KissenPlayerClient<PaperPermission, PaperPlayerRank, PaperPunishment> implements PaperPlayerClient {
+
+    @Override
+    public @NotNull User getUser() {
+        return Bukkit.getKissen()
+                .getImplementation(UserImplementation.class)
+                .getUser(getUniqueId());
+    }
+
+    @Override
+    protected @NotNull PaperPlayerRank translateRank(@NotNull KissenPlayerRankNode kissenPlayerRankNode, @Nullable DataWriter dataWriter) {
+        return new KissenPaperPlayerRank(kissenPlayerRankNode, dataWriter);
+    }
+
+    @Override
+    protected @NotNull PaperPlayerRank fallbackRank() {
+        return new KissenPaperPlayerFallBackRank();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<@NotNull PaperOnlinePlayerClient> getOnlineAltAccounts() {
+        return Bukkit.getOnlinePlayers().stream().filter(client -> client.getTotalID().equals(getTotalID())).collect(Collectors.toSet());
+    }
+
+    @Override
+    public @NotNull Set<Suffix> getSuffixSet() {
+        return Stream.concat(getSuffixSet(Context.LOCAL).stream(), getSuffixSet(Context.GLOBAL).stream()).collect(Collectors.toSet());
+    }
+
+    @Override
+    public @NotNull Set<Suffix> getSuffixSet(@NotNull Context context) {
+        //TODO
+        return new HashSet<>();
+    }
+
+    @Override
+    public @NotNull Optional<Suffix> getSuffix(@NotNull String name) {
+        return getSuffix(name, Context.LOCAL).or(() -> super.getSuffix(name));
+    }
+
+    @Override
+    public @NotNull Optional<Suffix> getSuffix(@NotNull String name, @NotNull Context context) {
+        return Optional.empty(); //TODO
+    }
+
+
+    @Override
+    public @NotNull Optional<Suffix> setSuffix(@NotNull String name, @NotNull Component content) {
+        return setSuffix(name, content, Context.LOCAL);
+    }
+
+    @Override
+    public @NotNull Optional<Suffix> setSuffix(@NotNull String name, @NotNull Component content, @NotNull Context context) {
+        return Optional.empty(); //TODO
+    }
+
+    @Override
+    public boolean deleteSuffix(@NotNull String name) {
+        return getSuffix(name, Context.LOCAL).map((suffix) -> deleteSuffix(name, Context.LOCAL)).orElse(false) || super.deleteSuffix(name);
+    }
+
+    @Override
+    public boolean deleteSuffix(@NotNull String name, @NotNull Context context) {
+        return false; //TODO
+    }
+
+    @Override
+    public void setSelectedSuffix(@NotNull String name) throws NullPointerException {
+        setSelectedSuffix(name, Context.LOCAL);
+    }
+
+    @Override
+    public void setSelectedSuffix(@NotNull String name, @NotNull Context context) throws NullPointerException {
+        //TODO
+    }
+
+    @Override
+    public long getOnlineTime() {
+        return getOnlineTime(Context.LOCAL);
+    }
+
+    @Override
+    public long getOnlineTime(@NotNull Context context) {
+        return getOnlineTime(getUser(context));
+    }
+
+    @Override
+    public long getLastPlayed(@NotNull Context context) {
+        return getLastPlayed(getUser(context));
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull Context context) {
+        KissenPaperPublicUser kissenPublicUser = (KissenPaperPublicUser) getUser();
+        return switch (context) {
+            case GLOBAL -> kissenPublicUser;
+            case LOCAL -> kissenPublicUser.getPrivateUserEntry();
+        };
+    }
+
+    public @NotNull KissenPaperPermissible getPermissionContext() throws PermissibleOverriddenException {
+        return (KissenPaperPermissible) getPermissible();
+    }
+
+    @Override
+    public boolean isPermissionSet(@NotNull String name) {
+        return getPermissionContext().isPermissionSet(name);
+    }
+
+    @Override
+    public boolean isPermissionSet(@NotNull Permission perm) {
+        return getPermissionContext().isPermissionSet(perm);
+    }
+
+    @Override
+    public @NotNull String getPermissionID() {
+        return getPermissionContext().getPermissionID();
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission) throws EventCancelledException {
+        return getPermissionContext().setPermission(permission);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, boolean value) throws EventCancelledException {
+        return getPermissionContext().setPermission(permission, value);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission) {
+        return getPermissionContext().unsetPermission(permission);
+    }
+
+    @Override
+    public int wipePermissions() {
+        return getPermissionContext().wipePermissions();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList() {
+        return getPermissionContext().getPermissionList();
+    }
+
+    @Override
+    public @NotNull Optional<PaperPermission> getPermission(@NotNull String permission) {
+        return getPermissionContext().getPermission(permission);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAffectedPermissionPlayer() {
+        return getPermissionContext().getAffectedPermissionPlayer();
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull PaperPermission permission) throws EventCancelledException {
+        return getPermissionContext().setPermission(permission);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String name) {
+        return getPermissionContext().hasPermission(name);
+    }
+
+    @Override
+    public void permissionUpdate() {
+        getPermissionContext().permissionUpdate();
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull Permission perm) {
+        return getPermissionContext().hasPermission(perm);
+    }
+
+    @Override
+    public @NotNull PermissionAttachment addAttachment(@NotNull Plugin plugin, @NotNull String name, boolean value) {
+        return getPermissionContext().addAttachment(plugin, name, value);
+    }
+
+    @Override
+    public @NotNull PermissionAttachment addAttachment(@NotNull Plugin plugin) {
+        return getPermissionContext().addAttachment(plugin);
+    }
+
+    @Override
+    public @Nullable PermissionAttachment addAttachment(@NotNull Plugin plugin, @NotNull String name, boolean value, int ticks) {
+        return getPermissionContext().addAttachment(plugin, name, value, ticks);
+    }
+
+    @Override
+    public @Nullable PermissionAttachment addAttachment(@NotNull Plugin plugin, int ticks) {
+        return getPermissionContext().addAttachment(plugin, ticks);
+    }
+
+    @Override
+    public void removeAttachment(@NotNull PermissionAttachment attachment) {
+        getPermissionContext().removeAttachment(attachment);
+    }
+
+    @Override
+    public void recalculatePermissions() {
+        getPermissionContext().recalculatePermissions();
+    }
+
+    @Override
+    public @NotNull Set<PermissionAttachmentInfo> getEffectivePermissions() {
+        return getPermissionContext().getEffectivePermissions();
+    }
+
+    @Override
+    public boolean isOp() {
+        return getPermissionContext().isOp();
+    }
+
+    @Override
+    public void setOp(boolean value) {
+        getPermissionContext().setOp(value);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getOwnPermissions() {
+        return getPermissionContext().getOwnPermissions();
+    }
+
+    @Override
+    public int wipeGroups() {
+        return getPermissionContext().wipeGroups();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups() {
+        return getPermissionContext().getPermissionGroups();
+    }
+
+    @Override
+    public boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup) {
+        return getPermissionContext().inGroup(permissionGroup);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getOwnPermissions(@NotNull Context context) {
+        return getPermissionContext().getOwnPermissions(context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups(@NotNull Context context) {
+        return getPermissionContext().getPermissionGroups(context);
+    }
+
+    @Override
+    public boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup, @NotNull Context context) {
+        return getPermissionContext().inGroup(permissionGroup, context);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, @NotNull Context context) throws EventCancelledException {
+        return getPermissionContext().setPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, boolean value, @NotNull Context context) throws EventCancelledException {
+        return getPermissionContext().setPermission(permission, value, context);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull PaperPermission permission, @NotNull Context context) throws EventCancelledException {
+        return getPermissionContext().setPermission(permission, context);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission, @NotNull Context context) {
+        return getPermissionContext().unsetPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList(@NotNull Context context) {
+        return getPermissionContext().getPermissionList(context);
+    }
+
+    @Override
+    public @NotNull Optional<PaperPermission> getPermission(@NotNull String permission, @NotNull Context context) {
+        return getPermissionContext().getPermission(permission, context);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String permission, @NotNull Context context) {
+        return getPermissionContext().hasPermission(permission, context);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/KissenPaperAttachmentPermission.java b/src/main/java/net/kissenpvp/paper/permission/KissenPaperAttachmentPermission.java
new file mode 100644
index 0000000000000000000000000000000000000000..b09c3c75fd962ed7aab8f694f4bea263146005c4
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/KissenPaperAttachmentPermission.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission;
+
+import net.kissenpvp.core.api.permission.Permission;
+import net.kissenpvp.core.api.permission.PermissionEntry;
+import net.kissenpvp.core.permission.KissenPermissionNode;
+import net.kissenpvp.core.time.TemporalMeasureNode;
+import org.bukkit.permissions.PermissionAttachment;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class KissenPaperAttachmentPermission extends KissenPaperPermission {
+
+    private final PermissionAttachment permissionAttachment;
+
+    public KissenPaperAttachmentPermission(@NotNull String permission, boolean value, @NotNull PermissionEntry<? extends Permission> permissionEntry, boolean immutable) {
+        this(null, permission, value, permissionEntry, immutable);
+    }
+
+    public KissenPaperAttachmentPermission(@Nullable PermissionAttachment permissionAttachment, @NotNull String permission, boolean value, @NotNull PermissionEntry<? extends Permission> permissionEntry, boolean immutable) {
+        super(new KissenPermissionNode(permission, permissionEntry, value, new TemporalMeasureNode()), permissionEntry, immutable ? null : (record) -> { /* ignored */ });
+        this.permissionAttachment = permissionAttachment;
+    }
+
+    public PermissionAttachment getPermissionAttachment() {
+        return permissionAttachment;
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/KissenPaperGroupablePermissionEntry.java b/src/main/java/net/kissenpvp/paper/permission/KissenPaperGroupablePermissionEntry.java
new file mode 100644
index 0000000000000000000000000000000000000000..d90715d018e9baf7466767cc23f1db9a8d61ae09
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/KissenPaperGroupablePermissionEntry.java
@@ -0,0 +1,163 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission;
+
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.permission.GroupablePermissionEntry;
+import net.kissenpvp.core.api.permission.PermissionGroup;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.PaperGroubablePermissionEntry;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Optional;
+import java.util.Set;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public interface KissenPaperGroupablePermissionEntry extends PaperGroubablePermissionEntry {
+
+    @Override
+    default int wipePermissions() {
+        return getPermissionEntry(Context.LOCAL).wipePermissions() + getPermissionEntry(Context.GLOBAL).wipePermissions();
+    }
+
+    @Override
+    default int wipeGroups() {
+        return getPermissionEntry(Context.LOCAL).wipeGroups() + getPermissionEntry(Context.GLOBAL).wipeGroups();
+    }
+
+    @Override
+    default @NotNull @Unmodifiable Set<PaperPermission> getOwnPermissions() {
+        return Stream.concat(getPermissionEntry(Context.LOCAL).getOwnPermissions().stream(), getPermissionEntry(Context.GLOBAL).getOwnPermissions().stream()).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    @NotNull
+    default Set<PaperPermission> getOwnPermissions(@NotNull Context context) {
+        return getPermissionEntry(context).getOwnPermissions();
+    }
+
+    @Override
+    default @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups() {
+        return Stream.concat(getPermissionEntry(Context.LOCAL).getPermissionGroups().stream(), getPermissionEntry(Context.GLOBAL).getPermissionGroups().stream()).collect(Collectors.toUnmodifiableSet()); //TODO
+    }
+
+
+    @Override
+    @NotNull
+    default Set<PermissionGroup<PaperPermission>> getPermissionGroups(@NotNull Context context) {
+        return getPermissionEntry(context).getPermissionGroups();
+    }
+
+    @Override
+    default boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup) {
+        return getPermissionEntry(Context.LOCAL).inGroup(permissionGroup) || getPermissionEntry(Context.GLOBAL).inGroup(permissionGroup);
+    }
+
+    @Override
+    default boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup, @NotNull Context context) {
+        return getPermissionEntry(context).inGroup(permissionGroup);
+    }
+
+    @Override
+    @NotNull
+    default PaperPermission setPermission(@NotNull String s) throws EventCancelledException {
+        return setPermission(s, Context.LOCAL);
+    }
+
+    @Override
+    @NotNull
+    default PaperPermission setPermission(@NotNull String permission, @NotNull Context context) throws EventCancelledException {
+        return getPermissionEntry(context).setPermission(permission);
+    }
+
+    @Override
+    @NotNull
+    default PaperPermission setPermission(@NotNull String s, boolean b) throws EventCancelledException {
+        return setPermission(s, b, Context.LOCAL);
+    }
+
+    @Override
+    @NotNull
+    default PaperPermission setPermission(@NotNull String permission, boolean value, @NotNull Context context) throws EventCancelledException {
+        return getPermissionEntry(context).setPermission(permission, value);
+    }
+
+    @Override
+    @NotNull
+    default PaperPermission setPermission(@NotNull PaperPermission paperPermission) throws EventCancelledException {
+        return setPermission(paperPermission, Context.LOCAL);
+    }
+
+    @Override
+    @NotNull
+    default PaperPermission setPermission(@NotNull PaperPermission permission, @NotNull Context context) throws EventCancelledException {
+        return getPermissionEntry(context).setPermission(permission);
+    }
+
+    @Override
+    default boolean unsetPermission(@NotNull String s) {
+        if (unsetPermission(s, Context.LOCAL)) {
+            return unsetPermission(s, Context.GLOBAL);
+        }
+        return false;
+    }
+
+    @Override
+    default boolean unsetPermission(@NotNull String permission, @NotNull Context context) {
+        return getPermissionEntry(context).unsetPermission(permission);
+    }
+
+    @Override
+    default @NotNull @Unmodifiable Set<PaperPermission> getPermissionList() {
+        return Stream.concat(getPermissionList(Context.LOCAL).stream(), getPermissionList(Context.GLOBAL).stream()).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    @NotNull
+    @Unmodifiable
+    default Set<PaperPermission> getPermissionList(@NotNull Context context) {
+        return getPermissionEntry(context).getPermissionList();
+    }
+
+    @Override
+    default @NotNull Optional<PaperPermission> getPermission(@NotNull String s) {
+        return getPermission(s, Context.LOCAL).or(() -> getPermission(s, Context.GLOBAL));
+    }
+
+    @Override
+    @NotNull
+    default Optional<PaperPermission> getPermission(@NotNull String permission, @NotNull Context context) {
+        return getPermissionEntry(context).getPermission(permission);
+    }
+
+    @Override
+    default boolean hasPermission(@NotNull String s) {
+        return isOp() || hasPermission(s, Context.LOCAL) || hasPermission(s, Context.GLOBAL);
+    }
+
+    @Override
+    default boolean hasPermission(@NotNull String permission, @NotNull Context context) {
+        return getPermissionEntry(context).hasPermission(permission);
+    }
+
+    @NotNull GroupablePermissionEntry<PaperPermission> getPermissionEntry(@NotNull Context context);
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermission.java b/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermission.java
new file mode 100644
index 0000000000000000000000000000000000000000..7a22a03f4c65ff2c5cb8d8362802c26f3e32a5ff
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermission.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission;
+
+import net.kissenpvp.core.api.permission.Permission;
+import net.kissenpvp.core.api.permission.PermissionEntry;
+import net.kissenpvp.core.database.DataWriter;
+import net.kissenpvp.core.permission.KissenPermission;
+import net.kissenpvp.core.permission.KissenPermissionNode;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class KissenPaperPermission extends KissenPermission implements PaperPermission {
+    public KissenPaperPermission(@NotNull KissenPermissionNode kissenPermissionNode, @NotNull PermissionEntry<? extends Permission> permissionEntry, @Nullable DataWriter dataWriter) {
+        super(kissenPermissionNode, permissionEntry, dataWriter);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermissionImplementation.java b/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermissionImplementation.java
new file mode 100644
index 0000000000000000000000000000000000000000..6d60c4a461828192d629e5875c95ac8004162a8d
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermissionImplementation.java
@@ -0,0 +1,223 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission;
+
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.database.savable.SavableMap;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.event.EventImplementation;
+import net.kissenpvp.core.api.permission.PermissionGroup;
+import net.kissenpvp.core.base.KissenCore;
+import net.kissenpvp.core.base.KissenImplementation;
+import net.kissenpvp.core.database.savable.KissenSavableMap;
+import net.kissenpvp.core.permission.PermissionImplementation;
+import net.kissenpvp.core.permission.event.KissenPermissionGroupCreateEvent;
+import net.kissenpvp.core.permission.event.KissenPermissionGroupCreatedEvent;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PaperPermissionGroup;
+import net.kissenpvp.paper.api.permission.PaperPermissionImplementation;
+import net.kissenpvp.paper.api.permission.PaperPrivatePermissionGroup;
+import net.kissenpvp.paper.permission.group.KissenPaperPermissionGroup;
+import net.kissenpvp.paper.permission.group.KissenPaperPrivatePermissionGroup;
+import net.kissenpvp.paper.permission.group.KissenPaperPublicPermissionGroup;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.function.Consumer;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public class KissenPaperPermissionImplementation implements PaperPermissionImplementation, PermissionImplementation, KissenImplementation {
+
+    private final Set<PermissionGroup<PaperPermission>> cachedGroups;
+
+    public KissenPaperPermissionImplementation() {
+        this.cachedGroups = new HashSet<>();
+    }
+
+    @Override
+    public boolean postStart() {
+        try {
+            Stream.concat(KissenCore.getInstance()
+                    .getPublicMeta()
+                    .getData(new KissenPaperPublicPermissionGroup())
+                    .values()
+                    .stream(), Bukkit.getKissen()
+                    .getPrivateMeta()
+                    .getData(new KissenPaperPrivatePermissionGroup())
+                    .values()
+                    .stream()).forEach(permissionGroupInitializer());
+        } catch (BackendException e) {
+            KissenCore.getInstance()
+                    .getLogger()
+                    .error("The system was unable to load the permission groups from the database.");
+            return false;
+        }
+
+        return PaperPermissionImplementation.super.postStart();
+    }
+
+    private Consumer<SavableMap> permissionGroupInitializer() {
+        return savableMap -> {
+            String id = ((KissenSavableMap) savableMap).getId();
+
+            if (id.startsWith(new KissenPaperPublicPermissionGroup().getSaveID())) {
+                createInternalPermissionGroup(savableMap.getNotNull("id"), savableMap);
+            } else {
+                if (id.startsWith(new KissenPaperPrivatePermissionGroup().getSaveID())) {
+                    try {
+                        createPrivateInternalPermissionGroup(savableMap.getNotNull("id"), savableMap);
+                    } catch (BackendException backendException) {
+                        KissenCore.getInstance()
+                                .getLogger()
+                                .error("The system was unable to load the permission group '{}' from the database.", id);
+                    }
+                }
+            }
+        };
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermissionGroup> getPermissionGroupSet() {
+        return cachedGroups.stream()
+                .filter(permissionGroup -> permissionGroup instanceof PaperPermissionGroup)
+                .map(paperPermissionPermissionGroup -> (PaperPermissionGroup) paperPermissionPermissionGroup)
+                .collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPrivatePermissionGroup> getPrivatePermissionGroupSet() {
+        return cachedGroups.stream()
+                .filter(permissionGroup -> permissionGroup instanceof PaperPrivatePermissionGroup)
+                .map(paperPermissionPermissionGroup -> (PaperPrivatePermissionGroup) paperPermissionPermissionGroup)
+                .collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @Nullable PaperPermissionGroup getPermissionGroup(@NotNull String group) {
+        return getPermissionGroupSet().stream()
+                .filter(paperPermissionGroup -> paperPermissionGroup.getPermissionID().equals(group))
+                .findFirst()
+                .orElse(null);
+    }
+
+    @Override
+    public @Nullable PermissionGroup<?> getPermissionGroupSavable(@NotNull String name) {
+        return getPermissionGroupSet().stream()
+                .map(paperPermissionGroup -> paperPermissionGroup.getCoreGroup(Context.GLOBAL))
+                .filter(paperPermissionGroup -> paperPermissionGroup.getPermissionID().equals(name))
+                .findFirst()
+                .orElse(null);
+    }
+
+    @Override
+    public void removePermissionGroup(@NotNull String name) {
+        cachedGroups.removeIf(paperPermissionPermissionGroup -> paperPermissionPermissionGroup.getPermissionID()
+                .equals(name));
+    }
+
+    public void removePublicPermissionGroup(String name) {
+        cachedGroups.removeIf(paperPermissionPermissionGroup -> paperPermissionPermissionGroup instanceof PaperPermissionGroup && paperPermissionPermissionGroup.getPermissionID()
+                .equals(name));
+    }
+
+    @Override
+    public @Nullable PaperPrivatePermissionGroup getPrivatePermissionGroup(@NotNull String group) {
+        return getPrivatePermissionGroupSet().stream()
+                .filter(paperPrivatePermissionGroup -> paperPrivatePermissionGroup.getPermissionID().equals(group))
+                .findFirst()
+                .orElse(null);
+    }
+
+    @Override
+    public @NotNull PaperPrivatePermissionGroup getPrivatePermissionGroupNotNull(@NotNull String group) throws EventCancelledException, BackendException {
+        PaperPrivatePermissionGroup permissionGroup = getPrivatePermissionGroup(group);
+        if (permissionGroup == null) {
+            permissionGroup = createPrivatePermissionGroup(group, null);
+        }
+        return permissionGroup;
+    }
+
+    @Override
+    public @NotNull PaperPermissionGroup getPermissionGroupNotNull(@NotNull String group) throws EventCancelledException {
+        PaperPermissionGroup permissionGroup = getPermissionGroup(group);
+        if (permissionGroup == null) {
+            permissionGroup = createPermissionGroup(group, null);
+        }
+        return permissionGroup;
+    }
+
+    @Override
+    public @NotNull PaperPermissionGroup createPermissionGroup(@NotNull String name, @Nullable Map<String, String> data) throws EventCancelledException {
+        KissenPermissionGroupCreateEvent kissenPermissionGroupCreateEvent = new KissenPermissionGroupCreateEvent(name, data);
+        if (Bukkit.getKissen().getImplementation(EventImplementation.class).call(kissenPermissionGroupCreateEvent)) {
+            this.createInternalPermissionGroup(name, data);
+        }
+        throw new EventCancelledException();
+    }
+
+    @Override
+    public @NotNull PermissionGroup<?> createInternalPermissionGroup(@NotNull String name, @Nullable Map<String, String> data) {
+        KissenPaperPublicPermissionGroup kissenPaperPublicPermissionGroup = new KissenPaperPublicPermissionGroup();
+        try {
+            kissenPaperPublicPermissionGroup.setup(name, data);
+            PaperPermissionGroup permissionGroup = new KissenPaperPermissionGroup(kissenPaperPublicPermissionGroup);
+            cachedGroups.removeIf(paperPermissionPermissionGroup -> paperPermissionPermissionGroup.getPermissionID()
+                    .equals(name));
+            cachedGroups.add(permissionGroup);
+
+            PaperPrivatePermissionGroup paperPrivatePermissionGroup = getPrivatePermissionGroup(name);
+            if (paperPrivatePermissionGroup == null) {
+                paperPrivatePermissionGroup = createPrivateInternalPermissionGroup(name, null);
+            }
+            cachedGroups.add(paperPrivatePermissionGroup);
+            Bukkit.getKissen()
+                    .getImplementation(EventImplementation.class)
+                    .call(new KissenPermissionGroupCreatedEvent(permissionGroup));
+            return permissionGroup;
+        } catch (BackendException e) {
+            throw new RuntimeException(e); //TODO replace with throw list
+        }
+    }
+
+    @Override
+    public @NotNull PaperPrivatePermissionGroup createPrivatePermissionGroup(@NotNull String group, @Nullable Map<String, String> data) throws EventCancelledException, BackendException {
+        KissenPermissionGroupCreateEvent kissenPermissionGroupCreateEvent = new KissenPermissionGroupCreateEvent(group, data);
+        if (Bukkit.getKissen().getImplementation(EventImplementation.class).call(kissenPermissionGroupCreateEvent)) {
+            return createPrivateInternalPermissionGroup(group, data);
+        }
+        throw new EventCancelledException();
+    }
+
+    public @NotNull PaperPrivatePermissionGroup createPrivateInternalPermissionGroup(@NotNull String group, @Nullable Map<String, String> data) throws BackendException {
+        KissenPaperPrivatePermissionGroup kissenPaperPrivatePermissionGroup = new KissenPaperPrivatePermissionGroup();
+        kissenPaperPrivatePermissionGroup.setup(group, data);
+        cachedGroups.add(kissenPaperPrivatePermissionGroup);
+        Bukkit.getKissen()
+                .getImplementation(EventImplementation.class)
+                .call(new KissenPermissionGroupCreatedEvent(kissenPaperPrivatePermissionGroup));
+        return kissenPaperPrivatePermissionGroup;
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/RemoveAttachmentRunnable.java b/src/main/java/net/kissenpvp/paper/permission/RemoveAttachmentRunnable.java
new file mode 100644
index 0000000000000000000000000000000000000000..318e2520843c49567887703a254e03a8dc4171d5
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/RemoveAttachmentRunnable.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission;
+
+import org.bukkit.permissions.PermissionAttachment;
+import org.jetbrains.annotations.NotNull;
+
+public record RemoveAttachmentRunnable(PermissionAttachment attachment) implements Runnable {
+    public RemoveAttachmentRunnable(@NotNull PermissionAttachment attachment) {
+        this.attachment = attachment;
+    }
+
+    @Override
+    public void run() {
+        attachment.remove();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperAbstractPermissionGroup.java b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperAbstractPermissionGroup.java
new file mode 100644
index 0000000000000000000000000000000000000000..3ee8ca89e1eb68e98df196c291de2f1615ace5ce
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperAbstractPermissionGroup.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission.group;
+
+import net.kissenpvp.core.api.permission.PermissionGroup;
+import net.kissenpvp.core.database.DataWriter;
+import net.kissenpvp.core.permission.KissenPermissionGroup;
+import net.kissenpvp.core.permission.KissenPermissionNode;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PaperPermissionImplementation;
+import net.kissenpvp.paper.permission.KissenPaperPermission;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Set;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public abstract class KissenPaperAbstractPermissionGroup extends KissenPermissionGroup<PaperPermission> {
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups() {
+        PaperPermissionImplementation paperPermissionImplementation = Bukkit.getKissen()
+            .getImplementation(PaperPermissionImplementation.class);
+
+        return Stream.concat(paperPermissionImplementation
+                .getPermissionGroupSet()
+                .stream()
+                .filter(paperPermissionGroup -> paperPermissionGroup.getMember()
+                    .contains(getPermissionID())), paperPermissionImplementation
+                .getPrivatePermissionGroupSet()
+                .stream()
+                .filter(paperPermissionGroup -> paperPermissionGroup.getMember().contains(getPermissionID())))
+            .collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    protected @NotNull PaperPermission translatePermission(@NotNull KissenPermissionNode kissenPermissionNode, @Nullable DataWriter dataWriter) {
+        return new KissenPaperPermission(kissenPermissionNode, this, dataWriter);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPermissionGroup.java b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPermissionGroup.java
new file mode 100644
index 0000000000000000000000000000000000000000..1580a15ab8dee85540de9e97e55951ffe8964f7b
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPermissionGroup.java
@@ -0,0 +1,300 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission.group;
+
+import net.kissenpvp.core.api.database.StorageImplementation;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.permission.GroupablePermissionEntry;
+import net.kissenpvp.core.api.permission.PermissionGroup;
+import net.kissenpvp.core.base.KissenCore;
+import net.kissenpvp.core.permission.InternalGroupablePermissionEntry;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PaperPermissionGroup;
+import net.kissenpvp.paper.api.permission.PaperPublicPermissionGroup;
+import net.kissenpvp.paper.permission.KissenPaperAttachmentPermission;
+import net.kissenpvp.paper.permission.permissible.KissenPaperPermissible;
+import net.kyori.adventure.text.Component;
+import org.bukkit.Bukkit;
+import org.bukkit.permissions.Permissible;
+import org.bukkit.permissions.PermissionAttachment;
+import org.bukkit.permissions.PermissionAttachmentInfo;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.*;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public class KissenPaperPermissionGroup extends KissenPaperPermissible implements PaperPermissionGroup, InternalGroupablePermissionEntry<PaperPermission> {
+    private final PaperPublicPermissionGroup permissionGroup;
+
+    public KissenPaperPermissionGroup(PaperPublicPermissionGroup permissionGroup) {
+        this.permissionGroup = permissionGroup;
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getOwnPermissions() {
+        return Stream.concat(getOwnPermissions(Context.LOCAL).stream(), getOwnPermissions(Context.GLOBAL).stream())
+            .collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public int wipeGroups() {
+        return getCoreGroup(Context.LOCAL).wipeGroups();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups() {
+        return Stream.concat(getPermissionGroups(Context.LOCAL).stream(), getPermissionGroups(Context.GLOBAL).stream())
+            .collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup) {
+        return getCoreGroup(Context.LOCAL).inGroup(permissionGroup) || getCoreGroup(Context.GLOBAL).inGroup(permissionGroup);
+    }
+
+    @Override
+    public @NotNull String getPermissionID() {
+        return getCoreGroup(Context.GLOBAL).getPermissionID();
+    }
+
+    @Override
+    public @NotNull Component displayName() {
+        return getCoreGroup(Context.GLOBAL).displayName();
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission) throws EventCancelledException {
+        return setPermission(permission, Context.GLOBAL);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, boolean value) throws EventCancelledException {
+        return setPermission(permission, value, Context.GLOBAL);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull PaperPermission permission) throws EventCancelledException {
+        return setPermission(permission, Context.GLOBAL);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission) {
+        return unsetPermission(permission, Context.GLOBAL);
+    }
+
+    @Override
+    public int wipePermissions() {
+        return getCoreGroup(Context.LOCAL).wipePermissions() + getCoreGroup(Context.GLOBAL).wipePermissions();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList() {
+        return Stream.concat(getPermissionList(Context.LOCAL).stream(), getPermissionList(Context.GLOBAL).stream())
+            .collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @NotNull Optional<PaperPermission> getPermission(@NotNull String permission) {
+        return Optional.ofNullable(getPermissionList(Context.LOCAL).stream()
+            .filter(paperPermission -> paperPermission.getName().equalsIgnoreCase(permission))
+            .findFirst()
+            .orElse(getPermissionList(Context.GLOBAL).stream()
+                .filter(paperPermission -> paperPermission.getName().equalsIgnoreCase(permission))
+                .findFirst()
+                .orElse(null)));
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAffectedPermissionPlayer() {
+        return Stream.concat(getCoreGroup(Context.LOCAL).getAffectedPermissionPlayer()
+                .stream(), getCoreGroup(Context.GLOBAL).getAffectedPermissionPlayer().stream())
+            .collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String permission) {
+        Optional<PaperPermission> optionalPaperPermission = getPermission(permission);
+        return optionalPaperPermission.isPresent() && optionalPaperPermission.get().getValue();
+    }
+
+    @Override
+    public @NotNull Set<PermissionAttachmentInfo> getEffectivePermissions() {
+        return getPermissionList().stream().map(permission ->
+        {
+            PermissionAttachment attachment = null;
+            if (permission instanceof KissenPaperAttachmentPermission kissenPaperAttachmentPermission) {
+                attachment = kissenPaperAttachmentPermission.getPermissionAttachment();
+            }
+            return new PermissionAttachmentInfo(this, permission.getName(), attachment, permission.getValue());
+        }).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public void permissionUpdate() {
+        getCoreGroup(Context.GLOBAL).permissionUpdate();
+        getCoreGroup(Context.LOCAL).permissionUpdate();
+        getAffectedPermissionPlayer().stream()
+            .map(Bukkit::getPlayer)
+            .filter(Objects::nonNull)
+            .forEach(Permissible::recalculatePermissions);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<String> getMember() {
+        return Stream.concat(getCoreGroup(Context.LOCAL).getMember()
+            .stream(), getCoreGroup(Context.GLOBAL).getMember().stream()).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public boolean addMember(@NotNull GroupablePermissionEntry<?> groupablePermissionEntry) {
+        return addMember(groupablePermissionEntry, Context.GLOBAL);
+    }
+
+    @Override
+    public boolean removeMember(@NotNull GroupablePermissionEntry<?> groupablePermissionEntry) {
+        return removeMember(groupablePermissionEntry, Context.GLOBAL);
+    }
+
+    @Override
+    public boolean addMember(@NotNull GroupablePermissionEntry<?> groupablePermissionEntry, @NotNull Context context) {
+        return getCoreGroup(context).addMember(groupablePermissionEntry);
+    }
+
+    @Override
+    public boolean removeMember(@NotNull GroupablePermissionEntry<?> groupablePermissionEntry, @NotNull Context context) {
+        return getCoreGroup(context).removeMember(groupablePermissionEntry);
+    }
+
+    @Override
+    public @NotNull PermissionGroup<PaperPermission> getCoreGroup(@NotNull Context context) {
+        return switch (context) {
+            case GLOBAL -> permissionGroup;
+            case LOCAL -> permissionGroup.getPrivatePermissionGroup();
+        };
+    }
+
+    @Override
+    public @NotNull Set<PaperPermission> getOwnPermissions(@NotNull Context context) {
+        return getCoreGroup(context).getOwnPermissions();
+    }
+
+    @Override
+    public @NotNull Set<PermissionGroup<PaperPermission>> getPermissionGroups(@NotNull Context context) {
+        return getCoreGroup(context).getPermissionGroups();
+    }
+
+    @Override
+    public boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup, @NotNull Context context) {
+        return getCoreGroup(context).inGroup(permissionGroup);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, @NotNull Context context) throws EventCancelledException {
+        return getCoreGroup(context).setPermission(permission);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, boolean value, @NotNull Context context) throws EventCancelledException {
+        return getCoreGroup(context).setPermission(permission, value);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull PaperPermission permission, @NotNull Context context) throws EventCancelledException {
+        return getCoreGroup(context).setPermission(permission);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission, @NotNull Context context) {
+        return getCoreGroup(context).unsetPermission(permission);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList(@NotNull Context context) {
+        return getCoreGroup(context).getPermissionList();
+    }
+
+    @Override
+    public @NotNull Optional<PaperPermission> getPermission(@NotNull String permission, @NotNull Context context) {
+        return getCoreGroup(context).getPermission(permission);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String permission, @NotNull Context context) {
+        return getCoreGroup(context).hasPermission(permission);
+    }
+
+    @Override
+    public @NotNull GroupablePermissionEntry<PaperPermission> getPermissionEntry(@NotNull Context context) {
+        return this;
+    }
+
+    @Override
+    public @NotNull Set<PaperPermission> internalPermissionCollector(@NotNull Set<String> blacklistedGroups, @NotNull Set<String> blacklistedPermissions) {
+        Set<PaperPermission> permissionSet = new HashSet<>(((InternalGroupablePermissionEntry<PaperPermission>) getCoreGroup(Context.LOCAL)).internalPermissionCollector(blacklistedGroups, blacklistedPermissions));
+        blacklistedGroups.remove(getPermissionID()); //remove blacklist because public group will be added as well.
+        permissionSet.addAll(((InternalGroupablePermissionEntry<PaperPermission>) getCoreGroup(Context.GLOBAL)).internalPermissionCollector(blacklistedGroups, blacklistedPermissions));
+        return permissionSet;
+    }
+
+    @Override
+    public @NotNull Set<String> internalGroupCollector(@NotNull Set<String> blacklistedGroups) {
+        Set<String> groups = new HashSet<>(((InternalGroupablePermissionEntry<PaperPermission>) getCoreGroup(Context.GLOBAL)).internalGroupCollector(blacklistedGroups));
+        blacklistedGroups.remove(getPermissionID()); //remove blacklist because public group will be added as well.
+        groups.addAll(((InternalGroupablePermissionEntry<PaperPermission>) getCoreGroup(Context.GLOBAL)).internalGroupCollector(blacklistedGroups));
+        return groups;
+    }
+
+    @Override
+    public boolean isOp() {
+        return hasPermission("*");
+    }
+
+    @Override
+    public void setOp(boolean value) {
+        if (isOp() && !value) {
+            unsetPermission("*");
+            return;
+        }
+
+        try {
+            setPermission("*", value);
+        } catch (EventCancelledException eventCancelledException) {
+            throw new RuntimeException(eventCancelledException);
+        }
+    }
+
+    /**
+     * Retrieves a map containing stored data from the storage system.
+     * <p>
+     * This method fetches data from the storage implementation associated with the Kissen Core instance. The data is retrieved based on the provided storage key.
+     * The retrieved data is returned as a map of string keys to associated objects.
+     *
+     * @return A non-null map containing the retrieved data from the storage system.
+     * @throws UnsupportedOperationException If the storage system is not supported or not properly configured.
+     */
+    private @NotNull Map<String, Object> getStorage() {
+        return KissenCore.getInstance()
+            .getImplementation(StorageImplementation.class)
+            .getStorage("permissiongroupattachments");
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPrivatePermissionGroup.java b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPrivatePermissionGroup.java
new file mode 100644
index 0000000000000000000000000000000000000000..2a951ec1b9bd6ef2360ccd995a78ea9edbb866f1
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPrivatePermissionGroup.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission.group;
+
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.database.meta.ObjectMeta;
+import net.kissenpvp.core.api.database.savable.Savable;
+import net.kissenpvp.core.api.networking.socket.DataPackage;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.PaperPermissionGroup;
+import net.kissenpvp.paper.api.permission.PaperPermissionImplementation;
+import net.kissenpvp.paper.api.permission.PaperPrivatePermissionGroup;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Objects;
+
+public class KissenPaperPrivatePermissionGroup extends KissenPaperAbstractPermissionGroup implements PaperPrivatePermissionGroup {
+    @Override
+    public void sendData(@NotNull DataPackage dataPackage) { /* ignored */ }
+
+    @Override
+    public @Nullable PaperPermissionGroup getPublicGroup() {
+        return Bukkit.getKissen()
+            .getImplementation(PaperPermissionImplementation.class)
+            .getPermissionGroup(getPermissionID());
+    }
+
+    @Override
+    public @NotNull ObjectMeta getMeta() {
+        return Bukkit.getKissen().getPrivateMeta();
+    }
+
+    @Override
+    public int softDelete() throws BackendException {
+        getSerializableSavableHandler().delete();
+        ((Savable) Objects.requireNonNull(getPublicGroup()).getCoreGroup(Context.GLOBAL)).delete();
+        return super.softDelete();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPublicPermissionGroup.java b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPublicPermissionGroup.java
new file mode 100644
index 0000000000000000000000000000000000000000..9b3dd93968395c211b8ca8975895b13b82c7dc2e
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPublicPermissionGroup.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission.group;
+
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.networking.socket.DataPackage;
+import net.kissenpvp.paper.api.permission.PaperPrivatePermissionGroup;
+import net.kissenpvp.paper.api.permission.PaperPublicPermissionGroup;
+import net.kissenpvp.paper.permission.KissenPaperPermissionImplementation;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Objects;
+
+public class KissenPaperPublicPermissionGroup extends KissenPaperAbstractPermissionGroup implements PaperPublicPermissionGroup {
+
+    @Override
+    public @NotNull String getSaveID() {
+        return "PublicPermissionGroup";
+    }
+
+    @Override
+    public void sendData(@NotNull DataPackage dataPackage) {
+        //TODO
+    }
+
+    @Override
+    public @NotNull PaperPrivatePermissionGroup getPrivatePermissionGroup() {
+        KissenPaperPermissionImplementation paperPermissionImplementation = Bukkit.getKissen()
+            .getImplementation(KissenPaperPermissionImplementation.class);
+        return Objects.requireNonNullElseGet(paperPermissionImplementation.getPrivatePermissionGroup(getPermissionID()), () -> {
+            try {
+                return paperPermissionImplementation.createPrivateInternalPermissionGroup(getPermissionID(), null);
+            } catch (BackendException backendException) {
+                throw new RuntimeException(backendException); //TODO use better approach
+            }
+        });
+    }
+
+    @Override
+    public int softDelete() throws BackendException {
+        Bukkit.getKissen()
+            .getImplementation(KissenPaperPermissionImplementation.class)
+            .removePublicPermissionGroup(getPermissionID());
+        return super.softDelete();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPermissible.java b/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPermissible.java
new file mode 100644
index 0000000000000000000000000000000000000000..ebc9bf7c16e1eb3b79553c4d7d9db54ccf8eaed4
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPermissible.java
@@ -0,0 +1,194 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission.permissible;
+
+import net.kissenpvp.core.api.message.ComponentSerializer;
+import net.kissenpvp.paper.api.permission.PaperPermissible;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.permission.KissenPaperAttachmentPermission;
+import net.kissenpvp.paper.permission.KissenPaperGroupablePermissionEntry;
+import net.kissenpvp.paper.permission.RemoveAttachmentRunnable;
+import org.bukkit.Bukkit;
+import org.bukkit.permissions.*;
+import org.bukkit.plugin.Plugin;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.logging.Level;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public abstract class KissenPaperPermissible implements KissenPaperGroupablePermissionEntry, PaperPermissible {
+
+    protected final Permissible parent;
+    protected final Set<PermissionAttachment> attachments;
+
+    public KissenPaperPermissible() {
+        this(null);
+    }
+
+    public KissenPaperPermissible(@Nullable Permissible parent) {
+        this.attachments = new HashSet<>();
+        this.parent = parent == null ? this : parent;
+        permissionUpdate();
+    }
+
+    @Override
+    public void permissionUpdate() {
+        unsubscribe();
+
+        Bukkit.getServer().getPluginManager().subscribeToDefaultPerms(isOp() || hasPermission("*"), parent);
+        for (PaperPermission permission : getPermissionList()) {
+            Bukkit.getServer().getPluginManager().subscribeToPermission(permission.getName(), parent);
+        }
+    }
+
+    @Override
+    public boolean isPermissionSet(@NotNull String name) {
+        return getPermission(name).isPresent();
+    }
+
+    @Override
+    public boolean isPermissionSet(@NotNull Permission perm) {
+        return isPermissionSet(perm.getName());
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull Permission perm) {
+        return hasPermission(perm.getName());
+    }
+
+    @Override
+    public @NotNull PermissionAttachment addAttachment(@NotNull Plugin plugin) {
+        PermissionAttachment result = new PermissionAttachment(plugin, parent);
+
+        attachments.add(result);
+        permissionUpdate();
+
+        return result;
+    }
+
+    @Override
+    public @NotNull PermissionAttachment addAttachment(@NotNull Plugin plugin, @NotNull String name, boolean value) {
+        PermissionAttachment permissionAttachment = addAttachment(plugin);
+        permissionAttachment.setPermission(name, value);
+        return permissionAttachment;
+    }
+
+    @Override
+    public @Nullable PermissionAttachment addAttachment(@NotNull Plugin plugin, @NotNull String name, boolean value, int ticks) {
+        PermissionAttachment permissionAttachment = addAttachment(plugin, ticks);
+        if (permissionAttachment != null) {
+            permissionAttachment.setPermission(name, value);
+        }
+        return permissionAttachment;
+    }
+
+    @Override
+    public @Nullable PermissionAttachment addAttachment(@NotNull Plugin plugin, int ticks) {
+        PermissionAttachment result = addAttachment(plugin);
+
+        if (Bukkit.getServer()
+                .getScheduler()
+                .scheduleSyncDelayedTask(plugin, new RemoveAttachmentRunnable(result), ticks) == -1) {
+            Bukkit.getServer()
+                    .getLogger()
+                    .log(Level.WARNING, "Could not add PermissionAttachment to " + ComponentSerializer.getInstance()
+                            .getLegacySerializer()
+                            .serialize(displayName()) + " for plugin " + plugin.getPluginMeta()
+                            .getDisplayName() + ": Scheduler returned -1");
+            result.remove();
+            return null;
+        } else {
+            return result;
+        }
+    }
+
+    @Override
+    public void removeAttachment(@NotNull PermissionAttachment attachment) {
+        if (attachments.remove(attachment)) {
+            PermissionRemovedExecutor permissionRemovedExecutor = attachment.getRemovalCallback();
+
+            if (permissionRemovedExecutor != null) {
+                permissionRemovedExecutor.attachmentRemoved(attachment);
+            }
+
+            permissionUpdate();
+        } else {
+            throw new IllegalArgumentException("Given attachment is not part of Permissible object " + ComponentSerializer.getInstance()
+                    .getLegacySerializer()
+                    .serialize(displayName()));
+        }
+    }
+
+    @Override
+    public void recalculatePermissions() {
+        permissionUpdate();
+    }
+
+    @Override
+    public @NotNull Set<PermissionAttachmentInfo> getEffectivePermissions() {
+        return getPermissionList().stream().map(permission -> {
+            PermissionAttachment attachment = null;
+            if (permission instanceof KissenPaperAttachmentPermission kissenPaperAttachmentPermission) {
+                attachment = kissenPaperAttachmentPermission.getPermissionAttachment();
+            }
+            return new PermissionAttachmentInfo(parent, permission.getName(), attachment, permission.getValue());
+        }).collect(Collectors.toSet());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList() {
+
+        Set<KissenPaperAttachmentPermission> kissenPaperAttachmentPermissions = new HashSet<>();
+        for (PermissionAttachment permissionAttachment : attachments) {
+            permissionAttachment.getPermissions()
+                    .forEach((key, value) -> kissenPaperAttachmentPermissions.add(new KissenPaperAttachmentPermission(permissionAttachment, key, value, KissenPaperPermissible.this, true)));
+        }
+
+        return Stream.concat(KissenPaperGroupablePermissionEntry.super.getPermissionList()
+                .stream(), kissenPaperAttachmentPermissions.stream()).collect(Collectors.toSet());
+    }
+
+    /**
+     * The <code>unsubscribe</code> method is used to deregister all permissions from a parent permission holder in the Bukkit server.
+     *
+     * <p>As a result of calling this method, the permission holder specified by 'parent' would not hold the permissions anymore until re-registered.</p>
+     *
+     * <p>Note: Parent could be a Player, a Group, or any entity that can hold permissions in Bukkit.</p>
+     *
+     * <p>It is advised to call this method when you no longer need the permissions to be associated with the parent or want to clear current permissions before setting new ones.</p>
+     *
+     * @see net.kissenpvp.core.api.permission.Permission
+     * @see org.bukkit.permissions.Permissible
+     */
+    public void unsubscribe() {
+        for (String name : getPermissionList().stream()
+                .map(net.kissenpvp.core.api.permission.Permission::getName)
+                .collect(Collectors.toSet())) {
+            Bukkit.getServer().getPluginManager().unsubscribeFromPermission(name, parent);
+        }
+
+        Bukkit.getServer().getPluginManager().unsubscribeFromDefaultPerms(false, parent);
+        Bukkit.getServer().getPluginManager().unsubscribeFromDefaultPerms(true, parent);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPlayerPermissible.java b/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPlayerPermissible.java
new file mode 100644
index 0000000000000000000000000000000000000000..55de8302538c8e5e85ccdd5f4250f24008057baf
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPlayerPermissible.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission.permissible;
+
+import net.kissenpvp.core.api.permission.GroupablePermissionEntry;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kyori.adventure.text.Component;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.permissions.Permissible;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Collections;
+import java.util.Set;
+import java.util.UUID;
+
+public class KissenPaperPlayerPermissible extends KissenPaperPermissible {
+
+    public KissenPaperPlayerPermissible(@NotNull Permissible parent) {
+        super(parent);
+    }
+
+    public @NotNull OfflinePlayer getPlayer() {
+        return (OfflinePlayer) parent; // Can be offline or online, does not matter
+    }
+
+    @Override
+    public @NotNull GroupablePermissionEntry<PaperPermission> getPermissionEntry(@NotNull Context context) {
+        return (GroupablePermissionEntry<PaperPermission>) getPlayer().getUser(context);
+    }
+
+    @Override
+    public @NotNull String getPermissionID() {
+        return getPermissionEntry(Context.GLOBAL).getPermissionID();
+    }
+
+    @Override
+    public @NotNull Component displayName() {
+        return getPlayer().displayName();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAffectedPermissionPlayer() {
+        return Collections.singleton(getPlayer().getUniqueId());
+    }
+
+    @Override
+    public boolean isOp() {
+        return getPlayer().isOp();
+    }
+
+    @Override
+    public void setOp(boolean value) {
+        getPlayer().setOp(value);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenOperatorDataNode.java b/src/main/java/net/kissenpvp/paper/user/KissenOperatorDataNode.java
new file mode 100644
index 0000000000000000000000000000000000000000..6e27b52d62505e5669f8b13235aba2cca5f20457
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/KissenOperatorDataNode.java
@@ -0,0 +1,15 @@
+package net.kissenpvp.paper.user;
+
+import com.mojang.authlib.GameProfile;
+import net.minecraft.server.players.ServerOpListEntry;
+import org.jetbrains.annotations.NotNull;
+
+public record KissenOperatorDataNode(int level, boolean bypassServerLimit)
+{
+
+    public @NotNull ServerOpListEntry getServerOpListEntry(@NotNull GameProfile profile)
+    {
+        return new ServerOpListEntry(profile, level(), bypassServerLimit());
+    }
+
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenPaperProfileCache.java b/src/main/java/net/kissenpvp/paper/user/KissenPaperProfileCache.java
new file mode 100644
index 0000000000000000000000000000000000000000..1dc4273c190d512036b4257a6370d112b1670cc6
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/KissenPaperProfileCache.java
@@ -0,0 +1,95 @@
+package net.kissenpvp.paper.user;
+
+import com.mojang.authlib.GameProfile;
+import com.mojang.authlib.GameProfileRepository;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.api.user.UserInfo;
+import net.kissenpvp.core.api.user.UserRepository;
+import net.minecraft.server.players.GameProfileCache;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Optional;
+import java.util.UUID;
+import java.util.function.Function;
+
+/**
+ * KissenPaperProfileCache is a cache specifically designed for KissenPaper profiles.
+ * This cache extends the {@code GameProfileCache} class to provide additional functionalities
+ * specific to the KissenPaper profiles. It has been designed to be used in the KissenPaper game application.
+ */
+public class KissenPaperProfileCache extends GameProfileCache {
+
+    private final UserRepository userRepository;
+
+    /**
+     * Creates a new instance of KissenPaperProfileCache.
+     *
+     * @param profileRepository - a not-null instance of a GameProfileRepository which is used to fetch and cache profiles
+     * @throws IllegalArgumentException if profileRepository is null
+     */
+    public KissenPaperProfileCache(@NotNull GameProfileRepository profileRepository) {
+        //noinspection DataFlowIssue
+        super(profileRepository, null); // not file based
+        userRepository = new KissenPaperUserRepository(profileRepository);
+        KissenPaperUserImplementation.setKissenPaperProfileCache(this);
+    }
+
+    @Override
+    public void add(@NotNull GameProfile profile) { /* moved to net.kissenpvp.core.user.KissenPublicUser#setup(String, Map) */ }
+
+    @Nullable
+    @Override
+    public GameProfile getProfileIfCached(@NotNull String name) {
+        return get(name).orElse(null);
+    }
+
+    @Override
+    public @NotNull Optional<GameProfile> get(@NotNull String name) {
+        return Bukkit.getKissen().getImplementation(UserImplementation.class).getCachedUserProfile(name).map(transformUserInfo()).or(() -> getUserRepository().getUser(name).join().map(translateUser()));
+    }
+
+    @Override
+    public @NotNull Optional<GameProfile> get(@NotNull UUID uuid) {
+        return Bukkit.getKissen().getImplementation(UserImplementation.class).getCachedUserProfile(uuid).map(transformUserInfo()).or(() -> getUserRepository().getUser(uuid).join().map(translateUser()));
+    }
+
+    @Override
+    protected @NotNull List<GameProfileInfo> load() {
+        // ignored
+        return new ArrayList<>();
+    }
+
+    @Override
+    public void save(boolean asyncSave) {
+        // ignored
+    }
+
+    private @NotNull Function<UserInfo, GameProfile> transformUserInfo() {
+        return userInfo -> new GameProfile(userInfo.getUUID(), userInfo.getName());
+    }
+
+    /**
+     * Returns the UserRepository object used within this class.
+     *
+     * @return UserRepository that this class uses to perform user related operations
+     */
+    public @NotNull UserRepository getUserRepository() {
+        return userRepository;
+    }
+
+    /**
+     * Returns a Function that can be used to translate a User object into a GameProfile.
+     *
+     * @return Function that translates a User object into a GameProfile
+     */
+    @Contract(pure = true)
+    private @NotNull Function<User, GameProfile> translateUser() {
+        return user -> new GameProfile(UUID.fromString(user.getRawID()), user.getNotNull("name"));
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenPaperPublicUser.java b/src/main/java/net/kissenpvp/paper/user/KissenPaperPublicUser.java
new file mode 100644
index 0000000000000000000000000000000000000000..77d31929ec28e774955713bce9a965a8b246b282
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/KissenPaperPublicUser.java
@@ -0,0 +1,258 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.user;
+
+import net.kissenpvp.core.api.base.Kissen;
+import net.kissenpvp.core.api.database.StorageImplementation;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.database.meta.ObjectMeta;
+import net.kissenpvp.core.api.database.savable.SavableMap;
+import net.kissenpvp.core.api.networking.client.entitiy.PlayerClient;
+import net.kissenpvp.core.api.networking.socket.DataPackage;
+import net.kissenpvp.core.api.permission.PermissionGroup;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.base.KissenCore;
+import net.kissenpvp.core.database.DataWriter;
+import net.kissenpvp.core.permission.KissenPermissionNode;
+import net.kissenpvp.core.user.KissenPublicUser;
+import net.kissenpvp.core.user.KissenUser;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.networking.client.entity.PaperPlayerClient;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PaperPermissionImplementation;
+import net.kissenpvp.paper.permission.KissenPaperPermission;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Objects;
+import java.util.Set;
+import java.util.UUID;
+import java.util.stream.Collectors;
+
+/**
+ * The {@code KissenPaperPublicUser} class extends the {@link KissenPublicUser} class with {@link PaperPermission}
+ * as its generic type. It represents a public user within the KissenPaper system.
+ * <p>
+ * While it maintains the key characteristics of a {@link KissenPublicUser}, such as a UUID and name,
+ * the {@code KissenPaperPublicUser} further enhances this with specifics for a user that has a public profile
+ * accessible across multiple servers.
+ * @see KissenPublicUser
+ */
+public class KissenPaperPublicUser extends KissenPublicUser<PaperPermission> {
+
+    /**
+     * The constructor for the {@code KissenPaperPublicUser} class.
+     * It initializes a new instance of the class with a specified UUID and name.
+     *
+     * @param uuid A unique identifier. It may be nullable, representing a user, whose unique identifier
+     *             might not be known or relevant at the time of creation.
+     * @param name A string representing the username. It may be nullable, representing a user whose name
+     *             might not be known or relevant at the time of creation.
+     * @throws BackendException If an error occurs during the creation and initialization of a KissenPaperPublicUser instance.
+     */
+    public KissenPaperPublicUser(@Nullable UUID uuid, @Nullable String name) throws BackendException {
+        super(uuid, name);
+    }
+
+    /**
+     * An alternate constructor for the {@code KissenPaperPublicUser} class which initializes a new instance
+     * of the class with a SavableMap data structure.
+     *
+     * @param data A {@link SavableMap} object that contains user details.
+     *             It is expected to be used when loading a user from saved storage.
+     * @throws BackendException If an error occurs during the creation and initialization of a KissenPaperPublicUser instance.
+     */
+    public KissenPaperPublicUser(@NotNull SavableMap data) throws BackendException
+    {
+        super(data);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups() {
+        return KissenCore.getInstance()
+            .getImplementation(PaperPermissionImplementation.class)
+            .getPermissionGroupSet()
+            .stream()
+            .filter(permissionGroup -> permissionGroup.getMember().contains(getPermissionID()))
+            .collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public PlayerClient<?, ?, ?> getPlayerClient() {
+        return getPrivateUserEntry().getPlayerClient();
+    }
+
+    @Override
+    protected @NotNull PaperPermission translatePermission(@NotNull KissenPermissionNode kissenPermissionNode, @Nullable DataWriter dataWriter) {
+        return new KissenPaperPermission(kissenPermissionNode, this, dataWriter);
+    }
+
+    @Override
+    public void sendData(@NotNull DataPackage dataPackage) {
+        // TODO Networking and stuff
+    }
+
+    @Override
+    public void login() {
+        super.login();
+        //getStorage().put("visual_hash", kissenPaperPlayerClient.visualHash()); //TODO
+        getStorage().put("time_joined", System.currentTimeMillis());
+        ((KissenUser<?>) getPrivateUserEntry()).login();
+        getStorage().put("tick", true);
+    }
+
+    @Override
+    public void logout() {
+        super.logout();
+        Bukkit.getKissen().getImplementation(StorageImplementation.class).dropStorage("user" + this.getRawID());
+    }
+
+    @Override
+    public void tick() {
+        //TODO check for visuals maybe
+        ((KissenUser<PaperPermission>) getPrivateUserEntry()).tick();
+        super.tick();
+    }
+
+    @Override
+    public int softDelete() throws BackendException {
+        return super.softDelete() + getPrivateUserEntry().delete();
+    }
+
+    /**
+     * The {@code getPrivateUserEntry} method retrieves an instance of a private user entry from the local storage.
+     * If the private user entry is not yet in the storage, it creates an entry using the 'setupPrivateUser' method.
+     * In case of an exception when creating the private user entry, an error log is produced, and the server
+     * is advised to be shut down to prevent further data problems.
+     *
+     * @return An instance of a {@link User} associated with the private user entry.
+     *         Cast is performed without check, which assumes that "private_user_entry" in the storage is always of {@link User} type.
+     */
+    public @NotNull User getPrivateUserEntry() {
+        if (!getStorage().containsKey("private_user_entry")) {
+            try {
+                getStorage().put("private_user_entry", setupPrivateUser(UUID.fromString(getRawID()), getNotNull("name")));
+            } catch (BackendException backendException) {
+                KissenCore.getInstance()
+                    .getLogger()
+                    .error("The backend was not able to create a private user entry for the user '{}' with the id '{}'. It's advised to shutdown the server to prevent further problems with the servers data.", getNotNull("name"), getRawID());
+            }
+        }
+        return (User) getStorage().get("private_user_entry");
+    }
+
+    /**
+     * The {@code setupPrivateUser} method creates a new instance of a private user, {@link KissenPaperPrivateUser}, using provided UUID and username.
+     *
+     * @param uuid The UUID for the private user to be created.
+     * @param name The username of the private user.
+     * @return An instance of a {@link KissenPaperPrivateUser} initialized with the provided UUID and username.
+     * @throws BackendException If an error occurs during the creation and initialization of a KissenPaperPrivateUser instance.
+     * @see KissenPaperPrivateUser
+     */
+    protected @NotNull KissenPaperPrivateUser setupPrivateUser(UUID uuid, String name) throws BackendException {
+        return new KissenPaperPrivateUser(uuid, name);
+    }
+
+    /**
+     * The nested class {@code KissenPaperPrivateUser} extends the {@link KissenUser} class while specifying {@link PaperPermission}
+     * as its generic type. It represents a private user entity within the KissenPaper system.
+     * <p>
+     * While the key characteristics of a {@link KissenUser} are maintained such as a UUID and name,
+     * the KissenPaperPrivateUser further enhances this with specifics for a user that owns a private profile which only this
+     * server can access.
+     * @see KissenUser
+     */
+    public static class KissenPaperPrivateUser extends KissenUser<PaperPermission> {
+
+        /**
+         * The constructor for the {@code KissenPaperPrivateUser} class.
+         * It initializes a new instance of the class with specified UUID and name.
+         *
+         * @param uuid A unique identifier. It may be nullable, representing a user whose unique identifier
+         *             might not be known or relevant at the time of creation.
+         * @param name A string representing the username. It may be nullable, representing a user whose name
+         *             might not be known or relevant at the time of creation.
+         * @throws BackendException If an error occurs during the creation and initialization of a KissenPaperPrivateUser instance.
+         */
+        public KissenPaperPrivateUser(@Nullable UUID uuid, @Nullable String name) throws BackendException {
+            super(uuid, name);
+        }
+
+        @Override
+        public @NotNull String getSaveID() {
+            return Bukkit.getKissen().getImplementation(KissenPaperUserImplementation.class).getUserSaveID(Context.LOCAL);
+        }
+
+        @Override
+        public @NotNull ObjectMeta getMeta() {
+            return Bukkit.getKissen().getImplementation(KissenPaperUserImplementation.class).getUserMeta(Context.LOCAL);
+        }
+
+        @Override
+        public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups() {
+            return KissenCore.getInstance()
+                    .getImplementation(PaperPermissionImplementation.class)
+                    .getPrivatePermissionGroupSet()
+                    .stream()
+                    .filter(permissionGroup -> permissionGroup.getMember().contains(getPermissionID()))
+                    .collect(Collectors.toUnmodifiableSet());
+        }
+
+        @Override
+        public PlayerClient<?, ?, ?> getPlayerClient() {
+            if (!getStorage().containsKey("player_client")) {
+                getStorage().put("player_client", injectPlayerClient());
+            }
+            return (PlayerClient<?, ?, ?>) getStorage().get("player_client");
+        }
+
+        @Override
+        protected @NotNull PaperPermission translatePermission(@NotNull KissenPermissionNode kissenPermissionNode, @Nullable DataWriter dataWriter) {
+            return new KissenPaperPermission(kissenPermissionNode, this, dataWriter);
+        }
+
+        @Override
+        public void sendData(@NotNull DataPackage dataPackage) { /* Ignored because it's private */ }
+
+        /**
+         * The 'injectPlayerClient' method is responsible for creating and returning a {@link PaperPlayerClient}.
+         * This method is used to get an instance of a user's player client (whether online or offline),
+         * crucial for various user-related functionality.
+         * <p>
+         * The method begins by obtaining the UUID of the user.
+         * It then checks if the user is currently online using Bukkit's {@link Kissen#isOnline(UUID)} method on 'Kissen' platform.
+         * If the user is online, it gets the online instance of the player using Bukkit's 'getPlayer' method.
+         * If the user is offline, it gets the offline instance of the player using Bukkit's 'getOfflinePlayer' method.
+         *
+         * @return Returns an instance of {@link PaperPlayerClient} associated with the user based on visibility status.
+         * Can be an online or offline player, depending on the user's current visibility in the game environment.
+         *
+         * @throws NullPointerException If 'getPlayer' method returns null, this exception is thrown, indicating that
+         * the user is currently marked as online but no associated online {@link PaperPlayerClient} was found.
+         * @see Kissen
+         */
+        protected @NotNull PaperPlayerClient injectPlayerClient() {
+            UUID uuid = UUID.fromString(getRawID());
+            return Bukkit.getKissen().isOnline(uuid) ? Objects.requireNonNull(Bukkit.getPlayer(uuid)) : Bukkit.getOfflinePlayer(uuid);
+        }
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenPaperUserImplementation.java b/src/main/java/net/kissenpvp/paper/user/KissenPaperUserImplementation.java
new file mode 100644
index 0000000000000000000000000000000000000000..0e55279320e158cb99830041f56a37e668eaf170
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/KissenPaperUserImplementation.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.user;
+
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.database.meta.ObjectMeta;
+import net.kissenpvp.core.api.database.savable.SavableMap;
+import net.kissenpvp.core.api.networking.client.entitiy.UnknownPlayerException;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.user.KissenUserImplementation;
+import net.kissenpvp.paper.api.base.Context;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Set;
+import java.util.UUID;
+import java.util.function.Supplier;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+/**
+ * The class 'KissenPaperUserImplementation' is an extension of the 'KissenUserImplementation' in the KissenPaper system.
+ * This class is responsible for interacting with or manipulating the paper-related functionality of a Kissen user.
+ * The class holds an instance of KissenPaperProfileCache which it uses to cache profiles for efficient read operations.
+ */
+public class KissenPaperUserImplementation extends KissenUserImplementation {
+
+    private static KissenPaperProfileCache kissenPaperProfileCache;
+
+    @Override
+    public @NotNull @Unmodifiable Set<SavableMap> getUserData() throws BackendException {
+        return Stream.concat(getUserMeta().getData(new KissenPaperPublicUser(null, null)).values().stream(), getUserMeta().getData(new KissenPaperPublicUser.KissenPaperPrivateUser(null, null)).values().stream()).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull UUID uuid) {
+
+        Supplier<User> createUser = () -> kissenPaperProfileCache.getUserRepository().getUser(uuid).join().orElseThrow(() -> new UnknownPlayerException(String.valueOf(uuid)));
+        Supplier<User> loadUser = () -> {
+            try {
+                return new KissenPaperPublicUser(getUserMeta().getData(getUserSaveID() + uuid).orElseGet(createUser));
+            } catch (BackendException backendException) {
+                throw new RuntimeException("It seems like the backend is unreachable. It's advised to shutdown the server to prevent further damage or loss to the servers data.", backendException);
+            }
+        };
+        return getOnlineUser(uuid).orElseGet(loadUser);
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull String name) throws BackendException {
+        try {
+            if (getUserProfiles().stream().noneMatch(userInfo -> userInfo.getName().equals(name))) {
+                throw new UnknownPlayerException(name);
+            }
+            return super.getUser(name);
+        } catch (UnknownPlayerException unknownPlayerException) {
+            return kissenPaperProfileCache.getUserRepository().getUser(name).join().orElseThrow(() -> new UnknownPlayerException(name));
+        }
+    }
+
+    /**
+     * Returns the User Save ID for the specified context.
+     *
+     * @param context an enum constant representing the context, either GLOBAL or LOCAL
+     * @return String representing the User Save ID. If context is GLOBAL, the ID is retrieved by getUserSaveID(),
+     * otherwise for LOCAL context, Returns the server's name concatenated with 'privateuser'.
+     */
+    public @NotNull String getUserSaveID(@NotNull Context context)
+    {
+        return switch (context)
+        {
+            case GLOBAL -> getUserSaveID();
+            case LOCAL -> Bukkit.getServer().getName() + "privateuser";
+        };
+    }
+
+    /**
+     * Returns the User MetaData for the specified context.
+     *
+     * @param context an enum constant indicating the context, either GLOBAL or LOCAL
+     * @return ObjectMeta instance representing User's metadata. If context is GLOBAL, the metadata is retrieved by getUserMeta(),
+     * otherwise for LOCAL context, Returns the private metadata available in Bukkit's 'Kissen'.
+     */
+    public @NotNull ObjectMeta getUserMeta(@NotNull Context context)
+    {
+        return switch (context)
+        {
+            case GLOBAL -> getUserMeta();
+            case LOCAL -> Bukkit.getKissen().getPrivateMeta();
+        };
+    }
+
+    /**
+     * This private static method retrieves the current instance of KissenPaperProfileCache.
+     *
+     * @return The current KissenPaperProfileCache instance.
+     */
+    private static KissenPaperProfileCache getKissenPaperProfileCache() {
+        return kissenPaperProfileCache;
+    }
+
+    /**
+     * This public static method sets the KissenPaperProfileCache with a new instance.
+     * The method expects to receive an instance of KissenPaperProfileCache.
+     * If the input is null, an IllegalStateException will be thrown.
+     *
+     * @param kissenPaperProfileCache A new KissenPaperProfileCache instance.
+     * @throws IllegalStateException If the provided KissenPaperProfileCache instance is null.
+     */
+    public static void setKissenPaperProfileCache(KissenPaperProfileCache kissenPaperProfileCache) {
+        if(kissenPaperProfileCache == null)
+        {
+            throw new IllegalStateException("Object already initialized.");
+        }
+        KissenPaperUserImplementation.kissenPaperProfileCache = kissenPaperProfileCache;
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenPaperUserRepository.java b/src/main/java/net/kissenpvp/paper/user/KissenPaperUserRepository.java
new file mode 100644
index 0000000000000000000000000000000000000000..671da825ee272f8ef7a02e43ca5620df939bf03c
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/KissenPaperUserRepository.java
@@ -0,0 +1,126 @@
+package net.kissenpvp.paper.user;
+
+import com.mojang.authlib.GameProfile;
+import com.mojang.authlib.GameProfileRepository;
+import com.mojang.authlib.ProfileLookupCallback;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.api.user.UserRepository;
+import net.minecraft.core.UUIDUtil;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Optional;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.atomic.AtomicReference;
+
+/**
+ * The class 'KissenPaperUserRepository' implements the 'UserRepository' interface.
+ * It represents a repository for the User entities from mojang.
+ * Compliant with the Repository pattern, this class is intended to encapsulate all
+ * data access mechanics needed for User entities.
+ * <p>
+ * It also holds a 'GameProfileRepository' which perhaps holds the source data for the
+ * Users, or is another important factor in the retrieval or manipulation of User data.
+ */
+public class KissenPaperUserRepository implements UserRepository {
+
+    private final GameProfileRepository gameProfileRepository;
+
+    /**
+     * The constructor for the 'KissenPaperUserRepository' class.
+     * It initializes a new instance of the class with a specified 'GameProfileRepository' object.
+     *
+     * @param gameProfileRepository A 'GameProfileRepository' object.
+     * Specifies the game profile repository that the user repository will work with.
+     */
+    public KissenPaperUserRepository(@NotNull GameProfileRepository gameProfileRepository) {
+        this.gameProfileRepository = gameProfileRepository;
+    }
+
+    @Override
+    public @NotNull CompletableFuture<Optional<User>> getUser(@NotNull String name) throws BackendException {
+        CompletableFuture<Optional<User>> gameProfileCompletableFuture = new CompletableFuture<>();
+        AtomicReference<Optional<GameProfile>> fetchedRef = new AtomicReference<>(Optional.empty());
+
+        gameProfileRepository.findProfilesByNames(new String[]{name}, new ProfileLookupCallback() {
+            @Override
+            public void onProfileLookupSucceeded(GameProfile gameProfile) {
+                fetchedRef.set(Optional.ofNullable(gameProfile));
+            }
+
+            @Override
+            public void onProfileLookupFailed(String s, Exception e) {
+                gameProfileCompletableFuture.completeExceptionally(e);
+            }
+        });
+
+        fetchedRef.get().ifPresentOrElse(gameProfile -> processGameProfile(gameProfileCompletableFuture, gameProfile), () -> processMissingProfile(gameProfileCompletableFuture, name));
+
+        return gameProfileCompletableFuture;
+    }
+
+    @Override
+    public @NotNull CompletableFuture<Optional<User>> getUser(@NotNull UUID uuid) {
+        return null; //TODO
+    }
+
+    /**
+     * This method is used to determine whether authorization should take place.
+     * Its behaviour may be determined by the 'GlobalConfiguration' setting 'isProxyOnlineMode'.
+     * The return value implies whether the proxy is in online mode or not,
+     * which further implies whether authentication is needed.
+     *
+     * @return A boolean value -- 'true' when proxy is in online mode implying authorization
+     * is required for network interactions, 'false' otherwise.
+     */
+    private boolean shouldAuthorize()
+    {
+        return io.papermc.paper.configuration.GlobalConfiguration.get().proxies.isProxyOnlineMode();
+    }
+
+    /**
+     * Processes a potentially missing user profile. If authentication is not required,
+     * it will generate and process a "cracked" user profile with an offline player UUID.
+     * Otherwise, the method will complete the CompletableFuture with an empty Optional.
+     *
+     * @param gameProfileFuture a CompletableFuture that will be completed with the found (or not found) User
+     * @param name the name of the user to lookup
+     */
+    private void processMissingProfile(CompletableFuture<Optional<User>> gameProfileFuture, String name) {
+        if (!shouldAuthorize()) {
+            // Create cracked user
+            UUID offlineUUID = UUIDUtil.createOfflinePlayerUUID(name);
+            processGameProfile(gameProfileFuture, new GameProfile(offlineUUID, name));
+            return;
+        }
+        gameProfileFuture.complete(Optional.empty());
+    }
+
+    /**
+     * Processes a game profile and completes the CompletableFuture with the translated User object.
+     * If any error occurs during the translation, the resulting BackendException will be completed exceptionally
+     * inside the CompletableFuture.
+     *
+     * @param gameProfileFuture a CompletableFuture that will be completed with the translated User or an Error.
+     * @param gameProfile the game profile to process.
+     */
+    private void processGameProfile(CompletableFuture<Optional<User>> gameProfileFuture, GameProfile gameProfile) {
+        try {
+            gameProfileFuture.complete(Optional.of(translate(gameProfile)));
+        } catch (BackendException backendException) {
+            gameProfileFuture.completeExceptionally(backendException);
+        }
+    }
+
+    /**
+     * Translates a game profile into a KissenPaperPublicUser object.
+     *
+     * @param gameProfile the game profile to translate.
+     * @return KissenPaperPublicUser a new user object with the id and name from the passed game profile.
+     * @throws BackendException if any error occurs during the translation process.
+     */
+    private @NotNull User translate(@NotNull GameProfile gameProfile) throws BackendException {
+        return new KissenPaperPublicUser(gameProfile.getId(), gameProfile.getName());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenUserOperatorList.java b/src/main/java/net/kissenpvp/paper/user/KissenUserOperatorList.java
new file mode 100644
index 0000000000000000000000000000000000000000..d577f93302821b058eaaa12834da9a16908fb76b
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/KissenUserOperatorList.java
@@ -0,0 +1,250 @@
+package net.kissenpvp.paper.user;
+
+import com.google.gson.JsonObject;
+import com.mojang.authlib.GameProfile;
+import net.kissenpvp.core.api.database.DataImplementation;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.database.meta.ObjectMeta;
+import net.kissenpvp.core.api.database.queryapi.Column;
+import net.kissenpvp.core.api.database.queryapi.FilterType;
+import net.kissenpvp.core.api.database.queryapi.QuerySelect;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.api.user.UserInfo;
+import net.kissenpvp.paper.api.base.Context;
+import net.minecraft.server.players.ServerOpList;
+import net.minecraft.server.players.ServerOpListEntry;
+import net.minecraft.server.players.StoredUserEntry;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.io.File;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Objects;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.Executors;
+import java.util.stream.Collectors;
+
+/**
+ * This is a class that extends the functionality of StoredUserList. It provides functionality to manage a list
+ * of users and their operation permissions(data represented by type ServerOpListEntry), related to a game profile
+ * (data represented by type GameProfile).
+ * <p>
+ * An instance of it can be created by providing a file which acts as the storage medium for
+ * this user list.
+ * <p>
+ * This class may provide additions to StoredUserList, capturing behaviors specific to users
+ * who have operator permissions (as denoted by a ServerOpListEntry) linked to a specific game profile.
+ */
+public class KissenUserOperatorList extends ServerOpList {
+
+    private final Set<LinkedOperatorDataNode> linkedOperatorDataNodes;
+
+    /**
+     * This is a class that extends the functionality of StoredUserList. It provides functionality to manage a list
+     * of users and their operation permissions (data represented by type ServerOpListEntry), related to a game profile
+     * (data represented by type GameProfile).
+     * <p>
+     * It is initially not associated with any file storage. Thus, the user list is not loaded from any file nor
+     * does it persist between application invocations if not manually persisted.
+     * <p>
+     * This class may provide additions to StoredUserList, capturing behaviors specific to users
+     * who have operator permissions (as denoted by a ServerOpListEntry) linked to a specific game profile.
+     */
+    public KissenUserOperatorList() {
+        //noinspection DataFlowIssue
+        super(null); // not file based
+        this.linkedOperatorDataNodes = new HashSet<>();
+    }
+
+    @Override
+    public void add(@NotNull ServerOpListEntry entry) {
+        KissenOperatorDataNode operatorDataNode = new KissenOperatorDataNode(entry.getLevel(), entry.getBypassesPlayerLimit());
+        getLinkedOperatorDataNodes().removeIf(linkedOperatorDataNode -> linkedOperatorDataNode.gameProfile().equals(entry.getUser()));
+        getLinkedOperatorDataNodes().add(new LinkedOperatorDataNode(Objects.requireNonNull(entry.getUser()), operatorDataNode));
+
+        Executors.newSingleThreadExecutor().submit(() -> {
+            try {
+                getLocalUserMeta().setRecord(getLocalUserSaveID() + Objects.requireNonNull(entry.getUser()).getId(), "operator", operatorDataNode);
+            } catch (BackendException backendException) {
+                throw new RuntimeException(String.format("Something went wrong when setting the operator data from user %s.", entry.getUser().getName()), backendException);
+            }
+        });
+    }
+
+    @Nullable
+    @Override
+    public ServerOpListEntry get(@NotNull GameProfile key) {
+        return getLinkedOperatorDataNodes().stream().filter(linkedOperatorDataNode -> linkedOperatorDataNode.gameProfile().equals(key)).findFirst().map(LinkedOperatorDataNode::getServerOpListEntry).orElse(null);
+    }
+
+    @Override
+    public void remove(@NotNull GameProfile key) {
+        getLinkedOperatorDataNodes().removeIf(linkedOperatorDataNode -> linkedOperatorDataNode.gameProfile().equals(key));
+        Executors.newSingleThreadExecutor().submit(() -> {
+            try {
+                getLocalUserMeta().delete(getLocalUserSaveID() + Objects.requireNonNull(key.getId(), "operator"));
+            } catch (BackendException backendException) {
+                throw new RuntimeException(String.format("An error occurred when removing operator rights from user %s.", key.getName()), backendException);
+            }
+        });
+    }
+
+    @Override
+    public void remove(@NotNull StoredUserEntry<GameProfile> entry) {
+        remove(Objects.requireNonNull(entry.getUser()));
+    }
+
+    @Override
+    public String @NotNull [] getUserList() {
+        return fetchOperators().stream().map(linkedOperatorDataNode -> linkedOperatorDataNode.gameProfile().getName()).distinct().toArray(String[]::new);
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return getLinkedOperatorDataNodes().isEmpty();
+    }
+
+    @Override
+    protected boolean contains(@NotNull GameProfile k0) {
+        return getLinkedOperatorDataNodes().stream().anyMatch(gameProfile -> gameProfile.gameProfile().equals(k0));
+    }
+
+    @Override
+    public @NotNull Collection<ServerOpListEntry> getEntries() {
+        return getLinkedOperatorDataNodes().stream().map(LinkedOperatorDataNode::getServerOpListEntry).collect(Collectors.toSet());
+    }
+
+    @Override
+    public void save() {
+        //ignored
+    }
+
+    @Override
+    protected @NotNull StoredUserEntry<GameProfile> createEntry(@NotNull JsonObject json) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public @NotNull File getFile() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void load() {
+        getLinkedOperatorDataNodes().clear();
+        getLinkedOperatorDataNodes().addAll(fetchOperators());
+    }
+
+    @Override
+    protected @NotNull String getKeyForUser(@NotNull GameProfile profile) {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * This method fetch operators data from the local user metadata and returns an unmodifiable set of LinkedOperatorDataNode.
+     * Each LinkedOperatorDataNode record holds a GameProfile and a KissenOperatorDataNode which correlates user information and operator data.
+     * <p>
+     * An SQL SELECT query is constructed to fetch the TOTAL_ID and VALUE columns.
+     * Filters are appended to this query to match rows starting with local user SaveID and where KEY equals 'operator'.
+     * The information is fetched into the 'data' array where every array element corresponds to a row from the result.
+     * <p>
+     * The method iterates over each row from the query result:
+     * - Extracts UUID by stripping the SaveID off TOTAL_ID
+     * - Fetches UserInfo from user profiles matching the UUID
+     * - Throws a RuntimeException if no such profile is found
+     * - Constructs KissenOperatorDataNode from the VALUE column data
+     * - The UUID and KissenOperatorDataNode are combined into a new LinkedOperatorDataNode instance and added to the resultant set.
+     * <p>
+     * If any exception is raised during the backend processing, it is wrapped in a runtime exception with an appropriate
+     * error message and thrown, thus indicating the issue with loading operators.
+     * <p>
+     * The method guarantees to return a set of LinkedOperatorDataNode or throw an exception in case of an error.
+     *
+     * @return Set of LinkedOperatorDataNode containing operator data info and user profile
+     * @throws RuntimeException if any error occurs while fetching and processing records from the database
+     */
+    private @NotNull @Unmodifiable Set<LinkedOperatorDataNode> fetchOperators() {
+        try {
+            Set<LinkedOperatorDataNode> result = new HashSet<>();
+
+            QuerySelect select = getLocalUserMeta().select(Column.TOTAL_ID, Column.VALUE).appendFilter(Column.TOTAL_ID, getLocalUserSaveID(), FilterType.START).appendFilter(Column.KEY, "operator", FilterType.EQUALS);
+            String[][] data = select.execute();
+            for (String[] current : data) {
+                UUID uuid = UUID.fromString(current[0].substring(getLocalUserSaveID().length()));
+                UserInfo userInfo = Bukkit.getKissen().getImplementation(UserImplementation.class).getUserProfiles().stream().filter(currentUserInfo -> currentUserInfo.getUUID().equals(uuid)).findFirst().orElseThrow(() -> new RuntimeException(String.format("Unknown user profile %s.", uuid)));
+                KissenOperatorDataNode kissenOperatorDataNode = Bukkit.getKissen().getImplementation(DataImplementation.class).fromJson(current[1], KissenOperatorDataNode.class);
+
+                result.add(new LinkedOperatorDataNode(new GameProfile(userInfo.getUUID(), userInfo.getName()), kissenOperatorDataNode));
+            }
+            return result;
+        } catch (BackendException backendException) {
+            throw new RuntimeException("Something went wrong when loading all operator having users.", backendException);
+        }
+    }
+
+    /**
+     * Retrieves the local user save ID. This is typically used for persisting user data in the {@link Context#LOCAL}.
+     *
+     * @return saved ID of the local user.
+     */
+    private @NotNull String getLocalUserSaveID() {
+        return Bukkit.getKissen().getImplementation(KissenPaperUserImplementation.class).getUserSaveID(Context.LOCAL);
+    }
+
+    /**
+     * Retrieves implementation of {@link KissenPaperUserImplementation} for {@link Context#LOCAL} and gets User Metadata.
+     *
+     * @return object meta of the local user.
+     */
+    private @NotNull ObjectMeta getLocalUserMeta() {
+        return Bukkit.getKissen().getImplementation(KissenPaperUserImplementation.class).getUserMeta(Context.LOCAL);
+    }
+
+    /**
+     * Retrieves the set of LinkedOperatorDataNodes.
+     * <p>
+     * This method returns a set that contains all the LinkedOperatorDataNodes
+     * that are currently being managed.
+     *
+     * @return A Set containing all LinkedOperatorDataNodes.
+     * This returned set is not null.
+     */
+    protected @NotNull Set<LinkedOperatorDataNode> getLinkedOperatorDataNodes() {
+        return linkedOperatorDataNodes;
+    }
+
+    /**
+     * This is a record class that encapsulates a GameProfile and a KissenOperatorDataNode
+     * into a single entity, termed as a LinkedOperatorDataNode.
+     * <p>
+     * It provides a method `getServerOpListEntry()`, that utilizes `getServerOpListEntry`
+     * method from `kissenOperatorDataNode` and passes the `gameProfile` from this record.
+     * Resulting a ServerOpListEntry correlating user profile and operator data.
+     * <p>
+     * GameProfile part of this record is user's profile information & KissenOperatorDataNode is operator data.
+     * <p>
+     * The data items stored in a LinkedOperatorDataNode record can be accessed
+     * directly by name.
+     */
+    protected record LinkedOperatorDataNode(@NotNull GameProfile gameProfile,
+                                          @NotNull KissenOperatorDataNode kissenOperatorDataNode) {
+        /**
+         * Returns ServerOpListEntry that associates with this LinkedOperatorDataNode's operator data and game profile.
+         * The ServerOpListEntry is obtained by calling `getServerOpListEntry` method on `kissenOperatorDataNode`
+         * with `gameProfile` passed as parameter.
+         * <p>
+         * The method is expected to return a new ServerOpListEntry for every call.
+         *
+         * @return ServerOpListEntry constructed from gameProfile and kissenOperatorDataNode
+         */
+        @Contract(" -> new")
+        private @NotNull ServerOpListEntry getServerOpListEntry() {
+            return kissenOperatorDataNode.getServerOpListEntry(gameProfile);
+        }
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenUserWhiteList.java b/src/main/java/net/kissenpvp/paper/user/KissenUserWhiteList.java
new file mode 100644
index 0000000000000000000000000000000000000000..70f34a75978203c8af045f79ba7eecc7a484fdaa
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/KissenUserWhiteList.java
@@ -0,0 +1,186 @@
+package net.kissenpvp.paper.user;
+
+import com.google.gson.JsonObject;
+import com.mojang.authlib.GameProfile;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.database.meta.ObjectMeta;
+import net.kissenpvp.core.api.database.queryapi.Column;
+import net.kissenpvp.core.api.database.queryapi.FilterType;
+import net.kissenpvp.core.api.database.queryapi.QuerySelect;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.api.user.UserInfo;
+import net.kissenpvp.core.user.UserInfoNode;
+import net.kissenpvp.paper.api.base.Context;
+import net.minecraft.server.players.StoredUserEntry;
+import net.minecraft.server.players.UserWhiteList;
+import net.minecraft.server.players.UserWhiteListEntry;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Objects;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.Executors;
+import java.util.function.Function;
+import java.util.function.Predicate;
+import java.util.function.Supplier;
+import java.util.stream.Collectors;
+
+
+public class KissenUserWhiteList extends UserWhiteList {
+
+    private final Set<UserInfo> whitelisted;
+
+    public KissenUserWhiteList() {
+        //noinspection DataFlowIssue
+        super(null); // not file based
+        this.whitelisted = new HashSet<>();
+    }
+
+    @Override
+    public @NotNull File getFile() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Nullable
+    @Override
+    public UserWhiteListEntry get(@NotNull GameProfile key) {
+        return getWhitelisted().stream().filter(userInfo -> userInfo.getUUID().equals(key.getId())).map(user -> new UserWhiteListEntry(new GameProfile(user.getUUID(), user.getName()))).findFirst().orElse(null);
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return getWhitelisted().isEmpty();
+    }
+
+    @Override
+    protected boolean contains(@NotNull GameProfile k0) {
+        return getWhitelisted().stream().anyMatch(userInfo -> userInfo.getUUID().equals(k0.getId()));
+    }
+
+    @Override
+    public @NotNull Collection<UserWhiteListEntry> getEntries() {
+        return getWhitelisted().stream().map(userInfo -> new GameProfile(userInfo.getUUID(), userInfo.getName())).map(UserWhiteListEntry::new).collect(Collectors.toSet());
+    }
+
+    @Override
+    public String @NotNull [] getUserList() {
+        return getWhitelisted().stream().map(UserInfo::getName).distinct().toArray(String[]::new);
+    }
+
+    @Override
+    public void add(@NotNull UserWhiteListEntry entry) {
+        if (!new io.papermc.paper.event.server.WhitelistStateUpdateEvent(com.destroystokyo.paper.profile.CraftPlayerProfile.asBukkitCopy(Objects.requireNonNull(entry.getUser())), io.papermc.paper.event.server.WhitelistStateUpdateEvent.WhitelistStatus.ADDED).callEvent()) {
+            return;
+        }
+        UserImplementation userImplementation = Bukkit.getKissen().getImplementation(UserImplementation.class);
+
+        Supplier<UserInfo> createNew = () -> new UserInfoNode(entry.getUser().getId(), entry.getUser().getName()).getUserInfo();
+        Predicate<UserInfo> userInfoPredicate = profile -> Objects.equals(entry.getUser().getId(), profile.getUUID());
+
+        getWhitelisted().removeIf(userInfo -> userInfo.getUUID().equals(entry.getUser().getId()));
+        getWhitelisted().add(userImplementation.getUserProfiles().stream().filter(userInfoPredicate).findFirst().orElseGet(createNew));
+
+        Executors.newSingleThreadExecutor().submit(() -> {
+            try {
+                getLocalUserMeta().setString(getLocalUserSaveID() + Objects.requireNonNull(entry.getUser()).getId(), "whitelist", "1");
+            } catch (BackendException backendException) {
+                throw new RuntimeException(String.format("An error occurred when adding user %s to the whitelist.", entry.getUser().getName()), backendException);
+            }
+        });
+    }
+
+    @Override
+    public void remove(@NotNull GameProfile profile) {
+
+        if (!new io.papermc.paper.event.server.WhitelistStateUpdateEvent(com.destroystokyo.paper.profile.CraftPlayerProfile.asBukkitCopy(profile), io.papermc.paper.event.server.WhitelistStateUpdateEvent.WhitelistStatus.REMOVED).callEvent()) {
+            return;
+        }
+
+        getWhitelisted().removeIf(userInfo -> Objects.equals(profile.getId(), userInfo.getUUID()));
+
+        Executors.newSingleThreadExecutor().submit(() -> {
+            try {
+                getLocalUserMeta().delete(getLocalUserSaveID() + profile.getId(), "whitelist");
+            } catch (BackendException backendException) {
+                throw new RuntimeException(String.format("An error occurred when deleting the whitelist value from user %s.", profile.getName()), backendException);
+            }
+        });
+    }
+
+    @Override
+    public void save() throws IOException {
+        // ignored
+    }
+
+    @Override
+    public void load() throws IOException {
+        getWhitelisted().clear();
+        getWhitelisted().addAll(fetchWhitelistedUsers());
+    }
+
+    @Override
+    public void remove(@NotNull StoredUserEntry<GameProfile> entry) {
+        remove(Objects.requireNonNull(entry.getUser()));
+    }
+
+    @Override
+    protected @NotNull StoredUserEntry<GameProfile> createEntry(@NotNull JsonObject json) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    protected @NotNull String getKeyForUser(@NotNull GameProfile gameProfile) {
+        throw new UnsupportedOperationException();
+    }
+
+    protected @NotNull Set<UserInfo> getWhitelisted() {
+        return whitelisted;
+    }
+
+    /**
+     * Fetches all whitelisted users from the database.
+     * Each user is identified by their UUID.
+     * If a backend exception is thrown while fetching, it is encapsulated in a RuntimeException.
+     *
+     * @return A set of whitelisted {@link UserInfo} objects. The returned value is unmodifiable to prevent any unwanted modifications.
+     * @throws RuntimeException if there's a backend issue when fetching users
+     */
+    private @NotNull @Unmodifiable Set<UserInfo> fetchWhitelistedUsers() {
+        try {
+            QuerySelect querySelect = getLocalUserMeta().select(Column.TOTAL_ID).appendFilter(Column.KEY, "whitelist", FilterType.EQUALS).appendFilter(Column.VALUE, "1", FilterType.EQUALS);
+
+            Function<UUID, UserInfo> fetchUserProfile = uuid -> Bukkit.getKissen().getImplementation(UserImplementation.class).getCachedUserProfile(uuid).orElse(null);
+            Function<String[], UserInfo> parse = (userData) -> fetchUserProfile.apply(UUID.fromString(userData[0].substring(getLocalUserSaveID().length())));
+
+            return Arrays.stream(querySelect.execute()).map(parse).filter(Objects::nonNull).collect(Collectors.toSet());
+        } catch (BackendException backendException) {
+            throw new RuntimeException("Something went wrong when fetching all whitelisted users from the database.", backendException);
+        }
+    }
+
+    /**
+     * Retrieves implementation of {@link KissenPaperUserImplementation} for {@link Context#LOCAL} and gets User Metadata.
+     *
+     * @return object meta of the local user.
+     */
+    private @NotNull ObjectMeta getLocalUserMeta() {
+        return Bukkit.getKissen().getImplementation(KissenPaperUserImplementation.class).getUserMeta(Context.LOCAL);
+    }
+
+    /**
+     * Retrieves the local user save ID. This is typically used for persisting user data in the {@link Context#LOCAL}.
+     *
+     * @return saved ID of the local user.
+     */
+    private @NotNull String getLocalUserSaveID() {
+        return Bukkit.getKissen().getImplementation(KissenPaperUserImplementation.class).getUserSaveID(Context.LOCAL);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperFallBackRank.java b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperFallBackRank.java
new file mode 100644
index 0000000000000000000000000000000000000000..aff8832d798ef05cb627b1414d9ba04dc8eb4c3b
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperFallBackRank.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.user.rank;
+
+import net.kissenpvp.core.user.rank.KissenFallBackRank;
+import net.kissenpvp.paper.api.networking.client.entity.PaperPlayerClient;
+import net.kissenpvp.paper.api.user.rank.PaperRank;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Optional;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+public class KissenPaperFallBackRank extends KissenFallBackRank implements PaperRank {
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPlayerClient> getPlayers() {
+        return Bukkit.getOnlinePlayers().stream().filter(playerClient ->
+        {
+            Optional<PaperRank> paperRankOptional = playerClient.getRank().getSource();
+            return paperRankOptional.isPresent() && paperRankOptional.get().equals(this);
+        }).collect(Collectors.toUnmodifiableSet());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperPlayerFallBackRank.java b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperPlayerFallBackRank.java
new file mode 100644
index 0000000000000000000000000000000000000000..964ee85ac174bf0badf6bb3444be4879cd0efdbf
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperPlayerFallBackRank.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.user.rank;
+
+import net.kissenpvp.core.user.rank.KissenPlayerFallBackRank;
+import net.kissenpvp.paper.api.user.rank.PaperPlayerRank;
+import net.kissenpvp.paper.api.user.rank.PaperRank;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Optional;
+
+public class KissenPaperPlayerFallBackRank extends KissenPlayerFallBackRank<PaperRank> implements PaperPlayerRank
+{
+    @Override public @NotNull Optional<PaperRank> getSource()
+    {
+        return Optional.of(new KissenPaperFallBackRank());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperPlayerRank.java b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperPlayerRank.java
new file mode 100644
index 0000000000000000000000000000000000000000..854aae7c2516fc405c2a1bebe205904db3cd6708
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperPlayerRank.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.user.rank;
+
+import net.kissenpvp.core.database.DataWriter;
+import net.kissenpvp.core.user.rank.KissenPlayerRank;
+import net.kissenpvp.core.user.rank.KissenPlayerRankNode;
+import net.kissenpvp.paper.api.user.rank.PaperPlayerRank;
+import net.kissenpvp.paper.api.user.rank.PaperRank;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class KissenPaperPlayerRank extends KissenPlayerRank<PaperRank> implements PaperPlayerRank {
+    public KissenPaperPlayerRank(@NotNull KissenPlayerRankNode kissenPlayerRankNode, @Nullable DataWriter dataWriter) {
+        super(kissenPlayerRankNode, dataWriter);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperRank.java b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperRank.java
new file mode 100644
index 0000000000000000000000000000000000000000..c6e107e7bc79c4f66c23f423452ac974105d9713
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperRank.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.user.rank;
+
+import net.kissenpvp.core.api.networking.socket.DataPackage;
+import net.kissenpvp.core.api.user.rank.Rank;
+import net.kissenpvp.core.user.rank.KissenRank;
+import org.jetbrains.annotations.NotNull;
+
+public class KissenPaperRank extends KissenRank implements Rank {
+    @Override
+    public void sendData(@NotNull DataPackage dataPackage) {
+        //TODO async network and so on
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Main.java b/src/main/java/net/minecraft/server/Main.java
index ec268189b19b6fa5c4521f96ce211a531db35ec5..da0cb15bbf8cd561a008344ae8ddd466de6defe8 100644
--- a/src/main/java/net/minecraft/server/Main.java
+++ b/src/main/java/net/minecraft/server/Main.java
@@ -193,15 +193,17 @@ public class Main {
             org.spigotmc.SpigotConfig.disabledAdvancements = spigotConfiguration.getStringList("advancements.disabled"); // Paper - fix SPIGOT-5885, must be set early in init
             // Paper start - fix SPIGOT-5824
             File file;
-            File userCacheFile = new File(Services.USERID_CACHE_FILE);
+            /* KissenPaper - remove cache file
+             * File userCacheFile = new File(Services.USERID_CACHE_FILE);
+             */
             if (optionset.has("universe")) {
                 file = (File) optionset.valueOf("universe"); // CraftBukkit
-                userCacheFile = new File(file, Services.USERID_CACHE_FILE);
+                //userCacheFile = new File(file, Services.USERID_CACHE_FILE); // KissenPaper
             } else {
                 file = new File(bukkitConfiguration.getString("settings.world-container", "."));
             }
             // Paper end - fix SPIGOT-5824
-            Services services = Services.create(new com.destroystokyo.paper.profile.PaperAuthenticationService(Proxy.NO_PROXY), file, userCacheFile, optionset); // Paper
+            Services services = Services.create(new com.destroystokyo.paper.profile.PaperAuthenticationService(Proxy.NO_PROXY), file/*, userCacheFile KissenPaper - remove cache file*/, optionset); // Paper
             // CraftBukkit start
             String s = (String) Optional.ofNullable((String) optionset.valueOf("world")).orElse(dedicatedserversettings.getProperties().levelName);
             LevelStorageSource convertable = LevelStorageSource.createDefault(file.toPath());
diff --git a/src/main/java/net/minecraft/server/Services.java b/src/main/java/net/minecraft/server/Services.java
index a9b2c8cd4dcd3f884e4306bebee9334d3848fce5..c3510492a900bcf2782fa6af332223803922e4bf 100644
--- a/src/main/java/net/minecraft/server/Services.java
+++ b/src/main/java/net/minecraft/server/Services.java
@@ -24,10 +24,10 @@ public record Services(MinecraftSessionService sessionService, ServicesKeySet se
     // Paper end
     public static final String USERID_CACHE_FILE = "usercache.json"; // Paper - private -> public
 
-    public static Services create(YggdrasilAuthenticationService authenticationService, File rootDirectory, File userCacheFile, joptsimple.OptionSet optionSet) throws Exception { // Paper
+    public static Services create(YggdrasilAuthenticationService authenticationService, File rootDirectory /*, File userCacheFile KissenPaper - remove file*/, joptsimple.OptionSet optionSet) throws Exception { // Paper
         MinecraftSessionService minecraftSessionService = authenticationService.createMinecraftSessionService();
         GameProfileRepository gameProfileRepository = authenticationService.createProfileRepository();
-        GameProfileCache gameProfileCache = new GameProfileCache(gameProfileRepository, userCacheFile); // Paper
+        GameProfileCache gameProfileCache = /*new GameProfileCache(gameProfileRepository, userCacheFile); // Paper*/ new net.kissenpvp.paper.user.KissenPaperProfileCache(gameProfileRepository); // KissenPaper
         // Paper start
         final java.nio.file.Path legacyConfigPath = ((File) optionSet.valueOf("paper-settings")).toPath();
         final java.nio.file.Path configDirPath = ((File) optionSet.valueOf("paper-settings-directory")).toPath();
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedPlayerList.java b/src/main/java/net/minecraft/server/dedicated/DedicatedPlayerList.java
index 935dac757280731bfeb0a8f033cbe315ecac46da..932c83a9d41ddff73d38e87ac7d97fadf5c5b8c2 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedPlayerList.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedPlayerList.java
@@ -30,7 +30,7 @@ public class DedicatedPlayerList extends PlayerList {
         this.loadOps();
         this.loadWhiteList();
         this.saveOps();
-        if (!this.getWhiteList().getFile().exists()) {
+        if (/*!this.getWhiteList().getFile().exists()*/ true) { // KissenPaper
             this.saveWhiteList();
         }
 
diff --git a/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
index ff2dd53e9e943aa929188fd9d4c35498b78c497a..454cee69c217106b840dc5c0019f8f7f80ca3782 100644
--- a/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
@@ -44,6 +44,13 @@ import org.bukkit.event.player.AsyncPlayerPreLoginEvent;
 import org.bukkit.event.player.PlayerPreLoginEvent;
 // CraftBukkit end
 
+// KissenPaper start
+import org.bukkit.Bukkit;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.user.KissenUserImplementation;
+import net.kissenpvp.paper.user.KissenPaperPublicUser;
+// KissenPaper end
+
 public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener, TickablePacketListener {
 
     private static final AtomicInteger UNIQUE_THREAD_ID = new AtomicInteger(0);
@@ -335,6 +342,11 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener,
                             disconnect("This server requires you to connect with Velocity.");
                             return;
                         }
+
+                        // KissenPaper start
+                        if (!loginUser(gameprofile)) return;
+                        // KissenPaper end
+
                         // Paper end
                         String playerName = gameprofile.getName();
                         java.net.InetAddress address = ((java.net.InetSocketAddress) ServerLoginPacketListenerImpl.this.connection.getRemoteAddress()).getAddress();
@@ -380,6 +392,44 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener,
                         ServerLoginPacketListenerImpl.LOGGER.info("UUID of player {} is {}", gameprofile.getName(), gameprofile.getId());
                         ServerLoginPacketListenerImpl.this.startClientVerification(gameprofile);
         }
+
+        // KissenPaper start
+        /**
+         * Attempts to log in a user represented by a GameProfile object. This includes loading the KissenPaperPublicUser via a
+         * KissenUserImplementation, checking the user's ban status, and if not banned, loading the user's
+         * private data.
+         *
+         * <p>If the user cannot be loaded, or they have an outstanding punishment, the method
+         * will disconnect them with an appropriate message and return false. If an exception occurs in the process,
+         * the user is also disconnected and false is returned. If the user is loaded successfully and has no
+         * outstanding punishments, true is returned.</p>
+         *
+         * @param gameProfile The GameProfile of the user attempting to log in. This parameter must not be null.
+         * @return true if the user was successfully logged in, false otherwise.
+         * @throws NullPointerException If gameProfile is null.
+         *
+         * @see KissenPaperPublicUser
+         * @see net.kissenpvp.paper.api.ban.PaperBanImplementation
+         * @see net.kissenpvp.paper.api.ban.PaperPunishment
+         * @see GameProfile
+         */
+        private boolean loginUser(GameProfile gameProfile) {
+            try {
+                KissenPaperPublicUser kissenPaperPublicUser = new KissenPaperPublicUser(gameProfile.getId(), gameProfile.getName());
+                if(!Bukkit.getKissen().getImplementation(KissenUserImplementation.class).loadUser(kissenPaperPublicUser))
+                {
+                    disconnect(Component.translatable("multiplayer.disconnect.unverified_username"));
+                    return false;
+                }
+
+                kissenPaperPublicUser.getPrivateUserEntry(); // load private user
+            } catch (BackendException backendException) {
+                disconnect(Component.translatable("multiplayer.disconnect.unverified_username")); // maybe better message
+                return false;
+            }
+            return true;
+        }
+        // KissenPaper end
     }
     // Spigot end
 
diff --git a/src/main/java/net/minecraft/server/players/GameProfileCache.java b/src/main/java/net/minecraft/server/players/GameProfileCache.java
index f4d903ed4342c3100c30deda291dfd6dd4e1ef40..b04ba26f9e04e31c5d4ba73436bf3492b62be9e6 100644
--- a/src/main/java/net/minecraft/server/players/GameProfileCache.java
+++ b/src/main/java/net/minecraft/server/players/GameProfileCache.java
@@ -228,7 +228,7 @@ public class GameProfileCache {
         return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z", Locale.ROOT);
     }
 
-    public List<GameProfileCache.GameProfileInfo> load() {
+    protected List<GameProfileCache.GameProfileInfo> load() { // KissenPaper - private -> protected
         ArrayList arraylist = Lists.newArrayList();
 
         try {
@@ -399,7 +399,7 @@ public class GameProfileCache {
         }
     }
 
-    private static class GameProfileInfo {
+    protected static class GameProfileInfo { // KissenPaper - private -> protected
 
         private final GameProfile profile;
         final Date expirationDate;
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 48d1444fbad1c57738807d0128b94160a5a17a4d..75fcd48b691e7a7879baaa7791ecef8c42e48f97 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -167,8 +167,8 @@ public abstract class PlayerList {
 
         this.bans = new UserBanList(PlayerList.USERBANLIST_FILE);
         this.ipBans = new IpBanList(PlayerList.IPBANLIST_FILE);
-        this.ops = new ServerOpList(PlayerList.OPLIST_FILE);
-        this.whitelist = new UserWhiteList(PlayerList.WHITELIST_FILE);
+        this.ops = /*new ServerOpList(PlayerList.OPLIST_FILE);*/ new net.kissenpvp.paper.user.KissenUserOperatorList(); // KissenPaper
+        this.whitelist = /*new UserWhiteList(PlayerList.WHITELIST_FILE);*/ new net.kissenpvp.paper.user.KissenUserWhiteList(); // KissenPaper
         // CraftBukkit start
         // this.stats = Maps.newHashMap();
         // this.advancements = Maps.newHashMap();
@@ -321,6 +321,13 @@ public abstract class PlayerList {
         // Ensure that player inventory is populated with its viewer
         player.containerMenu.transferTo(player.containerMenu, bukkitPlayer);
 
+        // KissenPaper start
+        if(!org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.core.user.KissenUserImplementation.class).loginUser(bukkitPlayer.getUser()))
+        {
+            //TODO disconnect player
+        }
+        // KissenPaper end
+
         PlayerJoinEvent playerJoinEvent = new PlayerJoinEvent(bukkitPlayer, io.papermc.paper.adventure.PaperAdventure.asAdventure(ichatmutablecomponent)); // Paper - Adventure
         this.cserver.getPluginManager().callEvent(playerJoinEvent);
 
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java b/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java
index 03fc90a470c0f63d44161843cac88bea09166858..79543c80a8a5f781924963ceadacd99a2229392f 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java
@@ -9,6 +9,8 @@ import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.UUID;
+
+import net.kissenpvp.core.api.networking.client.entitiy.ServerEntity;
 import net.minecraft.core.GlobalPos;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.NbtOps;
@@ -34,6 +36,43 @@ import org.bukkit.metadata.MetadataValue;
 import org.bukkit.plugin.Plugin;
 import org.bukkit.profile.PlayerProfile;
 
+// KissenPaper start
+import org.bukkit.permissions.Permission;
+import org.bukkit.permissions.Permissible;
+import org.bukkit.permissions.PermissionAttachment;
+import org.bukkit.permissions.PermissionAttachmentInfo;
+
+import java.util.Optional;
+import java.util.Set;
+import java.util.Locale;
+
+import net.kissenpvp.core.api.ban.Ban;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.message.Theme;
+import net.kissenpvp.core.api.permission.PermissionGroup;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.api.user.rank.Rank;
+import net.kissenpvp.core.api.user.suffix.Suffix;
+import net.kissenpvp.core.api.user.usersetttings.PlayerSetting;
+import net.kissenpvp.core.api.user.usersetttings.UserSetting;
+import net.kissenpvp.paper.api.ban.PaperPunishment;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.networking.client.entity.PaperOnlinePlayerClient;
+import net.kissenpvp.paper.api.permission.PaperPermissible;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PermissibleOverriddenException;
+import net.kissenpvp.paper.api.user.rank.PaperPlayerRank;
+import net.kissenpvp.paper.networking.client.entity.KissenPaperPlayerClient;
+import net.kissenpvp.paper.permission.permissible.KissenPaperPlayerPermissible;
+import net.kyori.adventure.text.Component;
+import net.kissenpvp.core.api.time.AccurateDuration;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+// KissenPaper end
+
 @SerializableAs("Player")
 public class CraftOfflinePlayer implements OfflinePlayer, ConfigurationSerializable {
     private static final org.slf4j.Logger LOGGER = com.mojang.logging.LogUtils.getLogger(); // Paper
@@ -41,6 +80,14 @@ public class CraftOfflinePlayer implements OfflinePlayer, ConfigurationSerializa
     private final CraftServer server;
     private final PlayerDataStorage storage;
 
+    // KissenPaper start
+    private final Permissible permissible = new KissenPaperPlayerPermissible(this) {
+        @Override public void permissionUpdate() { /* ignored */ }
+        @Override public void unsubscribe() { /* ignored */ }
+    };
+    private KissenPaperPlayerClient kissenPaperPlayerClient;
+    // KissenPaper end
+
     protected CraftOfflinePlayer(CraftServer server, GameProfile profile) {
         this.server = server;
         this.profile = profile;
@@ -567,4 +614,387 @@ public class CraftOfflinePlayer implements OfflinePlayer, ConfigurationSerializa
             manager.save();
         }
     }
+
+    // KissenPaper start - integrate kissen user
+
+    private @NotNull KissenPaperPlayerClient getKissenPaperPlayerClient()
+    {
+        if(kissenPaperPlayerClient == null) {
+            kissenPaperPlayerClient = new KissenPaperPlayerClient() {
+
+                private User cachedUser;
+
+                @Override
+                public @NotNull User getUser() {
+                    return Optional.ofNullable(cachedUser).orElseGet(() ->
+                    {
+                        cachedUser = super.getUser();
+                        return cachedUser;
+                    });
+                }
+
+                @Override
+                public @NotNull PaperPermissible getPermissible() throws PermissibleOverriddenException {
+                    return (PaperPermissible) permissible;
+                }
+
+                @Override
+                public @NotNull UUID getUniqueId() {
+                    return CraftOfflinePlayer.this.getUniqueId();
+                }
+
+                @Override
+                public boolean isConnected() {
+                    return false;
+                }
+            };
+        }
+        return kissenPaperPlayerClient;
+    }
+
+    @Override
+    public final boolean isClient() {
+        return true;
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAltAccounts() throws BackendException {
+        return getKissenPaperPlayerClient().getAltAccounts();
+    }
+
+    @Override
+    public @NotNull UUID getTotalID() {
+        return getKissenPaperPlayerClient().getTotalID();
+    }
+
+    @Override
+    public @NotNull PaperPunishment punish(@NotNull Ban ban, @NotNull ServerEntity banOperator) throws BackendException {
+        return getKissenPaperPlayerClient().punish(ban, banOperator);
+    }
+
+    @Override
+    public @NotNull PaperPunishment punish(@NotNull Ban ban, @NotNull ServerEntity banOperator, @Nullable Component reason) throws BackendException {
+        return getKissenPaperPlayerClient().punish(ban, banOperator, reason);
+    }
+
+    @Override
+    public @NotNull Optional<PaperPunishment> getBan(@NotNull String id) throws BackendException {
+        return getKissenPaperPlayerClient().getBan(id);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<PaperPunishment> getBanHistory() throws BackendException {
+        return getKissenPaperPlayerClient().getBanHistory();
+    }
+
+    @Override
+    public @NotNull Component displayName() {
+        return getKissenPaperPlayerClient().displayName();
+    }
+
+    @Override
+    public @NotNull Component styledRankName() {
+        return getKissenPaperPlayerClient().styledRankName();
+    }
+
+    @Override
+    public @NotNull Set<Suffix> getSuffixSet() {
+        return getKissenPaperPlayerClient().getSuffixSet();
+    }
+
+    @Override
+    public @NotNull Optional<Suffix> getSuffix(@NotNull String name) {
+        return getKissenPaperPlayerClient().getSuffix(name);
+    }
+
+    @Override
+    public @NotNull Optional<Suffix> setSuffix(@NotNull String name, @NotNull Component content) {
+        return getKissenPaperPlayerClient().setSuffix(name, content);
+    }
+
+    @Override
+    public boolean deleteSuffix(@NotNull String name) {
+        return getKissenPaperPlayerClient().deleteSuffix(name);
+    }
+
+    @Override
+    public @NotNull Optional<Suffix> getSelectedSuffix() {
+        return getKissenPaperPlayerClient().getSelectedSuffix();
+    }
+
+    @Override
+    public void setSelectedSuffix(@NotNull String name) throws NullPointerException {
+        getKissenPaperPlayerClient().setSelectedSuffix(name);
+    }
+
+    @Override
+    public long getOnlineTime() {
+        return getKissenPaperPlayerClient().getOnlineTime();
+    }
+
+    @Override
+    public @NotNull User getUser() {
+        return getKissenPaperPlayerClient().getUser();
+    }
+
+    @Override
+    public @NotNull <X> UserSetting<X> getUserSetting(Class<? extends PlayerSetting<X>> settingClass) {
+        return getKissenPaperPlayerClient().getUserSetting(settingClass);
+    }
+
+    @Override
+    public @NotNull Theme getTheme() {
+        return getKissenPaperPlayerClient().getTheme();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<PaperPlayerRank> getRankHistory() {
+        return getKissenPaperPlayerClient().getRankHistory();
+    }
+
+    @Override
+    public @NotNull PaperPlayerRank getRank() {
+        return getKissenPaperPlayerClient().getRank();
+    }
+
+    @Override
+    public @NotNull PaperPlayerRank grantRank(@NotNull Rank rank) {
+        return getKissenPaperPlayerClient().grantRank(rank);
+    }
+
+    @Override
+    public @NotNull PaperPlayerRank grantRank(@NotNull Rank rank, @Nullable AccurateDuration accurateDuration) {
+        return getKissenPaperPlayerClient().grantRank(rank, accurateDuration);
+    }
+
+    @Override
+    public @NotNull Locale getCurrentLocale() {
+        return getKissenPaperPlayerClient().getCurrentLocale();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<@NotNull PaperOnlinePlayerClient> getOnlineAltAccounts() {
+        return getKissenPaperPlayerClient().getOnlineAltAccounts();
+    }
+
+    @Override
+    public @NotNull Set<Suffix> getSuffixSet(@NotNull Context context) {
+        return getKissenPaperPlayerClient().getSuffixSet(context);
+    }
+
+    @Override
+    public @NotNull Optional<Suffix> getSuffix(@NotNull String name, @NotNull Context context) {
+        return getKissenPaperPlayerClient().getSuffix(name, context);
+    }
+
+    @Override
+    public @NotNull Optional<Suffix> setSuffix(@NotNull String name, @NotNull Component content, @NotNull Context context) {
+        return getKissenPaperPlayerClient().setSuffix(name, content, context);
+    }
+
+    @Override
+    public boolean deleteSuffix(@NotNull String name, @NotNull Context context) {
+        return getKissenPaperPlayerClient().deleteSuffix(name, context);
+    }
+
+    @Override
+    public void setSelectedSuffix(@NotNull String name, @NotNull Context context) throws NullPointerException {
+        getKissenPaperPlayerClient().setSelectedSuffix(name, context);
+    }
+
+    @Override
+    public long getOnlineTime(@NotNull Context context) {
+        return getKissenPaperPlayerClient().getOnlineTime(context);
+    }
+
+    @Override
+    public long getLastPlayed(@NotNull Context context) {
+        return getKissenPaperPlayerClient().getLastPlayed(context);
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull Context context) {
+        return getKissenPaperPlayerClient().getUser(context);
+    }
+
+    @Override
+    public @NotNull PaperPermissible getPermissible() throws PermissibleOverriddenException {
+        return getKissenPaperPlayerClient().getPermissible();
+    }
+
+    @Override
+    public boolean isPermissionSet(@NotNull String name) {
+        return getKissenPaperPlayerClient().isPermissionSet(name);
+    }
+
+    @Override
+    public boolean isPermissionSet(@NotNull Permission perm) {
+        return getKissenPaperPlayerClient().isPermissionSet(perm);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String name) {
+        return getKissenPaperPlayerClient().hasPermission(name);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull Permission perm) {
+        return getKissenPaperPlayerClient().hasPermission(perm);
+    }
+
+    @Override
+    public @NotNull PermissionAttachment addAttachment(@NotNull Plugin plugin, @NotNull String name, boolean value) {
+        return getKissenPaperPlayerClient().addAttachment(plugin, name, value);
+    }
+
+    @Override
+    public @NotNull PermissionAttachment addAttachment(@NotNull Plugin plugin) {
+        return getKissenPaperPlayerClient().addAttachment(plugin);
+    }
+
+    @Override
+    public @Nullable PermissionAttachment addAttachment(@NotNull Plugin plugin, @NotNull String name, boolean value, int ticks) {
+        return getKissenPaperPlayerClient().addAttachment(plugin, name, value, ticks);
+    }
+
+    @Override
+    public @Nullable PermissionAttachment addAttachment(@NotNull Plugin plugin, int ticks) {
+        return getKissenPaperPlayerClient().addAttachment(plugin, ticks);
+    }
+
+    @Override
+    public void removeAttachment(@NotNull PermissionAttachment attachment) {
+        getKissenPaperPlayerClient().removeAttachment(attachment);
+    }
+
+    @Override
+    public void recalculatePermissions() {
+        getKissenPaperPlayerClient().recalculatePermissions();
+    }
+
+    @Override
+    public @NotNull Set<PermissionAttachmentInfo> getEffectivePermissions() {
+        return getKissenPaperPlayerClient().getEffectivePermissions();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getOwnPermissions() {
+        return getKissenPaperPlayerClient().getOwnPermissions();
+    }
+
+    @Override
+    public int wipeGroups() {
+        return getKissenPaperPlayerClient().wipeGroups();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups() {
+        return getKissenPaperPlayerClient().getPermissionGroups();
+    }
+
+    @Override
+    public boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup) {
+        return getKissenPaperPlayerClient().inGroup(permissionGroup);
+    }
+
+    @Override
+    public @NotNull String getPermissionID() {
+        return getKissenPaperPlayerClient().getPermissionID();
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission) throws EventCancelledException {
+        return getKissenPaperPlayerClient().setPermission(permission);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, boolean value) throws EventCancelledException {
+        return getKissenPaperPlayerClient().setPermission(permission, value);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull PaperPermission permission) throws EventCancelledException {
+        return getKissenPaperPlayerClient().setPermission(permission);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission) {
+        return getKissenPaperPlayerClient().unsetPermission(permission);
+    }
+
+    @Override
+    public int wipePermissions() {
+        return getKissenPaperPlayerClient().wipePermissions();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList() {
+        return getKissenPaperPlayerClient().getPermissionList();
+    }
+
+    @Override
+    public @NotNull Optional<PaperPermission> getPermission(@NotNull String permission) {
+        return getKissenPaperPlayerClient().getPermission(permission);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAffectedPermissionPlayer() {
+        return getKissenPaperPlayerClient().getAffectedPermissionPlayer();
+    }
+
+    @Override
+    public void permissionUpdate() {
+        getKissenPaperPlayerClient().permissionUpdate();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getOwnPermissions(@NotNull Context context) {
+        return getKissenPaperPlayerClient().getOwnPermissions(context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups(@NotNull Context context) {
+        return getKissenPaperPlayerClient().getPermissionGroups(context);
+    }
+
+    @Override
+    public boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup, @NotNull Context context) {
+        return getKissenPaperPlayerClient().inGroup(permissionGroup, context);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, @NotNull Context context) throws EventCancelledException {
+        return getKissenPaperPlayerClient().setPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, boolean value, @NotNull Context context) throws EventCancelledException {
+        return getKissenPaperPlayerClient().setPermission(permission, value, context);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull PaperPermission permission, @NotNull Context context) throws EventCancelledException {
+        return getKissenPaperPlayerClient().setPermission(permission, context);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission, @NotNull Context context) {
+        return getKissenPaperPlayerClient().unsetPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList(@NotNull Context context) {
+        return getKissenPaperPlayerClient().getPermissionList(context);
+    }
+
+    @Override
+    public @NotNull Optional<PaperPermission> getPermission(@NotNull String permission, @NotNull Context context) {
+        return getKissenPaperPlayerClient().getPermission(permission, context);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String permission, @NotNull Context context) {
+        return getKissenPaperPlayerClient().hasPermission(permission, context);
+    }
+    // KissenPaper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java b/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java
index 4e56018b64d11f76c8da43fd8f85c6de72204e36..ddee5b265dae0dc986d7d51ffb1989387ea6a5f6 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java
@@ -104,4 +104,16 @@ public class CraftConsoleCommandSender extends ServerCommandSender implements Co
         return io.papermc.paper.configuration.GlobalConfiguration.get().console.hasAllPermissions || super.hasPermission(perm);
     }
     // Paper end
+
+    // KissenPaper start
+    @Override
+    public net.kissenpvp.core.api.message.@org.jetbrains.annotations.NotNull Theme getTheme() {
+        return org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.message.MessageImplementation.class).getDefaultTheme();
+    }
+
+    @Override
+    public net.kyori.adventure.audience.@org.jetbrains.annotations.NotNull Audience getKyoriAudience() {
+        return this;
+    }
+    // KissenPaper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/command/ProxiedNativeCommandSender.java b/src/main/java/org/bukkit/craftbukkit/command/ProxiedNativeCommandSender.java
index 3e7d14564f11a3ed0b0766444e9d681804597e9a..95eb776fe864240e0fd3c3a744082ec5c1405c05 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/ProxiedNativeCommandSender.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/ProxiedNativeCommandSender.java
@@ -146,4 +146,32 @@ public class ProxiedNativeCommandSender implements ProxiedCommandSender {
        return this.getCaller().spigot();
     }
     // Spigot end
+
+    // KissenPaper start
+    @org.jetbrains.annotations.NotNull
+    @Override
+    public net.kissenpvp.core.api.message.Theme getTheme() {
+        return org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.message.MessageImplementation.class).getDefaultTheme();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull java.util.Locale getCurrentLocale() {
+        return this.getCaller().getCurrentLocale();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull net.kyori.adventure.text.Component displayName() {
+        return this.getCaller().displayName();
+    }
+
+    @Override
+    public boolean isConnected() {
+        return this.getCaller().isConnected();
+    }
+
+    @Override
+    public boolean isClient() {
+        return this.getCaller().isClient();
+    }
+    // KissenPaper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/command/ServerCommandSender.java b/src/main/java/org/bukkit/craftbukkit/command/ServerCommandSender.java
index 1c638a4b1f2c841928d8b2a7ae43e4ebb1f7eac7..31c40acd927245ad59d111e178a61d5faad6b1ef 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/ServerCommandSender.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/ServerCommandSender.java
@@ -155,4 +155,27 @@ public abstract class ServerCommandSender implements CommandSender {
         return this.adventure$pointers;
     }
     // Paper end
+
+    // KissenPaper start
+    @org.jetbrains.annotations.NotNull
+    @Override
+    public net.kissenpvp.core.api.message.Theme getTheme() {
+        return Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.message.MessageImplementation.class).getDefaultTheme();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull java.util.Locale getCurrentLocale() {
+        return Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.message.localization.LocalizationImplementation.class).getDefaultLocale();
+    }
+
+    @Override
+    public final boolean isConnected() {
+        return true;
+    }
+
+    @Override
+    public final boolean isClient() {
+        return false;
+    }
+    // KissenPaper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index f7ebddd35ff5a60a81034fd7de035ebba83e9517..1441e648c1dfa3dd775c0b609a581eca84b74779 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -1527,4 +1527,27 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         return this.getHandle().getScoreboardName();
     }
     // Paper end - entity scoreboard name
+
+    // KissenPaper start
+    @org.jetbrains.annotations.NotNull
+    @Override
+    public net.kissenpvp.core.api.message.Theme getTheme() {
+        return org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.message.MessageImplementation.class).getDefaultTheme();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull java.util.Locale getCurrentLocale() {
+        return org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.message.localization.LocalizationImplementation.class).getDefaultLocale();
+    }
+
+    @Override
+    public boolean isConnected() {
+        return true;
+    }
+
+    @Override
+    public final boolean isClient() { // Kinda useless for this use case
+        return true;
+    }
+    // KissenPaper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
index 017e97c1618b8ee4640b36a0ec1b07026047bfc3..32787c6234ab6884b7ac0f62967ddc242630a918 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
@@ -71,7 +71,7 @@ import org.bukkit.plugin.Plugin;
 public class CraftHumanEntity extends CraftLivingEntity implements HumanEntity {
     private CraftInventoryPlayer inventory;
     private final CraftInventory enderChest;
-    protected final PermissibleBase perm = new PermissibleBase(this);
+    protected final /* PermissibleBase */ org.bukkit.permissions.Permissible perm = new net.kissenpvp.paper.permission.permissible.KissenPaperPlayerPermissible(this); // KissenPaper
     private boolean op;
     private GameMode mode;
 
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 604ed1f6742a6b028b9db2809f7bd4b9a3b38f4d..1972057382abda27d8349120711b0b0ee79cb642 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -6,37 +6,15 @@ import com.google.common.collect.ImmutableSet;
 import com.google.common.io.BaseEncoding;
 import com.mojang.authlib.GameProfile;
 import com.mojang.datafixers.util.Pair;
-import io.netty.buffer.Unpooled;
+import io.netty.channel.Channel;
 import it.unimi.dsi.fastutil.shorts.ShortArraySet;
 import it.unimi.dsi.fastutil.shorts.ShortSet;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.lang.ref.WeakReference;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.SocketAddress;
-import java.time.Duration;
-import java.time.Instant;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Optional;
-import java.util.Set;
-import java.util.UUID;
-import java.util.WeakHashMap;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import javax.annotation.Nullable;
+import net.kyori.adventure.audience.Audience;
+import net.md_5.bungee.api.chat.BaseComponent;
 import net.minecraft.advancements.AdvancementProgress;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Holder;
 import net.minecraft.core.SectionPos;
-import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.chat.Component;
@@ -138,7 +116,6 @@ import org.bukkit.craftbukkit.advancement.CraftAdvancement;
 import org.bukkit.craftbukkit.advancement.CraftAdvancementProgress;
 import org.bukkit.craftbukkit.block.CraftBlockEntityState;
 import org.bukkit.craftbukkit.block.CraftBlockState;
-import org.bukkit.craftbukkit.block.CraftBlockStates;
 import org.bukkit.craftbukkit.block.CraftSign;
 import org.bukkit.craftbukkit.block.data.CraftBlockData;
 import org.bukkit.craftbukkit.conversations.ConversationTracker;
@@ -146,7 +123,6 @@ import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.craftbukkit.map.CraftMapView;
 import org.bukkit.craftbukkit.map.RenderData;
-import org.bukkit.craftbukkit.profile.CraftPlayerProfile;
 import org.bukkit.craftbukkit.scoreboard.CraftScoreboard;
 import org.bukkit.craftbukkit.util.CraftChatMessage;
 import org.bukkit.craftbukkit.util.CraftLocation;
@@ -159,7 +135,6 @@ import org.bukkit.event.player.PlayerExpCooldownChangeEvent;
 import org.bukkit.event.player.PlayerHideEntityEvent;
 import org.bukkit.event.player.PlayerRegisterChannelEvent;
 import org.bukkit.event.player.PlayerShowEntityEvent;
-import org.bukkit.event.player.PlayerSpawnChangeEvent;
 import org.bukkit.event.player.PlayerTeleportEvent;
 import org.bukkit.event.player.PlayerUnregisterChannelEvent;
 import org.bukkit.inventory.EquipmentSlot;
@@ -168,13 +143,65 @@ import org.bukkit.inventory.ItemStack;
 import org.bukkit.map.MapCursor;
 import org.bukkit.map.MapView;
 import org.bukkit.metadata.MetadataValue;
+import org.bukkit.permissions.PermissibleBase;
 import org.bukkit.plugin.Plugin;
 import org.bukkit.plugin.messaging.StandardMessenger;
-import org.bukkit.profile.PlayerProfile;
 import org.bukkit.scoreboard.Scoreboard;
 import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
 
-import net.md_5.bungee.api.chat.BaseComponent; // Spigot
+import javax.annotation.Nullable;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.lang.ref.WeakReference;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+import java.time.Duration;
+import java.time.Instant;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Set;
+import java.util.UUID;
+import java.util.WeakHashMap;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+// KissenPaper start
+import net.kissenpvp.core.api.ban.Ban;
+import net.kissenpvp.core.api.base.KissenServer;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.message.Theme;
+import net.kissenpvp.core.api.networking.client.entitiy.ServerEntity;
+import net.kissenpvp.core.api.permission.PermissionGroup;
+import net.kissenpvp.core.api.time.AccurateDuration;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.api.user.rank.Rank;
+import net.kissenpvp.core.api.user.suffix.Suffix;
+import net.kissenpvp.core.api.user.usersetttings.PlayerSetting;
+import net.kissenpvp.core.api.user.usersetttings.UserSetting;
+import net.kissenpvp.core.user.KissenUserImplementation;
+import net.kissenpvp.paper.api.ban.PaperPunishment;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.networking.client.entity.PaperOnlinePlayerClient;
+import net.kissenpvp.paper.api.permission.PaperPermissible;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PermissibleOverriddenException;
+import net.kissenpvp.paper.api.user.rank.PaperPlayerRank;
+import net.kissenpvp.paper.networking.client.entity.KissenPaperOnlinePlayerClient;
+import net.kissenpvp.paper.permission.permissible.KissenPaperPermissible;
+import net.kissenpvp.paper.user.KissenPaperPublicUser;
+// KissenPaper stop
 
 @DelegateDeserialization(CraftOfflinePlayer.class)
 public class CraftPlayer extends CraftHumanEntity implements Player {
@@ -199,6 +226,10 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     private long lastSaveTime;
     // Paper end
 
+    // KissenPaper start
+    private KissenPaperOnlinePlayerClient kissenPaperPlayer;
+    // KissenPaper end
+
     public CraftPlayer(CraftServer server, ServerPlayer entity) {
         super(server, entity);
 
@@ -2422,7 +2453,19 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     public void disconnect(String reason) {
         this.conversationTracker.abandonAllConversations();
-        perm.clearPermissions();
+        // KissenPaper start
+        try {
+            ((KissenPaperPermissible) getPermissible()).unsubscribe();
+        } catch (PermissibleOverriddenException ignored) {
+            if (perm instanceof PermissibleBase permissibleBase) {
+                permissibleBase.clearPermissions();
+            }
+        }
+        if(!Bukkit.getKissen().getImplementation(KissenUserImplementation.class).logoutUser(getUser()))
+        {
+            Bukkit.getKissen().getLogger().warn("Player {} was on the server but was not recognized by the system.", getName());
+        }
+        // KissenPaper end
     }
 
     @Override
@@ -2768,7 +2811,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     // Paper start
     @Override
     public java.util.Locale locale() {
-        return getHandle().adventure$locale;
+        return /* getHandle().adventure$locale; */ getCurrentLocale(); // KissenPaper
     }
     // Paper end
     @Override
@@ -3283,4 +3326,362 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         return this.spigot;
     }
     // Spigot end
+
+    // KissenPaper start - integrate user methods provided by the kissen implementation
+
+    private @NotNull KissenPaperOnlinePlayerClient getKissenPaperOnlinePlayerClient() {
+        if (kissenPaperPlayer == null) {
+            kissenPaperPlayer = new KissenPaperOnlinePlayerClient() {
+                @Override
+                public @NotNull CraftPlayer getCraftPlayer() {
+                    return CraftPlayer.this;
+                }
+
+                @Override
+                public @NotNull PaperPermissible getPermissible() throws PermissibleOverriddenException {
+                    if (!(perm instanceof PaperPermissible permissible)) {
+                        throw new PermissibleOverriddenException();
+                    }
+                    return permissible;
+                }
+
+                @Override
+                public @NotNull UUID getUniqueId() {
+                    return CraftPlayer.this.getUniqueId();
+                }
+            };
+        }
+        return kissenPaperPlayer;
+    }
+
+    @Override
+    public @NotNull User getUser() {
+        return getUser(Context.GLOBAL);
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull Context context) {
+        KissenPaperPublicUser kissenPublicUser = (KissenPaperPublicUser) Bukkit.getKissen()
+                .getImplementation(UserImplementation.class)
+                .getOnlineUser(getUniqueId())
+                .orElseThrow(IllegalStateException::new);
+        return switch (context)
+        {
+            case GLOBAL -> kissenPublicUser;
+            case LOCAL -> kissenPublicUser.getPrivateUserEntry();
+        };
+    }
+
+    @Override
+    public @NotNull Channel getConnection() {
+        return getHandle().connection.connection.channel;
+    }
+
+    @Override
+    public void sendPacket(@NotNull Object object) throws ClassNotFoundException, ClassCastException {
+        getHandle().connection.send((Packet<?>) object);
+    }
+
+    @Override
+    public @NotNull Audience getKyoriAudience() {
+        return this;
+    }
+
+    @Override
+    public @NotNull Locale getCurrentLocale() {
+        return getKissenPaperOnlinePlayerClient().getCurrentLocale();
+    }
+
+    // -
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAltAccounts() throws BackendException {
+        return getKissenPaperOnlinePlayerClient().getAltAccounts();
+    }
+
+    @Override
+    public @NotNull UUID getTotalID() {
+        return getKissenPaperOnlinePlayerClient().getTotalID();
+    }
+
+    @Override
+    public @NotNull PaperPunishment punish(@NotNull Ban ban, @NotNull ServerEntity banOperator) throws BackendException {
+        return getKissenPaperOnlinePlayerClient().punish(ban, banOperator);
+    }
+
+    @Override
+    public @NotNull PaperPunishment punish(@NotNull Ban ban, @NotNull ServerEntity banOperator, net.kyori.adventure.text.@org.jetbrains.annotations.Nullable Component reason) throws BackendException {
+        return getKissenPaperOnlinePlayerClient().punish(ban, banOperator, reason);
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable PaperPunishment> getBan(@NotNull String id) throws BackendException {
+        return getKissenPaperOnlinePlayerClient().getBan(id);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<PaperPunishment> getBanHistory() throws BackendException {
+        return getKissenPaperOnlinePlayerClient().getBanHistory();
+    }
+
+    @Override
+    public net.kyori.adventure.text.@NotNull Component styledRankName() {
+        return getKissenPaperOnlinePlayerClient().styledRankName();
+    }
+
+    @Override
+    public @NotNull Set<Suffix> getSuffixSet() {
+        return getKissenPaperOnlinePlayerClient().getSuffixSet();
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable Suffix> getSuffix(@NotNull String name) {
+        return getKissenPaperOnlinePlayerClient().getSuffix(name);
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable Suffix> setSuffix(@NotNull String name, net.kyori.adventure.text.@NotNull Component content) {
+        return getKissenPaperOnlinePlayerClient().setSuffix(name, content);
+    }
+
+    @Override
+    public boolean deleteSuffix(@NotNull String name) {
+        return getKissenPaperOnlinePlayerClient().deleteSuffix(name);
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable Suffix> getSelectedSuffix() {
+        return getKissenPaperOnlinePlayerClient().getSelectedSuffix();
+    }
+
+    @Override
+    public void setSelectedSuffix(@NotNull String name) throws NullPointerException {
+        getKissenPaperOnlinePlayerClient().setSelectedSuffix(name);
+    }
+
+    @Override
+    public long getOnlineTime() {
+        return getKissenPaperOnlinePlayerClient().getOnlineTime();
+    }
+
+    @Override
+    public @NotNull <X> UserSetting<X> getUserSetting(Class<? extends PlayerSetting<X>> settingClass) {
+        return getKissenPaperOnlinePlayerClient().getUserSetting(settingClass);
+    }
+
+    @Override
+    public @NotNull Theme getTheme() {
+        return getKissenPaperOnlinePlayerClient().getTheme();
+    }
+
+    @Override
+    public void kick(@NotNull String message) {
+        getKissenPaperOnlinePlayerClient().kick(message);
+    }
+
+    @Override
+    public void killConnection() {
+        getKissenPaperOnlinePlayerClient().killConnection();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.Nullable KissenServer getCurrentServer() {
+        return getKissenPaperOnlinePlayerClient().getCurrentServer();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<PaperPlayerRank> getRankHistory() {
+        return getKissenPaperOnlinePlayerClient().getRankHistory();
+    }
+
+    @Override
+    public @NotNull PaperPlayerRank getRank() {
+        return getKissenPaperOnlinePlayerClient().getRank();
+    }
+
+    @Override
+    public @NotNull PaperPlayerRank grantRank(@NotNull Rank rank) {
+        return getKissenPaperOnlinePlayerClient().grantRank(rank);
+    }
+
+    @Override
+    public @NotNull PaperPlayerRank grantRank(@NotNull Rank rank, @org.jetbrains.annotations.Nullable AccurateDuration accurateDuration) {
+        return getKissenPaperOnlinePlayerClient().grantRank(rank, accurateDuration);
+    }
+
+    @Override
+    public int warn(@NotNull Ban ban, @NotNull ServerEntity warnOperator) {
+        return getKissenPaperOnlinePlayerClient().warn(ban, warnOperator);
+    }
+
+    @Override
+    public int warn(@NotNull Ban ban, @NotNull ServerEntity warnOperator, net.kyori.adventure.text.@org.jetbrains.annotations.Nullable Component reason) {
+        return getKissenPaperOnlinePlayerClient().warn(ban, warnOperator, reason);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<@NotNull PaperOnlinePlayerClient> getOnlineAltAccounts() {
+        return getKissenPaperOnlinePlayerClient().getOnlineAltAccounts();
+    }
+
+    @Override
+    public @NotNull Set<Suffix> getSuffixSet(@NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getSuffixSet(context);
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable Suffix> getSuffix(@NotNull String name, @NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getSuffix(name, context);
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable Suffix> setSuffix(@NotNull String name, net.kyori.adventure.text.@NotNull Component content, @NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().setSuffix(name, content);
+    }
+
+    @Override
+    public boolean deleteSuffix(@NotNull String name, @NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().deleteSuffix(name, context);
+    }
+
+    @Override
+    public void setSelectedSuffix(@NotNull String name, @NotNull Context context) throws NullPointerException {
+        getKissenPaperOnlinePlayerClient().setSelectedSuffix(name, context);
+    }
+
+    @Override
+    public long getOnlineTime(@NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getOnlineTime(context);
+    }
+
+    @Override
+    public long getLastPlayed(@NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getLastPlayed(context);
+    }
+
+    @Override
+    public @NotNull PaperPermissible getPermissible() throws PermissibleOverriddenException {
+        return getKissenPaperOnlinePlayerClient().getPermissible();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getOwnPermissions() {
+        return getKissenPaperOnlinePlayerClient().getOwnPermissions();
+    }
+
+    @Override
+    public int wipeGroups() {
+        return getKissenPaperOnlinePlayerClient().wipeGroups();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups() {
+        return getKissenPaperOnlinePlayerClient().getPermissionGroups();
+    }
+
+    @Override
+    public boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup) {
+        return getKissenPaperOnlinePlayerClient().inGroup(permissionGroup);
+    }
+
+    @Override
+    public @NotNull String getPermissionID() {
+        return getKissenPaperOnlinePlayerClient().getPermissionID();
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission) throws EventCancelledException {
+        return getKissenPaperOnlinePlayerClient().setPermission(permission);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, boolean value) throws EventCancelledException {
+        return getKissenPaperOnlinePlayerClient().setPermission(permission, value);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull PaperPermission permission) throws EventCancelledException {
+        return getKissenPaperOnlinePlayerClient().setPermission(permission);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission) {
+        return getKissenPaperOnlinePlayerClient().unsetPermission(permission);
+    }
+
+    @Override
+    public int wipePermissions() {
+        return getKissenPaperOnlinePlayerClient().wipePermissions();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList() {
+        return getKissenPaperOnlinePlayerClient().getPermissionList();
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable PaperPermission> getPermission(@NotNull String permission) {
+        return getKissenPaperOnlinePlayerClient().getPermission(permission);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAffectedPermissionPlayer() {
+        return getKissenPaperOnlinePlayerClient().getAffectedPermissionPlayer();
+    }
+
+    @Override
+    public void permissionUpdate() {
+        getKissenPaperOnlinePlayerClient().permissionUpdate();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getOwnPermissions(@NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getOwnPermissions(context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups(@NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getPermissionGroups(context);
+    }
+
+    @Override
+    public boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup, @NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().inGroup(permissionGroup, context);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, @NotNull Context context) throws EventCancelledException {
+        return getKissenPaperOnlinePlayerClient().setPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, boolean value, @NotNull Context context) throws EventCancelledException {
+        return getKissenPaperOnlinePlayerClient().setPermission(permission, value, context);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull PaperPermission permission, @NotNull Context context) throws EventCancelledException {
+        return getKissenPaperOnlinePlayerClient().setPermission(permission, context);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission, @NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().unsetPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList(@NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getPermissionList(context);
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable PaperPermission> getPermission(@NotNull String permission, @NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getPermission(permission, context);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String permission, @NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().hasPermission(permission, context);
+    }
+    // KissenPaper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/profile/CraftPlayerProfile.java b/src/main/java/org/bukkit/craftbukkit/profile/CraftPlayerProfile.java
index 51a6e84198f5b95488e8c757951ba14be4c55625..bb2c06fbe964c382de2ae2b5b86638cd7b95fb88 100644
--- a/src/main/java/org/bukkit/craftbukkit/profile/CraftPlayerProfile.java
+++ b/src/main/java/org/bukkit/craftbukkit/profile/CraftPlayerProfile.java
@@ -54,6 +54,10 @@ public final class CraftPlayerProfile implements PlayerProfile, com.destroystoky
     private final PropertyMap properties = new PropertyMap();
     private final CraftPlayerTextures textures = new CraftPlayerTextures(this);
 
+    // KissenPaper start
+    private net.kissenpvp.core.api.user.User cached;
+    // KissenPaper end
+
     public CraftPlayerProfile(UUID uniqueId, String name) {
         Preconditions.checkArgument((uniqueId != null) || !StringUtils.isBlank(name), "uniqueId is null or name is blank");
         this.uniqueId = (uniqueId == null) ? Util.NIL_UUID : uniqueId;
@@ -352,4 +356,13 @@ public final class CraftPlayerProfile implements PlayerProfile, com.destroystoky
     public boolean complete(final boolean textures, final boolean onlineMode) {
         throw new UnsupportedOperationException("Do not cast to com.destroystokyo.paper.profile.PlayerProfile");
     }
+
+
+    // KissenPaper start
+    @Override
+    public @org.jetbrains.annotations.NotNull net.kissenpvp.core.api.user.User getUser()
+    {
+        return org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.user.UserImplementation.class).getUser(getId());
+    }
+    // KissenPaper end
 }
