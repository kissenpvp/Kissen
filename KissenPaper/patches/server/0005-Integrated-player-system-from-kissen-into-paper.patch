From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Groldi <chniucg@gmail.com>
Date: Fri, 15 Sep 2023 22:45:32 +0200
Subject: [PATCH] Integrated player system from kissen into paper


diff --git a/src/main/java/com/destroystokyo/paper/profile/CraftPlayerProfile.java b/src/main/java/com/destroystokyo/paper/profile/CraftPlayerProfile.java
index 72e232791efa2154c6c95d2158734a86480cb40d..8b079e9ab9ff4dcdb2897aac87eb39696e1ae7d2 100644
--- a/src/main/java/com/destroystokyo/paper/profile/CraftPlayerProfile.java
+++ b/src/main/java/com/destroystokyo/paper/profile/CraftPlayerProfile.java
@@ -32,6 +32,10 @@ public class CraftPlayerProfile implements PlayerProfile, SharedPlayerProfile {
     private GameProfile profile;
     private final PropertySet properties = new PropertySet();
 
+    // KissenPaper start
+    private net.kissenpvp.core.api.user.User cached;
+    // KissenPaper end
+
     public CraftPlayerProfile(CraftPlayer player) {
         this.profile = player.getHandle().getGameProfile();
     }
@@ -417,4 +421,12 @@ public class CraftPlayerProfile implements PlayerProfile, SharedPlayerProfile {
             }
         }
     }
+
+    // KissenPaper start
+    @Override
+    public @org.jetbrains.annotations.NotNull net.kissenpvp.core.api.user.User getUser()
+    {
+        return org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.user.UserImplementation.class).getUser(java.util.Objects.requireNonNull(getId()));
+    }
+    // KissenPaper end
 }
diff --git a/src/main/java/io/papermc/paper/brigadier/NullCommandSender.java b/src/main/java/io/papermc/paper/brigadier/NullCommandSender.java
index 367ef7e0769537e8c13c7fd818a1249e15a28a65..44a0449fe2fb6e120d44570d186f8e51205bb1b1 100644
--- a/src/main/java/io/papermc/paper/brigadier/NullCommandSender.java
+++ b/src/main/java/io/papermc/paper/brigadier/NullCommandSender.java
@@ -1,5 +1,6 @@
 package io.papermc.paper.brigadier;
 
+import java.util.Locale;
 import java.util.Set;
 import java.util.UUID;
 import net.kyori.adventure.text.Component;
@@ -148,4 +149,21 @@ public final class NullCommandSender implements CommandSender {
     @Override
     public void setOp(final boolean value) {
     }
+    
+    // KissenPaper start
+    @Override
+    public @NotNull Locale getCurrentLocale() {
+        return org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.message.localization.LocalizationImplementation.class).getDefaultLocale();
+    }
+
+    @Override
+    public boolean isConnected() {
+        return true;
+    }
+
+    @Override
+    public boolean isClient() {
+        return true;
+    }
+    // KissenPaper end
 }
diff --git a/src/main/java/io/papermc/paper/plugin/manager/PaperPluginManagerImpl.java b/src/main/java/io/papermc/paper/plugin/manager/PaperPluginManagerImpl.java
index f4cce65cd6bb99768edd15ae7bf8f43b9cf2c817..da8a57253428efd0636b6f8265d79f0fe0dc6499 100644
--- a/src/main/java/io/papermc/paper/plugin/manager/PaperPluginManagerImpl.java
+++ b/src/main/java/io/papermc/paper/plugin/manager/PaperPluginManagerImpl.java
@@ -250,5 +250,9 @@ public class PaperPluginManagerImpl implements PluginManager, DependencyContext
     {
         org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.config.ConfigurationImplementation.class).registerSetting(plugin, setting);
     }
-    // KissenPaper end
+    @Override
+    public void registerPlayerSetting(@NotNull net.kissenpvp.core.api.user.playersettting.AbstractPlayerSetting<?, ? extends org.bukkit.OfflinePlayer> playerSetting, @NotNull Plugin plugin) {
+        org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.user.UserImplementation.class).registerPlayerSetting(plugin, playerSetting);
+    }
+    // KissenPaper start
 }
diff --git a/src/main/java/net/kissenpvp/paper/base/KissenPaperCore.java b/src/main/java/net/kissenpvp/paper/base/KissenPaperCore.java
index 0741270ec506fa45bf3f9eec9c400dc4545256b1..38fa6ae5a2a2ab5300384c01c251bc12be659690 100644
--- a/src/main/java/net/kissenpvp/paper/base/KissenPaperCore.java
+++ b/src/main/java/net/kissenpvp/paper/base/KissenPaperCore.java
@@ -49,6 +49,11 @@ public class KissenPaperCore extends KissenCore implements PaperKissen {
     protected void loadImplementations(@NotNull Map<Class<? extends Implementation>, Implementation> loader) {
         loader.put(net.kissenpvp.core.api.config.ConfigurationImplementation.class, new net.kissenpvp.paper.config.KissenPaperConfigurationImplementation());
         loader.put(net.kissenpvp.core.event.EventImplementation.class, new net.kissenpvp.paper.event.KissenEventImplementation());
+        loader.put(net.kissenpvp.core.api.user.UserImplementation.class, new net.kissenpvp.paper.user.KissenPaperUserImplementation());
+        loader.put(net.kissenpvp.paper.api.user.rank.RankImplementation.class, new net.kissenpvp.paper.user.rank.KissenPaperRankImplementation());
+        net.kissenpvp.paper.permission.KissenPaperPermissionImplementation permissionImplementation = new net.kissenpvp.paper.permission.KissenPaperPermissionImplementation();
+        loader.put(net.kissenpvp.paper.api.permission.PermissionImplementation.class, permissionImplementation);
+        loader.put(net.kissenpvp.core.permission.InternalPermissionImplementation.class, permissionImplementation);
         super.loadImplementations(loader);
     }
 
diff --git a/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperOnlinePlayerClient.java b/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperOnlinePlayerClient.java
new file mode 100644
index 0000000000000000000000000000000000000000..7b1b95202c1fd999a6a5c339526a8f3fe654d536
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperOnlinePlayerClient.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.networking.client.entity;
+
+import io.netty.channel.Channel;
+import net.kissenpvp.core.api.ban.AbstractBan;
+import net.kissenpvp.core.api.base.KissenServer;
+import net.kissenpvp.core.api.networking.client.entitiy.ServerEntity;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.paper.api.ban.warn.Warn;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.networking.client.entity.PaperOnlinePlayerClient;
+import net.kyori.adventure.audience.Audience;
+import net.kyori.adventure.key.Key;
+import net.kyori.adventure.sound.Sound;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.kyori.adventure.text.minimessage.MiniMessage;
+import net.kyori.adventure.title.Title;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.entity.Player;
+import org.bukkit.potion.PotionEffect;
+import org.bukkit.potion.PotionEffectType;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Objects;
+
+public abstract class KissenPaperOnlinePlayerClient extends KissenPaperPlayerClient implements PaperOnlinePlayerClient {
+
+    public abstract @NotNull CraftPlayer getCraftPlayer();
+
+    @Override
+    public @NotNull User getUser() {
+        return getCraftPlayer().getUser();
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull Context context) {
+        return getCraftPlayer().getUser(context);
+    }
+
+    @Override
+    public @NotNull Warn warn(@NotNull AbstractBan ban, @NotNull ServerEntity warnOperator, @Nullable Component reason)
+    {
+        Component title = Component.translatable("server.ban.player.warned.target", Component.text(ban.getName())).color(NamedTextColor.RED);
+
+        Player player = Bukkit.getPlayer(getUniqueId());
+        assert player != null;
+        player.showTitle(Title.title(title, Objects.requireNonNullElseGet(reason, Component::empty)));
+        player.playSound(Sound.sound(Key.key("minecraft:block.anvil.destroy"), Sound.Source.MASTER, .5f, 1f));
+        player.addPotionEffect(new PotionEffect(PotionEffectType.BLINDNESS, 100, 255));
+
+        return super.warn(ban, warnOperator, reason);
+    }
+
+    @Override
+    public final boolean isConnected() {
+        return true;
+    }
+
+    @Override
+    public void kick(@NotNull String message) {
+        kick(MiniMessage.miniMessage().deserialize(message));
+    }
+
+    @Override
+    public void kick(@NotNull Component component) {
+        getCraftPlayer().kick(component);
+    }
+
+    @Override
+    public void killConnection() {
+        getConnection().close();
+    }
+
+    @Override
+    public @NotNull Channel getConnection() {
+        return getCraftPlayer().getHandle().connection.connection.channel;
+    }
+
+    @Override
+    public void sendPacket(@NotNull Object object) throws ClassCastException {
+        getCraftPlayer().getHandle().connection.send((Packet<?>) object);
+    }
+
+    @Override
+    public @Nullable KissenServer getCurrentServer() {
+        return MinecraftServer.getServer();
+    }
+
+    @Override
+    public @NotNull Audience getKyoriAudience() {
+        return getCraftPlayer();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperPlayerClient.java b/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperPlayerClient.java
new file mode 100644
index 0000000000000000000000000000000000000000..5508962f5f1aaa253c25a6871eb399ec1278bc32
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperPlayerClient.java
@@ -0,0 +1,150 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.networking.client.entity;
+
+import net.kissenpvp.core.api.ban.AbstractBan;
+import net.kissenpvp.core.api.database.DataWriter;
+import net.kissenpvp.core.api.database.meta.list.MetaList;
+import net.kissenpvp.core.api.networking.client.entitiy.ServerEntity;
+import net.kissenpvp.core.api.time.AccurateDuration;
+import net.kissenpvp.core.api.time.TemporalData;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.ban.warn.WarnNode;
+import net.kissenpvp.core.networking.client.entity.KissenPlayerClient;
+import net.kissenpvp.core.user.rank.PlayerRankNode;
+import net.kissenpvp.paper.api.ban.Punishment;
+import net.kissenpvp.paper.api.ban.warn.Warn;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.networking.client.entity.PaperOnlinePlayerClient;
+import net.kissenpvp.paper.api.networking.client.entity.PaperPlayerClient;
+import net.kissenpvp.paper.api.permission.PermissibleOverriddenException;
+import net.kissenpvp.paper.api.user.playersetting.BoundPlayerSetting;
+import net.kissenpvp.paper.api.user.playersetting.PlayerSetting;
+import net.kissenpvp.paper.api.user.rank.PlayerRank;
+import net.kissenpvp.paper.permission.permissible.KissenPaperPermissible;
+import net.kissenpvp.paper.user.KissenPaperPublicUser;
+import net.kissenpvp.paper.user.playersetting.KissenPaperBoundPlayerSetting;
+import net.kissenpvp.paper.user.rank.KissenPaperKissenPlayerRank;
+import net.kissenpvp.paper.user.rank.KissenPaperPlayerFallBackRank;
+import net.kyori.adventure.text.Component;
+import org.bukkit.Bukkit;
+import org.bukkit.OfflinePlayer;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.time.Period;
+import java.util.List;
+import java.util.Set;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+public abstract class KissenPaperPlayerClient extends KissenPlayerClient<PlayerRank, Punishment> implements PaperPlayerClient {
+
+    @Override
+    public @NotNull User getUser() {
+        return Bukkit.getKissen().getImplementation(UserImplementation.class).getUser(getUniqueId());
+    }
+
+    @Override
+    protected @NotNull PlayerRank translateRank(@NotNull PlayerRankNode playerRankNode, @Nullable DataWriter<PlayerRankNode> dataWriter) {
+        return new KissenPaperKissenPlayerRank(playerRankNode, dataWriter);
+    }
+
+    @Override
+    protected @NotNull PlayerRank fallbackRank() {
+        return new KissenPaperPlayerFallBackRank();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<@NotNull PaperOnlinePlayerClient> getOnlineAltAccounts() {
+        return Bukkit.getOnlinePlayers().stream().filter(client -> client.getTotalID().equals(getTotalID())).collect(Collectors.toSet());
+    }
+
+    @Override
+    public @NotNull AccurateDuration getOnlineTime() {
+        return getOnlineTime(Context.LOCAL);
+    }
+
+    @Override
+    public @NotNull AccurateDuration getOnlineTime(@NotNull Context context) {
+        return getOnlineTime(getUser(context));
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<Warn> getWarnHistory() {
+        return ((KissenPaperPublicUser) getUser()).getWarns().stream().map(transformWarn()).toList();
+    }
+
+    @Override
+    public void clearActiveWarns() {
+        //TODO
+        /*List<WarnNode> nodes = new ArrayList<>(getUser().getListNotNull("warn_list", WarnNode.class));
+        nodes.forEach(warn -> warn.temporalMeasure().end().setValue(System.currentTimeMillis()));
+        getUser().setList("warn_list", nodes);*/
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull Context context) {
+        KissenPaperPublicUser kissenPublicUser = (KissenPaperPublicUser) getUser();
+        return switch (context) {
+            case GLOBAL -> kissenPublicUser;
+            case LOCAL -> kissenPublicUser.getPrivateUserEntry();
+        };
+    }
+
+    @Override
+    public @NotNull <X> BoundPlayerSetting<X> getSetting(@NotNull Class<? extends PlayerSetting<X>> settingClass) {
+        return getSetting(settingClass, Context.LOCAL);
+    }
+
+    @Override
+    public @NotNull <X> BoundPlayerSetting<X> getSetting(@NotNull Class<? extends PlayerSetting<X>> settingClass, @NotNull Context context) {
+        OfflinePlayer offlinePlayer = Bukkit.getOfflinePlayer(getUniqueId());
+        return new KissenPaperBoundPlayerSetting<>(getPlayerSetting(settingClass), offlinePlayer);
+    }
+
+    @Override
+    public @NotNull Warn warn(@NotNull AbstractBan ban, @NotNull ServerEntity warnOperator) {
+        return warn(ban, warnOperator, null);
+    }
+
+    @Override
+    public @NotNull Warn warn(@NotNull AbstractBan ban, @NotNull ServerEntity warnOperator, @Nullable Component reason) {
+        MetaList<WarnNode> nodes = ((KissenPaperPublicUser) getUser()).getWarns();
+
+        AccurateDuration duration = new AccurateDuration(Period.ofWeeks(1));
+        TemporalData temporalData = new TemporalData(duration);
+
+        WarnNode node = new WarnNode(ban.getID(), warnOperator.getName(), reason, temporalData);
+        nodes.add(node);
+        return transformWarn().apply(node);
+    }
+
+    public @NotNull KissenPaperPermissible getPermissionContext() throws PermissibleOverriddenException {
+        return (KissenPaperPermissible) getPermissible();
+    }
+
+    @Contract(pure = true, value = "-> new")
+    protected @NotNull Function<WarnNode, Warn> transformWarn() {
+        return (w) -> null; //TODO
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/AttachmentAbstractPermission.java b/src/main/java/net/kissenpvp/paper/permission/AttachmentAbstractPermission.java
new file mode 100644
index 0000000000000000000000000000000000000000..d122af1d7fd753536375652664d9c809b01bd1e6
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/AttachmentAbstractPermission.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission;
+
+import net.kissenpvp.core.api.permission.AbstractPermission;
+import net.kissenpvp.core.api.permission.AbstractPermissionEntry;
+import net.kissenpvp.core.permission.PermissionNode;
+import net.kissenpvp.core.api.time.TemporalData;
+import org.bukkit.permissions.PermissionAttachment;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class AttachmentAbstractPermission extends KissenPaperPermission {
+
+    private final PermissionAttachment permissionAttachment;
+
+    public AttachmentAbstractPermission(@NotNull String permission, boolean value, @NotNull AbstractPermissionEntry<? extends AbstractPermission> permissionEntry, boolean immutable) {
+        this(null, permission, value, permissionEntry, immutable);
+    }
+
+    public AttachmentAbstractPermission(@Nullable PermissionAttachment permissionAttachment, @NotNull String permission, boolean value, @NotNull AbstractPermissionEntry<? extends AbstractPermission> permissionEntry, boolean immutable) {
+        super(new PermissionNode(permission, permissionEntry, value, new TemporalData()), permissionEntry, immutable ? null : (record) -> { /* ignored */ });
+        this.permissionAttachment = permissionAttachment;
+    }
+
+    public PermissionAttachment getPermissionAttachment() {
+        return permissionAttachment;
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/KissenPaperGroupablePermissionEntry.java b/src/main/java/net/kissenpvp/paper/permission/KissenPaperGroupablePermissionEntry.java
new file mode 100644
index 0000000000000000000000000000000000000000..6c6d6e58b4fea726ae94d08452a1a1a868824d6d
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/KissenPaperGroupablePermissionEntry.java
@@ -0,0 +1,301 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission;
+
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.permission.AbstractGroupablePermissionEntry;
+import net.kissenpvp.core.api.permission.AbstractPermissionEntry;
+import net.kissenpvp.core.api.permission.AbstractPermissionGroup;
+import net.kissenpvp.core.permission.KissenGroupablePermissionEntry;
+import net.kissenpvp.core.permission.KissenPermissionSet;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.GroupablePermissionEntry;
+import net.kissenpvp.paper.api.permission.Permission;
+import net.kyori.adventure.text.Component;
+import org.bukkit.permissions.PermissionAttachment;
+import org.bukkit.permissions.PermissionAttachmentInfo;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.*;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public abstract class KissenPaperGroupablePermissionEntry implements GroupablePermissionEntry
+{
+    @Override
+    public @NotNull Component displayName()
+    {
+        return getContext(Context.LOCAL).map(AbstractPermissionEntry::displayName).orElseGet(() -> getContext(Context.GLOBAL).map(
+                AbstractPermissionEntry::displayName).orElseThrow());
+    }
+
+    @Override
+    public int wipePermissions()
+    {
+        return wipePermissions(Context.LOCAL) + wipePermissions(Context.GLOBAL);
+    }
+
+    @Override
+    public int wipeGroups()
+    {
+        int local = getContext(Context.LOCAL).map(AbstractGroupablePermissionEntry::wipeGroups).orElse(0);
+        int global = getContext(Context.GLOBAL).map(AbstractGroupablePermissionEntry::wipeGroups).orElse(0);
+        return local + global;
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<AbstractPermissionGroup<Permission>> getOwnPermissionGroups()
+    {
+        LinkedHashSet<AbstractPermissionGroup<Permission>> groups = new LinkedHashSet<>(getOwnPermissionsGroups(Context.LOCAL));
+        groups.addAll(getOwnPermissionsGroups(Context.GLOBAL));
+        return groups.stream().toList();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<AbstractPermissionGroup<Permission>> getPermissionGroups()
+    {
+        LinkedHashSet<AbstractPermissionGroup<Permission>> groups = new LinkedHashSet<>(getPermissionGroups(Context.LOCAL));
+        groups.addAll(getPermissionGroups(Context.GLOBAL));
+        return groups.stream().toList();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<Permission> getOwnPermissions()
+    {
+
+        Stream<Permission> local = getOwnPermissions(Context.LOCAL).stream();
+        Stream<Permission> global = getOwnPermissions(Context.GLOBAL).stream();
+
+        return Stream.concat(local, global).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @NotNull Optional<Permission> getOwnPermission(@NotNull String permission)
+    {
+        return getOwnPermission(permission, Context.LOCAL).or(() -> getOwnPermission(permission, Context.GLOBAL));
+    }
+
+    @Override
+    @NotNull
+    public Set<Permission> getOwnPermissions(@NotNull Context context)
+    {
+
+        return getContext(context).map(AbstractGroupablePermissionEntry::getOwnPermissions).orElse(Collections.emptySet());
+    }
+
+    @Override
+    public @NotNull Optional<Permission> getOwnPermission(@NotNull String permission, @NotNull Context context)
+    {
+        return getContextNotNull(context).getOwnPermission(permission);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<AbstractPermissionGroup<Permission>> getOwnPermissionsGroups(@NotNull Context context)
+    {
+        return getContext(context).map(AbstractGroupablePermissionEntry::getOwnPermissionGroups).orElse(Collections.emptyList());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<AbstractPermissionGroup<Permission>> getPermissionGroups(@NotNull Context context)
+    {
+        return getContext(context).map(AbstractGroupablePermissionEntry::getPermissionGroups).orElse(Collections.emptyList());
+    }
+
+    @Override
+    public boolean inGroup(@NotNull AbstractPermissionGroup<Permission> permissionGroup)
+    {
+        return inGroup(permissionGroup, Context.LOCAL) || inGroup(permissionGroup, Context.GLOBAL);
+    }
+
+    @Override
+    public boolean inGroup(@NotNull AbstractPermissionGroup<Permission> permissionGroup, @NotNull Context context)
+    {
+        return getContext(context).map(group -> group.inGroup(permissionGroup)).orElse(false);
+    }
+
+    @Override
+    public int wipeGroups(@NotNull Context context)
+    {
+        return getContext(context).map(AbstractPermissionEntry::wipePermissions).orElse(0);
+    }
+
+    @Override
+    @NotNull
+    public Permission setPermission(@NotNull String s) throws EventCancelledException
+    {
+        return setPermission(s, Context.LOCAL);
+    }
+
+    @Override
+    @NotNull
+    public Permission setPermission(@NotNull String permission, @NotNull Context context) throws EventCancelledException
+    {
+        return getContextNotNull(context).setPermission(permission);
+    }
+
+    @Override
+    @NotNull
+    public Permission setPermission(@NotNull String permission, boolean value) throws EventCancelledException
+    {
+        return setPermission(permission, value, Context.LOCAL);
+    }
+
+    @Override
+    @NotNull
+    public Permission setPermission(@NotNull String permission, boolean value, @NotNull Context context) throws EventCancelledException
+    {
+        return getContextNotNull(context).setPermission(permission, value);
+    }
+
+    @Override
+    @NotNull
+    public Permission setPermission(@NotNull Permission paperPermission) throws EventCancelledException
+    {
+        return setPermission(paperPermission, Context.LOCAL);
+    }
+
+    @Override
+    @NotNull
+    public Permission setPermission(@NotNull Permission permission, @NotNull Context context) throws EventCancelledException
+    {
+        return getContextNotNull(context).setPermission(permission);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String s)
+    {
+        return unsetPermission(s, Context.LOCAL) || unsetPermission(s, Context.GLOBAL);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission, @NotNull Context context)
+    {
+        return getContext(context).map(group -> group.unsetPermission(permission)).orElse(false);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<Permission> getPermissionList()
+    {
+        KissenPermissionSet<Permission> permission = new KissenPermissionSet<>(getOwnPermissions(Context.LOCAL));
+        permission.addAll(getPermissionList(Context.GLOBAL));
+        return permission;
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<Permission> getPermissionList(@NotNull Context context)
+    {
+        return getContext(context).map(AbstractPermissionEntry::getPermissionList).orElse(Collections.emptySet());
+    }
+
+    @Override
+    public @NotNull Optional<Permission> getPermission(@NotNull String permission)
+    {
+        return getPermission(permission, Context.LOCAL).or(() -> getPermission(permission, Context.GLOBAL));
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAffectedUsers()
+    {
+        Function<AbstractGroupablePermissionEntry<Permission>, Stream<UUID>> toStream = entry -> entry.getAffectedUsers().stream();
+        Stream<UUID> local = getContext(Context.LOCAL).map(toStream).orElse(Stream.empty());
+        Stream<UUID> global = getContext(Context.GLOBAL).map(toStream).orElse(Stream.empty());
+
+        return Stream.concat(local, global).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<AbstractGroupablePermissionEntry<Permission>> getConnectedEntries()
+    {
+        var stream = new Object()
+        {
+            private @NotNull Stream<AbstractGroupablePermissionEntry<Permission>> getStream(@NotNull Context context)
+            {
+                return getContext(context).map(entry -> entry.getConnectedEntries().stream()).orElseGet(Stream::empty);
+            }
+        };
+
+        Stream<AbstractGroupablePermissionEntry<Permission>> local = stream.getStream(Context.LOCAL);
+        Stream<AbstractGroupablePermissionEntry<Permission>> global = stream.getStream(Context.GLOBAL);
+
+        return Stream.concat(local, global).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    @NotNull
+    public Optional<Permission> getPermission(@NotNull String permission, @NotNull Context context)
+    {
+        return getContext(context).flatMap(group -> group.getPermission(permission));
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String permission)
+    {
+        return hasPermission(permission, Context.LOCAL) || hasPermission(permission, Context.GLOBAL);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String permission, @NotNull Context context)
+    {
+        return getContext(context).flatMap(group -> hasInternalPermission(permission, context)).orElse(isOp());
+    }
+
+    @Override
+    public void permissionUpdate()
+    {
+        getContext(Context.LOCAL).ifPresent(AbstractPermissionEntry::permissionUpdate);
+        getContext(Context.GLOBAL).ifPresent(AbstractPermissionEntry::permissionUpdate);
+        getConnectedEntries().forEach(AbstractPermissionEntry::permissionUpdate);
+    }
+
+    @Override
+    public int wipePermissions(@NotNull Context context)
+    {
+        return getContext(Context.LOCAL).map(AbstractPermissionEntry::wipePermissions).orElse(0);
+    }
+
+    @NotNull
+    public abstract Optional<? extends AbstractGroupablePermissionEntry<Permission>> getContext(@NotNull Context context);
+
+    @NotNull
+    public abstract AbstractGroupablePermissionEntry<Permission> getContextNotNull(@NotNull Context context);
+
+    public @NotNull @Unmodifiable Set<PermissionAttachmentInfo> getEffectivePermissions()
+    {
+        return getPermissionList().stream().map(permission ->
+        {
+            PermissionAttachment attachment = null;
+            if (permission instanceof AttachmentAbstractPermission kissenPaperAttachmentPermission)
+            {
+                attachment = kissenPaperAttachmentPermission.getPermissionAttachment();
+            }
+            return new PermissionAttachmentInfo(this, permission.getName(), attachment, permission.getValue());
+        }).collect(Collectors.toUnmodifiableSet());
+    }
+
+    private @NotNull Optional<Boolean> hasInternalPermission(@NotNull String permission, @NotNull Context context)
+    {
+        return getContext(context).flatMap(group ->
+        {
+            KissenGroupablePermissionEntry<?, Permission> internal = (KissenGroupablePermissionEntry<?, Permission>) group;
+            return internal.getInternalPermission(permission);
+        });
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermission.java b/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermission.java
new file mode 100644
index 0000000000000000000000000000000000000000..87e6013e84b547e09037dc7e2e6f172f36107147
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermission.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission;
+
+import net.kissenpvp.core.api.database.DataWriter;
+import net.kissenpvp.core.api.permission.AbstractPermission;
+import net.kissenpvp.core.api.permission.AbstractPermissionEntry;
+import net.kissenpvp.core.permission.KissenPermission;
+import net.kissenpvp.core.permission.PermissionNode;
+import net.kissenpvp.paper.api.permission.Permission;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class KissenPaperPermission extends KissenPermission implements Permission {
+    public KissenPaperPermission(@NotNull PermissionNode permissionNode, @NotNull AbstractPermissionEntry<? extends AbstractPermission> permissionEntry, @Nullable DataWriter<PermissionNode> dataWriter) {
+        super(permissionNode, permissionEntry, dataWriter);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermissionImplementation.java b/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermissionImplementation.java
new file mode 100644
index 0000000000000000000000000000000000000000..0e8009923c35311211c349eb01d39b5ccf0a625f
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermissionImplementation.java
@@ -0,0 +1,322 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission;
+
+import net.kissenpvp.core.api.database.connection.DatabaseImplementation;
+import net.kissenpvp.core.api.database.meta.Meta;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.permission.AbstractPermissionGroup;
+import net.kissenpvp.core.base.KissenCore;
+import net.kissenpvp.core.base.KissenImplementation;
+import net.kissenpvp.core.command.InternalCommandImplementation;
+import net.kissenpvp.core.database.KissenTable;
+import net.kissenpvp.core.message.localization.KissenLocalizationImplementation;
+import net.kissenpvp.core.permission.InternalKissenPermissionImplementation;
+import net.kissenpvp.core.permission.InternalPermissionImplementation;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.*;
+import net.kissenpvp.paper.permission.command.PermissionCommand;
+import net.kissenpvp.paper.permission.group.KissenPaperAbstractPermissionGroup;
+import net.kissenpvp.paper.permission.group.KissenPaperPermissionGroup;
+import net.kissenpvp.paper.permission.group.KissenPaperPrivatePermissionGroup;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.bukkit.permissions.PermissionDefault;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.text.MessageFormat;
+import java.util.*;
+import java.util.stream.Collectors;
+
+public class KissenPaperPermissionImplementation extends InternalKissenPermissionImplementation<Permission> implements PermissionImplementation, InternalPermissionImplementation<Permission>, KissenImplementation {
+
+    private static final Logger log = LoggerFactory.getLogger("Kissen");
+
+    private final Set<GroupHolder> cachedHolder;
+    private KissenTable privateTable;
+
+    public KissenPaperPermissionImplementation() {
+        this.cachedHolder = new HashSet<>();
+    }
+
+    @Override
+    public boolean preStart() {
+        DatabaseImplementation implementation = KissenCore.getInstance().getImplementation(DatabaseImplementation.class);
+        privateTable = (KissenTable) implementation.getConnection("private").map(table -> table.createTable("kissen_private_permission_group_table")).orElse(null);
+        return super.preStart();
+    }
+
+    @Override
+    public boolean start() {
+        String prefix = "The permission entry {0}";
+
+        Class<KissenLocalizationImplementation> clazz = KissenLocalizationImplementation.class;
+        KissenLocalizationImplementation localize = Bukkit.getKissen().getImplementation(clazz);
+
+        localize.register("server.permission.set.success", new MessageFormat(prefix + " was successfully set {1} to {2}."));
+        localize.register("server.permission.set.failed", new MessageFormat(prefix + " has already set {1} to {2}."));
+        localize.register("server.permission.group.failed", new MessageFormat(prefix + " is already in this state within the relation to group {1}."));
+        localize.register("server.permission.group.success", new MessageFormat(prefix + " has been set to the state."));
+        localize.register("server.permission.unset.success", new MessageFormat("The permission {1} from the permission entry {0} was successfully unset."));
+        localize.register("server.permission.entity.failed", new MessageFormat(prefix + " does not have the permission {1}."));
+
+        localize.register("server.permission.group.created", new MessageFormat(prefix + " has been created."));
+        localize.register("server.permission.group.deleted", new MessageFormat(prefix + " has been deleted."));
+
+        localize.register("server.permission.info.compact", new MessageFormat("[{0}] [{1}] {2}"));
+
+        localize.register("server.permission.owner", new MessageFormat("Owner"));
+        localize.register("server.permission.info.clear", new MessageFormat(prefix + " has no permissions."));
+
+        localize.register("server.permission.groups.clear", new MessageFormat(prefix + " is no part of any groups ({1} groups removed)."));
+        localize.register("server.permission.permissions.clear", new MessageFormat(prefix + " has no more permissions ({1} permissions removed)."));
+
+        InternalCommandImplementation<CommandSender> command = Bukkit.getKissen().getImplementation(InternalCommandImplementation.class);
+        command.getInternalHandler().registerParser(PermissionGroup.class, new PermissionGroupParser());
+        command.getInternalHandler().registerParser(PermissionParser.PermissionArgument.class, new PermissionParser());
+        return PermissionImplementation.super.start();
+    }
+
+    @Override
+    public boolean postStart() {
+        log.info("Successfully loaded {} permission group(s) from the database.", cachedHolder.size());
+        return PermissionImplementation.super.postStart();
+    }
+
+    @Override
+    public void setupComplete() {
+        InternalCommandImplementation<CommandSender> command = Bukkit.getKissen().getImplementation(InternalCommandImplementation.class);
+        command.getInternalHandler().registerCommand(new PermissionCommand());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup> getGroups() {
+        return cachedHolder.stream().map(GroupHolder::toGroup).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<AbstractPermissionGroup<Permission>> getInternalGroups() {
+        return getGroups().stream().collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @NotNull Optional<AbstractPermissionGroup<?>> getPermissionGroupSavable(@NotNull String name) {
+        return getGroup(name).flatMap(group -> ((KissenPaperPermissionGroup) group).getContext(Context.GLOBAL));
+    }
+
+    @Override
+    public void removePermissionGroup(@NotNull String name) {
+        cachedHolder.removeIf(group -> group.getPermissionID().equals(name));
+    }
+
+    @Override
+    public @NotNull Optional<PermissionGroup> getGroup(@NotNull String group) {
+        return getGroups().stream().filter(currentGroup -> currentGroup.getPermissionID().equals(group)).findFirst();
+    }
+
+    @Override
+    public @NotNull PermissionGroup getGroupNotNull(@NotNull String group) throws EventCancelledException {
+        return getGroup(group).orElseGet(() -> create(group, Context.LOCAL));
+    }
+
+    @Override
+    public void addPermission(@NotNull String permission) {
+        if (Bukkit.getPluginManager().getPermission(permission)==null) {
+            Bukkit.getPluginManager().addPermission(new org.bukkit.permissions.Permission(permission, PermissionDefault.OP));
+        }
+    }
+
+    @Override
+    public @NotNull PermissionGroup create(@NotNull String name) throws EventCancelledException {
+        return create(name, Context.GLOBAL);
+    }
+
+    public @NotNull KissenTable getTable(@NotNull Context context) {
+        return switch (context) {
+            case GLOBAL -> super.getTable();
+            case LOCAL -> Objects.requireNonNullElseGet(privateTable, super::getTable);
+        };
+    }
+
+    public @NotNull Meta getMeta(@NotNull Context context) {
+        return getTable(context).setupMeta(null);
+    }
+
+    public @NotNull PermissionGroup create(@NotNull String name, @NotNull Context context) throws EventCancelledException {
+        return this.createInternal(name, context).toGroup();
+    }
+
+    /**
+     * Retrieves an optional {@link AbstractPermissionGroup} of type {@link Permission} associated with the specified name
+     * and context. The result is wrapped in an {@link Optional} to handle cases where the group is not present.
+     *
+     * @param name    The name of the permission group to retrieve.
+     * @param context The context in which to retrieve the permission group.
+     * @return An {@link Optional} containing the requested {@link AbstractPermissionGroup}, or an empty {@link Optional}
+     * if the group is not found.
+     * @throws NullPointerException If either the 'name' or 'context' parameters are {@code null}.
+     */
+    public @NotNull Optional<AbstractPermissionGroup<Permission>> getGroup(@NotNull String name, @NotNull Context context) {
+        return getHolder(name).flatMap(groupHolder -> groupHolder.getGroup(context));
+    }
+
+    /**
+     * Retrieves a non-null {@link AbstractPermissionGroup} of type {@link Permission} associated with the specified name
+     * and context. If the group is not present, it creates a new group using the {@code createInternal} method and returns it.
+     *
+     * @param name    The name of the permission group to retrieve.
+     * @param context The context in which to retrieve the permission group.
+     * @return The requested {@link AbstractPermissionGroup}, either existing or newly created.
+     * @throws NullPointerException If either the 'name' or 'context' parameters are {@code null}.
+     */
+    public @NotNull AbstractPermissionGroup<Permission> getGroupNotNull(@NotNull String name, @NotNull Context context) {
+        return getGroup(name, context).orElseGet(() -> createInternal(name, context).getGroupOrThrow(context));
+    }
+
+    /**
+     * Retrieves an optional {@link GroupHolder} associated with the specified name from the cached holders.
+     * The result is wrapped in an {@link Optional} to handle cases where the holder is not present.
+     *
+     * @param name The name of the group holder to retrieve.
+     * @return An {@link Optional} containing the requested {@link GroupHolder}, or an empty {@link Optional}
+     * if the holder is not found.
+     * @throws NullPointerException If the 'name' parameter is {@code null}.
+     */
+    private @NotNull Optional<GroupHolder> getHolder(@NotNull String name) {
+        return cachedHolder.stream().filter(groupHolder -> groupHolder.getPermissionID().equals(name)).findFirst();
+    }
+
+    /**
+     * Retrieves a non-null {@link GroupHolder} associated with the specified name from the cached holders.
+     * If the holder is not present, it creates a new one, adds it to the cache, and returns the new holder.
+     *
+     * @param name The name of the group holder to retrieve.
+     * @return The requested {@link GroupHolder}, either existing or newly created.
+     * @throws NullPointerException If the 'name' parameter is {@code null}.
+     */
+    private @NotNull GroupHolder getHolderNotNull(@NotNull String name) {
+        return getHolder(name).orElseGet(() -> {
+            GroupHolder groupHolder = new GroupHolder(name);
+            cachedHolder.add(groupHolder);
+            return groupHolder;
+        });
+    }
+
+    /**
+     * Creates and returns a non-null {@link GroupHolder} associated with the specified name, data, and context.
+     * If a holder with the specified name already exists, it retrieves and returns the existing one.
+     * Otherwise, it creates a new holder, sets up the group based on the provided context, and returns the new holder.
+     *
+     * @param name    The name of the group holder to create or retrieve.
+     * @param context The context in which to set up the group.
+     * @return The created or retrieved {@link GroupHolder} with the associated group set up.
+     * @throws NullPointerException If either the 'name' or 'context' parameters are {@code null}.
+     */
+    private @NotNull GroupHolder createInternal(@NotNull String name, @NotNull Context context) {
+        GroupHolder holder = getHolderNotNull(name);
+        holder.setGroup(switch (context) {
+            case GLOBAL -> new KissenPaperPrivatePermissionGroup.KissenPaperPublicPermissionGroup();
+            case LOCAL -> new KissenPaperPrivatePermissionGroup();
+        }, context).setup(name);
+
+        return holder;
+    }
+
+    /**
+     * A static nested class representing a holder for a permission group.
+     * It contains methods for retrieving, setting up, and converting the associated permission group.
+     */
+    private static final class GroupHolder {
+        private final String permissionID;
+        private KissenPaperPrivatePermissionGroup privateGroup;
+        private KissenPaperPrivatePermissionGroup.KissenPaperPublicPermissionGroup publicGroup;
+
+        /**
+         * Constructs a new GroupHolder with the specified permission ID.
+         *
+         * @param permissionID The unique identifier for the permission group held by this holder.
+         */
+        private GroupHolder(@NotNull String permissionID) {
+            this.permissionID = permissionID;
+        }
+
+        /**
+         * Retrieves the permission ID associated with this GroupHolder.
+         *
+         * @return The permission ID.
+         */
+        private @NotNull String getPermissionID() {
+            return permissionID;
+        }
+
+        /**
+         * Retrieves an optional {@link KissenPaperAbstractPermissionGroup} associated with the specified context.
+         *
+         * @param context The context in which to retrieve the permission group.
+         * @return An {@link Optional} containing the requested {@link KissenPaperAbstractPermissionGroup},
+         * or an empty {@link Optional} if the group is not found.
+         * @throws NullPointerException If the 'context' parameter is {@code null}.
+         */
+        private @NotNull Optional<KissenPaperAbstractPermissionGroup> getGroup(@NotNull Context context) {
+            return Optional.ofNullable(switch (context) {
+                case GLOBAL -> publicGroup;
+                case LOCAL -> privateGroup;
+            });
+        }
+
+        /**
+         * Retrieves the associated {@link KissenPaperAbstractPermissionGroup} for the specified context.
+         * Throws {@link NullPointerException} if the group is not present.
+         *
+         * @param context The context in which to retrieve the permission group.
+         * @return The requested {@link KissenPaperAbstractPermissionGroup}.
+         * @throws NoSuchElementException If the 'context' parameter is {@code null} or the group is not found.
+         */
+        private @NotNull KissenPaperAbstractPermissionGroup getGroupOrThrow(@NotNull Context context) {
+            return getGroup(context).orElseThrow();
+        }
+
+        /**
+         * Sets the associated permission group for the specified context.
+         *
+         * @param group   The permission group to set.
+         * @param context The context in which to set the permission group.
+         * @return The set permission group.
+         */
+        private @NotNull KissenPaperAbstractPermissionGroup setGroup(@NotNull KissenPaperAbstractPermissionGroup group, @NotNull Context context) {
+            switch (context) {
+                case GLOBAL -> publicGroup = (KissenPaperPrivatePermissionGroup.KissenPaperPublicPermissionGroup) group;
+                case LOCAL -> privateGroup = (KissenPaperPrivatePermissionGroup) group;
+            }
+            return group;
+        }
+
+        /**
+         * Converts the GroupHolder to a non-null {@link PermissionGroup}.
+         *
+         * @return A {@link PermissionGroup} representation of the GroupHolder.
+         */
+        private @NotNull PermissionGroup toGroup() {
+            return new KissenPaperPermissionGroup(getPermissionID());
+        }
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/RemoveAttachmentRunnable.java b/src/main/java/net/kissenpvp/paper/permission/RemoveAttachmentRunnable.java
new file mode 100644
index 0000000000000000000000000000000000000000..318e2520843c49567887703a254e03a8dc4171d5
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/RemoveAttachmentRunnable.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission;
+
+import org.bukkit.permissions.PermissionAttachment;
+import org.jetbrains.annotations.NotNull;
+
+public record RemoveAttachmentRunnable(PermissionAttachment attachment) implements Runnable {
+    public RemoveAttachmentRunnable(@NotNull PermissionAttachment attachment) {
+        this.attachment = attachment;
+    }
+
+    @Override
+    public void run() {
+        attachment.remove();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/command/PermissionCommand.java b/src/main/java/net/kissenpvp/paper/permission/command/PermissionCommand.java
index 4b96b6a41ca3ba9c0fce327cabcb02dcd10d6e6d..be7583e67edffa30e41738a6e59cbc7082e5a5e7 100644
--- a/src/main/java/net/kissenpvp/paper/permission/command/PermissionCommand.java
+++ b/src/main/java/net/kissenpvp/paper/permission/command/PermissionCommand.java
@@ -4,23 +4,16 @@ import net.kissenpvp.core.api.command.CommandPayload;
 import net.kissenpvp.core.api.command.annotations.ArgumentName;
 import net.kissenpvp.core.api.command.annotations.CommandData;
 import net.kissenpvp.core.api.command.exception.ArgumentMissingException;
-import net.kissenpvp.core.api.message.ThemeProvider;
 import net.kissenpvp.core.api.util.PageBuilder;
 import net.kissenpvp.core.api.util.PageImplementation;
 import net.kissenpvp.paper.api.base.Context;
-import net.kissenpvp.paper.api.permission.PaperGroupablePermissionEntry;
-import net.kissenpvp.paper.api.permission.PaperPermission;
-import net.kissenpvp.paper.api.permission.PaperPermissionGroup;
-import net.kissenpvp.paper.api.permission.PaperPermissionImplementation;
-import net.kissenpvp.paper.permission.PermissionParser;
+import net.kissenpvp.paper.api.permission.*;
 import net.kyori.adventure.text.Component;
 import net.kyori.adventure.text.TextComponent;
 import net.kyori.adventure.text.TranslatableComponent;
-import net.kyori.adventure.text.format.TextColor;
 import org.bukkit.Bukkit;
 import org.bukkit.OfflinePlayer;
 import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Player;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
@@ -37,99 +30,105 @@ public class PermissionCommand
         throw new ArgumentMissingException();
     }
 
-    @CommandData(value = "permission.user", permission = "*", runAsync = true)
+    @CommandData(value = "permission.user", permission = "*")
     public void permissionUser(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull OfflinePlayer player, @NotNull PermissionParser.PermissionArgument permission, @NotNull @ArgumentName("value") Optional<PermissionAction> value)
     {
-        commandPayload.confirmRequest(() -> commandPayload.getSender().sendMessage(
-                execute(player, permission.permission(), value.orElse(null))));
+        commandPayload.confirmRequest(() ->
+        {
+            Component response = execute(player, permission.permission(), value.orElse(null));
+            commandPayload.getSender().sendMessage(response);
+        }).send();
     }
 
-    @CommandData(value = "permission.user.wipe", permission = "*", runAsync = true)
+    @CommandData(value = "permission.user.wipe", permission = "*")
     public void permissionUserWipe(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull OfflinePlayer player)
     {
         commandPayload.getSender().sendMessage(player.wipePermissions() + " permissions gewiped");
     }
 
-    @CommandData(value = "permission.group", permission = "*", runAsync = true)
-    public void permissionGroup(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PaperPermissionGroup group, @NotNull PermissionParser.PermissionArgument permission, @NotNull @ArgumentName("value") Optional<PermissionAction> value)
+    @CommandData(value = "permission.group", permission = "*")
+    public void permissionGroup(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PermissionGroup group, @NotNull PermissionParser.PermissionArgument permission, @NotNull @ArgumentName("value") Optional<PermissionAction> value)
     {
-        commandPayload.confirmRequest(() -> commandPayload.getSender().sendMessage(
-                execute(group, permission.permission(), value.orElse(null))));
+        commandPayload.confirmRequest(() ->
+        {
+            Component response = execute(group, permission.permission(), value.orElse(null));
+            commandPayload.getSender().sendMessage(response);
+        }).send();
     }
 
-    @CommandData(value = "permission.group.create", permission = "*", runAsync = true)
+    @CommandData(value = "permission.group.create", permission = "*")
     public void permissionGroupCreate(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull String group)
     {
-        PaperPermissionImplementation implementation = Bukkit.getKissen().getImplementation(PaperPermissionImplementation.class);
-        PaperPermissionGroup permissionGroup = implementation.getGroupNotNull(group);
-        Component message = Component.translatable("server.permission.group.created", Component.text(group));
+        PermissionImplementation implementation = Bukkit.getKissen().getImplementation(PermissionImplementation.class);
+        PermissionGroup permissionGroup = implementation.getGroupNotNull(group);
+        Component message = Component.translatable("server.permission.group.created", permissionGroup.displayName());
         commandPayload.getSender().sendMessage(message);
     }
 
-    @CommandData(value = "permission.group.delete", permission = "*", runAsync = true)
-    public void permissionGroupCreate(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PaperPermissionGroup group)
+    @CommandData(value = "permission.group.delete", permission = "*")
+    public void permissionGroupCreate(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PermissionGroup group)
     {
         group.delete();
         Component message = Component.translatable("server.permission.group.deleted", group.displayName());
         commandPayload.getSender().sendMessage(message);
     }
 
-    @CommandData(value = "permission.group.wipe", permission = "*", runAsync = true)
-    public void permissionGroupWipe(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PaperPermissionGroup group)
+    @CommandData(value = "permission.group.wipe", permission = "*")
+    public void permissionGroupWipe(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PermissionGroup group)
     {
         commandPayload.getSender().sendMessage(Component.translatable("server.permission.groups.clear", commandPayload.getSender().displayName(), Component.text(group.wipeGroups())));
     }
 
-    @CommandData(value = "group", permission = "*", runAsync = true)
+    @CommandData(value = "group", permission = "*")
     public void group() {throw new ArgumentMissingException();}
 
-    @CommandData(value = "group.add.user", permission = "*", runAsync = true)
-    public void groupAddUser(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull OfflinePlayer player, @NotNull PaperPermissionGroup group)
+    @CommandData(value = "group.add.user", permission = "*")
+    public void groupAddUser(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull OfflinePlayer player, @NotNull PermissionGroup group)
     {
         commandPayload.getSender().sendMessage(executor().setGroup(true, player, group));
     }
 
-    @CommandData(value = "group.wipe.user", permission = "*", runAsync = true)
+    @CommandData(value = "group.wipe.user", permission = "*")
     public void groupWipeUser(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull OfflinePlayer player)
     {
         commandPayload.getSender().sendMessage(Component.translatable("server.permission.groups.clear", player.displayName(), Component.text(player.wipeGroups())));
     }
 
-    @CommandData(value = "group.remove.user", permission = "*", runAsync = true)
-    public void groupRemoveUser(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull OfflinePlayer player, @NotNull PaperPermissionGroup group)
+    @CommandData(value = "group.remove.user", permission = "*")
+    public void groupRemoveUser(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull OfflinePlayer player, @NotNull PermissionGroup group)
     {
         commandPayload.getSender().sendMessage(executor().setGroup(false, player, group));
     }
 
-    @CommandData(value = "group.add.group", permission = "*", runAsync = true)
-    public void groupAddGroup(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PaperPermissionGroup group, @NotNull PaperPermissionGroup group1)
+    @CommandData(value = "group.add.group", permission = "*")
+    public void groupAddGroup(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PermissionGroup group, @NotNull PermissionGroup group1)
     {
         commandPayload.getSender().sendMessage(executor().setGroup(true, group, group1));
     }
 
-    @CommandData(value = "group.remove.group", permission = "*", runAsync = true)
-    public void groupRemoveGroup(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PaperPermissionGroup group, @NotNull PaperPermissionGroup group1)
+    @CommandData(value = "group.remove.group", permission = "*")
+    public void groupRemoveGroup(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PermissionGroup group, @NotNull PermissionGroup group1)
     {
         commandPayload.getSender().sendMessage(executor().setGroup(false, group, group1));
     }
 
-    @CommandData(value = "group.wipe.group", permission = "*", runAsync = true)
-    public void groupWipeGroup(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PaperPermissionGroup group)
+    @CommandData(value = "group.wipe.group", permission = "*")
+    public void groupWipeGroup(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PermissionGroup group)
     {
         commandPayload.getSender().sendMessage(Component.translatable("server.permission.permissions.clear", group.displayName(), Component.text(group.wipeGroups())));
     }
 
-    @CommandData(value = "permissioninfo", aliases = {"peri"}, runAsync = true)
+    @CommandData(value = "permissioninfo", aliases = {"peri"})
     public void permissionInfo() {throw new ArgumentMissingException();}
 
-    @CommandData(value = "permissioninfo.user", runAsync = true)
+    @CommandData(value = "permissioninfo.user")
     public void permissionInfoUser(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull OfflinePlayer player, @NotNull @ArgumentName("page/permission") Optional<String> data)
     {
         commandPayload.getSender().sendMessage(info(player, data.orElse(null)));
     }
 
-    @CommandData(value = "permissioninfo.group", runAsync = true)
-    public void permissionInfoGroup(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PaperPermissionGroup group, @NotNull @ArgumentName("page/permission") Optional<String> data)
+    @CommandData(value = "permissioninfo.group")
+    public void permissionInfoGroup(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PermissionGroup group, @NotNull @ArgumentName("page/permission") Optional<String> data)
     {
         commandPayload.getSender().sendMessage(info(group, data.orElse(null)));
     }
@@ -145,7 +144,7 @@ public class PermissionCommand
      * @return A Component representing the generated information.
      * @throws NullPointerException if entry is null.
      */
-    private @NotNull Component info(@NotNull PaperGroupablePermissionEntry entry, @Nullable String data)
+    private @NotNull Component info(@NotNull GroupablePermissionEntry entry, @Nullable String data)
     {
         if (data == null)
         {
@@ -162,27 +161,27 @@ public class PermissionCommand
     }
 
     /**
-     * Generates an information {@link Component} displaying details about the permissions of a {@link PaperGroupablePermissionEntry}.
+     * Generates an information {@link Component} displaying details about the permissions of a {@link GroupablePermissionEntry}.
      *
-     * @param permissionEntry The {@link PaperGroupablePermissionEntry} for which information is displayed.
+     * @param permissionEntry The {@link GroupablePermissionEntry} for which information is displayed.
      * @param page            The page number for paginating the information (if applicable).
      * @return A formatted {@link Component} containing information about the permissions of the specified entry.
      */
-    private @NotNull Component infoComponent(@NotNull PaperGroupablePermissionEntry permissionEntry, int page)
+    private @NotNull Component infoComponent(@NotNull GroupablePermissionEntry permissionEntry, int page)
     {
-        Set<PaperPermission> permissionSet = permissionEntry.getPermissionList();
+        Set<Permission> permissionSet = permissionEntry.getPermissionList();
         if (permissionSet.isEmpty())
         {
             return Component.translatable("server.permission.info.clear", permissionEntry.displayName());
         }
 
-        Comparator<PaperPermission> comparator = (a, b) -> CharSequence.compare(a.getOwner().getPermissionID(),
+        Comparator<Permission> comparator = (a, b) -> CharSequence.compare(a.getOwner().getPermissionID(),
                 b.getOwner().getPermissionID());
 
         PageImplementation pageBuilder = Bukkit.getKissen().getImplementation(PageImplementation.class);
-        List<PaperPermission> sorted = permissionSet.stream().sorted(comparator).toList();
+        List<Permission> sorted = permissionSet.stream().sorted(comparator).toList();
 
-        PageBuilder<PaperPermission> permissions = pageBuilder.createPageBuilder(sorted);
+        PageBuilder<Permission> permissions = pageBuilder.createPageBuilder(sorted);
 
         Component header = permissions.getHeader(permissionEntry.displayName(), page);
         Component footer = permissions.getFooter(permissionEntry.displayName(), page);
@@ -190,11 +189,10 @@ public class PermissionCommand
         TextComponent.Builder builder = Component.text().append(header);
         permissions.getEntries(page).forEach(per ->
         {
-            TextColor statusColor = per.getValue() ? ThemeProvider.enabled() : ThemeProvider.disabled();
             Component[] args = {
-                    Component.text(per.getValue() ? "" : "").color(statusColor),
-                    per.getOwner().displayName().color(ThemeProvider.secondary()),
-                    Component.text(per.getName()).color(ThemeProvider.general())
+                    Component.text(per.getValue() ? "" : ""),
+                    per.getOwner().displayName(),
+                    Component.text(per.getName())
             };
             builder.appendNewline().append(Component.translatable("server.permission.info.compact", args));
         });
@@ -203,13 +201,13 @@ public class PermissionCommand
     }
 
     /**
-     * Generates an information {@link Component} displaying details about a specific permission of a {@link PaperGroupablePermissionEntry}.
+     * Generates an information {@link Component} displaying details about a specific permission of a {@link GroupablePermissionEntry}.
      *
-     * @param permissionEntry The {@link PaperGroupablePermissionEntry} for which information is displayed.
+     * @param permissionEntry The {@link GroupablePermissionEntry} for which information is displayed.
      * @param permission      The name of the specific permission.
      * @return A formatted {@link Component} containing information about the specified permission of the entry.
      */
-    private @NotNull Component infoComponent(@NotNull PaperGroupablePermissionEntry permissionEntry, @NotNull String permission)
+    private @NotNull Component infoComponent(@NotNull GroupablePermissionEntry permissionEntry, @NotNull String permission)
     {
         return permissionEntry.getPermission(permission).map(paperPermission ->
         {
@@ -218,8 +216,8 @@ public class PermissionCommand
             Component footer = Component.translatable("server.command.general.footer", permissionEntry.displayName());
             TranslatableComponent keyValue = Component.translatable("server.command.general.key.value");
 
-            Component id = Component.translatable("server.general.id").color(ThemeProvider.general());
-            Component owner = Component.translatable("server.permission.owner").color(ThemeProvider.general());
+            Component id = Component.translatable("server.general.id");
+            Component owner = Component.translatable("server.permission.owner");
 
             TextComponent.Builder builder = Component.text().appendNewline().append(header);
             builder.appendNewline().append(keyValue.arguments(id, Component.text(paperPermission.getName())));
@@ -240,7 +238,7 @@ public class PermissionCommand
      * @return A Component representing the result of the permission operation.
      * @throws NullPointerException if entry, permission, or executor() result in null.
      */
-    private @NotNull Component execute(@NotNull PaperGroupablePermissionEntry entry, @NotNull String permission, @Nullable PermissionAction action)
+    private @NotNull Component execute(@NotNull GroupablePermissionEntry entry, @NotNull String permission, @Nullable PermissionAction action)
     {
         PermissionCommandExecutor executor = executor();
         if (action == null)
diff --git a/src/main/java/net/kissenpvp/paper/permission/command/PermissionCommandExecutor.java b/src/main/java/net/kissenpvp/paper/permission/command/PermissionCommandExecutor.java
new file mode 100644
index 0000000000000000000000000000000000000000..c2ce49715c77e6be76a2e113948e5fc394815ed2
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/command/PermissionCommandExecutor.java
@@ -0,0 +1,108 @@
+package net.kissenpvp.paper.permission.command;
+
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.GroupablePermissionEntry;
+import net.kissenpvp.paper.api.permission.Permission;
+import net.kissenpvp.paper.api.permission.PermissionEntry;
+import net.kissenpvp.paper.api.permission.PermissionGroup;
+import net.kyori.adventure.text.Component;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Optional;
+import java.util.function.Function;
+
+/**
+ * The {@code PermissionCommandExecutor} class provides methods for executing permission-related commands
+ * within the context of a server. It is designed to handle operations such as setting or unsetting
+ * permissions for a given {@link GroupablePermissionEntry} and interacting with a {@link PermissionGroup}.
+ * This class is part of a broader system for managing permissions in a server environment.
+ *
+ * @param context The {@link Context} object representing the execution context of the commands.
+ */
+public record PermissionCommandExecutor(@NotNull Context context)
+{
+    /**
+     * Sets or removes a {@link GroupablePermissionEntry} from a {@link PermissionGroup}.
+     *
+     * @param add              {@code true} to add the entry to the group, {@code false} to remove it.
+     * @param permissionEntry The {@link GroupablePermissionEntry} to be added or removed.
+     * @param permissionGroup The target {@link PermissionGroup} for the operation.
+     * @return A {@link Component} indicating the success or failure of the operation.
+     */
+    public @NotNull Component setGroup(boolean add, @NotNull GroupablePermissionEntry permissionEntry, @NotNull PermissionGroup permissionGroup)
+    {
+        if (!(add ? permissionGroup.addMember(permissionEntry, context()) : permissionGroup.removeMember(permissionEntry, context())))
+        {
+            return Component.translatable("server.permission.group.failed", permissionEntry.displayName(),
+                    permissionGroup.displayName());
+        }
+        return Component.translatable("server.permission.group.success", permissionEntry.displayName());
+    }
+
+    /**
+     * Sets a permission for a {@link GroupablePermissionEntry}.
+     *
+     * @param permissionEntry The {@link GroupablePermissionEntry} for which the permission is set.
+     * @param permission      The name of the permission.
+     * @param unparsedBoolean An optional boolean value. If {@code null}, the opposite of the current value is used.
+     * @return A {@link Component} indicating the success or failure of the operation.
+     */
+    public @NotNull Component setPermission(@NotNull GroupablePermissionEntry permissionEntry, @NotNull String permission, @Nullable Boolean unparsedBoolean)
+    {
+        boolean value = Optional.ofNullable(unparsedBoolean).orElseGet(
+                () -> permissionEntry.getOwnPermission(permission, context()).map(current -> !current.getValue()).orElse(true));
+
+        Component[] args = {
+                permissionEntry.displayName(),
+                Component.text(permission),
+                Component.text(value)
+        };
+
+        Component component = Component.translatable("server.permission.set.success", args);
+        Component failed = Component.translatable("server.permission.set.failed", args);
+
+        Function<Permission, Component> mapper = paperPermission -> component;
+        return setPermission(permissionEntry, permission, value).map(mapper).orElse(failed);
+    }
+
+    /**
+     * Unsets a permission for a {@link PermissionEntry}.
+     *
+     * @param permissionEntry The {@link PermissionEntry} for which the permission is unset.
+     * @param permission      The name of the permission.
+     * @return A {@link Component} indicating the success or failure of the operation.
+     */
+    public @NotNull Component unsetPermission(@NotNull PermissionEntry permissionEntry, @NotNull String permission)
+    {
+        Component[] args = {
+                permissionEntry.displayName(),
+                Component.text(permission)
+        };
+        if (!permissionEntry.unsetPermission(permission, context()))
+        {
+            return Component.translatable("server.permission.entity.failed", args);
+        }
+        return Component.translatable("server.permission.unset.success", args);
+    }
+
+    /**
+     * Sets a permission for a {@link GroupablePermissionEntry} and returns an Optional result.
+     * This method is used internally to perform the permission setting operation.
+     *
+     * @param permissionEntry The {@link GroupablePermissionEntry} for which the permission is set.
+     * @param permission      The name of the permission.
+     * @param value           The boolean value to set for the permission.
+     * @return An {@link Optional} containing the resulting {@link Permission} if the operation is successful;
+     *         empty otherwise.
+     */
+    private @NotNull Optional<Permission> setPermission(@NotNull GroupablePermissionEntry permissionEntry, @NotNull String permission, boolean value)
+    {
+        Function<Permission, Boolean> mapper = (paperPermission -> paperPermission.getValue() == value);
+        if (permissionEntry.getOwnPermission(permission).map(mapper).orElse(false))
+        {
+            return Optional.empty();
+        }
+        return Optional.of(permissionEntry.setPermission(permission, value, context()));
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperAbstractPermissionGroup.java b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperAbstractPermissionGroup.java
new file mode 100644
index 0000000000000000000000000000000000000000..836e83b1ec2ac49d0011a45e9ab67a1d9cd64e05
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperAbstractPermissionGroup.java
@@ -0,0 +1,38 @@
+package net.kissenpvp.paper.permission.group;
+
+import net.kissenpvp.core.api.database.DataWriter;
+import net.kissenpvp.core.api.permission.AbstractPermissionEntry;
+import net.kissenpvp.core.permission.KissenPermissionGroup;
+import net.kissenpvp.core.permission.PermissionNode;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.Permission;
+import net.kissenpvp.paper.api.permission.PermissionImplementation;
+import net.kissenpvp.paper.permission.KissenPaperPermission;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public abstract class KissenPaperAbstractPermissionGroup extends KissenPermissionGroup<Permission>
+{
+
+    @Override
+    public void permissionUpdate()
+    {
+        // instead update paper permission group
+        Class<PermissionImplementation> clazz = PermissionImplementation.class;
+        PermissionImplementation permission = Bukkit.getKissen().getImplementation(clazz);
+        permission.getGroup(getPermissionID()).ifPresent(AbstractPermissionEntry::permissionUpdate);
+    }
+
+    public void internalPermissionUpdate()
+    {
+        super.permissionUpdate();
+    }
+
+    @Override
+    protected @NotNull KissenPaperPermission translatePermission(@NotNull PermissionNode permissionNode, @Nullable DataWriter<PermissionNode> dataWriter) {
+        return new KissenPaperPermission(permissionNode, this, dataWriter);
+    }
+
+    protected abstract @NotNull Context getContext();
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPermissionGroup.java b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPermissionGroup.java
new file mode 100644
index 0000000000000000000000000000000000000000..c1441dbb6332b1a3a76f065387ff9e2b118e312c
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPermissionGroup.java
@@ -0,0 +1,163 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission.group;
+
+import net.kissenpvp.core.api.database.savable.Savable;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.permission.AbstractGroupablePermissionEntry;
+import net.kissenpvp.core.api.permission.AbstractPermissionEntry;
+import net.kissenpvp.core.api.permission.AbstractPermissionGroup;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.Permission;
+import net.kissenpvp.paper.api.permission.PermissionGroup;
+import net.kissenpvp.paper.permission.KissenPaperPermissionImplementation;
+import net.kissenpvp.paper.permission.permissible.KissenPaperPermissible;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Collections;
+import java.util.Optional;
+import java.util.Set;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public class KissenPaperPermissionGroup extends KissenPaperPermissible implements PermissionGroup
+{
+    @Override
+    public void permissionUpdate()
+    {
+        Consumer<AbstractPermissionGroup<Permission>> internalUpdate = entry ->
+        {
+            if(entry instanceof KissenPaperAbstractPermissionGroup abstractPermissionGroup)
+            {
+                abstractPermissionGroup.internalPermissionUpdate();
+            }
+        };
+
+        getContext(Context.LOCAL).ifPresent(internalUpdate);
+        getContext(Context.GLOBAL).ifPresent(internalUpdate);
+
+        getConnectedEntries().forEach(AbstractPermissionEntry::permissionUpdate);
+    }
+
+    private final String permissionID;
+
+    public KissenPaperPermissionGroup(@NotNull String permissionID)
+    {
+        this.permissionID = permissionID;
+    }
+
+    @Override
+    public @NotNull String getPermissionID() {
+        return permissionID;
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<String> getMember() {
+        Stream<String> local = getMember(Context.LOCAL).stream(), global = getMember(Context.GLOBAL).stream();
+        return Stream.concat(local, global).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<String> getOwnMember()
+    {
+        Stream<String> local = getOwnMember(Context.LOCAL).stream(), global = getOwnMember(Context.GLOBAL).stream();
+        return Stream.concat(local, global).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<String> getMember(@NotNull Context context)
+    {
+        return getContext(context).map(AbstractPermissionGroup::getMember).orElse(Collections.emptySet());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<String> getOwnMember(@NotNull Context context)
+    {
+        return getContext(context).map(AbstractPermissionGroup::getOwnMember).orElse(Collections.emptySet());
+    }
+
+    @Override
+    public boolean addMember(@NotNull AbstractGroupablePermissionEntry<?> groupablePermissionEntry) {
+        return addMember(groupablePermissionEntry, Context.GLOBAL);
+    }
+
+    @Override
+    public boolean addMember(@NotNull AbstractGroupablePermissionEntry<?> groupablePermissionEntry, @NotNull Context context) {
+        return getContext(context).map(group -> group.addMember(groupablePermissionEntry)).orElse(false);
+    }
+
+    @Override
+    public boolean removeMember(@NotNull AbstractGroupablePermissionEntry<?> groupablePermissionEntry) {
+        return removeMember(groupablePermissionEntry, Context.GLOBAL);
+    }
+
+    @Override
+    public int delete()
+    {
+        KissenPaperPermissionImplementation implementation = Bukkit.getKissen().getImplementation(KissenPaperPermissionImplementation.class);
+        implementation.removePermissionGroup(getPermissionID());
+
+        Function<AbstractGroupablePermissionEntry<Permission>, Integer> delete = group -> ((Savable) group).delete();
+        return getContext(Context.LOCAL).map(delete).orElse(0) + getContext(Context.GLOBAL).map(delete).orElse(0);
+    }
+
+    @Override
+    public boolean removeMember(@NotNull AbstractGroupablePermissionEntry<?> groupablePermissionEntry, @NotNull Context context) {
+        return getContext(context).map(group -> group.removeMember(groupablePermissionEntry)).orElse(false);
+    }
+
+    @Override
+    public @NotNull Optional<AbstractPermissionGroup<Permission>> getContext(@NotNull Context context)
+    {
+        Class<KissenPaperPermissionImplementation> clazz = KissenPaperPermissionImplementation.class;
+        KissenPaperPermissionImplementation permissionImplementation = Bukkit.getKissen().getImplementation(clazz);
+        return permissionImplementation.getGroup(getPermissionID(), context);
+    }
+
+    @Override
+    public @NotNull AbstractGroupablePermissionEntry<Permission> getContextNotNull(@NotNull Context context)
+    {
+        Class<KissenPaperPermissionImplementation> clazz = KissenPaperPermissionImplementation.class;
+        KissenPaperPermissionImplementation permissionImplementation = Bukkit.getKissen().getImplementation(clazz);
+        return permissionImplementation.getGroupNotNull(getPermissionID(), context);
+    }
+
+    @Override
+    public boolean isOp() {
+        return hasPermission("*");
+    }
+
+    @Override
+    public void setOp(boolean value) {
+        if (isOp() && !value) {
+            unsetPermission("*");
+            return;
+        }
+
+        try {
+            setPermission("*", value);
+        } catch (EventCancelledException eventCancelledException) {
+            throw new RuntimeException(eventCancelledException);
+        }
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPrivatePermissionGroup.java b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPrivatePermissionGroup.java
new file mode 100644
index 0000000000000000000000000000000000000000..57eec5dd7240063c85d6612dfff44e943ed04595
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPrivatePermissionGroup.java
@@ -0,0 +1,76 @@
+package net.kissenpvp.paper.permission.group;
+
+import net.kissenpvp.core.api.base.Kissen;
+import net.kissenpvp.core.api.networking.socket.DataPackage;
+import net.kissenpvp.core.api.permission.AbstractPermissionGroup;
+import net.kissenpvp.core.base.KissenCore;
+import net.kissenpvp.core.database.KissenTable;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.Permission;
+import net.kissenpvp.paper.api.permission.PrivatePermissionGroup;
+import net.kissenpvp.paper.api.permission.PublicPermissionGroup;
+import net.kissenpvp.paper.permission.KissenPaperPermissionImplementation;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Optional;
+
+public class KissenPaperPrivatePermissionGroup extends KissenPaperAbstractPermissionGroup implements PrivatePermissionGroup
+{
+    @Override
+    public void sendData(@NotNull DataPackage dataPackage) { /* ignored */ }
+
+    @Override
+    public @NotNull String getSaveID()
+    {
+        return "privatepermissiongroup";
+    }
+
+    @Override
+    public @NotNull Optional<AbstractPermissionGroup<Permission>> getPublicGroup()
+    {
+        Kissen kissen = Bukkit.getKissen();
+        KissenPaperPermissionImplementation implementation = kissen.getImplementation(KissenPaperPermissionImplementation.class);
+        return implementation.getGroup(getPermissionID(), Context.GLOBAL);
+    }
+
+    @Override
+    protected @NotNull Context getContext()
+    {
+        return Context.LOCAL;
+    }
+
+    public static class KissenPaperPublicPermissionGroup extends KissenPaperAbstractPermissionGroup implements PublicPermissionGroup
+    {
+        @Override
+        public @NotNull String getSaveID()
+        {
+            return "publicpermissiongroup";
+        }
+
+        @Override
+        public @NotNull KissenTable getTable() {
+            return (KissenTable) KissenCore.getInstance().getImplementation(KissenPaperPermissionImplementation.class).getTable(Context.LOCAL);
+        }
+
+        @Override
+        public void sendData(@NotNull DataPackage dataPackage)
+        {
+            //TODO
+        }
+
+        @Override
+        public @NotNull Optional<AbstractPermissionGroup<Permission>> getPrivateGroup()
+        {
+            Kissen kissen = Bukkit.getKissen();
+            KissenPaperPermissionImplementation implementation = kissen.getImplementation(KissenPaperPermissionImplementation.class);
+            return implementation.getGroup(getPermissionID(), Context.LOCAL);
+        }
+
+        @Override
+        protected @NotNull Context getContext()
+        {
+            return Context.GLOBAL;
+        }
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPermissible.java b/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPermissible.java
new file mode 100644
index 0000000000000000000000000000000000000000..1732625354e263b206f43f40d2931b5ed887dfd8
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPermissible.java
@@ -0,0 +1,183 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission.permissible;
+
+import net.kissenpvp.core.api.permission.AbstractPermission;
+import net.kissenpvp.paper.api.permission.PaperPermissible;
+import net.kissenpvp.paper.api.permission.Permission;
+import net.kissenpvp.paper.permission.AttachmentAbstractPermission;
+import net.kissenpvp.paper.permission.KissenPaperGroupablePermissionEntry;
+import net.kissenpvp.paper.permission.RemoveAttachmentRunnable;
+import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;
+import org.bukkit.Bukkit;
+import org.bukkit.permissions.Permissible;
+import org.bukkit.permissions.PermissionAttachment;
+import org.bukkit.permissions.PermissionRemovedExecutor;
+import org.bukkit.plugin.Plugin;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.function.BiConsumer;
+import java.util.logging.Level;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public abstract class KissenPaperPermissible extends KissenPaperGroupablePermissionEntry implements PaperPermissible {
+
+    protected final Permissible parent;
+    protected final Set<PermissionAttachment> attachments;
+    private boolean initialized;
+
+    public KissenPaperPermissible() {
+        this(null);
+    }
+
+    public KissenPaperPermissible(@Nullable Permissible parent) {
+        this.attachments = new HashSet<>();
+        this.parent = parent == null ? this : parent;
+        this.initialized = false;
+    }
+
+    @Override
+    public boolean isPermissionSet(@NotNull String name) {
+        return getPermission(name).isPresent();
+    }
+
+    @Override
+    public boolean isPermissionSet(@NotNull org.bukkit.permissions.Permission perm) {
+        return isPermissionSet(perm.getName());
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull org.bukkit.permissions.Permission perm) {
+        return hasPermission(perm.getName());
+    }
+
+    @Override
+    public @NotNull PermissionAttachment addAttachment(@NotNull Plugin plugin) {
+        PermissionAttachment result = new PermissionAttachment(plugin, parent);
+
+        attachments.add(result);
+        permissionUpdate();
+
+        return result;
+    }
+
+    @Override
+    public @NotNull PermissionAttachment addAttachment(@NotNull Plugin plugin, @NotNull String name, boolean value) {
+        PermissionAttachment permissionAttachment = addAttachment(plugin);
+        permissionAttachment.setPermission(name, value);
+        return permissionAttachment;
+    }
+
+    @Override
+    public @Nullable PermissionAttachment addAttachment(@NotNull Plugin plugin, @NotNull String name, boolean value, int ticks) {
+        PermissionAttachment permissionAttachment = addAttachment(plugin, ticks);
+        if (permissionAttachment != null) {
+            permissionAttachment.setPermission(name, value);
+        }
+        return permissionAttachment;
+    }
+
+    @Override
+    public @Nullable PermissionAttachment addAttachment(@NotNull Plugin plugin, int ticks) {
+        PermissionAttachment result = addAttachment(plugin);
+
+        if (Bukkit.getServer()
+                .getScheduler()
+                .scheduleSyncDelayedTask(plugin, new RemoveAttachmentRunnable(result), ticks) == -1) {
+            Bukkit.getServer()
+                    .getLogger()
+                    .log(Level.WARNING, "Could not add PermissionAttachment to " + LegacyComponentSerializer.legacySection().serialize(displayName()) + " for plugin " + plugin.getPluginMeta()
+                            .getDisplayName() + ": Scheduler returned -1");
+            result.remove();
+            return null;
+        } else {
+            return result;
+        }
+    }
+
+    @Override
+    public void removeAttachment(@NotNull PermissionAttachment attachment) {
+        if (attachments.remove(attachment)) {
+            PermissionRemovedExecutor permissionRemovedExecutor = attachment.getRemovalCallback();
+
+            if (permissionRemovedExecutor != null) {
+                permissionRemovedExecutor.attachmentRemoved(attachment);
+            }
+
+            permissionUpdate();
+        } else {
+            throw new IllegalArgumentException("Given attachment is not part of Permissible object " + LegacyComponentSerializer.legacySection().serialize(displayName()));
+        }
+    }
+
+    @Override
+    public void recalculatePermissions() {
+        if(initialized)
+        {
+            unsubscribe();
+        }
+
+        Bukkit.getServer().getPluginManager().subscribeToDefaultPerms(isOp() || hasPermission("*"), parent);
+        for (Permission permission : getPermissionList()) {
+            Bukkit.getServer().getPluginManager().subscribeToPermission(permission.getName(), parent);
+        }
+        initialized = true;
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<Permission> getPermissionList() {
+        Set<AttachmentAbstractPermission> permissions = new HashSet<>();
+        for (PermissionAttachment attachment : attachments)
+        {
+            BiConsumer<String, Boolean> transform = (key, value) -> permissions.add(
+                    new AttachmentAbstractPermission(attachment, key, value, KissenPaperPermissible.this, true));
+            attachment.getPermissions().forEach(transform);
+        }
+
+        return Stream.concat(super.getPermissionList().stream(), permissions.stream()).collect(Collectors.toSet());
+    }
+
+    /**
+     * The <code>unsubscribe</code> method is used to deregister all permissions from a parent permission holder in the Bukkit server.
+     *
+     * <p>As a result of calling this method, the permission holder specified by 'parent' would not hold the permissions anymore until re-registered.</p>
+     *
+     * <p>Note: Parent could be a Player, a Group, or any entity that can hold permissions in Bukkit.</p>
+     *
+     * <p>It is advised to call this method when you no longer need the permissions to be associated with the parent or want to clear current permissions before setting new ones.</p>
+     *
+     * @see AbstractPermission
+     * @see Permissible
+     */
+    public void unsubscribe() {
+        for (String name : getPermissionList().stream()
+                .map(AbstractPermission::getName)
+                .collect(Collectors.toSet())) {
+            Bukkit.getServer().getPluginManager().unsubscribeFromPermission(name, parent);
+        }
+
+        Bukkit.getServer().getPluginManager().unsubscribeFromDefaultPerms(false, parent);
+        Bukkit.getServer().getPluginManager().unsubscribeFromDefaultPerms(true, parent);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPlayerPermissible.java b/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPlayerPermissible.java
new file mode 100644
index 0000000000000000000000000000000000000000..3a3ec320a976b7331021e0aeeac849830a768738
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPlayerPermissible.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.permission.permissible;
+
+import net.kissenpvp.core.api.permission.AbstractGroupablePermissionEntry;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.Permission;
+import net.kyori.adventure.text.Component;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.permissions.Permissible;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Collections;
+import java.util.Optional;
+import java.util.Set;
+import java.util.UUID;
+
+public class KissenPaperPlayerPermissible extends KissenPaperPermissible {
+
+    public KissenPaperPlayerPermissible(@NotNull Permissible parent) {
+        super(parent);
+    }
+
+    @Override
+    public void unsubscribe()
+    {
+        if (getPlayer().isConnected())
+        {
+            super.unsubscribe();
+        }
+    }
+
+    public @NotNull OfflinePlayer getPlayer() {
+        return (OfflinePlayer) parent; // Can be offline or online, does not matter
+    }
+
+    @Override
+    public @NotNull String getPermissionID() {
+        return getContextNotNull(Context.GLOBAL).getPermissionID();
+    }
+
+    @Override
+    public @NotNull Component displayName() {
+        return getPlayer().displayName();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAffectedUsers() {
+        return Collections.singleton(getPlayer().getUniqueId());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<AbstractGroupablePermissionEntry<Permission>> getConnectedEntries()
+    {
+        return getPlayer().isConnected() ? Collections.singleton((AbstractGroupablePermissionEntry<Permission>) parent) : Collections.EMPTY_SET;
+    }
+
+    @Override
+    public void permissionUpdate()
+    {
+        OfflinePlayer player = getPlayer();
+        if (player.isConnected())
+        {
+            ServerPlayer serverPlayer = ((CraftPlayer) player).getHandle();
+            MinecraftServer.getServer().getPlayerList().sendPlayerPermissionLevel(serverPlayer, true);
+        }
+    }
+
+    @Override
+    public @NotNull Optional<AbstractGroupablePermissionEntry<Permission>> getContext(@NotNull Context context)
+    {
+        return Optional.of(getContextNotNull(context));
+    }
+
+    @Override
+    public boolean isOp() {
+        return getPlayer().isOp();
+    }
+
+    @Override
+    public void setOp(boolean value) {
+        getPlayer().setOp(value);
+    }
+
+    @Override
+    public @NotNull AbstractGroupablePermissionEntry<Permission> getContextNotNull(@NotNull Context context)
+    {
+        return (AbstractGroupablePermissionEntry<Permission>) getPlayer().getUser(context);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenPaperProfileCache.java b/src/main/java/net/kissenpvp/paper/user/KissenPaperProfileCache.java
new file mode 100644
index 0000000000000000000000000000000000000000..f8344bec3cd20dbd76e5c23edeeed19676e3f527
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/KissenPaperProfileCache.java
@@ -0,0 +1,95 @@
+package net.kissenpvp.paper.user;
+
+import com.mojang.authlib.GameProfile;
+import com.mojang.authlib.GameProfileRepository;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.api.user.UserInfo;
+import net.kissenpvp.core.api.user.UserRepository;
+import net.minecraft.server.players.GameProfileCache;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Optional;
+import java.util.UUID;
+import java.util.function.Function;
+
+/**
+ * KissenPaperProfileCache is a cache specifically designed for KissenPaper profiles.
+ * This cache extends the {@code GameProfileCache} class to provide additional functionalities
+ * specific to the KissenPaper profiles. It has been designed to be used in the KissenPaper game application.
+ */
+public class KissenPaperProfileCache extends GameProfileCache {
+
+    private final UserRepository userRepository;
+
+    /**
+     * Creates a new instance of KissenPaperProfileCache.
+     *
+     * @param profileRepository - a not-null instance of a GameProfileRepository which is used to fetch and cache profiles
+     * @throws IllegalArgumentException if profileRepository is null
+     */
+    public KissenPaperProfileCache(@NotNull GameProfileRepository profileRepository) {
+        //noinspection DataFlowIssue
+        super(profileRepository, null); // not file based
+        userRepository = new KissenPaperUserRepository(profileRepository);
+        KissenPaperUserImplementation.setProfileCache(this);
+    }
+
+    @Override
+    public void add(@NotNull GameProfile profile) { /* moved to net.kissenpvp.core.user.KissenPublicUser#setup(String, Map) */ }
+
+    @Nullable
+    @Override
+    public GameProfile getProfileIfCached(@NotNull String name) {
+        return get(name).orElse(null);
+    }
+
+    @Override
+    public @NotNull Optional<GameProfile> get(@NotNull String name) {
+        return Bukkit.getKissen().getImplementation(UserImplementation.class).getCachedUserProfile(name).map(transformUserInfo()).or(() -> getUserRepository().getUser(name).join().map(translateUser()));
+    }
+
+    @Override
+    public @NotNull Optional<GameProfile> get(@NotNull UUID uuid) {
+        return Bukkit.getKissen().getImplementation(UserImplementation.class).getCachedUserProfile(uuid).map(transformUserInfo()).or(() -> getUserRepository().getUser(uuid).join().map(translateUser()));
+    }
+
+    @Override
+    protected @NotNull List<GameProfileInfo> load() {
+        // ignored
+        return new ArrayList<>();
+    }
+
+    @Override
+    public void save(boolean asyncSave) {
+        // ignored
+    }
+
+    private @NotNull Function<UserInfo, GameProfile> transformUserInfo() {
+        return userInfo -> new GameProfile(userInfo.getUUID(), userInfo.getName());
+    }
+
+    /**
+     * Returns the UserRepository object used within this class.
+     *
+     * @return UserRepository that this class uses to perform user related operations
+     */
+    public @NotNull UserRepository getUserRepository() {
+        return userRepository;
+    }
+
+    /**
+     * Returns a Function that can be used to translate a User object into a GameProfile.
+     *
+     * @return Function that translates a User object into a GameProfile
+     */
+    @Contract(pure = true)
+    private @NotNull Function<User, GameProfile> translateUser() {
+        return user -> new GameProfile((UUID) user.getRawID(), user.getName());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenPaperPublicUser.java b/src/main/java/net/kissenpvp/paper/user/KissenPaperPublicUser.java
new file mode 100644
index 0000000000000000000000000000000000000000..dcb89301584f021de9e1ee45e60eb8ad86c99b8d
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/KissenPaperPublicUser.java
@@ -0,0 +1,245 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.user;
+
+import net.kissenpvp.core.api.database.DataWriter;
+import net.kissenpvp.core.api.database.StorageImplementation;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.database.meta.Meta;
+import net.kissenpvp.core.api.database.meta.Table;
+import net.kissenpvp.core.api.database.meta.list.MetaList;
+import net.kissenpvp.core.api.database.savable.SavableMap;
+import net.kissenpvp.core.api.networking.client.entitiy.PlayerClient;
+import net.kissenpvp.core.api.networking.socket.DataPackage;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.ban.warn.WarnNode;
+import net.kissenpvp.core.base.KissenCore;
+import net.kissenpvp.core.database.savable.KissenSavableMap;
+import net.kissenpvp.core.event.EventImplementation;
+import net.kissenpvp.core.permission.PermissionNode;
+import net.kissenpvp.core.user.KissenPublicUser;
+import net.kissenpvp.core.user.KissenUser;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.Permission;
+import net.kissenpvp.paper.api.user.event.VisualChangeEvent;
+import net.kissenpvp.paper.permission.KissenPaperPermission;
+import org.bukkit.Bukkit;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Map;
+import java.util.Objects;
+import java.util.UUID;
+
+/**
+ * The {@code KissenPaperPublicUser} class extends the {@link KissenPublicUser} class with {@link Permission}
+ * as its generic type. It represents a public user within the KissenPaper system.
+ * <p>
+ * While it maintains the key characteristics of a {@link KissenPublicUser}, such as a UUID and name,
+ * the {@code KissenPaperPublicUser} further enhances this with specifics for a user that has a public profile
+ * accessible across multiple servers.
+ *
+ * @see KissenPublicUser
+ */
+public class KissenPaperPublicUser extends KissenPublicUser<Permission> {
+
+    /**
+     * The constructor for the {@code KissenPaperPublicUser} class.
+     * It initializes a new instance of the class with a specified UUID and name.
+     *
+     * @param uuid A unique identifier. It may be nullable, representing a user, whose unique identifier
+     *             might not be known or relevant at the expire of creation.
+     * @param name A string representing the username. It may be nullable, representing a user whose name
+     *             might not be known or relevant at the expire of creation.
+     * @throws BackendException If an error occurs during the creation and initialization of a KissenPaperPublicUser instance.
+     */
+    public KissenPaperPublicUser(@Nullable UUID uuid, @Nullable String name) throws BackendException {
+        super(uuid, name);
+    }
+
+    public @NotNull MetaList<WarnNode> getWarns() {
+        return getRepository().getListNotNull("warn_list", WarnNode.class);
+    }
+
+    @Override
+    public @NotNull PlayerClient<?, ?> getPlayerClient() {
+        return getPrivateUserEntry().getPlayerClient();
+    }
+
+    @Override
+    protected @NotNull Permission translatePermission(@NotNull PermissionNode permissionNode, @Nullable DataWriter<PermissionNode> dataWriter) {
+        return new KissenPaperPermission(permissionNode, this, dataWriter);
+    }
+
+    @Override
+    public void sendData(@NotNull DataPackage dataPackage) {
+        // TODO Networking and stuff
+    }
+
+    @Override
+    public void login() {
+        super.login();
+
+        ((KissenUser<?>) getPrivateUserEntry()).login();
+        getStorage().put("tick", true);
+    }
+
+    @Override
+    public void logout() {
+        super.logout();
+        Bukkit.getKissen().getImplementation(StorageImplementation.class).dropStorage(getDatabaseID());
+    }
+
+    @Override
+    public void tick() {
+        super.tick();
+        checkVisuals();
+
+        ((KissenUser<Permission>) getPrivateUserEntry()).tick();
+    }
+
+    @Override
+    protected @NotNull SavableMap createRepository(@Nullable Map<String, Object> data) {
+        Meta meta = Bukkit.getKissen().getImplementation(KissenPaperUserImplementation.class).getMeta(Context.GLOBAL);
+        return new KissenSavableMap(getDatabaseID(), meta, Objects.requireNonNullElseGet(data, meta.getData(getDatabaseID())::join));
+    }
+
+    @Override
+    public int softDelete() throws BackendException {
+        return super.softDelete() + getPrivateUserEntry().delete();
+    }
+
+    /**
+     * The {@code getPrivateUserEntry} method retrieves an instance of a private user entry from the local storage.
+     * If the private user entry is not yet in the storage, it creates an entry using the 'setupPrivateUser' method.
+     * In case of an exception when creating the private user entry, an error log is produced, and the server
+     * is advised to be shut down to prevent further data problems.
+     *
+     * @return An instance of a {@link User} associated with the private user entry.
+     * Cast is performed without check, which assumes that "private_user_entry" in the storage is always of {@link User} type.
+     */
+    public @NotNull User getPrivateUserEntry() {
+        return (User) getStorage().computeIfAbsent("private_user_entry", (key) -> {
+            return setupPrivateUser((UUID) getRawID(), getRepository().getNotNull("name", String.class)); // If offline still return actual private entity
+        });
+    }
+
+    /**
+     * The {@code setupPrivateUser} method creates a new instance of a private user, {@link KissenPaperPrivateUser}, using provided UUID and username.
+     *
+     * @param uuid The UUID for the private user to be created.
+     * @param name The username of the private user.
+     * @return An instance of a {@link KissenPaperPrivateUser} initialized with the provided UUID and username.
+     * @throws BackendException If an error occurs during the creation and initialization of a KissenPaperPrivateUser instance.
+     * @see KissenPaperPrivateUser
+     */
+    protected @NotNull KissenPaperPrivateUser setupPrivateUser(UUID uuid, String name) throws BackendException {
+        return new KissenPaperPrivateUser(uuid, name);
+    }
+
+    private void checkVisuals() {
+        int visualHash = getVisualHash();
+        if (!Objects.equals(getStorage().get("visual_hash"), visualHash)) {
+            extracted(visualHash);
+        }
+    }
+
+    private void extracted(int visualHash) {
+        getStorage().put("visual_hash", visualHash);
+
+        if (getStorage().containsKey("tick")) {
+            ((KissenUser<?>) getPrivateUserEntry()).clearCache();
+            permissionUpdate();
+        }
+
+        Runnable update = () -> {
+            Player player = Objects.requireNonNull(Bukkit.getPlayer((UUID) getRawID()));
+            VisualChangeEvent visualChangeEvent = new VisualChangeEvent(player);
+            Bukkit.getKissen().getImplementation(EventImplementation.class).call(visualChangeEvent);
+        };
+
+        if (!Bukkit.isPrimaryThread()) {
+            KissenCore.getInstance().runTask(update, 0, "Visual Update");
+            return;
+        }
+        update.run();
+    }
+
+    private int getVisualHash() {
+        return getPlayerClient().getRank().hashCode() + displayName().hashCode();
+    }
+
+    /**
+     * The nested class {@code KissenPaperPrivateUser} extends the {@link KissenUser} class while specifying {@link Permission}
+     * as its generic type. It represents a private user entity within the KissenPaper system.
+     * <p>
+     * While the key characteristics of a {@link KissenUser} are maintained such as a UUID and name,
+     * the KissenPaperPrivateUser further enhances this with specifics for a user that owns a private profile which only this
+     * server can access.
+     *
+     * @see KissenUser
+     */
+    public static class KissenPaperPrivateUser extends KissenUser<Permission> {
+
+        /**
+         * The constructor for the {@code KissenPaperPrivateUser} class.
+         * It initializes a new instance of the class with specified UUID and name.
+         *
+         * @param uuid A unique identifier. It may be nullable, representing a user whose unique identifier
+         *             might not be known or relevant at the expire of creation.
+         * @param name A string representing the username. It may be nullable, representing a user whose name
+         *             might not be known or relevant at the expire of creation.
+         * @throws BackendException If an error occurs during the creation and initialization of a KissenPaperPrivateUser instance.
+         */
+        public KissenPaperPrivateUser(@Nullable UUID uuid, @Nullable String name) throws BackendException {
+            super(uuid, name);
+        }
+
+        @Override
+        public @NotNull Table getTable() {
+            return Bukkit.getKissen().getImplementation(KissenPaperUserImplementation.class).getTable(Context.LOCAL);
+        }
+
+        @Override
+        protected @NotNull SavableMap createRepository(@Nullable Map<String, Object> data) {
+            Meta meta = Bukkit.getKissen().getImplementation(KissenPaperUserImplementation.class).getMeta(Context.LOCAL);
+            return new KissenSavableMap(getDatabaseID(), meta, Objects.requireNonNullElseGet(data, meta.getData(getDatabaseID())::join));
+        }
+
+        @Override
+        public @NotNull String getSaveID() {
+            return ((KissenPaperUserImplementation) getImplementation()).getUserSaveID(Context.LOCAL);
+        }
+
+        @Override
+        public @NotNull PlayerClient<?, ?> getPlayerClient() {
+            UUID uuid = getRawID();
+            return Objects.requireNonNullElse(Bukkit.getPlayer(uuid), Bukkit.getOfflinePlayer(uuid));
+        }
+
+        @Override
+        protected @NotNull Permission translatePermission(@NotNull PermissionNode permissionNode, @Nullable DataWriter<PermissionNode> dataWriter) {
+            return new KissenPaperPermission(permissionNode, this, dataWriter);
+        }
+
+        @Override
+        public void sendData(@NotNull DataPackage dataPackage) { /* Ignored because it's private */ }
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenPaperUserImplementation.java b/src/main/java/net/kissenpvp/paper/user/KissenPaperUserImplementation.java
new file mode 100644
index 0000000000000000000000000000000000000000..cbbb6a3a19e63470bdbc2d9727cf55a9027c0045
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/KissenPaperUserImplementation.java
@@ -0,0 +1,169 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.user;
+
+import net.kissenpvp.core.api.database.connection.DatabaseConnection;
+import net.kissenpvp.core.api.database.connection.DatabaseImplementation;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.database.meta.Meta;
+import net.kissenpvp.core.api.database.savable.SavableMap;
+import net.kissenpvp.core.api.networking.client.entitiy.UnknownPlayerException;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.base.KissenImplementation;
+import net.kissenpvp.core.command.InternalCommandImplementation;
+import net.kissenpvp.core.database.KissenTable;
+import net.kissenpvp.core.message.localization.KissenLocalizationImplementation;
+import net.kissenpvp.core.user.KissenUserImplementation;
+import net.kissenpvp.paper.api.base.Context;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+
+import java.text.MessageFormat;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.function.Supplier;
+
+/**
+ * The class 'KissenPaperUserImplementation' is an extension of the 'KissenUserImplementation' in the KissenPaper system.
+ * This class is responsible for interacting with or manipulating the paper-related functionality of a Kissen user.
+ * The class holds an instance of KissenPaperProfileCache which it uses to cache profiles for efficient read operations.
+ */
+public class KissenPaperUserImplementation extends KissenUserImplementation implements KissenImplementation {
+
+    private static KissenPaperProfileCache profileCache;
+    private KissenTable privateTable;
+
+    /**
+     * This private static method retrieves the current instance of KissenPaperProfileCache.
+     *
+     * @return The current KissenPaperProfileCache instance.
+     */
+    private static KissenPaperProfileCache getProfileCache() {
+        return profileCache;
+    }
+
+    /**
+     * This public static method sets the KissenPaperProfileCache with a new instance.
+     * The method expects to receive an instance of KissenPaperProfileCache.
+     * If the input is null, an IllegalStateException will be thrown.
+     *
+     * @param profileCache A new KissenPaperProfileCache instance.
+     * @throws IllegalStateException If the provided KissenPaperProfileCache instance is null.
+     */
+    public static void setProfileCache(KissenPaperProfileCache profileCache) {
+        if (profileCache == null) {
+            throw new IllegalStateException("Object already initialized.");
+        }
+        KissenPaperUserImplementation.profileCache = profileCache;
+    }
+
+    public @NotNull KissenTable getTable(@NotNull Context context)
+    {
+        return switch (context)
+        {
+            case GLOBAL -> super.getTable();
+            case LOCAL -> privateTable;
+        };
+    }
+
+    @Override
+    public boolean preStart() {
+        DatabaseImplementation database = Bukkit.getKissen().getImplementation(DatabaseImplementation.class);
+
+        DatabaseConnection connection = database.getConnection("private").orElseGet(database::getPrimaryConnection);
+        privateTable = (KissenTable) connection.createTable("kissen_private_user_data");
+        return super.preStart();
+    }
+
+    @Override
+    public boolean start() {
+        InternalCommandImplementation<?> commandImplementation = Bukkit.getKissen().getImplementation(InternalCommandImplementation.class);
+        commandImplementation.getInternalHandler().registerExceptionHandler(new PlayerSettingCommand());
+
+        KissenLocalizationImplementation localize = Bukkit.getKissen().getImplementation(KissenLocalizationImplementation.class);
+        localize.register("server.user.setting.changed", new MessageFormat("The setting {0} has been set to {1}."));
+        localize.register("server.user.setting.value.invalid", new MessageFormat("The value {0} is not allowed in setting {1}."));
+        localize.register("server.user.setting.not.found", new MessageFormat("The setting {0} does not exists."));
+        localize.register("server.user.setting.reset", new MessageFormat("The setting {1} has been reset to its default value {0}."));
+
+        localize.register("server.user.suffix.granted", new MessageFormat("The suffix {0} was granted to {1}."));
+        localize.register("server.user.suffix.received", new MessageFormat("You have received the suffix {0}."));
+        localize.register("server.user.suffix.revoked", new MessageFormat("The suffix {0} from player {1} was revoked."));
+        localize.register("server.user.suffix.not.found", new MessageFormat("The suffix {0} from player {1} was not found."));
+
+        return super.start();
+    }
+
+    @Override
+    public void setupComplete() {
+        InternalCommandImplementation<?> commandImplementation = Bukkit.getKissen().getImplementation(InternalCommandImplementation.class);
+        commandImplementation.getInternalHandler().registerCommand(new PlayerSettingCommand());
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull UUID uuid) {
+
+        Supplier<User> createUser = () -> profileCache.getUserRepository().getUser(uuid).join().orElseThrow(() -> new UnknownPlayerException(String.valueOf(uuid)));
+        Supplier<User> loadUser = () -> {
+            CompletableFuture<SavableMap> future = getMeta(Context.GLOBAL).getData(getUserSaveID() + uuid);
+            return new KissenPaperPublicUser(uuid, null);
+        };
+        return getOnlineUser(uuid).orElseGet(loadUser);
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull String name) throws BackendException {
+        try {
+            if (getUserProfiles().stream().noneMatch(userInfo -> userInfo.getName().equals(name))) {
+                throw new UnknownPlayerException(name);
+            }
+            return super.getUser(name);
+        } catch (UnknownPlayerException unknownPlayerException) {
+            return profileCache.getUserRepository().getUser(name).join().orElseThrow(() -> new UnknownPlayerException(name));
+        }
+    }
+
+    /**
+     * Returns the User Save ID for the specified context.
+     *
+     * @param context an enum constant representing the context, either GLOBAL or LOCAL
+     * @return String representing the User Save ID. If context is GLOBAL, the ID is retrieved by getUserSaveID(),
+     * otherwise for LOCAL context, Returns the server's name concatenated with 'privateuser'.
+     */
+    public @NotNull String getUserSaveID(@NotNull Context context) {
+        return switch (context) {
+            case GLOBAL -> getUserSaveID();
+            case LOCAL -> "privateuser";
+        };
+    }
+
+    /**
+     * Returns the User MetaData for the specified context.
+     *
+     * @param context an enum constant indicating the context, either GLOBAL or LOCAL
+     * @return ObjectMeta instance representing User's metadata. If context is GLOBAL, the metadata is retrieved by getUserMeta(),
+     * otherwise for LOCAL context, Returns the private metadata available in Bukkit's 'Kissen'.
+     */
+    public @NotNull Meta getMeta(@NotNull Context context) {
+        return switch (context) {
+            case GLOBAL -> super.getMeta();
+            case LOCAL -> privateTable.setupMeta(null);
+        };
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenPaperUserRepository.java b/src/main/java/net/kissenpvp/paper/user/KissenPaperUserRepository.java
new file mode 100644
index 0000000000000000000000000000000000000000..74477d0a2bdd4df9f09bab3cbaec1ce7a7e749a5
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/KissenPaperUserRepository.java
@@ -0,0 +1,132 @@
+package net.kissenpvp.paper.user;
+
+import com.mojang.authlib.GameProfile;
+import com.mojang.authlib.GameProfileRepository;
+import com.mojang.authlib.ProfileLookupCallback;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.api.user.UserRepository;
+import net.minecraft.core.UUIDUtil;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Optional;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.atomic.AtomicReference;
+
+/**
+ * The class 'KissenPaperUserRepository' implements the 'UserRepository' interface.
+ * It represents a repository for the User entities from mojang.
+ * Compliant with the Repository pattern, this class is intended to encapsulate all
+ * data access mechanics needed for User entities.
+ * <p>
+ * It also holds a 'GameProfileRepository' which perhaps holds the source data for the
+ * Users, or is another important factor in the retrieval or manipulation of User data.
+ */
+public class KissenPaperUserRepository implements UserRepository {
+
+    private final GameProfileRepository gameProfileRepository;
+
+    /**
+     * The constructor for the 'KissenPaperUserRepository' class.
+     * It initializes a new instance of the class with a specified 'GameProfileRepository' object.
+     *
+     * @param gameProfileRepository A 'GameProfileRepository' object.
+     * Specifies the game profile repository that the user repository will work with.
+     */
+    public KissenPaperUserRepository(@NotNull GameProfileRepository gameProfileRepository) {
+        this.gameProfileRepository = gameProfileRepository;
+    }
+
+    @Override
+    public @NotNull CompletableFuture<Optional<User>> getUser(@NotNull String name) throws BackendException {
+
+        if(!shouldAuthorize())
+        {
+
+        }
+
+        CompletableFuture<Optional<User>> gameProfileCompletableFuture = new CompletableFuture<>();
+        AtomicReference<Optional<GameProfile>> fetchedRef = new AtomicReference<>(Optional.empty());
+
+        gameProfileRepository.findProfilesByNames(new String[]{name}, new ProfileLookupCallback() {
+            @Override
+            public void onProfileLookupSucceeded(GameProfile gameProfile) {
+                fetchedRef.set(Optional.ofNullable(gameProfile));
+            }
+
+            @Override
+            public void onProfileLookupFailed(String s, Exception e) {
+                gameProfileCompletableFuture.completeExceptionally(e);
+            }
+        });
+
+        fetchedRef.get().ifPresentOrElse(gameProfile -> processGameProfile(gameProfileCompletableFuture, gameProfile), () -> processMissingProfile(gameProfileCompletableFuture, name));
+
+        return gameProfileCompletableFuture;
+    }
+
+    @Override
+    public @NotNull CompletableFuture<Optional<User>> getUser(@NotNull UUID uuid) {
+        return null; //TODO
+    }
+
+    /**
+     * This method is used to determine whether authorization should take place.
+     * Its behaviour may be determined by the 'GlobalConfiguration' setting 'isProxyOnlineMode'.
+     * The return value implies whether the proxy is in online mode or not,
+     * which further implies whether authentication is needed.
+     *
+     * @return A boolean value -- 'true' when proxy is in online mode implying authorization
+     * is required for network interactions, 'false' otherwise.
+     */
+    private boolean shouldAuthorize()
+    {
+        return io.papermc.paper.configuration.GlobalConfiguration.get().proxies.isProxyOnlineMode();
+    }
+
+    /**
+     * Processes a potentially missing user profile. If authentication is not required,
+     * it will generate and process a "cracked" user profile with an offline player UUID.
+     * Otherwise, the method will complete the CompletableFuture with an empty Optional.
+     *
+     * @param gameProfileFuture a CompletableFuture that will be completed with the found (or not found) User
+     * @param name the name of the user to lookup
+     */
+    private void processMissingProfile(CompletableFuture<Optional<User>> gameProfileFuture, String name) {
+        if (!shouldAuthorize()) {
+            // Create cracked user
+            UUID offlineUUID = UUIDUtil.createOfflinePlayerUUID(name);
+            processGameProfile(gameProfileFuture, new GameProfile(offlineUUID, name));
+            return;
+        }
+        gameProfileFuture.complete(Optional.empty());
+    }
+
+    /**
+     * Processes a game profile and completes the CompletableFuture with the translated User object.
+     * If any error occurs during the translation, the resulting BackendException will be completed exceptionally
+     * inside the CompletableFuture.
+     *
+     * @param gameProfileFuture a CompletableFuture that will be completed with the translated User or an Error.
+     * @param gameProfile the game profile to process.
+     */
+    private void processGameProfile(CompletableFuture<Optional<User>> gameProfileFuture, GameProfile gameProfile) {
+        try {
+            gameProfileFuture.complete(Optional.of(translate(gameProfile)));
+        } catch (BackendException backendException) {
+            gameProfileFuture.completeExceptionally(backendException);
+        }
+    }
+
+    /**
+     * Translates a game profile into a KissenPaperPublicUser object.
+     *
+     * @param gameProfile the game profile to translate.
+     * @return KissenPaperPublicUser a new user object with the id and name from the passed game profile.
+     * @throws BackendException if any error occurs during the translation process.
+     */
+    private @NotNull User translate(@NotNull GameProfile gameProfile) throws BackendException {
+        return new KissenPaperPublicUser(gameProfile.getId(), gameProfile.getName());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenUserOperatorList.java b/src/main/java/net/kissenpvp/paper/user/KissenUserOperatorList.java
new file mode 100644
index 0000000000000000000000000000000000000000..b09f063fb5b9cd702fc359fd9c517d209f164915
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/KissenUserOperatorList.java
@@ -0,0 +1,247 @@
+package net.kissenpvp.paper.user;
+
+import com.google.gson.JsonObject;
+import com.mojang.authlib.GameProfile;
+import net.kissenpvp.core.api.database.meta.Meta;
+import net.kissenpvp.core.api.database.meta.list.MetaList;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.api.user.UserInfo;
+import net.kissenpvp.paper.api.base.Context;
+import net.minecraft.server.players.ServerOpList;
+import net.minecraft.server.players.ServerOpListEntry;
+import net.minecraft.server.players.StoredUserEntry;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.File;
+import java.util.*;
+import java.util.function.Function;
+import java.util.function.Predicate;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+/**
+ * This is a class that extends the functionality of StoredUserList. It provides functionality to manage a list
+ * of users and their operation permissions(data represented by type ServerOpListEntry), related to a game profile
+ * (data represented by type GameProfile).
+ * <p>
+ * An instance of it can be created by providing a file which acts as the storage medium for
+ * this user list.
+ * <p>
+ * This class may provide additions to StoredUserList, capturing behaviors specific to users
+ * who have operator permissions (as denoted by a ServerOpListEntry) linked to a specific game profile.
+ */
+public class KissenUserOperatorList extends ServerOpList {
+
+    private MetaList<OperatorData> cached;
+
+    /**
+     * Creates a predicate for comparing {@link OperatorData} based on the equality of their associated {@link GameProfile}.
+     *
+     * <p>This method returns a {@link Predicate} that compares {@link OperatorData} based on the equality of their associated {@link GameProfile}.
+     * The returned predicate tests whether the {@link GameProfile} ID of the provided {@link OperatorData} is equal to the ID of the specified {@link GameProfile}.</p>
+     *
+     * @param gameProfile the {@link GameProfile} to compare against
+     * @return a {@link Predicate} for comparing {@link OperatorData} based on the equality of their associated {@link GameProfile}
+     * @throws NullPointerException if the specified {@link GameProfile} is `null`
+     * @see OperatorData
+     * @see GameProfile
+     */
+    @Contract(pure = true, value = "_ -> new")
+    private static @NotNull Predicate<OperatorData> equals(@NotNull GameProfile gameProfile) {
+        return info -> Objects.equals(info.uuid(), gameProfile.getId());
+    }
+
+    /**
+     * This is a class that extends the functionality of StoredUserList. It provides functionality to manage a list
+     * of users and their operation permissions (data represented by type ServerOpListEntry), related to a game profile
+     * (data represented by type GameProfile).
+     * <p>
+     * It is initially not associated with any file storage. Thus, the user list is not loaded from any file nor
+     * does it persist between application invocations if not manually persisted.
+     * <p>
+     * This class may provide additions to StoredUserList, capturing behaviors specific to users
+     * who have operator permissions (as denoted by a ServerOpListEntry) linked to a specific game profile.
+     */
+    public KissenUserOperatorList() {
+        //noinspection DataFlowIssue
+        super(null); // not file based
+    }
+
+    @Override
+    public void add(@NotNull ServerOpListEntry entry) {
+        UUID id = Objects.requireNonNull(entry.getUser()).getId();
+        cached.add(new OperatorData(id, entry.getLevel(), entry.getBypassesPlayerLimit()));
+    }
+
+    @Nullable
+    @Override
+    public ServerOpListEntry get(@NotNull GameProfile key) {
+        return getCached(key).map(OperatorData::getServerOpListEntry).orElse(null);
+    }
+
+    @Override
+    public void remove(@NotNull StoredUserEntry<GameProfile> entry) {
+        remove(Objects.requireNonNull(entry.getUser()));
+    }
+
+    @Override
+    public void remove(@NotNull GameProfile key) {
+        cached.removeIf(equals(key));
+    }
+
+    @Override
+    public String @NotNull [] getUserList() {
+        return getCached().stream().flatMap(node -> {
+            GameProfile info = node.getServerOpListEntry().getUser();
+            return Stream.of(Objects.requireNonNull(info).getName());
+        }).toArray(String[]::new);
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return getCached().isEmpty();
+    }
+
+    @Override
+    protected boolean contains(@NotNull GameProfile k0) {
+        return getCached(k0).isPresent();
+    }
+
+    @Override
+    public @NotNull Collection<ServerOpListEntry> getEntries() {
+        return getCached().stream().map(OperatorData::getServerOpListEntry).collect(Collectors.toSet());
+    }
+
+    @Override
+    public void save() {
+        //ignored
+    }
+
+    @Override
+    protected @NotNull StoredUserEntry<GameProfile> createEntry(@NotNull JsonObject json) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public @NotNull File getFile() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void load() {
+        cached = getMeta().getCollection("operator_players", OperatorData.class).join();
+    }
+
+    @Override
+    protected @NotNull String getKeyForUser(@NotNull GameProfile profile) {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Retrieves implementation of {@link KissenPaperUserImplementation} for {@link Context#LOCAL} and gets User Metadata.
+     *
+     * @return object meta of the local user.
+     */
+    protected @NotNull Meta getMeta() {
+        return Bukkit.getKissen().getImplementation(KissenPaperUserImplementation.class).getMeta(Context.LOCAL);
+    }
+
+    /**
+     * Retrieves the cached {@link OperatorData} associated with the specified {@link GameProfile}, if present.
+     *
+     * <p>This method retrieves the cached {@link OperatorData} from the set of cached data by filtering the set based on the provided {@link GameProfile}.
+     * If the cached data for the specified {@link GameProfile} is found, it is wrapped in an {@link Optional} and returned; otherwise, an empty {@link Optional} is returned.</p>
+     *
+     * @param gameProfile the {@link GameProfile} for which to retrieve the cached {@link OperatorData}
+     * @return an {@link Optional} containing the cached {@link OperatorData} associated with the specified {@link GameProfile},
+     * or an empty {@link Optional} if no data is found for the specified {@link GameProfile}
+     * @throws NullPointerException if the specified {@link GameProfile} is `null`
+     * @see OperatorData
+     * @see GameProfile
+     */
+    protected @NotNull Optional<OperatorData> getCached(@NotNull GameProfile gameProfile) {
+        return getCached().stream().filter(equals(gameProfile)).findFirst();
+    }
+
+    /**
+     * Retrieves the set of LinkedOperatorDataNodes.
+     * <p>
+     * This method returns a set that contains all the LinkedOperatorDataNodes
+     * that are currently being managed.
+     *
+     * @return A Set containing all LinkedOperatorDataNodes.
+     * This returned set is not null.
+     */
+    protected @NotNull Set<OperatorData> getCached()
+    {
+        return Set.copyOf(cached);
+    }
+
+    /**
+     * Represents data for an operator.
+     *
+     * <p>An {@code OperatorData} object encapsulates information about an operator, including their UUID, level, and whether they can bypass server limits.</p>
+     *
+     * @param uuid the UUID of the operator. This value is not `null`.
+     * @param level the level of the operator.
+     * @param bypassServerLimit {@code true} if the operator can bypass server limits; {@code false} otherwise.
+     * @see UUID
+     */
+    protected record OperatorData(@NotNull UUID uuid, int level, boolean bypassServerLimit) {
+
+        /**
+         * Converts {@link UserInfo} to {@link GameProfile}.
+         *
+         * <p>This method returns a {@link Function} that converts a {@link UserInfo} object to a {@link GameProfile}.
+         * The returned function creates a new {@link GameProfile} using the UUID and name obtained from the provided {@link UserInfo}.</p>
+         *
+         * @return a {@link Function} for converting {@link UserInfo} to {@link GameProfile}
+         * @see UserInfo
+         * @see GameProfile
+         */
+        @Contract(pure = true, value = "-> new")
+        private static @NotNull Function<UserInfo, GameProfile> toGameProfile() {
+            return userInfo -> new GameProfile(userInfo.getUUID(), userInfo.getName());
+        }
+
+        /**
+         * Retrieves the {@link ServerOpListEntry} associated with this operator.
+         *
+         * <p>This method retrieves the {@link ServerOpListEntry} associated with this operator.
+         * It obtains the {@link GameProfile} from the cached user profile using the operator's UUID,
+         * then constructs a new {@link ServerOpListEntry} using the obtained {@link GameProfile},
+         * the operator's level, and whether the operator can bypass server limits.</p>
+         *
+         * @return the {@link ServerOpListEntry} associated with this operator
+         * @throws NoSuchElementException if the cached user profile is not present for the operator's UUID
+         * @see ServerOpListEntry
+         */
+        public @NotNull ServerOpListEntry getServerOpListEntry() {
+            UserImplementation userImplementation = Bukkit.getKissen().getImplementation(UserImplementation.class);
+            GameProfile gameProfile = userImplementation.getCachedUserProfile(uuid()).map(toGameProfile()).orElseThrow();
+            return new ServerOpListEntry(gameProfile, level(), bypassServerLimit());
+        }
+
+        @Contract(pure = true)
+        @Override
+        public @NotNull String toString() {
+            return "OperatorData{" + "uuid=" + uuid + ", level=" + level + ", bypassServerLimit=" + bypassServerLimit + '}';
+        }
+
+        @Override
+        public boolean equals(Object object) {
+            if (this == object) return true;
+            if (object == null || getClass() != object.getClass()) return false;
+            OperatorData that = (OperatorData) object;
+            return Objects.equals(uuid, that.uuid);
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hashCode(uuid);
+        }
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenUserWhiteList.java b/src/main/java/net/kissenpvp/paper/user/KissenUserWhiteList.java
new file mode 100644
index 0000000000000000000000000000000000000000..d8c589da70c14e03f7b6a4b59d4d8938867f864d
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/KissenUserWhiteList.java
@@ -0,0 +1,142 @@
+package net.kissenpvp.paper.user;
+
+import com.google.gson.JsonObject;
+import com.mojang.authlib.GameProfile;
+import net.kissenpvp.core.api.database.meta.list.MetaList;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.api.user.UserInfo;
+import net.kissenpvp.paper.api.base.Context;
+import net.minecraft.server.players.StoredUserEntry;
+import net.minecraft.server.players.UserWhiteList;
+import net.minecraft.server.players.UserWhiteListEntry;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Collection;
+import java.util.Objects;
+import java.util.Set;
+import java.util.UUID;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+
+/**
+ * Represents a user whitelist specific to the Kissen application.
+ *
+ * <p>The {@code KissenUserWhiteList} class extends {@link UserWhiteList} and provides functionality for managing a whitelist of users
+ * specific to the Kissen application. This class is not file-based, meaning it does not rely on external files for storing user whitelist data.</p>
+ *
+ * @see UserWhiteList
+ */
+public class KissenUserWhiteList extends UserWhiteList {
+
+    private MetaList<UUID> whitelisted;
+
+    /**
+     * Constructs a new instance of {@code KissenUserWhiteList}.
+     *
+     * <p>This constructor initializes the whitelist of users specific to the Kissen application. It sets up an empty HashSet to store whitelisted users.</p>
+     */
+    public KissenUserWhiteList() {
+        //noinspection DataFlowIssue
+        super(null); // not file based
+    }
+
+    private static @NotNull KissenPaperUserImplementation getImplementation() {
+        return Bukkit.getKissen().getImplementation(KissenPaperUserImplementation.class);
+    }
+
+    @Override
+    public @NotNull File getFile() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Nullable
+    @Override
+    public UserWhiteListEntry get(@NotNull GameProfile key) {
+        return getWhitelisted().stream().filter(userInfo -> userInfo.getUUID().equals(key.getId())).map(user -> new UserWhiteListEntry(new GameProfile(user.getUUID(), user.getName()))).findFirst().orElse(null);
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return getWhitelisted().isEmpty();
+    }
+
+    @Override
+    protected boolean contains(@NotNull GameProfile k0) {
+        return getWhitelisted().stream().anyMatch(userInfo -> userInfo.getUUID().equals(k0.getId()));
+    }
+
+    @Override
+    public @NotNull Collection<UserWhiteListEntry> getEntries() {
+        return getWhitelisted().stream().map(userInfo -> new GameProfile(userInfo.getUUID(), userInfo.getName())).map(UserWhiteListEntry::new).collect(Collectors.toSet());
+    }
+
+    @Override
+    public String @NotNull [] getUserList() {
+        return getWhitelisted().stream().map(UserInfo::getName).distinct().toArray(String[]::new);
+    }
+
+    @Override
+    public void save() throws IOException {
+        // ignored
+    }
+
+    @Override
+    public void add(@NotNull UserWhiteListEntry entry) {
+        if (!new io.papermc.paper.event.server.WhitelistStateUpdateEvent(com.destroystokyo.paper.profile.CraftPlayerProfile.asBukkitCopy(Objects.requireNonNull(entry.getUser())), io.papermc.paper.event.server.WhitelistStateUpdateEvent.WhitelistStatus.ADDED).callEvent()) {
+            return;
+        }
+
+        UserImplementation userImplementation = getImplementation();
+        whitelisted.replaceOrInsert(entry.getUser().getId());
+    }
+
+    @Override
+    public void remove(@NotNull StoredUserEntry<GameProfile> entry) {
+        remove(Objects.requireNonNull(entry.getUser()));
+    }
+
+    @Override
+    protected @NotNull StoredUserEntry<GameProfile> createEntry(@NotNull JsonObject json) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    protected @NotNull String getKeyForUser(@NotNull GameProfile gameProfile) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void remove(@NotNull GameProfile profile) {
+        if (!new io.papermc.paper.event.server.WhitelistStateUpdateEvent(com.destroystokyo.paper.profile.CraftPlayerProfile.asBukkitCopy(profile), io.papermc.paper.event.server.WhitelistStateUpdateEvent.WhitelistStatus.REMOVED).callEvent()) {
+            return;
+        }
+
+        whitelisted.remove(profile.getId());
+    }
+
+    @Override
+    public void load() throws IOException {
+        whitelisted = getImplementation().getMeta(Context.LOCAL).getCollection("whitelisted_players", UUID.class).join();
+    }
+
+    /**
+     * Retrieves the set of whitelisted user information.
+     *
+     * <p>This method returns an unmodifiable set containing user information of whitelisted users. Any attempt to modify the returned set will result in an UnsupportedOperationException.
+     * The set returned by this method is backed by the original set, meaning changes to the original set will be reflected in the returned set and vice versa.</p>
+     *
+     * @return an unmodifiable set containing user information of whitelisted users
+     * @see UserInfo
+     */
+    protected @NotNull Set<UserInfo> getWhitelisted() {
+        UserImplementation user = getImplementation();
+        Function<UUID, Stream<UserInfo>> toUser = uuid -> user.getCachedUserProfile(uuid).stream();
+        return whitelisted.stream().flatMap(toUser).collect(Collectors.toUnmodifiableSet());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/PlayerSettingCommand.java b/src/main/java/net/kissenpvp/paper/user/PlayerSettingCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..e722ab642948bdacaa7f02a23b12361e8eb56047
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/PlayerSettingCommand.java
@@ -0,0 +1,109 @@
+package net.kissenpvp.paper.user;
+
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.core.api.command.CommandTarget;
+import net.kissenpvp.core.api.command.annotations.ArgumentName;
+import net.kissenpvp.core.api.command.annotations.CommandData;
+import net.kissenpvp.core.api.command.annotations.TabCompleter;
+import net.kissenpvp.core.api.networking.client.entitiy.PlayerClient;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.api.user.exception.UnauthorizedException;
+import net.kissenpvp.core.api.user.playersettting.RegisteredPlayerSetting;
+import net.kissenpvp.core.api.user.playersettting.UserValue;
+import net.kissenpvp.core.user.playersetting.IllegalSettingException;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.command.CommandExceptionHandler;
+import net.kissenpvp.paper.user.playersetting.KissenPaperBoundPlayerSetting;
+import net.kyori.adventure.text.Component;
+import org.bukkit.Bukkit;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Objects;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public class PlayerSettingCommand implements CommandExceptionHandler<IllegalSettingException>
+{
+    @Override
+    public boolean handle(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull IllegalSettingException throwable)
+    {
+        Component setting = Component.text(throwable.getSettingsKey());
+        commandPayload.getSender().sendMessage(Component.translatable("server.user.setting.not.found", setting));
+        return true;
+    }
+
+    @CommandData(value = "setting", runAsync = true, aliases = "settings", target = CommandTarget.PLAYER)
+    public void settingCommand(@NotNull CommandPayload<CommandSender> sender, @NotNull @ArgumentName("setting") String setting, @NotNull @ArgumentName("value") String... value) throws UnauthorizedException
+    {
+        sender.getSender().sendMessage(setSetting(sender, deserialize(setting), String.join(" ", value)));
+    }
+
+    private <T> @NotNull Component setSetting(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull RegisteredPlayerSetting<T, OfflinePlayer> settingsKey, @NotNull String value) throws UnauthorizedException
+    {
+        Component setting = Component.text(settingsKey.getParent().getKey());
+        try
+        {
+            boolean reset = value.equalsIgnoreCase("reset");
+            Player player = (Player) commandPayload.getSender();
+            KissenPaperBoundPlayerSetting<T> stetting = new KissenPaperBoundPlayerSetting<>(settingsKey, player);
+
+            T newValue = reset ? settingsKey.getParent().getDefaultValue(player):settingsKey.getParent().deserialize(value);
+            stetting.setValue(newValue);
+
+            String langKey = reset ? "server.user.setting.reset" : "server.user.setting.changed";
+            Component changedTo = Component.text(stetting.getSetting().getParent().serialize(newValue));
+            return Component.translatable(langKey, setting, changedTo);
+        }
+        catch (ClassCastException | IllegalArgumentException exception)
+        {
+            return Component.translatable("server.user.setting.value.invalid", setting, Component.text(value));
+        }
+    }
+
+    @TabCompleter("setting")
+    public @NotNull <S extends PlayerClient<?, ?>> Collection<String> settingCommand(@NotNull CommandPayload<CommandSender> payload)
+    {
+        try
+        {
+            if (payload.getArguments().length < 2)
+            {
+                return tabCompletion();
+            }
+
+            RegisteredPlayerSetting<?, S> setting = deserialize(payload.getArguments()[0]);
+            Stream<UserValue<?>> stream = Arrays.stream(setting.getParent().getPossibleValues((S) payload.getSender()));
+            Stream<String> possibilities = stream.map(value -> castUnknownValue(value, setting));
+            return Stream.concat(Stream.of("reset"), possibilities).collect(Collectors.toSet());
+        }
+        catch (IllegalSettingException ignored) {}
+        return Collections.EMPTY_SET;
+    }
+
+    public <S extends PlayerClient<?, ?>> @NotNull RegisteredPlayerSetting<?, S> deserialize(@NotNull String input)
+    {
+        UserImplementation userImplementation = Bukkit.getKissen().getImplementation(UserImplementation.class);
+        Stream<RegisteredPlayerSetting<?, ?>> settings = userImplementation.getPlayerSettings().stream();
+        return (RegisteredPlayerSetting<?, S>) settings.filter(userSetting -> {
+            String parentKey = userSetting.getParent().getKey();
+            return Objects.equals(parentKey, input);
+        }).findFirst().orElseThrow(() -> new IllegalSettingException(input));
+    }
+
+    public @NotNull Collection<String> tabCompletion()
+    {
+        UserImplementation userImplementation = Bukkit.getKissen().getImplementation(UserImplementation.class);
+        Stream<RegisteredPlayerSetting<?, ?>> settings = userImplementation.getPlayerSettings().stream();
+        return settings.map(setting -> setting.getParent().getKey()).collect(Collectors.toSet());
+    }
+
+    private <T> @NotNull String castUnknownValue(@NotNull Object value, @NotNull RegisteredPlayerSetting<T, ?> setting)
+    {
+        return setting.getParent().serialize(((UserValue<T>) value).value());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/playersetting/KissenPaperBoundPlayerSetting.java b/src/main/java/net/kissenpvp/paper/user/playersetting/KissenPaperBoundPlayerSetting.java
new file mode 100644
index 0000000000000000000000000000000000000000..d69b4d28b10a378be2f6f01783177798dc57fef5
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/playersetting/KissenPaperBoundPlayerSetting.java
@@ -0,0 +1,74 @@
+package net.kissenpvp.paper.user.playersetting;
+
+import net.kissenpvp.core.api.database.savable.SavableMap;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.api.user.exception.UnauthorizedException;
+import net.kissenpvp.core.api.user.playersettting.RegisteredPlayerSetting;
+import net.kissenpvp.core.api.user.playersettting.UserValue;
+import net.kissenpvp.core.user.playersetting.KissenBoundPlayerSetting;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.user.playersetting.BoundPlayerSetting;
+import org.bukkit.OfflinePlayer;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Objects;
+import java.util.Optional;
+
+public class KissenPaperBoundPlayerSetting<T> extends KissenBoundPlayerSetting<T, OfflinePlayer> implements BoundPlayerSetting<T> {
+
+    public KissenPaperBoundPlayerSetting(@NotNull RegisteredPlayerSetting<T, OfflinePlayer> setting, @NotNull OfflinePlayer player) {
+        super(setting, player);
+    }
+
+    @Override
+    public @NotNull T setValue(@NotNull T value) throws UnauthorizedException {
+        return setValue(value, Context.LOCAL);
+    }
+
+    @Override
+    public @NotNull T getValue() {
+        return super.getValue(getPlayer().getUser(Context.LOCAL)).or(() -> {
+            User globalUser = getPlayer().getUser(Context.GLOBAL);
+            return super.getValue(globalUser);
+        }).orElse(getSetting().getParent().getDefaultValue(getPlayer()));
+    }
+
+    @Override
+    public void reset() {
+        //TODO debate
+        super.reset(getPlayer().getUser(Context.LOCAL));
+        super.reset(getPlayer().getUser(Context.GLOBAL));
+    }
+
+    @Override
+    public @NotNull T setValue(@NotNull T value, @NotNull Context context) throws UnauthorizedException {
+        T oldValue = getValue(context);
+
+        UserValue<T>[] possibilities = getSetting().getParent().getPossibleValues(getPlayer());
+        if (possibilities.length!=0) {
+            isAllowed(value, possibilities);
+        }
+
+        T defaultValue = getSetting().getParent().getDefaultValue(getPlayer());
+        if (Objects.equals(defaultValue, value)) {
+            reset();
+            return oldValue;
+        }
+
+        setValue(getPlayer().getUser(context), value);
+        return oldValue;
+    }
+
+    @Override
+    public @NotNull T getValue(@NotNull Context context) {
+        T defaultValue = getSetting().getParent().getDefaultValue(getPlayer());
+        SavableMap repo = getPlayer().getUser(context).getRepository(getSetting().getPlugin());
+        Optional<String> value = repo.get(getKey(), String.class);
+        return value.map(currentValue -> getSetting().getParent().deserialize(currentValue)).orElse(defaultValue);
+    }
+
+    @Override
+    public void reset(@NotNull Context context) {
+        super.reset(getPlayer().getUser(context));
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperFallBackRank.java b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperFallBackRank.java
new file mode 100644
index 0000000000000000000000000000000000000000..1f5b323541a67c29a8c9ddeb89fdb6493ee65a70
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperFallBackRank.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.user.rank;
+
+import net.kissenpvp.core.user.rank.KissenFallBackRank;
+import net.kissenpvp.paper.api.networking.client.entity.PaperPlayerClient;
+import net.kissenpvp.paper.api.user.rank.Rank;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Set;
+import java.util.stream.Collectors;
+
+public class KissenPaperFallBackRank extends KissenFallBackRank implements Rank {
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPlayerClient> getPlayers() {
+        return Bukkit.getOnlinePlayers().stream().filter(playerClient ->
+        {
+            Rank paperRank = playerClient.getRank().getSource();
+            return paperRank.equals(this);
+        }).collect(Collectors.toUnmodifiableSet());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperKissenPlayerRank.java b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperKissenPlayerRank.java
new file mode 100644
index 0000000000000000000000000000000000000000..ae87ee2094b39784dbbb2b8354faf00b84c92833
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperKissenPlayerRank.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.user.rank;
+
+import net.kissenpvp.core.api.database.DataWriter;
+import net.kissenpvp.core.user.rank.KissenPlayerRank;
+import net.kissenpvp.core.user.rank.PlayerRankNode;
+import net.kissenpvp.paper.api.user.rank.PlayerRank;
+import net.kissenpvp.paper.api.user.rank.Rank;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class KissenPaperKissenPlayerRank extends KissenPlayerRank<Rank> implements PlayerRank {
+    public KissenPaperKissenPlayerRank(@NotNull PlayerRankNode playerRankNode, @Nullable DataWriter<PlayerRankNode> dataWriter) {
+        super(playerRankNode, dataWriter);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperPlayerFallBackRank.java b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperPlayerFallBackRank.java
new file mode 100644
index 0000000000000000000000000000000000000000..1e16ed5f466a8d840b9a05a19288ca5c3ba4075b
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperPlayerFallBackRank.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.user.rank;
+
+import net.kissenpvp.core.user.rank.KissenPlayerFallBackRank;
+import net.kissenpvp.paper.api.user.rank.PlayerRank;
+import net.kissenpvp.paper.api.user.rank.Rank;
+import org.jetbrains.annotations.NotNull;
+
+public class KissenPaperPlayerFallBackRank extends KissenPlayerFallBackRank<Rank> implements PlayerRank
+{
+    @Override public @NotNull Rank getSource()
+    {
+        return new KissenPaperFallBackRank();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperRank.java b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperRank.java
new file mode 100644
index 0000000000000000000000000000000000000000..61ea896ac5e41ff83b37552841797fc8173d838d
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperRank.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.user.rank;
+
+import net.kissenpvp.core.api.database.meta.Meta;
+import net.kissenpvp.core.api.database.meta.Table;
+import net.kissenpvp.core.api.database.savable.SavableMap;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.networking.socket.DataPackage;
+import net.kissenpvp.core.database.savable.KissenSavableMap;
+import net.kissenpvp.core.event.EventImplementation;
+import net.kissenpvp.core.user.rank.KissenRank;
+import net.kissenpvp.core.user.rank.KissenRankImplementation;
+import net.kissenpvp.paper.api.networking.client.entity.PaperPlayerClient;
+import net.kissenpvp.paper.api.user.rank.Rank;
+import net.kissenpvp.paper.user.rank.event.KissenPaperRankSetPriorityEvent;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+public class KissenPaperRank extends KissenRank implements Rank
+{
+    @Override
+    protected @NotNull SavableMap createRepository(@Nullable Map<String, Object> data) {
+        Meta meta = Bukkit.getKissen().getImplementation(KissenRankImplementation.class).getMeta();
+        return new KissenSavableMap(getDatabaseID(), meta, Objects.requireNonNullElseGet(data, meta.getData(getDatabaseID())::join));
+    }
+
+    @Override
+    public void sendData(@NotNull DataPackage dataPackage) {
+        //TODO async network and so on
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPlayerClient> getPlayers() {
+        return Bukkit.getOnlinePlayers().stream().filter(playerClient ->
+        {
+            Rank paperRank = playerClient.getRank().getSource();
+            return paperRank.equals(this);
+        }).collect(Collectors.toUnmodifiableSet());
+    }
+
+
+    @Override
+    public void setPriority(int priority)
+    {
+        KissenPaperRankSetPriorityEvent event = new KissenPaperRankSetPriorityEvent(this, getPriority(), priority);
+        EventImplementation eventImplementation = Bukkit.getKissen().getImplementation(EventImplementation.class);
+        if(!eventImplementation.call(event))
+        {
+            throw new EventCancelledException();
+        }
+        super.setPriority(priority);
+    }
+
+    @Override
+    public @NotNull Table getTable() {
+        return Bukkit.getKissen().getImplementation(KissenRankImplementation.class).getTable();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperRankImplementation.java b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperRankImplementation.java
new file mode 100644
index 0000000000000000000000000000000000000000..0e66395f1cc09ea8f3f78d8a82eb8a19b9968f21
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/KissenPaperRankImplementation.java
@@ -0,0 +1,59 @@
+package net.kissenpvp.paper.user.rank;
+
+import net.kissenpvp.core.api.database.savable.Savable;
+import net.kissenpvp.core.base.KissenImplementation;
+import net.kissenpvp.core.command.InternalCommandImplementation;
+import net.kissenpvp.core.message.localization.KissenLocalizationImplementation;
+import net.kissenpvp.core.user.rank.KissenRankImplementation;
+import net.kissenpvp.paper.api.user.rank.Rank;
+import net.kissenpvp.paper.api.user.rank.RankParser;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+
+import java.text.MessageFormat;
+
+@SuppressWarnings("unchecked")
+public class KissenPaperRankImplementation extends KissenRankImplementation<Rank> implements KissenImplementation
+{
+
+    @Override
+    public boolean start()
+    {
+        KissenLocalizationImplementation localize = Bukkit.getKissen().getImplementation(KissenLocalizationImplementation.class);
+        localize.register("server.rank.edit.prefix.set", new MessageFormat("The prefix from rank {0} has been set to {1}.."));
+        localize.register("server.rank.edit.suffix.set", new MessageFormat("The suffix from rank {0} has been set to {1}.."));
+        localize.register("server.rank.edit.chatcolor.set", new MessageFormat("The chatcolor from rank {0} has been set to {1}."));
+        localize.register("server.rank.edit.priority.set", new MessageFormat("The priority from rank {0} has been set to {1}."));
+
+        localize.register("server.rank.player.granted", new MessageFormat("The player {0} now has the rank {1} granted."));
+        localize.register("server.rank.player.revoked", new MessageFormat("The rank {1} from player {0} has been revoked."));
+        localize.register("server.rank.player.not.found", new MessageFormat("The player {0} does not have a rank with the id {1}."));
+
+        localize.register("server.rank.created", new MessageFormat("The rank {0} has been created with the priority {1}."));
+        localize.register("server.rank.deleted", new MessageFormat("The rank {0} has been deleted."));
+
+        InternalCommandImplementation<CommandSender> command = Bukkit.getKissen().getImplementation(InternalCommandImplementation.class);
+        command.getInternalHandler().registerParser(Rank.class, new RankParser());
+        return super.start();
+    }
+
+    @Override
+    public void setupComplete()
+    {
+        InternalCommandImplementation<CommandSender> commandImplementation = Bukkit.getKissen().getImplementation(InternalCommandImplementation.class);
+        commandImplementation.getInternalHandler().registerCommand(new RankCommand());
+    }
+
+    @Override
+    protected @NotNull Savable<String> getSavableType()
+    {
+        return new KissenPaperRank();
+    }
+
+    @Override
+    protected @NotNull Rank getFallbackRank()
+    {
+        return new KissenPaperFallBackRank();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/RankCommand.java b/src/main/java/net/kissenpvp/paper/user/rank/RankCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..cfa673e5762f4d92832e6cd16edfe0298abf37bd
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/RankCommand.java
@@ -0,0 +1,154 @@
+package net.kissenpvp.paper.user.rank;
+
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.core.api.command.annotations.ArgumentName;
+import net.kissenpvp.core.api.command.annotations.CommandData;
+import net.kissenpvp.core.api.command.annotations.TabCompleter;
+import net.kissenpvp.core.api.command.exception.ArgumentMissingException;
+import net.kissenpvp.core.api.time.AccurateDuration;
+import net.kissenpvp.core.api.time.TemporalObject;
+import net.kissenpvp.core.api.user.rank.AbstractPlayerRank;
+import net.kissenpvp.paper.api.command.parser.OfflinePlayerParser;
+import net.kissenpvp.paper.api.user.rank.PlayerRank;
+import net.kissenpvp.paper.api.user.rank.Rank;
+import net.kyori.adventure.text.Component;
+import org.bukkit.Bukkit;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+
+import java.time.Instant;
+import java.util.Collection;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.function.Function;
+import java.util.function.Predicate;
+import java.util.function.Supplier;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+/**
+ * The {@code RankCommand} class represents a command related to player ranks.
+ *
+ * <p>This class provides functionality for handling commands related to player ranks, such as setting, querying, or modifying
+ * rank-related information. It may include methods for managing player ranks, checking rank permissions, or performing
+ * rank-specific actions.</p>
+ */
+public class RankCommand {
+
+    @CommandData("rank")
+    public void rank() {
+        throw new ArgumentMissingException();
+    }
+
+    @CommandData(value = "rank.grant")
+    public void rankGrant(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull OfflinePlayer offlinePlayer, @NotNull @ArgumentName("rank") Rank paperRank, @NotNull @ArgumentName("duration") Optional<AccurateDuration> accurateDuration) {
+        Function<AccurateDuration, PlayerRank> grant = duration -> offlinePlayer.grantRank(paperRank, duration);
+        Supplier<PlayerRank> orElse = () -> offlinePlayer.grantRank(paperRank);
+        commandPayload.getSender().sendMessage(rankGrant(offlinePlayer, accurateDuration.map(grant).orElseGet(orElse)));
+    }
+
+    @CommandData(value = "rank.revoke")
+    public void rankRevoke(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull OfflinePlayer offlinePlayer, @ArgumentName("playerrankid") @NotNull String id) {
+        commandPayload.getSender().sendMessage(rankRevoke(offlinePlayer, id));
+    }
+
+    @CommandData(value = "rank.edit.priority")
+    public void rankRevoke(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull Rank paperRank, @ArgumentName("priority") int priority) {
+        paperRank.setPriority(priority);
+
+        Component[] args = {Component.text(paperRank.getName()), Component.text(priority)};
+        commandPayload.getSender().sendMessage(Component.translatable("server.rank.edit.priority.set", args));
+    }
+
+    @CommandData(value = "rank.create")
+    public void rankCreate(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull @ArgumentName("name") String name, @ArgumentName("priority") int priority) {
+        Class<KissenPaperRankImplementation> clazz = KissenPaperRankImplementation.class;
+        KissenPaperRankImplementation rankImplementation = Bukkit.getKissen().getImplementation(clazz);
+        Rank paperRank = rankImplementation.createRank(name, priority);
+
+        Component[] args = {Component.text(paperRank.getName()), Component.text(priority)};
+        commandPayload.getSender().sendMessage(Component.translatable("server.rank.created", args));
+    }
+
+    @CommandData(value = "rank.delete")
+    public void rankDelete(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull Rank paperRank) {
+        paperRank.delete();
+        commandPayload.getSender().sendMessage(Component.translatable("server.rank.player.deleted", Component.text(paperRank.getName())));
+    }
+
+    @TabCompleter(value = "rank.revoke")
+    public @NotNull Collection<String> rankRevokeTab(@NotNull CommandPayload<CommandSender> commandPayload) {
+        OfflinePlayerParser offlinePlayerParser = new OfflinePlayerParser();
+        if (commandPayload.getArguments().length < 2) {
+            return offlinePlayerParser.tabCompletion(commandPayload);
+        }
+        OfflinePlayer offlinePlayer = offlinePlayerParser.deserialize(commandPayload.getArguments()[0]);
+        return offlinePlayer.getRankHistory().stream().filter(TemporalObject::isValid).map(AbstractPlayerRank::getID).collect(Collectors.toSet());
+    }
+
+    /**
+     * Grants a rank to the specified offline player and generates a message indicating the rank has been granted.
+     *
+     * <p>The {@code rankGrant} method grants the specified {@link PlayerRank} to the {@link OfflinePlayer},
+     * generating a message indicating the successful grant. The generated message includes the player's display name
+     * and the name of the granted rank.</p>
+     *
+     * @param offlinePlayer the {@link OfflinePlayer} to whom the rank is granted
+     * @param paperPlayerRank the {@link PlayerRank} to be granted
+     * @return a {@link Component} representing the message indicating the rank has been granted
+     * @throws NullPointerException if either {@code offlinePlayer} or {@code paperPlayerRank} is {@code null}
+     */
+    private static @NotNull Component rankGrant(@NotNull OfflinePlayer offlinePlayer, @NotNull PlayerRank paperPlayerRank) {
+        Component rankName = Component.text(paperPlayerRank.getSource().getName());
+        return Component.translatable("server.rank.player.granted", offlinePlayer.displayName(), rankName);
+    }
+
+    /**
+     * Revokes a rank from the specified offline player and generates a corresponding message.
+     *
+     * <p>The {@code rankRevoke} method revokes the rank with the specified ID from the {@link OfflinePlayer},
+     * generating a message indicating the outcome of the revocation. The generated message includes the player's display name
+     * and the ID of the revoked rank.</p>
+     *
+     * @param player the {@link OfflinePlayer} from whom the rank is revoked
+     * @param id the ID of the rank to be revoked
+     * @return a {@link Component} representing the message indicating the outcome of the rank revocation
+     * @throws NullPointerException if either {@code player} or {@code id} is {@code null}
+     */
+    private static @NotNull Component rankRevoke(@NotNull OfflinePlayer player, @NotNull String id) {
+
+        String translationString = "server.rank.player.not.found";
+        if (player.getRankHistory().stream().anyMatch(endRank(id))) {
+            translationString = "server.rank.player.revoked";
+        }
+
+        Component[] args = {player.displayName(), Component.text(id)};
+        return Component.translatable(translationString, args);
+    }
+
+    /**
+     * Returns a {@link Predicate} that ends the rank with the specified ID and sets its end time to the current instant.
+     *
+     * <p>The {@code endRank} method returns a {@link Predicate} that can be used with {@link Stream#anyMatch(Predicate)}
+     * to find and end the rank with the specified ID. If the rank is found and is currently valid, its end time is set to the
+     * current instant, and the predicate returns {@code true}; otherwise, it returns {@code false}.</p>
+     *
+     * <p>This method is intended for use with streams and filtering rank history based on the rank's ID.</p>
+     *
+     * @param id the ID of the rank to be ended
+     * @return a {@link Predicate} ending the rank with the specified ID
+     * @throws NullPointerException if {@code id} is {@code null}
+     */
+    @Contract(pure = true, value = "_ -> new")
+    private static @NotNull Predicate<PlayerRank> endRank(@NotNull String id) {
+        return current -> {
+            if (Objects.equals(current.getID(), id) && current.isValid()) {
+                current.setEnd(Instant.now());
+                return true;
+            }
+            return false;
+        };
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetChatColorEvent.java b/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetChatColorEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..574cd8194c423caa1d4f601ee8c4315a6efe019d
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetChatColorEvent.java
@@ -0,0 +1,15 @@
+package net.kissenpvp.paper.user.rank.event;
+
+import net.kissenpvp.core.api.user.rank.event.RankSetChatColorEvent;
+import net.kissenpvp.core.user.rank.event.KissenRankSetEvent;
+import net.kissenpvp.paper.api.user.rank.Rank;
+import net.kyori.adventure.text.format.TextColor;
+import org.jetbrains.annotations.NotNull;
+
+public class KissenPaperRankSetChatColorEvent extends KissenRankSetEvent<Rank, TextColor> implements RankSetChatColorEvent<Rank>
+{
+    public KissenPaperRankSetChatColorEvent(@NotNull Rank rank, @NotNull TextColor old, @NotNull TextColor updated)
+    {
+        super(rank, old, updated);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetPrefixEvent.java b/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetPrefixEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..12854f74ccd74d293a40108ce00fc8e77774749a
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetPrefixEvent.java
@@ -0,0 +1,16 @@
+package net.kissenpvp.paper.user.rank.event;
+
+import net.kissenpvp.core.api.user.rank.event.RankSetPrefixEvent;
+import net.kissenpvp.core.user.rank.event.KissenRankSetEvent;
+import net.kissenpvp.paper.api.user.rank.Rank;
+import net.kyori.adventure.text.Component;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class KissenPaperRankSetPrefixEvent extends KissenRankSetEvent<Rank, Component> implements RankSetPrefixEvent<Rank>
+{
+    public KissenPaperRankSetPrefixEvent(@NotNull Rank rank, @Nullable Component old, @Nullable Component updated)
+    {
+        super(rank, old, updated);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetPriorityEvent.java b/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetPriorityEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..9b9e2ae442eadc6fac39d4ea77f8668a9148419e
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetPriorityEvent.java
@@ -0,0 +1,14 @@
+package net.kissenpvp.paper.user.rank.event;
+
+import net.kissenpvp.core.api.user.rank.event.RankSetPriorityEvent;
+import net.kissenpvp.core.user.rank.event.KissenRankSetEvent;
+import net.kissenpvp.paper.api.user.rank.Rank;
+import org.jetbrains.annotations.NotNull;
+
+public class KissenPaperRankSetPriorityEvent extends KissenRankSetEvent<Rank, Integer> implements RankSetPriorityEvent<Rank>
+{
+    public KissenPaperRankSetPriorityEvent(@NotNull Rank rank, @NotNull Integer old, @NotNull Integer updated)
+    {
+        super(rank, old, updated);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetSuffixEvent.java b/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetSuffixEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..73128f8b8697090414c919793d907c3edc25bbda
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/user/rank/event/KissenPaperRankSetSuffixEvent.java
@@ -0,0 +1,16 @@
+package net.kissenpvp.paper.user.rank.event;
+
+import net.kissenpvp.core.api.user.rank.event.RankSetPrefixEvent;
+import net.kissenpvp.core.user.rank.event.KissenRankSetEvent;
+import net.kissenpvp.paper.api.user.rank.Rank;
+import net.kyori.adventure.text.Component;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class KissenPaperRankSetSuffixEvent extends KissenRankSetEvent<Rank, Component> implements RankSetPrefixEvent<Rank>
+{
+    public KissenPaperRankSetSuffixEvent(@NotNull Rank rank, @Nullable Component old, @Nullable Component updated)
+    {
+        super(rank, old, updated);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Main.java b/src/main/java/net/minecraft/server/Main.java
index 5443013060b62e3bfcc51cddca96d1c0bc59fe72..3ee2b9c8bac70f053d7e59fe507bcf44c5fceb88 100644
--- a/src/main/java/net/minecraft/server/Main.java
+++ b/src/main/java/net/minecraft/server/Main.java
@@ -182,15 +182,17 @@ public class Main {
             org.spigotmc.SpigotConfig.disabledAdvancements = spigotConfiguration.getStringList("advancements.disabled"); // Paper - fix SPIGOT-5885, must be set early in init
             // Paper start - fix SPIGOT-5824
             File file;
-            File userCacheFile = new File(Services.USERID_CACHE_FILE);
+            /* KissenPaper - remove cache file
+             * File userCacheFile = new File(Services.USERID_CACHE_FILE);
+             */
             if (optionset.has("universe")) {
                 file = (File) optionset.valueOf("universe"); // CraftBukkit
-                userCacheFile = new File(file, Services.USERID_CACHE_FILE);
+                //userCacheFile = new File(file, Services.USERID_CACHE_FILE); // KissenPaper
             } else {
                 file = new File(bukkitConfiguration.getString("settings.world-container", "."));
             }
             // Paper end - fix SPIGOT-5824
-            Services services = Services.create(new com.destroystokyo.paper.profile.PaperAuthenticationService(Proxy.NO_PROXY), file, userCacheFile, optionset); // Paper - pass OptionSet to load paper config files; override authentication service; fix world-container
+            Services services = Services.create(new com.destroystokyo.paper.profile.PaperAuthenticationService(Proxy.NO_PROXY), file/*, userCacheFile KissenPaper - remove cache file*/, optionset); // Paper - pass OptionSet to load paper config files; override authentication service; fix world-container
             // CraftBukkit start
             String s = (String) Optional.ofNullable((String) optionset.valueOf("world")).orElse(dedicatedserversettings.getProperties().levelName);
             LevelStorageSource convertable = LevelStorageSource.createDefault(file.toPath());
diff --git a/src/main/java/net/minecraft/server/Services.java b/src/main/java/net/minecraft/server/Services.java
index 33e3815a0c979609d4c7ab83ad91e87ac07a556d..f5d03be7adf7e8cc478ddf6ae972ed85829cd880 100644
--- a/src/main/java/net/minecraft/server/Services.java
+++ b/src/main/java/net/minecraft/server/Services.java
@@ -26,10 +26,10 @@ public record Services(
     // Paper end - add paper configuration files
     public static final String USERID_CACHE_FILE = "usercache.json"; // Paper - private -> public
 
-    public static Services create(YggdrasilAuthenticationService authenticationService, File rootDirectory, File userCacheFile, joptsimple.OptionSet optionSet) throws Exception { // Paper - add optionset to load paper config files; add userCacheFile parameter
+    public static Services create(YggdrasilAuthenticationService authenticationService, File rootDirectory, /* File userCacheFile KissenPaper - remove cache file,*/ joptsimple.OptionSet optionSet) throws Exception { // Paper - add optionset to load paper config files; add userCacheFile parameter
         MinecraftSessionService minecraftSessionService = authenticationService.createMinecraftSessionService();
         GameProfileRepository gameProfileRepository = authenticationService.createProfileRepository();
-        GameProfileCache gameProfileCache = new GameProfileCache(gameProfileRepository, userCacheFile); // Paper - use specified user cache file
+        GameProfileCache gameProfileCache = /*new GameProfileCache(gameProfileRepository, userCacheFile);*/  new net.kissenpvp.paper.user.KissenPaperProfileCache(gameProfileRepository); // Paper - use specified user cache file  // KissenPaper - use database instead
         // Paper start - load paper config files from cli options
         final java.nio.file.Path legacyConfigPath = ((File) optionSet.valueOf("paper-settings")).toPath();
         final java.nio.file.Path configDirPath = ((File) optionSet.valueOf("paper-settings-directory")).toPath();
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedPlayerList.java b/src/main/java/net/minecraft/server/dedicated/DedicatedPlayerList.java
index 22c4f8dea99f92a1eb3da2baf0a15bf9d2ca0462..8eaeb2f6096e1b1310022aa494257aac4aa15a8b 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedPlayerList.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedPlayerList.java
@@ -30,7 +30,7 @@ public class DedicatedPlayerList extends PlayerList {
         this.loadOps();
         this.loadWhiteList();
         this.saveOps();
-        if (!this.getWhiteList().getFile().exists()) {
+        if (/*!this.getWhiteList().getFile().exists()*/ true) { // KissenPaper
             this.saveWhiteList();
         }
     }
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index a645ad66af061966c5e47cae677026b35a55c486..ab9bac053c443acdefc3045df4b50d902b998d88 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -2178,17 +2178,22 @@ public class ServerPlayer extends Player {
 
     public void sendSystemMessage(Component message, boolean overlay) {
         if (this.acceptsSystemMessages(overlay)) {
-            this.connection.send(new ClientboundSystemChatPacket(message, overlay), PacketSendListener.exceptionallySend(() -> {
-                if (this.acceptsSystemMessages(false)) {
-                    boolean flag1 = true;
-                    String s = message.getString(256);
-                    MutableComponent ichatmutablecomponent = Component.literal(s).withStyle(ChatFormatting.YELLOW);
-
-                    return new ClientboundSystemChatPacket(Component.translatable("multiplayer.message_not_delivered", ichatmutablecomponent).withStyle(ChatFormatting.RED), false);
-                } else {
-                    return null;
-                }
-            }));
+            // KissenPaper start - add custom renderer
+            net.kyori.adventure.text.Component component = PaperAdventure.asAdventure(message);
+            Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.message.ChatImplementation.class).handle(Bukkit.getConsoleSender(), getBukkitEntity(), component).ifPresent(styled ->
+                this.connection.send(new ClientboundSystemChatPacket(styled, overlay), PacketSendListener.exceptionallySend(() -> {
+                    if (this.acceptsSystemMessages(false)) {
+                        boolean flag1 = true;
+                        String s = message.getString(256);
+                        MutableComponent ichatmutablecomponent = Component.literal(s).withStyle(ChatFormatting.YELLOW);
+
+                        return new ClientboundSystemChatPacket(PaperAdventure.asAdventure(Component.translatable("multiplayer.message_not_delivered", ichatmutablecomponent).withStyle(ChatFormatting.RED)), false);
+                    } else {
+                        return null;
+                    }
+                }))
+            );
+            // KissenPaper end
         }
     }
 
diff --git a/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
index b656741eb68adeb04bf995f1045902cb6bd5f2e7..ad5a3263b44b42deb6a57368fde7dcf488f0388a 100644
--- a/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
@@ -50,6 +50,13 @@ import org.bukkit.craftbukkit.util.Waitable;
 import org.bukkit.event.player.AsyncPlayerPreLoginEvent;
 import org.bukkit.event.player.PlayerPreLoginEvent;
 
+// KissenPaper start
+import org.bukkit.Bukkit;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.user.KissenUserImplementation;
+import net.kissenpvp.paper.user.KissenPaperPublicUser;
+// KissenPaper end
+
 public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener, TickablePacketListener, CraftPlayer.TransferCookieConnection {
 
     @Override
@@ -353,6 +360,17 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener,
             return gameprofile;
         }
         // Paper end - Add Velocity IP Forwarding Support
+
+        // KissenPaper start
+        KissenPaperPublicUser kissenPaperPublicUser = new KissenPaperPublicUser(gameprofile.getId(), gameprofile.getName());
+        if (!loginUser(kissenPaperPublicUser, gameprofile))
+        {
+            kissenPaperPublicUser.logout();
+            return gameprofile;
+        }
+        // KissenPaper end
+
+        // Paper end - Velocity support
         String playerName = gameprofile.getName();
         java.net.InetAddress address = ((java.net.InetSocketAddress) this.connection.getRemoteAddress()).getAddress();
         java.util.UUID uniqueId = gameprofile.getId();
@@ -396,6 +414,56 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener,
     }
     // CraftBukkit end
 
+    // KissenPaper start
+    /**
+     * Attempts to log in a user represented by a GameProfile object. This includes loading the KissenPaperPublicUser via a
+     * KissenUserImplementation, checking the user's ban status, and if not banned, loading the user's
+     * private data.
+     *
+     * <p>If the user cannot be loaded, or they have an outstanding punishment, the method
+     * will disconnect them with an appropriate message and return false. If an exception occurs in the process,
+     * the user is also disconnected and false is returned. If the user is loaded successfully and has no
+     * outstanding punishments, true is returned.</p>
+     *
+     * @param gameProfile The GameProfile of the user attempting to log in. This parameter must not be null.
+     * @return true if the user was successfully logged in, false otherwise.
+     * @throws NullPointerException If gameProfile is null.
+     *
+     * @see KissenPaperPublicUser
+     * @see net.kissenpvp.paper.api.ban.BanImplementation
+     * @see net.kissenpvp.paper.api.ban.Punishment
+     * @see GameProfile
+     */
+    private boolean loginUser(@org.jetbrains.annotations.NotNull KissenPaperPublicUser user, @org.jetbrains.annotations.NotNull GameProfile gameProfile) {
+        try {
+            if(!Bukkit.getKissen().getImplementation(KissenUserImplementation.class).loadUser(user))
+            {
+                disconnect(Component.translatable("multiplayer.disconnect.unverified_username"));
+                return false;
+            }
+
+            if(Bukkit.hasWhitelist() && !MinecraftServer.getServer().getPlayerList().isWhiteListed(gameProfile))
+            {
+                disconnect(Component.translatable("multiplayer.disconnect.not_whitelisted"));
+                return false;
+            }
+
+            net.kissenpvp.paper.api.ban.BanImplementation banImplementation = org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.paper.api.ban.BanImplementation.class);
+            java.util.UUID totalId = user.getTotalId();
+            net.kissenpvp.paper.api.ban.Punishment paperPunishment = banImplementation.getLatestPunishment(totalId, net.kissenpvp.core.api.ban.BanType.BAN).orElse(null);
+            if (paperPunishment != null) {
+                disconnect(io.papermc.paper.adventure.PaperAdventure.asVanilla(paperPunishment.getPunishmentText(user.getLocale())));
+                return false;
+            }
+
+        } catch (BackendException backendException) {
+            disconnect(Component.translatable("multiplayer.disconnect.unverified_username")); // maybe better message
+            return false;
+        }
+        return true;
+    }
+    // KissenPaper end
+
     @Override
     public void handleCustomQueryPacket(ServerboundCustomQueryAnswerPacket packet) {
         // Paper start - Add Velocity IP Forwarding Support
diff --git a/src/main/java/net/minecraft/server/players/GameProfileCache.java b/src/main/java/net/minecraft/server/players/GameProfileCache.java
index 34b4166adfae8ff7d1eb73d56a72931b005330a7..ee9030ee27aa66520277fbf99607345c266de514 100644
--- a/src/main/java/net/minecraft/server/players/GameProfileCache.java
+++ b/src/main/java/net/minecraft/server/players/GameProfileCache.java
@@ -230,7 +230,7 @@ public class GameProfileCache {
         return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z", Locale.ROOT);
     }
 
-    public List<GameProfileCache.GameProfileInfo> load() {
+    protected List<GameProfileCache.GameProfileInfo> load() { // KissenPaper - private -> protected
         List<GameProfileCache.GameProfileInfo> list = Lists.newArrayList();
 
         try {
@@ -401,7 +401,7 @@ public class GameProfileCache {
         }
     }
 
-    private static class GameProfileInfo {
+    protected static class GameProfileInfo { // KissenPaper - private -> protected
 
         private final GameProfile profile;
         final Date expirationDate;
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index a2142930b4d4b05987c90496fb9d733d99040aa0..6ab435657c92d9fbf863d2a47254de9f138537f4 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -168,8 +168,8 @@ public abstract class PlayerList {
 
         this.bans = new UserBanList(PlayerList.USERBANLIST_FILE);
         this.ipBans = new IpBanList(PlayerList.IPBANLIST_FILE);
-        this.ops = new ServerOpList(PlayerList.OPLIST_FILE);
-        this.whitelist = new UserWhiteList(PlayerList.WHITELIST_FILE);
+        this.ops = /*new ServerOpList(PlayerList.OPLIST_FILE);*/ new net.kissenpvp.paper.user.KissenUserOperatorList(); // KissenPaper
+        this.whitelist = /*new UserWhiteList(PlayerList.WHITELIST_FILE);*/ new net.kissenpvp.paper.user.KissenUserWhiteList(); // KissenPaper
         // CraftBukkit start
         // this.stats = Maps.newHashMap();
         // this.advancements = Maps.newHashMap();
@@ -314,7 +314,6 @@ public abstract class PlayerList {
         } else {
             ichatmutablecomponent = Component.translatable("multiplayer.player.joined.renamed", player.getDisplayName(), s);
         }
-        // CraftBukkit start
         ichatmutablecomponent.withStyle(ChatFormatting.YELLOW);
         Component joinMessage = ichatmutablecomponent; // Paper - Adventure
 
@@ -343,6 +342,13 @@ public abstract class PlayerList {
         // Ensure that player inventory is populated with its viewer
         player.containerMenu.transferTo(player.containerMenu, bukkitPlayer);
 
+        // KissenPaper start
+        if(!org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.core.user.KissenUserImplementation.class).loginUser(bukkitPlayer.getUser()))
+        {
+            //TODO disconnect player
+        }
+        // KissenPaper end
+
         PlayerJoinEvent playerJoinEvent = new PlayerJoinEvent(bukkitPlayer, io.papermc.paper.adventure.PaperAdventure.asAdventure(ichatmutablecomponent)); // Paper - Adventure
         this.cserver.getPluginManager().callEvent(playerJoinEvent);
 
@@ -687,6 +693,12 @@ public abstract class PlayerList {
         this.cserver.getScoreboardManager().removePlayer(entityplayer.getBukkitEntity());
         // CraftBukkit end
 
+        // KissenPaper start - logout user
+        if(!org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.core.user.KissenUserImplementation.class).logoutUser(entityplayer.getBukkitEntity().getUser()))
+        {
+            PlayerList.LOGGER.warn("Player {} was on the server but was not recognized by the system.", entityplayer.getName());
+        }
+
         return playerQuitEvent.quitMessage(); // Paper - Adventure
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java b/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java
index 9d93130f23addb18b97d7f5ec013faef17a74529..54c969597595f02604fa9f75536be760c04a8c71 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java
@@ -4,11 +4,7 @@ import com.mojang.authlib.GameProfile;
 import java.io.File;
 import java.time.Duration;
 import java.time.Instant;
-import java.util.Date;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.UUID;
+import java.util.*;
 import net.minecraft.core.GlobalPos;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.ListTag;
@@ -28,12 +24,39 @@ import org.bukkit.ban.ProfileBanList;
 import org.bukkit.configuration.serialization.ConfigurationSerializable;
 import org.bukkit.configuration.serialization.SerializableAs;
 import org.bukkit.craftbukkit.entity.memory.CraftMemoryMapper;
-import org.bukkit.craftbukkit.profile.CraftPlayerProfile;
 import org.bukkit.entity.EntityType;
 import org.bukkit.entity.Player;
 import org.bukkit.metadata.MetadataValue;
 import org.bukkit.plugin.Plugin;
-import org.bukkit.profile.PlayerProfile;
+
+// KissenPaper start
+import org.bukkit.permissions.Permissible;
+import org.bukkit.permissions.PermissionAttachment;
+import org.bukkit.permissions.PermissionAttachmentInfo;
+
+import net.kissenpvp.core.api.ban.AbstractBan;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.permission.AbstractPermissionGroup;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.api.user.rank.AbstractRank;
+import net.kissenpvp.core.api.time.AccurateDuration;
+import net.kissenpvp.core.api.networking.client.entitiy.ServerEntity;
+import net.kissenpvp.paper.api.ban.Punishment;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.networking.client.entity.PaperOnlinePlayerClient;
+import net.kissenpvp.paper.api.permission.PaperPermissible;
+import net.kissenpvp.paper.api.permission.Permission;
+import net.kissenpvp.paper.api.permission.PermissibleOverriddenException;
+import net.kissenpvp.paper.api.user.rank.PlayerRank;
+import net.kissenpvp.paper.networking.client.entity.KissenPaperPlayerClient;
+import net.kissenpvp.paper.permission.permissible.KissenPaperPlayerPermissible;
+import net.kyori.adventure.text.Component;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+// KissenPaper end
 
 @SerializableAs("Player")
 public class CraftOfflinePlayer implements OfflinePlayer, ConfigurationSerializable {
@@ -42,6 +65,11 @@ public class CraftOfflinePlayer implements OfflinePlayer, ConfigurationSerializa
     private final CraftServer server;
     private final PlayerDataStorage storage;
 
+    // KissenPaper start
+    private final Permissible permissible = new KissenPaperPlayerPermissible(this);
+    private net.kissenpvp.paper.networking.client.entity.KissenPaperPlayerClient kissenPaperPlayerClient;
+    // KissenPaper end
+
     protected CraftOfflinePlayer(CraftServer server, GameProfile profile) {
         this.server = server;
         this.profile = profile;
@@ -598,4 +626,388 @@ public class CraftOfflinePlayer implements OfflinePlayer, ConfigurationSerializa
             manager.save();
         }
     }
+
+    // KissenPaper start - integrate kissen user
+
+    private @NotNull KissenPaperPlayerClient getKissenPaperPlayerClient()
+    {
+        if(kissenPaperPlayerClient == null) {
+            kissenPaperPlayerClient = new KissenPaperPlayerClient() {
+
+                private User cachedUser;
+
+                @Override
+                public @NotNull User getUser() {
+                    return Optional.ofNullable(cachedUser).orElseGet(() ->
+                    {
+                        cachedUser = super.getUser();
+                        return cachedUser;
+                    });
+                }
+
+                @Override
+                public @NotNull PaperPermissible getPermissible() throws PermissibleOverriddenException {
+                    return (PaperPermissible) permissible;
+                }
+
+                @Override
+                public @NotNull UUID getUniqueId() {
+                    return CraftOfflinePlayer.this.getUniqueId();
+                }
+
+                @Override
+                public boolean isConnected() {
+                    return false;
+                }
+            };
+        }
+        return kissenPaperPlayerClient;
+    }
+
+    @Override
+    public final boolean isClient() {
+        return true;
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAltAccounts() throws BackendException {
+        return getKissenPaperPlayerClient().getAltAccounts();
+    }
+
+    @Override
+    public @NotNull UUID getTotalID() {
+        return getKissenPaperPlayerClient().getTotalID();
+    }
+
+    @Override
+    public @NotNull Punishment punish(@NotNull AbstractBan ban, @NotNull ServerEntity banOperator) throws BackendException {
+        return getKissenPaperPlayerClient().punish(ban, banOperator);
+    }
+
+    @Override
+    public @NotNull Punishment punish(@NotNull AbstractBan ban, @NotNull ServerEntity banOperator, @Nullable Component reason) throws BackendException {
+        return getKissenPaperPlayerClient().punish(ban, banOperator, reason);
+    }
+
+    @Override
+    public @NotNull Optional<Punishment> getPunishment(@NotNull String id) throws BackendException {
+        return getKissenPaperPlayerClient().getPunishment(id);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<Punishment> getPunishmentHistory() throws BackendException {
+        return getKissenPaperPlayerClient().getPunishmentHistory();
+    }
+
+    @Override
+    public @NotNull Component displayName() {
+        return getKissenPaperPlayerClient().displayName();
+    }
+
+    @Override
+    public @NotNull net.kissenpvp.core.api.time.AccurateDuration getOnlineTime() {
+        return getKissenPaperPlayerClient().getOnlineTime();
+    }
+
+    @Override
+    public @NotNull User getUser() {
+        return getKissenPaperPlayerClient().getUser();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<PlayerRank> getRankHistory() {
+        return getKissenPaperPlayerClient().getRankHistory();
+    }
+
+    @Override
+    public @NotNull PlayerRank getRank() {
+        return getKissenPaperPlayerClient().getRank();
+    }
+
+    @Override
+    public @NotNull PlayerRank grantRank(@NotNull AbstractRank rank) {
+        return getKissenPaperPlayerClient().grantRank(rank);
+    }
+
+    @Override
+    public @NotNull PlayerRank grantRank(@NotNull AbstractRank rank, @Nullable AccurateDuration accurateDuration) {
+        return getKissenPaperPlayerClient().grantRank(rank, accurateDuration);
+    }
+
+    @Override
+    public @NotNull Locale getCurrentLocale() {
+        return getKissenPaperPlayerClient().getCurrentLocale();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<@NotNull PaperOnlinePlayerClient> getOnlineAltAccounts() {
+        return getKissenPaperPlayerClient().getOnlineAltAccounts();
+    }
+
+    @Override
+    public @NotNull net.kissenpvp.core.api.time.AccurateDuration getOnlineTime(@NotNull Context context) {
+        return getKissenPaperPlayerClient().getOnlineTime(context);
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull Context context) {
+        return getKissenPaperPlayerClient().getUser(context);
+    }
+
+    @Override
+    public @NotNull PaperPermissible getPermissible() throws PermissibleOverriddenException {
+        return getKissenPaperPlayerClient().getPermissible();
+    }
+
+    @Override
+    public @NotNull <X> net.kissenpvp.paper.api.user.playersetting.BoundPlayerSetting<X> getSetting(@NotNull Class<? extends net.kissenpvp.paper.api.user.playersetting.PlayerSetting<X>> settingClass) {
+        return getKissenPaperPlayerClient().getSetting(settingClass);
+    }
+
+    @Override
+    public @NotNull <X> net.kissenpvp.paper.api.user.playersetting.BoundPlayerSetting<X> getSetting(@NotNull Class<? extends net.kissenpvp.paper.api.user.playersetting.PlayerSetting<X>> settingClass, @NotNull Context context)
+    {
+        return getKissenPaperPlayerClient().getSetting(settingClass, context);
+    }
+
+    @Override
+    public @NotNull net.kissenpvp.paper.api.ban.warn.Warn warn(@NotNull AbstractBan ban, @NotNull ServerEntity warnOperator)
+    {
+        return getKissenPaperPlayerClient().warn(ban, warnOperator);
+    }
+
+    @Override
+    public @NotNull net.kissenpvp.paper.api.ban.warn.Warn warn(@NotNull AbstractBan ban, @NotNull ServerEntity warnOperator, @Nullable Component reason)
+    {
+        return getKissenPaperPlayerClient().warn(ban, warnOperator, reason);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<net.kissenpvp.paper.api.ban.warn.Warn> getWarnHistory()
+    {
+        return getKissenPaperPlayerClient().getWarnHistory();
+    }
+
+    @Override
+    public void clearActiveWarns()
+    {
+        getKissenPaperPlayerClient().clearActiveWarns();
+    }
+
+    @Override
+    public boolean isPermissionSet(@NotNull String name) {
+        return getKissenPaperPlayerClient().getPermissionContext().isPermissionSet(name);
+    }
+
+    @Override
+    public boolean isPermissionSet(@NotNull org.bukkit.permissions.Permission perm) {
+        return getKissenPaperPlayerClient().getPermissionContext().isPermissionSet(perm);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String name) {
+        return getKissenPaperPlayerClient().getPermissionContext().hasPermission(name);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull org.bukkit.permissions.Permission perm) {
+        return getKissenPaperPlayerClient().getPermissionContext().hasPermission(perm);
+    }
+
+    @Override
+    public @NotNull PermissionAttachment addAttachment(@NotNull Plugin plugin, @NotNull String name, boolean value) {
+        return getKissenPaperPlayerClient().getPermissionContext().addAttachment(plugin, name, value);
+    }
+
+    @Override
+    public @NotNull PermissionAttachment addAttachment(@NotNull Plugin plugin) {
+        return getKissenPaperPlayerClient().getPermissionContext().addAttachment(plugin);
+    }
+
+    @Override
+    public @Nullable PermissionAttachment addAttachment(@NotNull Plugin plugin, @NotNull String name, boolean value, int ticks) {
+        return getKissenPaperPlayerClient().getPermissionContext().addAttachment(plugin, name, value, ticks);
+    }
+
+    @Override
+    public @Nullable PermissionAttachment addAttachment(@NotNull Plugin plugin, int ticks) {
+        return getKissenPaperPlayerClient().getPermissionContext().addAttachment(plugin, ticks);
+    }
+
+    @Override
+    public void removeAttachment(@NotNull PermissionAttachment attachment) {
+        getKissenPaperPlayerClient().getPermissionContext().removeAttachment(attachment);
+    }
+
+    @Override
+    public void recalculatePermissions() {
+        getKissenPaperPlayerClient().getPermissionContext().recalculatePermissions();
+    }
+
+    @Override
+    public @NotNull Set<PermissionAttachmentInfo> getEffectivePermissions() {
+        return getKissenPaperPlayerClient().getPermissionContext().getEffectivePermissions();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<Permission> getOwnPermissions() {
+        return getKissenPaperPlayerClient().getPermissionContext().getOwnPermissions();
+    }
+
+    @Override
+    public int wipeGroups() {
+        return getKissenPaperPlayerClient().getPermissionContext().wipeGroups();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<AbstractPermissionGroup<Permission>> getOwnPermissionGroups()
+    {
+        return getKissenPaperPlayerClient().getPermissionContext().getOwnPermissionGroups();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<AbstractPermissionGroup<Permission>> getPermissionGroups() {
+        return getKissenPaperPlayerClient().getPermissionContext().getPermissionGroups();
+    }
+
+    @Override
+    public boolean inGroup(@NotNull AbstractPermissionGroup<Permission> permissionGroup) {
+        return getKissenPaperPlayerClient().getPermissionContext().inGroup(permissionGroup);
+    }
+
+    @Override
+    public @NotNull String getPermissionID() {
+        return getKissenPaperPlayerClient().getPermissionContext().getPermissionID();
+    }
+
+    @Override
+    public @NotNull Permission setPermission(@NotNull String permission) throws EventCancelledException {
+        return getKissenPaperPlayerClient().getPermissionContext().setPermission(permission);
+    }
+
+    @Override
+    public @NotNull Permission setPermission(@NotNull String permission, boolean value) throws EventCancelledException {
+        return getKissenPaperPlayerClient().getPermissionContext().setPermission(permission, value);
+    }
+
+    @Override
+    public @NotNull Permission setPermission(@NotNull Permission permission) throws EventCancelledException {
+        return getKissenPaperPlayerClient().getPermissionContext().setPermission(permission);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission) {
+        return getKissenPaperPlayerClient().getPermissionContext().unsetPermission(permission);
+    }
+
+    @Override
+    public int wipePermissions() {
+        return getKissenPaperPlayerClient().getPermissionContext().wipePermissions();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<Permission> getPermissionList() {
+        return getKissenPaperPlayerClient().getPermissionContext().getPermissionList();
+    }
+
+    @Override
+    public @NotNull Optional<Permission> getPermission(@NotNull String permission) {
+        return getKissenPaperPlayerClient().getPermissionContext().getPermission(permission);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAffectedUsers() {
+        return java.util.Collections.EMPTY_SET;
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<net.kissenpvp.core.api.permission.AbstractGroupablePermissionEntry<Permission>> getConnectedEntries()
+    {
+        return java.util.Collections.EMPTY_SET;
+    }
+
+    @Override
+    public void permissionUpdate() {/* ignored */ }
+
+    @Override
+    public @NotNull Optional<Permission> getOwnPermission(@NotNull String permission)
+    {
+        return getKissenPaperPlayerClient().getPermissionContext().getOwnPermission(permission);
+    }
+
+    @Override
+    public @NotNull Optional<Permission> getOwnPermission(@NotNull String permission, @NotNull Context context)
+    {
+        return getKissenPaperPlayerClient().getPermissionContext().getOwnPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<AbstractPermissionGroup<Permission>> getOwnPermissionsGroups(@NotNull Context context)
+    {
+        return getKissenPaperPlayerClient().getPermissionContext().getOwnPermissionsGroups(context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<AbstractPermissionGroup<Permission>> getPermissionGroups(@NotNull Context context)
+    {
+        return getKissenPaperPlayerClient().getPermissionContext().getPermissionGroups(context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<Permission> getOwnPermissions(@NotNull Context context) {
+        return getKissenPaperPlayerClient().getPermissionContext().getOwnPermissions(context);
+    }
+
+    @Override
+    public boolean inGroup(@NotNull AbstractPermissionGroup<Permission> permissionGroup, @NotNull Context context) {
+        return getKissenPaperPlayerClient().getPermissionContext().inGroup(permissionGroup, context);
+    }
+
+    @Override
+    public int wipeGroups(@NotNull Context context)
+    {
+        return getKissenPaperPlayerClient().getPermissionContext().wipeGroups(context);
+    }
+
+    @Override
+    public @NotNull Permission setPermission(@NotNull String permission, @NotNull Context context) throws EventCancelledException {
+        return getKissenPaperPlayerClient().getPermissionContext().setPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull Permission setPermission(@NotNull String permission, boolean value, @NotNull Context context) throws EventCancelledException {
+        return getKissenPaperPlayerClient().getPermissionContext().setPermission(permission, value, context);
+    }
+
+    @Override
+    public @NotNull Permission setPermission(@NotNull Permission permission, @NotNull Context context) throws EventCancelledException {
+        return getKissenPaperPlayerClient().getPermissionContext().setPermission(permission, context);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission, @NotNull Context context) {
+        return getKissenPaperPlayerClient().getPermissionContext().unsetPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<Permission> getPermissionList(@NotNull Context context) {
+        return getKissenPaperPlayerClient().getPermissionContext().getPermissionList(context);
+    }
+
+    @Override
+    public @NotNull Optional<Permission> getPermission(@NotNull String permission, @NotNull Context context) {
+        return getKissenPaperPlayerClient().getPermissionContext().getPermission(permission, context);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String permission, @NotNull Context context) {
+        return getKissenPaperPlayerClient().getPermissionContext().hasPermission(permission, context);
+    }
+
+    @Override
+    public int wipePermissions(@NotNull Context context)
+    {
+        return getKissenPaperPlayerClient().getPermissionContext().wipePermissions(context);
+    }
+    // KissenPaper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java b/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java
index 4e56018b64d11f76c8da43fd8f85c6de72204e36..d4260b8c0ae9bd7452651355899bf063261eb0a5 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java
@@ -104,4 +104,11 @@ public class CraftConsoleCommandSender extends ServerCommandSender implements Co
         return io.papermc.paper.configuration.GlobalConfiguration.get().console.hasAllPermissions || super.hasPermission(perm);
     }
     // Paper end
+
+    // KissenPaper start
+    @Override
+    public net.kyori.adventure.audience.@org.jetbrains.annotations.NotNull Audience getKyoriAudience() {
+        return this;
+    }
+    // KissenPaper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/command/ProxiedNativeCommandSender.java b/src/main/java/org/bukkit/craftbukkit/command/ProxiedNativeCommandSender.java
index 3e7d14564f11a3ed0b0766444e9d681804597e9a..afd092c5c046a471c2f44defb55d2eaa70090caf 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/ProxiedNativeCommandSender.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/ProxiedNativeCommandSender.java
@@ -146,4 +146,26 @@ public class ProxiedNativeCommandSender implements ProxiedCommandSender {
        return this.getCaller().spigot();
     }
     // Spigot end
+
+    // KissenPaper start
+    @Override
+    public @org.jetbrains.annotations.NotNull java.util.Locale getCurrentLocale() {
+        return this.getCaller().getCurrentLocale();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull net.kyori.adventure.text.Component displayName() {
+        return this.getCaller().displayName();
+    }
+
+    @Override
+    public boolean isConnected() {
+        return this.getCaller().isConnected();
+    }
+
+    @Override
+    public boolean isClient() {
+        return this.getCaller().isClient();
+    }
+    // KissenPaper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/command/ServerCommandSender.java b/src/main/java/org/bukkit/craftbukkit/command/ServerCommandSender.java
index 1e3091687735b461d3b6a313ab8761127981d3e8..fb8c7e4e78b9ceb11e61f769cba085d7a4ea8b0e 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/ServerCommandSender.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/ServerCommandSender.java
@@ -145,4 +145,21 @@ public abstract class ServerCommandSender implements CommandSender {
         return this.adventure$pointers;
     }
     // Paper end
+
+    // KissenPaper start
+    @Override
+    public @org.jetbrains.annotations.NotNull java.util.Locale getCurrentLocale() {
+        return Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.message.localization.LocalizationImplementation.class).getDefaultLocale();
+    }
+
+    @Override
+    public final boolean isConnected() {
+        return true;
+    }
+
+    @Override
+    public final boolean isClient() {
+        return false;
+    }
+    // KissenPaper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index a2d336ceb52b63db5c03432ee7bc94dc6a742b82..01f544a7c7e009d087b5128ca564ca71a549de7e 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -1280,4 +1280,21 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         return this.getHandle().getScoreboardName();
     }
     // Paper end - entity scoreboard name
+
+    // KissenPaper start
+    @Override
+    public @org.jetbrains.annotations.NotNull java.util.Locale getCurrentLocale() {
+        return org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.message.localization.LocalizationImplementation.class).getDefaultLocale();
+    }
+
+    @Override
+    public boolean isConnected() {
+        return true;
+    }
+
+    @Override
+    public final boolean isClient() { // Kinda useless for this use case
+        return true;
+    }
+    // KissenPaper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
index 41f3cdec7deabf34358b8087df77169f85a5b919..fb988ad444a8c57136ffa09f9a37e6a999e4b51a 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
@@ -70,7 +70,7 @@ import org.bukkit.plugin.Plugin;
 public class CraftHumanEntity extends CraftLivingEntity implements HumanEntity {
     private CraftInventoryPlayer inventory;
     private final CraftInventory enderChest;
-    protected final PermissibleBase perm = new PermissibleBase(this);
+    protected final /* PermissibleBase */ org.bukkit.permissions.Permissible perm = new net.kissenpvp.paper.permission.permissible.KissenPaperPlayerPermissible(this); // KissenPaper
     private boolean op;
     private GameMode mode;
 
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 7e6116963d835d4606ef3d93b69d3e44b61288e1..7720ee4da48c5e4eb4c6e1cf6bdc1f93ab84e1ea 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -191,6 +191,30 @@ import org.jetbrains.annotations.NotNull;
 
 import net.md_5.bungee.api.chat.BaseComponent; // Spigot
 
+// KissenPaper start
+import net.kissenpvp.core.api.ban.AbstractBan;
+import net.kissenpvp.core.api.base.KissenServer;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.networking.client.entitiy.ServerEntity;
+import net.kissenpvp.core.api.permission.AbstractPermissionGroup;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.api.user.rank.AbstractRank;
+import net.kissenpvp.core.api.time.AccurateDuration;
+import net.kissenpvp.paper.api.ban.Punishment;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.networking.client.entity.PaperOnlinePlayerClient;
+import net.kissenpvp.paper.api.permission.PaperPermissible;
+import net.kissenpvp.paper.api.permission.Permission;
+import net.kissenpvp.paper.api.permission.PermissibleOverriddenException;
+import net.kissenpvp.paper.api.user.rank.PlayerRank;
+import net.kissenpvp.paper.networking.client.entity.KissenPaperOnlinePlayerClient;
+import net.kissenpvp.paper.permission.permissible.KissenPaperPermissible;
+import net.kissenpvp.paper.user.KissenPaperPublicUser;
+import org.jetbrains.annotations.Unmodifiable;
+// KissenPaper stop
+
 @DelegateDeserialization(CraftOfflinePlayer.class)
 public class CraftPlayer extends CraftHumanEntity implements Player {
     private long firstPlayed = 0;
@@ -211,6 +235,10 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     private static final boolean DISABLE_CHANNEL_LIMIT = System.getProperty("paper.disableChannelLimit") != null; // Paper - add a flag to disable the channel limit
     private long lastSaveTime; // Paper - getLastPlayed replacement API
 
+    // KissenPaper start
+    private KissenPaperOnlinePlayerClient kissenPaperPlayer;
+    // KissenPaper end
+
     public CraftPlayer(CraftServer server, ServerPlayer entity) {
         super(server, entity);
 
@@ -2643,7 +2671,16 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     public void disconnect(String reason) {
         this.conversationTracker.abandonAllConversations();
-        this.perm.clearPermissions();
+        // KissenPaper start - logout user
+        try {
+            ((KissenPaperPermissible) getPermissible()).unsubscribe();
+        } catch (PermissibleOverriddenException overridden) {
+            if (this.perm instanceof org.bukkit.permissions.PermissibleBase permissibleBase) {
+                permissibleBase.clearPermissions();
+            }
+        }
+        ((net.kissenpvp.core.user.KissenUser) getUser(Context.LOCAL)).writeOnlineTimeData(Instant.ofEpochMilli(getLastLogin()));
+        // KissenPaper end - logout user
     }
 
     @Override
@@ -2985,7 +3022,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     // Paper start
     @Override
     public java.util.Locale locale() {
-        return getHandle().adventure$locale;
+        return /* getHandle().adventure$locale; */ getCurrentLocale(); // KissenPaper
     }
     // Paper end
     @Override
@@ -3120,7 +3157,14 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     public void sendMessage(final net.kyori.adventure.identity.Identity identity, final net.kyori.adventure.text.Component message, final net.kyori.adventure.audience.MessageType type) {
         if (getHandle().connection == null) return;
         final net.minecraft.core.Registry<net.minecraft.network.chat.ChatType> chatTypeRegistry = this.getHandle().level().registryAccess().registryOrThrow(net.minecraft.core.registries.Registries.CHAT_TYPE);
-        this.getHandle().connection.send(new net.minecraft.network.protocol.game.ClientboundSystemChatPacket(message, false));
+
+        // KissenPaper start - add custom renderer
+        Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.message.ChatImplementation.class).handle(Bukkit.getConsoleSender(), this, message).ifPresent(styled ->
+
+            this.getHandle().connection.send(new net.minecraft.network.protocol.game.ClientboundSystemChatPacket(styled, false))
+
+        );
+        // KissenPaper end
     }
 
     @Override
@@ -3382,7 +3426,15 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         public void sendMessage(net.md_5.bungee.api.ChatMessageType position, UUID sender, BaseComponent... components) {
             if ( CraftPlayer.this.getHandle().connection == null ) return;
 
-            CraftPlayer.this.getHandle().connection.send(new net.minecraft.network.protocol.game.ClientboundSystemChatPacket(components, position == net.md_5.bungee.api.ChatMessageType.ACTION_BAR));
+            // KissenPaper start - add custom renderer
+            net.kyori.adventure.text.Component[] componentData = java.util.Arrays.stream(components).map(net.md_5.bungee.chat.ComponentSerializer::toString).map(json ->
+                net.kyori.adventure.text.serializer.json.JSONComponentSerializer.json().deserialize(json)
+            ).toList().toArray(new net.kyori.adventure.text.Component[0]);
+
+            Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.message.ChatImplementation.class).handle(Bukkit.getConsoleSender(), CraftPlayer.this, componentData).ifPresent(styled ->
+                CraftPlayer.this.getHandle().connection.send(new net.minecraft.network.protocol.game.ClientboundSystemChatPacket(styled, position == net.md_5.bungee.api.ChatMessageType.ACTION_BAR))
+            );
+            // KissenPaper end
         }
 
         // Paper start
@@ -3519,4 +3571,353 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     public void setSendViewDistance(final int viewDistance) {
         this.getHandle().setSendViewDistance(viewDistance);
     }
+
+    // KissenPaper start - integrate user methods provided by the kissen implementation
+
+    private @NotNull KissenPaperOnlinePlayerClient getKissenPaperOnlinePlayerClient() {
+        if (kissenPaperPlayer == null) {
+            kissenPaperPlayer = new KissenPaperOnlinePlayerClient() {
+                @Override
+                public @NotNull CraftPlayer getCraftPlayer() {
+                    return CraftPlayer.this;
+                }
+
+                @Override
+                public @NotNull PaperPermissible getPermissible() throws PermissibleOverriddenException {
+                    if (!(perm instanceof PaperPermissible permissible)) {
+                        throw new PermissibleOverriddenException();
+                    }
+                    return permissible;
+                }
+
+                @Override
+                public @NotNull UUID getUniqueId() {
+                    return CraftPlayer.this.getUniqueId();
+                }
+            };
+        }
+        return kissenPaperPlayer;
+    }
+
+    @Override
+    public @NotNull User getUser() {
+        return getUser(Context.GLOBAL);
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull Context context) {
+        KissenPaperPublicUser kissenPublicUser = (KissenPaperPublicUser) Bukkit.getKissen()
+                .getImplementation(UserImplementation.class)
+                .getOnlineUser(getUniqueId())
+                .orElseThrow(IllegalStateException::new);
+        return switch (context)
+        {
+            case GLOBAL -> kissenPublicUser;
+            case LOCAL -> kissenPublicUser.getPrivateUserEntry();
+        };
+    }
+
+    @Override
+    public @NotNull io.netty.channel.Channel getConnection() {
+        return getHandle().connection.connection.channel;
+    }
+
+    @Override
+    public void sendPacket(@NotNull Object object) throws ClassNotFoundException, ClassCastException {
+        getHandle().connection.send((net.minecraft.network.protocol.Packet<?>) object);
+    }
+
+    @Override
+    public @NotNull net.kyori.adventure.audience.Audience getKyoriAudience() {
+        return this;
+    }
+
+    @Override
+    public @NotNull java.util.Locale getCurrentLocale() {
+        return getKissenPaperOnlinePlayerClient().getCurrentLocale();
+    }
+
+    // -
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAltAccounts() throws BackendException {
+        return getKissenPaperOnlinePlayerClient().getAltAccounts();
+    }
+
+    @Override
+    public @NotNull UUID getTotalID() {
+        return getKissenPaperOnlinePlayerClient().getTotalID();
+    }
+
+    @Override
+    public @NotNull Punishment punish(@NotNull AbstractBan ban, @NotNull ServerEntity banOperator) throws BackendException {
+        return getKissenPaperOnlinePlayerClient().punish(ban, banOperator);
+    }
+
+    @Override
+    public @NotNull Punishment punish(@NotNull AbstractBan ban, @NotNull ServerEntity banOperator, net.kyori.adventure.text.@org.jetbrains.annotations.Nullable Component reason) throws BackendException {
+        return getKissenPaperOnlinePlayerClient().punish(ban, banOperator, reason);
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable Punishment> getPunishment(@NotNull String id) throws BackendException {
+        return getKissenPaperOnlinePlayerClient().getPunishment(id);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<Punishment> getPunishmentHistory() throws BackendException {
+        return getKissenPaperOnlinePlayerClient().getPunishmentHistory();
+    }
+
+    @Override
+    public @NotNull net.kissenpvp.core.api.time.AccurateDuration getOnlineTime() {
+        return getKissenPaperOnlinePlayerClient().getOnlineTime();
+    }
+
+    @Override
+    public void kick(@NotNull String message) {
+        getKissenPaperOnlinePlayerClient().kick(message);
+    }
+
+    @Override
+    public void killConnection() {
+        getKissenPaperOnlinePlayerClient().killConnection();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.Nullable KissenServer getCurrentServer() {
+        return getKissenPaperOnlinePlayerClient().getCurrentServer();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<PlayerRank> getRankHistory() {
+        return getKissenPaperOnlinePlayerClient().getRankHistory();
+    }
+
+    @Override
+    public @NotNull PlayerRank getRank() {
+        return getKissenPaperOnlinePlayerClient().getRank();
+    }
+
+    @Override
+    public @NotNull PlayerRank grantRank(@NotNull AbstractRank rank) {
+        return getKissenPaperOnlinePlayerClient().grantRank(rank);
+    }
+
+    @Override
+    public @NotNull PlayerRank grantRank(@NotNull AbstractRank rank, @org.jetbrains.annotations.Nullable AccurateDuration accurateDuration) {
+        return getKissenPaperOnlinePlayerClient().grantRank(rank, accurateDuration);
+    }
+
+    @Override
+    public @NotNull net.kissenpvp.paper.api.ban.warn.Warn warn(@NotNull AbstractBan ban, @NotNull ServerEntity warnOperator) {
+        return getKissenPaperOnlinePlayerClient().warn(ban, warnOperator);
+    }
+
+    @Override
+    public @NotNull net.kissenpvp.paper.api.ban.warn.Warn warn(@NotNull AbstractBan ban, @NotNull ServerEntity warnOperator, net.kyori.adventure.text.@org.jetbrains.annotations.Nullable Component reason) {
+        return getKissenPaperOnlinePlayerClient().warn(ban, warnOperator, reason);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<net.kissenpvp.paper.api.ban.warn.Warn> getWarnHistory()
+    {
+        return getKissenPaperOnlinePlayerClient().getWarnHistory();
+    }
+
+    @Override
+    public void clearActiveWarns()
+    {
+        getKissenPaperOnlinePlayerClient().clearActiveWarns();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<@NotNull PaperOnlinePlayerClient> getOnlineAltAccounts() {
+        return getKissenPaperOnlinePlayerClient().getOnlineAltAccounts();
+    }
+
+    @Override
+    public @NotNull net.kissenpvp.core.api.time.AccurateDuration getOnlineTime(@NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getOnlineTime(context);
+    }
+
+    @Override
+    public @NotNull PaperPermissible getPermissible() throws PermissibleOverriddenException {
+        return getKissenPaperOnlinePlayerClient().getPermissible();
+    }
+
+    @Override
+    public @NotNull <X> net.kissenpvp.paper.api.user.playersetting.BoundPlayerSetting<X> getSetting(@NotNull Class<? extends net.kissenpvp.paper.api.user.playersetting.PlayerSetting<X>> settingClass) {
+        return getKissenPaperOnlinePlayerClient().getSetting(settingClass);
+    }
+
+    @Override
+    public @NotNull <X> net.kissenpvp.paper.api.user.playersetting.BoundPlayerSetting<X> getSetting(@NotNull Class<? extends net.kissenpvp.paper.api.user.playersetting.PlayerSetting<X>> settingClass, @NotNull Context context)
+    {
+        return getKissenPaperOnlinePlayerClient().getSetting(settingClass, context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<Permission> getOwnPermissions() {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getOwnPermissions();
+    }
+
+    @Override
+    public int wipeGroups() {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().wipeGroups();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<AbstractPermissionGroup<Permission>> getOwnPermissionGroups()
+    {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getOwnPermissionGroups();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<AbstractPermissionGroup<Permission>> getPermissionGroups() {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getPermissionGroups();
+    }
+
+    @Override
+    public boolean inGroup(@NotNull AbstractPermissionGroup<Permission> permissionGroup) {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().inGroup(permissionGroup);
+    }
+
+    @Override
+    public @NotNull String getPermissionID() {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getPermissionID();
+    }
+
+    @Override
+    public @NotNull Permission setPermission(@NotNull String permission) throws EventCancelledException {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().setPermission(permission);
+    }
+
+    @Override
+    public @NotNull Permission setPermission(@NotNull String permission, boolean value) throws EventCancelledException {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().setPermission(permission, value);
+    }
+
+    @Override
+    public @NotNull Permission setPermission(@NotNull Permission permission) throws EventCancelledException {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().setPermission(permission);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission) {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().unsetPermission(permission);
+    }
+
+    @Override
+    public int wipePermissions() {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().wipePermissions();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<Permission> getPermissionList() {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getPermissionList();
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable Permission> getPermission(@NotNull String permission) {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getPermission(permission);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAffectedUsers() {
+        return java.util.Collections.singleton(getUniqueId());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<net.kissenpvp.core.api.permission.AbstractGroupablePermissionEntry<Permission>> getConnectedEntries()
+    {
+        return java.util.Collections.singleton(this);
+    }
+
+    @Override
+    public void permissionUpdate() {
+        getPermissible().permissionUpdate();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<Permission> getOwnPermissions(@NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getOwnPermissions(context);
+    }
+
+    @Override
+    public @NotNull Optional<Permission> getOwnPermission(@NotNull String permission)
+    {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getOwnPermission(permission);
+    }
+
+    @Override
+    public @NotNull Optional<Permission> getOwnPermission(@NotNull String permission, @NotNull Context context)
+    {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getOwnPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<AbstractPermissionGroup<Permission>> getOwnPermissionsGroups(@NotNull Context context)
+    {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getOwnPermissionsGroups(context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<AbstractPermissionGroup<Permission>> getPermissionGroups(@NotNull Context context)
+    {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getPermissionGroups(context);
+    }
+
+    @Override
+    public boolean inGroup(@NotNull AbstractPermissionGroup<Permission> permissionGroup, @NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().inGroup(permissionGroup, context);
+    }
+
+    @Override
+    public int wipeGroups(@NotNull Context context)
+    {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().wipeGroups(context);
+    }
+
+    @Override
+    public @NotNull Permission setPermission(@NotNull String permission, @NotNull Context context) throws EventCancelledException {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().setPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull Permission setPermission(@NotNull String permission, boolean value, @NotNull Context context) throws EventCancelledException {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().setPermission(permission, value, context);
+    }
+
+    @Override
+    public @NotNull Permission setPermission(@NotNull Permission permission, @NotNull Context context) throws EventCancelledException {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().setPermission(permission, context);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission, @NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().unsetPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<Permission> getPermissionList(@NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getPermissionList(context);
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable Permission> getPermission(@NotNull String permission, @NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().getPermission(permission, context);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String permission, @NotNull Context context) {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().hasPermission(permission, context);
+    }
+
+    @Override
+    public int wipePermissions(@NotNull Context context)
+    {
+        return getKissenPaperOnlinePlayerClient().getPermissionContext().wipePermissions(context);
+    }
+    // KissenPaper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/profile/CraftPlayerProfile.java b/src/main/java/org/bukkit/craftbukkit/profile/CraftPlayerProfile.java
index 3e725dd3aca80a062917e3fd214c554b52dddde5..ed378ad44e88726a826fc8e9107c299e285e5170 100644
--- a/src/main/java/org/bukkit/craftbukkit/profile/CraftPlayerProfile.java
+++ b/src/main/java/org/bukkit/craftbukkit/profile/CraftPlayerProfile.java
@@ -61,6 +61,10 @@ public final class CraftPlayerProfile implements PlayerProfile, com.destroystoky
     private final PropertyMap properties = new PropertyMap();
     private final CraftPlayerTextures textures = new CraftPlayerTextures(this);
 
+    // KissenPaper start
+    private net.kissenpvp.core.api.user.User cached;
+    // KissenPaper end
+
     public CraftPlayerProfile(UUID uniqueId, String name) {
         Preconditions.checkArgument((uniqueId != null) || !StringUtils.isBlank(name), "uniqueId is null or name is blank");
         Preconditions.checkArgument(name == null || name.length() <= 16, "The name of the profile is longer than 16 characters"); // Paper - Validate
@@ -356,4 +360,13 @@ public final class CraftPlayerProfile implements PlayerProfile, com.destroystoky
     public boolean complete(final boolean textures, final boolean onlineMode) {
         throw new UnsupportedOperationException("Do not cast to com.destroystokyo.paper.profile.PlayerProfile");
     }
+
+
+    // KissenPaper start
+    @Override
+    public @org.jetbrains.annotations.NotNull net.kissenpvp.core.api.user.User getUser()
+    {
+        return org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.user.UserImplementation.class).getUser(getId());
+    }
+    // KissenPaper end
 }
