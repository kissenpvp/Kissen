From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Groldi <chniucg@gmail.com>
Date: Sun, 24 Sep 2023 13:30:52 +0200
Subject: [PATCH] Integrated ban system from kissen into paper


diff --git a/src/main/java/io/papermc/paper/adventure/ChatProcessor.java b/src/main/java/io/papermc/paper/adventure/ChatProcessor.java
index e4fd372a1d585887287253a02531cd192929377b..1d1567bd485d4fa076f2c0b311701a40bd1ed221 100644
--- a/src/main/java/io/papermc/paper/adventure/ChatProcessor.java
+++ b/src/main/java/io/papermc/paper/adventure/ChatProcessor.java
@@ -175,9 +175,14 @@ public final class ChatProcessor {
     }
 
     private void processModern(final ChatRenderer renderer, final Set<Audience> viewers, final Component message, final Player player, final boolean cancelled) {
+        // KissenPaper start - integrate mute
+        net.kissenpvp.paper.api.ban.PaperBanImplementation paperBanImplementation = org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.paper.api.ban.PaperBanImplementation.class);
+        java.util.Optional<net.kissenpvp.paper.api.ban.PaperPunishment> mute = paperBanImplementation.getLatestPunishment(player.getTotalID(), net.kissenpvp.core.api.ban.BanType.MUTE);
+        // KissenPaper end
+
         final PlayerChatMessage.AdventureView signedMessage = this.message.adventureView();
         final AsyncChatEvent ae = new AsyncChatEvent(this.async, player, viewers, renderer, message, this.paper$originalMessage, signedMessage);
-        ae.setCancelled(cancelled); // propagate cancelled state
+        ae.setCancelled(cancelled || mute.isPresent()); // propagate cancelled state // KissenPaper - set true if muted
         this.post(ae);
         final boolean listenersOnSyncEvent = canYouHearMe(ChatEvent.getHandlerList());
         if (listenersOnSyncEvent) {
@@ -188,13 +193,22 @@ public final class ChatProcessor {
                     se.setCancelled(ae.isCancelled()); // propagate cancelled state
                     ChatProcessor.this.post(se);
                     ChatProcessor.this.readModernModifications(se, renderer);
-                    ChatProcessor.this.complete(se);
+                    // KissenPaper start - integrate mute
+                    if(allowedToSend(player, mute.orElse(null), se.isCancelled()))
+                    {
+                        ChatProcessor.this.complete(se);
+                    }
                     return null;
                 }
             });
         } else {
             this.readModernModifications(ae, renderer);
-            this.complete(ae);
+            // KissenPaper start - integrate mute
+            if(allowedToSend(player, mute.orElse(null), ae.isCancelled()))
+            {
+                this.complete(ae);
+            }
+            // KissenPaper end
         }
     }
 
@@ -419,4 +433,33 @@ public final class ChatProcessor {
     static boolean canYouHearMe(final HandlerList handlers) {
         return handlers.getRegisteredListeners().length > 0;
     }
+
+    // KissenPaper start
+    /**
+     * Determines whether a player is allowed to send a message based on specified conditions.
+     * <p>
+     * This method evaluates the provided parameters and decides whether the player is allowed to send a message.
+     * The decision depends on the values of the 'muted' and 'cancelled' parameters. If both parameters are true,
+     * indicating that the player is both muted and the action is cancelled, a message is sent to the player
+     * notifying them about being muted, and the method returns false to indicate that the player is not allowed
+     * to send the message. Otherwise, the method returns true, allowing the player to send the message.
+     *
+     * @param player The player who intends to send a message. Must not be null.
+     * @param mute  A boolean flag indicating whether the player is muted. If true, the player is considered muted.
+     * @param cancelled A boolean flag indicating whether the action is cancelled. If true, the action is considered cancelled.
+     * @return true if the player is allowed to send the message, false otherwise.
+     *
+     * @throws NullPointerException If the 'player' parameter is null.
+     */
+    private boolean allowedToSend(@org.jetbrains.annotations.NotNull Player player, @org.jetbrains.annotations.Nullable net.kissenpvp.paper.api.ban.PaperPunishment mute, boolean cancelled)
+    {
+        if(mute != null && cancelled)
+        {
+            //mute is not null
+            player.sendMessage(mute.getPunishmentText(player.getCurrentLocale()));
+            return false;
+        }
+        return true;
+    }
+    // KissenPaper end
 }
diff --git a/src/main/java/net/kissenpvp/paper/ban/KissenPaperBan.java b/src/main/java/net/kissenpvp/paper/ban/KissenPaperBan.java
new file mode 100644
index 0000000000000000000000000000000000000000..a9f09b141d510355eb6d5a1d60d90e894ab130b5
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/ban/KissenPaperBan.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.ban;
+
+import net.kissenpvp.core.api.networking.socket.DataPackage;
+import net.kissenpvp.core.ban.KissenBan;
+import net.kissenpvp.paper.api.ban.PaperBan;
+import org.jetbrains.annotations.NotNull;
+
+public class KissenPaperBan extends KissenBan implements PaperBan {
+    @Override
+    public void sendData(@NotNull DataPackage dataPackage) {
+        //TODO
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/ban/KissenPaperBanImplementation.java b/src/main/java/net/kissenpvp/paper/ban/KissenPaperBanImplementation.java
new file mode 100644
index 0000000000000000000000000000000000000000..ecb0baf6216f53f3254b330817debaaf15f78938
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/ban/KissenPaperBanImplementation.java
@@ -0,0 +1,506 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.ban;
+
+import com.destroystokyo.paper.profile.CraftPlayerProfile;
+import com.destroystokyo.paper.profile.PlayerProfile;
+import com.mojang.authlib.GameProfile;
+import net.kissenpvp.core.api.ban.BanType;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.database.meta.Meta;
+import net.kissenpvp.core.api.database.meta.ObjectMeta;
+import net.kissenpvp.core.api.database.savable.SavableMap;
+import net.kissenpvp.core.api.message.MessageImplementation;
+import net.kissenpvp.core.api.message.Theme;
+import net.kissenpvp.core.api.message.localization.LocalizationImplementation;
+import net.kissenpvp.core.api.networking.client.entitiy.ServerEntity;
+import net.kissenpvp.core.api.time.AccurateDuration;
+import net.kissenpvp.core.api.time.TimeImplementation;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.ban.KissenBanImplementation;
+import net.kissenpvp.core.ban.KissenPunishmentNode;
+import net.kissenpvp.core.base.KissenCore;
+import net.kissenpvp.core.base.KissenImplementation;
+import net.kissenpvp.core.message.localization.KissenLocalizationImplementation;
+import net.kissenpvp.paper.api.ban.PaperBan;
+import net.kissenpvp.paper.api.ban.PaperBanImplementation;
+import net.kissenpvp.paper.api.ban.PaperPunishment;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.command.PaperCommandImplementation;
+import net.kissenpvp.paper.ban.command.BanCommand;
+import net.kissenpvp.paper.ban.command.PaperBanParser;
+import net.kissenpvp.paper.ban.command.PaperPunishmentParser;
+import net.kissenpvp.paper.ban.warn.command.WarnCommand;
+import net.kissenpvp.paper.command.KissenPaperCommandImplementation;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.BanEntry;
+import org.bukkit.Bukkit;
+import org.bukkit.entity.Player;
+import org.bukkit.event.player.PlayerKickEvent;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.text.MessageFormat;
+import java.time.Duration;
+import java.time.Instant;
+import java.time.temporal.ChronoUnit;
+import java.util.*;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+@SuppressWarnings("rawtypes")
+public class KissenPaperBanImplementation extends KissenBanImplementation<PaperBan, PaperPunishment> implements PaperBanImplementation, KissenImplementation {
+
+    @Override
+    public boolean start() {
+        KissenLocalizationImplementation kissenLocalizationImplementation = KissenCore.getInstance().getImplementation(KissenLocalizationImplementation.class);
+        kissenLocalizationImplementation.register("server.ban.created.permanent", new MessageFormat("The ban has been created with the ID {0}, designated with the name {1}, classified under the type {2}, and assigned a permanent duration."));
+        kissenLocalizationImplementation.register("server.ban.created", new MessageFormat("The ban has been created with the ID {0}, designated with the name {1}, classified under the type {2}, and assigned a duration of {3}."));
+        kissenLocalizationImplementation.register("server.ban.deleted", new MessageFormat("The ban with ID {0} was successfully deleted."));
+        kissenLocalizationImplementation.register("server.ban.invalid", new MessageFormat("The ban with ID {0} was not found."));
+        kissenLocalizationImplementation.register("server.ban.punishment.invalid", new MessageFormat("The punishment with ID {0} was not found."));
+        kissenLocalizationImplementation.register("server.ban.punishment.pardoned", new MessageFormat("The ban, bearing the ID {0}, has been revoked."));
+
+        kissenLocalizationImplementation.register("server.ban.punishment.compact", new MessageFormat("[{7}] [{3}] {1} #{0}"));
+        kissenLocalizationImplementation.register("server.ban.compact", new MessageFormat("[{0}] [{2}] {1}"));
+
+        kissenLocalizationImplementation.register("server.ban.punishment.operator", new MessageFormat("Operator"));
+        kissenLocalizationImplementation.register("server.ban.punishment.cause", new MessageFormat("Cause"));
+        kissenLocalizationImplementation.register("server.ban.punishment.start", new MessageFormat("Start"));
+        kissenLocalizationImplementation.register("server.ban.punishment.actual.end", new MessageFormat("Actual End"));
+        kissenLocalizationImplementation.register("server.ban.punishment.predicted.end", new MessageFormat("Expected End"));
+
+        kissenLocalizationImplementation.register("server.ban.punishment.end.never", new MessageFormat("never"));
+        kissenLocalizationImplementation.register("server.ban.history.empty", new MessageFormat("The punishment history of {0} is empty."));
+        kissenLocalizationImplementation.register("server.ban.warn.ban", new MessageFormat("The player {0} already has {1} warn(s). Do you want to punish the player instead?\n{2} {3}"));
+        kissenLocalizationImplementation.register("server.ban.warn.clear", new MessageFormat("The warn(s) of the player {0} have been reset."));
+
+        PaperCommandImplementation command = Bukkit.getKissen().getImplementation(PaperCommandImplementation.class);
+        command.registerParser(PaperBan.class, new PaperBanParser());
+        command.registerParser(PaperPunishment.class, new PaperPunishmentParser());
+        command.registerHandler(new PaperBanParser());
+        command.registerHandler(new PaperPunishmentParser());
+        return super.start();
+    }
+
+    @Override
+    public void setupComplete() {
+        Bukkit.getKissen().getImplementation(KissenPaperCommandImplementation.class).registerCommand(new BanCommand());
+        Bukkit.getKissen().getImplementation(KissenPaperCommandImplementation.class).registerCommand(new WarnCommand());
+    }
+
+    @Override
+    public void applyBan(@NotNull PaperPunishment ban) {
+        ban.getOnlineAffectedPlayers().forEach(player -> applyBan(ban, player));
+    }
+
+    private void applyBan(@NotNull PaperPunishment ban, @NotNull Player player) {
+        switch (ban.getBanType())
+        {
+            case BAN -> player.kick(Component.translatable("multiplayer.disconnect.banned"), PlayerKickEvent.Cause.BANNED);
+            case KICK -> player.kick(Component.translatable("multiplayer.disconnect.kicked"), PlayerKickEvent.Cause.KICK_COMMAND);
+            case MUTE -> player.sendMessage(Component.translatable("chat.filtered_full"));
+        }
+    }
+
+    @Override
+    protected @NotNull @Unmodifiable Set<PaperBan> fetchBanSet() throws BackendException {
+        return Stream.concat(queryBanStream(getMeta()), queryBanStream(getMeta(Context.LOCAL)))
+                .filter(Objects::nonNull)
+                .collect(Collectors.toSet());
+    }
+
+    @Override
+    protected @NotNull @Unmodifiable ObjectMeta getMeta() {
+        return Bukkit.getKissen().getPublicMeta();
+    }
+
+    @Override
+    protected @NotNull PaperBan buildBan(int id, @NotNull Map<String, String> data) throws BackendException {
+        KissenPaperBan kissenPaperBan = new KissenPaperBan();
+        kissenPaperBan.setup(String.valueOf(id), data);
+        return kissenPaperBan;
+    }
+
+    @Override
+    protected @NotNull PaperPunishment translatePunishment(@NotNull UUID totalID, @NotNull KissenPunishmentNode kissenPunishmentNode, @NotNull Meta meta) {
+        return new KissenPaperPunishment(totalID, kissenPunishmentNode, record -> set(totalID, (KissenPunishmentNode) record, meta));
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPunishment> getPunishmentSet(@NotNull Context context) throws BackendException {
+        return getPunishmentSet(getMeta(context));
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPunishment> getPunishmentSet(@NotNull UUID totalID, @NotNull Context context) throws BackendException {
+        return getPunishmentSet(totalID, getMeta(context));
+    }
+
+    @Override
+    public @NotNull Optional<PaperPunishment> getLatestPunishment(@NotNull UUID totalID, @NotNull Context context) throws BackendException {
+        return getLatestPunishment(totalID, getMeta(context));
+    }
+
+    @Override
+    public @NotNull Optional<PaperPunishment> getLatestPunishment(@NotNull UUID totalID, @NotNull BanType banType, @NotNull Context context) throws BackendException {
+        return getLatestPunishment(totalID, banType, getMeta(context));
+    }
+
+    @Override
+    public @NotNull PaperPunishment punish(@NotNull UUID totalID, @NotNull PaperBan ban, @NotNull ServerEntity banOperator, @Nullable Component cause, @NotNull Context context) throws BackendException {
+        return punish(totalID, ban, banOperator, true, cause);
+    }
+
+    @Override
+    public @NotNull PaperPunishment punish(@NotNull UUID totalID, @NotNull PaperBan ban, @NotNull ServerEntity banOperator, @NotNull Context context) throws BackendException {
+        return punish(totalID, ban, banOperator, true, context);
+    }
+
+    @Override
+    public @NotNull PaperPunishment punish(@NotNull UUID totalID, @NotNull PaperBan ban, @NotNull ServerEntity banOperator, boolean apply, @NotNull Context context) throws BackendException {
+        return punish(totalID, ban, banOperator, apply, null, context);
+    }
+
+    @Override
+    public @NotNull PaperPunishment punish(@NotNull UUID totalID, @NotNull PaperBan ban, @NotNull ServerEntity banOperator, boolean apply, @Nullable Component cause, @NotNull Context context) throws BackendException {
+        return punish(totalID, ban, banOperator, apply, cause, getMeta(context));
+    }
+
+    /**
+     * Retrieves the meta information based on the provided context.
+     *
+     * @param context The context to determine which meta information to retrieve.
+     * @return The meta information based on the provided context.
+     */
+    protected @NotNull @Unmodifiable ObjectMeta getMeta(@NotNull Context context) {
+        return switch (context) {
+            case GLOBAL -> getMeta();
+            case LOCAL -> Bukkit.getKissen().getPrivateMeta();
+        };
+    }
+
+    /**
+     * Queries the ban stream based on the given meta information.
+     * <p>
+     * This method performs a database operation under the hood to fetch a stream of PaperBan
+     * instances. The query operates on the foundations of the supplied meta information. This
+     * metaobject encapsulates essential data that directs the query towards the appropriate
+     * dataset within the database.
+     * <p>
+     * A stream interface is being utilized here due to its advantages in handling large datasets.
+     * It works by loading data on-demand, instead of loading it all at once into memory, making the
+     * process more efficient.
+     * <p>
+     * The function will map over the values returned from the database query by utilizing the
+     * banProcessor() function on each element, further processing the raw data into PaperBan
+     * objects that the application can interact with.
+     * <p>
+     * An important factor to note is that this method throws a BackendException. This exception
+     * is thrown if there are issues encountered when querying the ban stream from the database,
+     * such as connection problems, invalid query syntax.
+     *
+     * @param meta The meta information containing the data to query. This is an instance of
+     *             ObjectMeta which encapsulates the query parameters.
+     * @return The ban stream based on the given meta information. Takes form as a stream of
+     * PaperBan objects each representing a unique ban instance.
+     * @throws BackendException If there is an error querying the ban stream, this exception
+     *                          will be thrown. It signifies an issue with the backend operation.
+     */
+    private @NotNull Stream<PaperBan> queryBanStream(@NotNull ObjectMeta meta) throws BackendException {
+        return meta.getData(new KissenPaperBan()).thenApply(Map::values).thenApply(Collection::stream).thenApply(
+                s -> s.map(banProcessor())).join();
+    }
+
+    /**
+     * Retrieves the ban processor function, which processes a SavableMap and returns a PaperBan.
+     *
+     * @return The ban processor function.
+     */
+    @Contract(pure = true)
+    private @NotNull Function<SavableMap, PaperBan> banProcessor() {
+        return savableMap -> createBan(Integer.parseInt(savableMap.getNotNull("id")), savableMap);
+    }
+
+    // Bukkit
+
+    @Override
+    public @NotNull <E extends BanEntry<? super PlayerProfile>> Set<E> getEntries() {
+        return getPunishmentSet().stream().map(punishment -> (E) punishment).collect(Collectors.toSet());
+    }
+
+    @Override
+    public <E extends BanEntry<? super PlayerProfile>> @Nullable E getBanEntry(@NotNull String target) {
+        return (E) getBanEntry(Objects.requireNonNull(resolvePlayerProfile(target)));
+    }
+
+    @Override
+    public @Nullable BanEntry<PlayerProfile> getBanEntry(@NotNull PlayerProfile target) {
+        return getLatestPunishment(Objects.requireNonNull(target.getId())).orElse(null);
+    }
+
+    @Override
+    public @NotNull Set<BanEntry> getBanEntries() {
+        return getPunishmentSet().stream().map(punishment -> (BanEntry<?>) punishment).collect(Collectors.toSet());
+    }
+
+    @SuppressWarnings("deprecation")
+    @Override
+    public <E extends BanEntry<? super PlayerProfile>> @Nullable E getBanEntry(org.bukkit.profile.@NotNull PlayerProfile target) {
+        return (E) getLatestPunishment(Objects.requireNonNull(target.getUniqueId())).orElse(null);
+    }
+
+    @Override
+    public boolean isBanned(@NotNull String target) {
+        return isBanned(Objects.requireNonNull(resolvePlayerProfile(target)));
+    }
+
+    @Override
+    public boolean isBanned(@NotNull PlayerProfile target) {
+            return getLatestPunishment(Objects.requireNonNull(target.getId())).isPresent();
+    }
+
+    @SuppressWarnings("deprecation")
+    @Override
+    public boolean isBanned(@NotNull org.bukkit.profile.PlayerProfile target) {
+        return getLatestPunishment(Objects.requireNonNull(target.getUniqueId())).isPresent();
+    }
+
+    @Override
+    public void pardon(@NotNull String target) {
+        //TODO
+    }
+
+    @Override
+    public void pardon(@NotNull PlayerProfile target) {
+        //TODO
+    }
+
+    @SuppressWarnings("deprecation")
+    @Override
+    public void pardon(@NotNull org.bukkit.profile.PlayerProfile target) {
+        //TODO
+    }
+
+    @Override
+    public <E extends BanEntry<? super PlayerProfile>> @Nullable E addBan(@NotNull String target, @Nullable String reason, @Nullable Date expires, @Nullable String source) {
+        return (E) addBan(Objects.requireNonNull(resolvePlayerProfile(target)), reason, expires, source);
+    }
+
+    @SuppressWarnings("deprecation")
+    @Override
+    public <E extends BanEntry<? super PlayerProfile>> @Nullable E addBan(org.bukkit.profile.@NotNull PlayerProfile target, @Nullable String reason, @Nullable Instant expires, @Nullable String source) {
+        return (E) addBan(target.getUser(), reason, getDateTransformer(expires), source);
+    }
+
+    @SuppressWarnings("deprecation")
+    @Override
+    public <E extends BanEntry<? super PlayerProfile>> @Nullable E addBan(org.bukkit.profile.@NotNull PlayerProfile target, @Nullable String reason, @Nullable Duration duration, @Nullable String source) {
+        return (E) addBan(target.getUser(), reason, getDateTransformer(duration), source);
+    }
+
+    @SuppressWarnings("deprecation")
+    @Override
+    public <E extends BanEntry<? super PlayerProfile>> @Nullable E addBan(org.bukkit.profile.@NotNull PlayerProfile target, @Nullable String reason, @Nullable Date expires, @Nullable String source) {
+        return (E) addBan(target.getUser(), reason, getDateTransformer(expires), source);
+    }
+
+    @Override
+    public @Nullable BanEntry<PlayerProfile> addBan(@NotNull PlayerProfile target, @Nullable String reason, @Nullable Instant expires, @Nullable String source) {
+        return addBan(target.getUser(), reason, getDateTransformer(expires), source);
+    }
+
+    @Override
+    public @Nullable BanEntry<PlayerProfile> addBan(@NotNull PlayerProfile target, @Nullable String reason, @Nullable Duration duration, @Nullable String source) {
+        return addBan(target.getUser(), reason, getDateTransformer(duration), source);
+    }
+
+    @Override
+    public @Nullable BanEntry<PlayerProfile> addBan(@NotNull PlayerProfile target, @Nullable String reason, @Nullable Date expires, @Nullable String source) {
+        return addBan(target.getUser(), reason, getDateTransformer(expires), source);
+    }
+
+    private @Nullable PlayerProfile resolvePlayerProfile(@NotNull String target)
+    {
+        GameProfile gameProfile = resolveGameProfile(target);
+        return gameProfile == null ? null : new CraftPlayerProfile(gameProfile.getId(), gameProfile.getName());
+    }
+
+    private @Nullable GameProfile resolveGameProfile(@NotNull String target)
+    {
+        if(target.matches("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$"))
+        {
+            UUID targetUUID = UUID.fromString(target);
+            return Objects.requireNonNull(MinecraftServer.getServer().getProfileCache()).get(targetUUID).orElse(null);
+        }
+        return Objects.requireNonNull(MinecraftServer.getServer().getProfileCache()).get(target).orElse(null);
+    }
+
+    /**
+     * This method is responsible for adding an entry to the ban list for a specific player. This method requires several parameters as described below.
+     * <p>
+     * The action of banning involves communicating with a backend system.
+     * If the system is not reachable, a {@link BackendException} will be thrown.
+     * To handle such situations, this method has a catch block to wrap the {@link BackendException}
+     *
+     * @param target              represents the {@link User} object to be banned.
+     *                            This parameter is annotated with {@link NotNull}
+     *                            which means it must never be null.
+     * @param reason              is a string containing the reason for the ban.
+     *                            This parameter is allowed to be null, represent by {@link Nullable}.
+     *                            If null, the default reason specified by the system will be used.
+     * @param durationTransformer is an instance of {@link DurationTransformer}.
+     *                            This parameter is used to determine the duration of the ban.
+     *                            This cannot be null.
+     * @param source              is a string representing the entity which imposes the ban action.
+     *                            Though this parameter is nullable, a {@link IllegalArgumentException}
+     *                            will be thrown if source is null after an internal checking.
+     * @return An instance of {@link BanEntry}<{@link PlayerProfile}> is created and returned.
+     * The return value encapsulates details such as ban type, ban duration,
+     * operator and reason for the ban.
+     * @throws IllegalArgumentException If the {@code source} parameter is null.
+     * @throws RuntimeException         If the backend system cannot be reached.
+     */
+    private @NotNull BanEntry<PlayerProfile> addBan(@NotNull User target, @Nullable String reason, @NotNull DurationTransformer durationTransformer, @Nullable String source) {
+
+        if (source == null) {
+            throw new IllegalArgumentException("Source must not be null");
+        }
+        // Detect source
+        return punish(target.getPlayerClient().getTotalID(),
+                new MinecraftBan(BanType.BAN, durationTransformer.create()), new ServerEntity()
+                {
+                    @Override
+                    public @NotNull String getName()
+                    {
+                        return source;
+                    }
+
+                    @Override
+                    public @NotNull Component displayName()
+                    {
+                        return Component.text(source);
+                    }
+
+                    @Override
+                    public @NotNull Locale getCurrentLocale()
+                    {
+                        return Bukkit.getKissen().getImplementation(
+                                LocalizationImplementation.class).getDefaultLocale();
+                    }
+
+                    @Override
+                    public @NotNull Theme getTheme()
+                    {
+                        return Bukkit.getKissen().getImplementation(MessageImplementation.class).getDefaultTheme();
+                    }
+
+                    @Override
+                    public boolean isConnected()
+                    {
+                        return false;
+                    }
+
+                    @Override
+                    public boolean isClient()
+                    {
+                        return true;
+                    }
+                }, reason == null ? null : LegacyComponentSerializer.legacySection().deserialize(reason));
+    }
+
+    /**
+     * The `getDateTransformer` method is overloaded to accept three different types of arguments: {@link Date}, {@link Duration}, and {@link Instant}.
+     * These methods have been contractually defined to produce a new value whenever they're called and are considered to be pure (no side effects).
+     * <p>
+     * Each of these methods is responsible for converting a given {@link Date}, {@link Duration}, or {@link Instant} into an instance of {@link DurationTransformer}, an interface that only contains one method: `create()`, which returns an {@link AccurateDuration} object.
+     * <p>
+     * Note: If the `Date`, `Duration`, or `Instant` provided to these methods is null, the `create()` method of the resultant {@link DurationTransformer} will return null when called.
+     *
+     * @param expires - {@link Date} object representing point of expire instance or null.
+     * @return a new {@link DurationTransformer} that encapsulates the conversion logic from {@link Date} to {@link AccurateDuration}.
+     */
+    @Contract(value = "_ -> new", pure = true)
+    private @NotNull DurationTransformer getDateTransformer(@Nullable Date expires) {
+        return getDateTransformer(expires == null ? null : expires.toInstant());
+    }
+
+    /**
+     * Converts a given {@link Duration} object to a new instance of {@link DurationTransformer}. This method is a part of a suite of transformation methods that handle different types of expire representation.
+     *
+     * @param duration is a {@link Duration} that represents the amount of expire or can potentially be null.
+     *                 If null, the method will delegate to another `getDateTransformer` method with a null {@link Instant} as an argument.
+     *                 If not null, the method will transform it into an {@link Instant} that is the current moment in expire incremented by the
+     *                 number of milliseconds represented by the duration. Then it delegates to another `getDateTransformer` method.
+     * @return a new {@link DurationTransformer}, which is a functional interface for converting different types of expire representation into
+     * an {@link AccurateDuration}. This returned transformer's `create` method will, when called, produce an {@link AccurateDuration}
+     * representing the same expire span as the given duration argument.
+     */
+    @Contract(value = "_ -> new", pure = true)
+    private @NotNull DurationTransformer getDateTransformer(@Nullable Duration duration) {
+        return getDateTransformer(duration == null ? null : Instant.now().plusMillis(duration.toMillis()));
+    }
+
+    /**
+     * Converts a given {@link Instant} object to a new instance of {@link DurationTransformer}. This method is a part of a suite of transformation methods that handle different types of expire representation.
+     *
+     * @param instant is an {@link Instant} that represents a specific moment on a expire-line or can potentially be null.
+     *                If null, the returned {@link DurationTransformer}'s `create` method will produce null when called.
+     *                If not null, the returned {@link DurationTransformer}'s `create` method will produce an {@link AccurateDuration} which represents
+     *                amount of expire between now and the instant when called.
+     * @return a new {@link DurationTransformer}, which is a functional interface for converting different types of expire representation into an
+     * {@link AccurateDuration}. Depending on the arguments it has been passed, the `create` method of returned object will produce different output.
+     */
+    @Contract(value = "_ -> new", pure = true)
+    private @NotNull DurationTransformer getDateTransformer(@Nullable Instant instant) {
+        return new DurationTransformer() {
+            @Override
+            public @Nullable AccurateDuration create() {
+                return instant == null ? null : Bukkit.getKissen().getImplementation(TimeImplementation.class).millis(Instant.now().until(instant, ChronoUnit.MILLIS));
+            }
+        };
+    }
+
+    /**
+     * DurationTransformer is a functional interface which provides a contract for transforming various expire representations into an {@link AccurateDuration}.
+     * It's intended to be utilized by classes that need expire conversion functionalities.
+     * Annotated with {@code @FunctionalInterface}, it ensures that this interface should only have one abstract method, conforming to the Java language specification.
+     */
+    @FunctionalInterface
+    private interface DurationTransformer {
+
+        /**
+         * This abstract method named 'create' is the single method in this functional interface. The duty of exact transformation varies depending on its implementation.
+         * <ul>
+         * <li> In some implementations, the 'create' method will convert a specific point in expire into a duration from that point until the current expire.</li>
+         * <li> In others, it might translate a specific elapsed expire period into a duration.</li>
+         * </ul>
+         *
+         * @return an {@link AccurateDuration} instance representing the result of the transformation, or null if the transformation could not be successfully completed
+         * or resulted in a null value.
+         */
+        @Nullable AccurateDuration create();
+
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/ban/KissenPaperPunishment.java b/src/main/java/net/kissenpvp/paper/ban/KissenPaperPunishment.java
new file mode 100644
index 0000000000000000000000000000000000000000..f3aa1569a7d9afd281d3d2914ba384783a6652f0
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/ban/KissenPaperPunishment.java
@@ -0,0 +1,131 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.ban;
+
+import com.destroystokyo.paper.profile.PlayerProfile;
+import net.kissenpvp.core.ban.KissenPunishment;
+import net.kissenpvp.core.ban.KissenPunishmentNode;
+import net.kissenpvp.core.database.DataWriter;
+import net.kissenpvp.paper.api.ban.PaperPunishment;
+import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;
+import org.bukkit.Bukkit;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Date;
+import java.util.Set;
+import java.util.UUID;
+import java.util.stream.Collectors;
+
+/**
+ * The {@code KissenPaperPunishment} class is a specific implementation of {@code KissenPunishment}, representing
+ * punishment data in a Paper server context. This class additionally implements the {@code PaperPunishment}
+ * interface, hence making it a Paper-specific extension of the {@code KissenPunishment}.
+ * <p>
+ * This class is designed to work with in-game Players and their associated punishment data, including
+ * PunishmentNode, DataWriter and much more. It provides operations to manipulate the punishment data such as
+ * {@code getOnlineAffectedPlayers()}, {@code getBanTarget()}, {@code getCreated()} etc.
+ * <p>
+ * The instances of this class are mutable but do not allow direct mutation of the created and source fields.
+ * Mutating operations for these fields will throw an {@code UnsupportedOperationException}.
+ *
+ * @see KissenPunishment
+ * @see PaperPunishment
+ * @author User
+ */
+public class KissenPaperPunishment extends KissenPunishment<Player> implements PaperPunishment {
+
+    /**
+     * Instantiates a {@code KissenPaperPunishment}.
+     *
+     * @param totalID The UUID of the dataset for which the punishment data is to be created.
+     * @param kissenPunishmentNode The data container for this punishment.
+     * @param dataWriter (Nullable) The DataWriter that will be used for updating the punishment data.
+     */
+    public KissenPaperPunishment(@NotNull UUID totalID, @NotNull KissenPunishmentNode kissenPunishmentNode, @Nullable DataWriter dataWriter) {
+        super(totalID, kissenPunishmentNode, dataWriter);
+    }
+
+    @Override
+    public @Unmodifiable Set<Player> getOnlineAffectedPlayers() {
+        return Bukkit.getOnlinePlayers().stream().filter(player -> player.getTotalID().equals(getTotalID())).collect(Collectors.toSet());
+    }
+
+    @Override
+    public @NotNull String getTarget() {
+        return null; //TODO
+    }
+
+    @Override
+    public @NotNull PlayerProfile getBanTarget() {
+        return null; //TODO
+    }
+
+    @Override
+    public @NotNull Date getCreated() {
+        return Date.from(getStart());
+    }
+
+    @Override
+    public void setCreated(@NotNull Date created) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public @NotNull String getSource() {
+        return getBanOperator();
+    }
+
+    @Override
+    public void setSource(@NotNull String source) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public @Nullable Date getExpiration() {
+        return getEnd().map(Date::from).orElse(null);
+    }
+
+    @Override
+    public void setExpiration(@Nullable Date expiration) {
+        setEnd(expiration == null ? null : expiration.toInstant());
+    }
+
+    @Override
+    public @Nullable String getReason() {
+        return getCause().map(cause -> LegacyComponentSerializer.legacyAmpersand().serialize(cause)).orElse(null);
+    }
+
+    @Override
+    public void setReason(@Nullable String reason) {
+        setCause(reason == null ? null : LegacyComponentSerializer.legacySection().deserialize(reason));
+    }
+
+    @Override
+    public void save() {
+        // not used
+    }
+
+    @Override
+    public void remove() {
+        // not used
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/ban/KissenPaperPunishmentList.java b/src/main/java/net/kissenpvp/paper/ban/KissenPaperPunishmentList.java
new file mode 100644
index 0000000000000000000000000000000000000000..0f6f4a3b3d05ffd7fd74f86bb39b5c749a67a4af
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/ban/KissenPaperPunishmentList.java
@@ -0,0 +1,167 @@
+package net.kissenpvp.paper.ban;
+
+import com.google.gson.JsonObject;
+import com.mojang.authlib.GameProfile;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.api.user.UserInfo;
+import net.kissenpvp.paper.api.ban.PaperBanImplementation;
+import net.kissenpvp.paper.api.ban.PaperPunishment;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.MutableComponent;
+import net.minecraft.server.players.StoredUserEntry;
+import net.minecraft.server.players.UserBanList;
+import net.minecraft.server.players.UserBanListEntry;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Collection;
+import java.util.List;
+import java.util.Objects;
+import java.util.stream.Collectors;
+
+public class KissenPaperPunishmentList extends UserBanList {
+
+    public KissenPaperPunishmentList() {
+        super(null);
+    }
+
+
+    
+    @Override
+    protected @NotNull StoredUserEntry<GameProfile> createEntry(JsonObject json) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean isBanned(GameProfile profile) {
+        return getBanImplementation().isBanned(String.valueOf(profile.getId()));
+    }
+
+    @Override
+    public String @NotNull [] getUserList() {
+        return new String[0]; // too performance consuming and not even necessary.
+    }
+
+    @Override
+    public @NotNull File getFile() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void add(UserBanListEntry entry) {
+        getBanImplementation().addBan(String.valueOf(Objects.requireNonNull(entry.getUser()).getId()), entry.getReason(), entry.getExpires(), entry.getSource());
+    }
+
+    @Nullable
+    @Override
+    public UserBanListEntry get(@NotNull GameProfile key) {
+        try {
+            return getBanImplementation().getLatestPunishment(key.getId()).map(this::translate).orElse(null); //TODO use totalID instead.
+        }catch (BackendException backendException)
+        {
+            return null;
+        }
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return getBanImplementation().getEntries().isEmpty();
+    }
+
+    @Override
+    protected boolean contains(@NotNull GameProfile k0) {
+        return getEntries().stream().anyMatch(entry -> Objects.equals(entry.getUser(), k0));
+    }
+
+    @Override
+    public @NotNull Collection<UserBanListEntry> getEntries() {
+        return getBanImplementation().getEntries().stream().map(ban -> translate((PaperPunishment) ban)).collect(Collectors.toSet());
+    }
+
+    @Override
+    public void save() throws IOException {
+        // ignored
+    }
+
+    @Override
+    public void load()  {
+        // ignored
+    }
+
+    @Override
+    public void remove(@NotNull GameProfile key) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void remove(@NotNull StoredUserEntry<GameProfile> entry) {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Retrieves the PaperBanImplementation instance.
+     *
+     * @return The PaperBanImplementation instance. This method returns the implementation of the PaperBan plugin
+     *         registered with Bukkit's implementation provider.
+     * @throws IllegalStateException if the PaperBanImplementation has not been registered with the implementation provider.
+     */
+    private @NotNull PaperBanImplementation getBanImplementation()
+    {
+        return Bukkit.getKissen().getImplementation(PaperBanImplementation.class);
+    }
+
+    /**
+     * Translates a PaperPunishment object into a UserBanListEntry object.
+     *
+     * @param paperPunishment The PaperPunishment object to be translated.
+     * @return The translated UserBanListEntry object.
+     */
+    @Contract("_ -> new")
+    private @NotNull UserBanListEntry translate(@NotNull PaperPunishment paperPunishment)
+    {
+        return new KissenPaperPunishmentListEntry(paperPunishment);
+    }
+
+    private final static class KissenPaperPunishmentListEntry extends UserBanListEntry
+    {
+        private final PaperPunishment paperPunishment;
+
+        public KissenPaperPunishmentListEntry(@NotNull PaperPunishment paperPunishment)
+        {
+            super(null, paperPunishment.getCreated(), paperPunishment.getSource(), paperPunishment.getExpiration(),
+                    paperPunishment.getName());
+            this.paperPunishment = paperPunishment;
+        }
+
+        @Override
+        public @NotNull Component getDisplayName()
+        {
+
+            UserImplementation userImplementation = Bukkit.getKissen().getImplementation(UserImplementation.class);
+            List<MutableComponent> componentStream = paperPunishment.getAffectedPlayers().stream().map(
+                    uuid -> userImplementation.getCachedUserProfile(uuid).map(UserInfo::getName).map(
+                            Component::literal).orElse(Component.translatable("commands.banlist.entry.unknown"))).toList();
+
+            MutableComponent names = Component.empty();
+            for (int i = 0; i < componentStream.size(); i++)
+            {
+                names.append(componentStream.get(i));
+                if(i < componentStream.size() - 2)
+                {
+                    names.append(", ");
+                }
+                else if(i < componentStream.size() - 1)
+                {
+                    names.append(" and ");
+                }
+            }
+
+            return names;
+        }
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/ban/MinecraftBan.java b/src/main/java/net/kissenpvp/paper/ban/MinecraftBan.java
new file mode 100644
index 0000000000000000000000000000000000000000..d2b3e173d8ef4886da76a40f48761a9f5eeeb607
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/ban/MinecraftBan.java
@@ -0,0 +1,60 @@
+package net.kissenpvp.paper.ban;
+
+import net.kissenpvp.core.api.ban.BanType;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.time.AccurateDuration;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Optional;
+
+public class MinecraftBan implements net.kissenpvp.paper.api.ban.PaperBan {
+
+    private final BanType banType;
+    private final AccurateDuration duration;
+
+    public MinecraftBan(BanType banType, AccurateDuration duration) {
+        this.banType = banType;
+        this.duration = duration;
+    }
+
+    @Override
+    public int getID() {
+        return -1;
+    }
+
+    @Override
+    public @NotNull String getName() {
+        return "Minecraft";
+    }
+
+    @Override
+    public void setName(@NotNull String name) throws EventCancelledException {
+        throw new EventCancelledException(new UnsupportedOperationException());
+    }
+
+    @Override
+    public @NotNull BanType getBanType() {
+        return banType;
+    }
+
+    @Override
+    public void setBanType(@NotNull BanType banType) throws EventCancelledException {
+        throw new EventCancelledException(new UnsupportedOperationException());
+    }
+
+    @Override
+    public @NotNull Optional<AccurateDuration> getAccurateDuration() {
+        return Optional.ofNullable(duration);
+    }
+
+    @Override
+    public void setAccurateDuration(@Nullable AccurateDuration duration) throws EventCancelledException {
+        throw new EventCancelledException(new UnsupportedOperationException());
+    }
+
+    @Override
+    public int delete()  {
+        throw new EventCancelledException(new UnsupportedOperationException());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/ban/command/BanCommand.java b/src/main/java/net/kissenpvp/paper/ban/command/BanCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..fc6ceb34627bb42ed3ea533d41ffa271e5956f87
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/ban/command/BanCommand.java
@@ -0,0 +1,159 @@
+package net.kissenpvp.paper.ban.command;
+
+import net.kissenpvp.core.api.ban.BanType;
+import net.kissenpvp.core.api.ban.Punishment;
+import net.kissenpvp.core.api.ban.exception.NonexistentPunishmentException;
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.core.api.command.annotations.ArgumentName;
+import net.kissenpvp.core.api.command.annotations.CommandData;
+import net.kissenpvp.core.api.command.annotations.Optional;
+import net.kissenpvp.core.api.command.annotations.TabCompleter;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.time.AccurateDuration;
+import net.kissenpvp.core.api.time.TemporalObject;
+import net.kissenpvp.paper.api.ban.PaperBan;
+import net.kissenpvp.paper.api.ban.PaperBanImplementation;
+import net.kissenpvp.paper.api.ban.PaperPunishment;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;
+import org.bukkit.Bukkit;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+
+import java.time.Instant;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+public class BanCommand
+{
+
+    /**
+     * Executes the ban command to punish a specific user by removing their access rights from the server.
+     *
+     * @param payload       the command payload containing the sender information
+     * @param player the offline player to be banned
+     * @param paperBan      the PaperBan representing the type of ban
+     * @param reasonArray        the optional reason for the ban
+     * @throws BackendException if there is an error in the backend
+     */
+    @CommandData(value = "ban", aliases = {"punish",
+                                           "mute",
+                                           "kick"}, description = "This command is used to ban or punish a specific user by removing their access rights from the server.")
+    public void ban(@NotNull CommandPayload<CommandSender> payload, @NotNull OfflinePlayer player, @NotNull PaperBan paperBan, @NotNull @Optional @ArgumentName("reason") String[] reasonArray) throws BackendException {
+        if(payload.getSender() instanceof OfflinePlayer && player.getRank().getSource().getPriority() < player.getRank().getSource().getPriority())
+        {
+            payload.getSender().sendMessage(Component.translatable("server.ban.player.not.allowed", player.displayName()));
+            return;
+        }
+        java.util.Optional<Component> reason = getReason(reasonArray);
+        PaperPunishment punishment = player.punish(paperBan, payload.getSender(), reason.orElse(null));
+
+        Component displayName = player.displayName();
+        Component message = messages().punishComponent(displayName, punishment.getBanType(), reason.orElse(null));
+        payload.getSender().sendMessage(message);
+    }
+
+    /**
+     * This method is responsible for executing the command to create predefined ban types
+     * with a specified duration which can serve as templates for different banning situations.
+     * CommandData annotation is used to provide command metadata.
+     *
+     * @param payload          The information about the command including sender and command details.
+     * @param name             The name of the ban template.
+     * @param id               The identifier for the ban template.
+     * @param banType          The type of ban that this template represents.
+     * @param accurateDuration The duration which the ban (derived from this template) will last.
+     * @throws BackendException If any error occurs during the creation of the ban template at the backend.
+     */
+    @CommandData(value = "banidcreate", aliases = {"bidc", "createidban"}, description = "Command to create predefined ban types with a specified duration. These can be used as templates for various ban situations.")
+    public void create(@NotNull CommandPayload<CommandSender> payload, @ArgumentName("id") int id, @NotNull @ArgumentName("name") String name, @NotNull @ArgumentName("type") BanType banType, @NotNull java.util.Optional<AccurateDuration> accurateDuration) throws BackendException {
+        PaperBanImplementation paperBanImplementation = Bukkit.getKissen().getImplementation(PaperBanImplementation.class);
+
+        Runnable runnable = () -> {
+            PaperBan paperBan = paperBanImplementation.createBan(id, name, banType, accurateDuration.orElse(null));
+
+            Component idComponent = Component.text(paperBan.getID()), nameComponent = Component.text(paperBan.getName()), banTypeComponent = Component.text(paperBan.getBanType().toString());
+            if(accurateDuration.isPresent())
+            {
+                Component[] args = {
+                        idComponent,
+                        nameComponent,
+                        banTypeComponent,
+                        accurateDuration.get().toComponent(payload.getSender().getCurrentLocale())
+                };
+                payload.getSender().sendMessage(Component.translatable("server.ban.created", args));
+                return;
+            }
+            Component[] args = {
+                    idComponent,
+                    nameComponent,
+                    banTypeComponent
+            };
+            payload.getSender().sendMessage(Component.translatable("server.ban.created.permanent", args));
+        };
+
+        //Ask for confirmation if ban exists.
+        if(paperBanImplementation.getBan(id).isPresent())
+        {
+            payload.confirmRequest(runnable);
+            return;
+        }
+        runnable.run();
+    }
+
+    @CommandData(value = "baniddelete", aliases = {"bidd", "deleteidban"})
+    public void delete(@NotNull CommandPayload<CommandSender> payload, @NotNull PaperBan paperBan) throws BackendException {
+        paperBan.delete();
+        payload.getSender().sendMessage(Component.translatable("server.ban.deleted", Component.text(paperBan.getID())));
+    }
+
+    @CommandData(value = "unban", description = "This command is used to disable a specific ban, identifying it by its unique ID.")
+    public void unban(@NotNull CommandPayload<CommandSender> payload, @NotNull PaperPunishment punishment)
+    {
+        if (!punishment.isValid())
+        {
+            throw new NonexistentPunishmentException(punishment.getID());
+        }
+        punishment.setEnd(Instant.now());
+
+        Component idComponent = Component.text(punishment.getID());
+        payload.getSender().sendMessage(Component.translatable("server.ban.punishment.pardoned", idComponent));
+    }
+
+    @TabCompleter("unban")
+    public @NotNull Set<String> tabUnban() {
+        return Bukkit.getKissen().getImplementation(PaperBanImplementation.class).getPunishmentSet().stream().filter(
+                TemporalObject::isValid).map(Punishment::getID).collect(Collectors.toSet());
+    }
+
+    @CommandData(value = "banhistory", aliases = "bh")
+    public void history(@NotNull CommandPayload<CommandSender> payload, @NotNull OfflinePlayer offlinePlayer, @NotNull @ArgumentName("page") java.util.Optional<Integer> page) {
+        payload.getSender().sendMessage(messages().getHistory(payload, offlinePlayer, page.orElse(1)));
+    }
+
+    @CommandData(value = "baninfo", aliases = {"punishmentinfo"})
+    public void banInfo(@NotNull CommandPayload<CommandSender> payload, @NotNull PaperPunishment paperPunishment) {
+        payload.getSender().sendMessage(messages().punishmentInfo(payload, paperPunishment));
+    }
+
+
+    @Contract(pure = true, value = "-> new") private @NotNull BanCommandMessages messages()
+    {
+        return new BanCommandMessages();
+    }
+
+    /**
+     * Retrieves the reason as a {@link Component} object.
+     *
+     * @param reason the array of strings representing the reason
+     * @return the reason as a Component object, or null if the reason is empty
+     */
+    private @NotNull java.util.Optional<Component> getReason(@NotNull String @NotNull [] reason) {
+        if (reason.length != 0) {
+            return java.util.Optional.of(LegacyComponentSerializer.legacyAmpersand().deserialize(String.join(" ", reason).strip()));
+        }
+        return java.util.Optional.empty();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/ban/command/PaperBanParser.java b/src/main/java/net/kissenpvp/paper/ban/command/PaperBanParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..c461c3b8ee406be885c9c2d92e6de9ec0c2a7dc1
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/ban/command/PaperBanParser.java
@@ -0,0 +1,60 @@
+package net.kissenpvp.paper.ban.command;
+
+import net.kissenpvp.core.api.ban.Ban;
+import net.kissenpvp.core.api.ban.exception.NonexistentBanException;
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.core.api.command.exception.deserialization.DeserializationException;
+import net.kissenpvp.paper.api.ban.PaperBan;
+import net.kissenpvp.paper.api.ban.PaperBanImplementation;
+import net.kissenpvp.paper.api.command.PaperArgumentParser;
+import net.kissenpvp.paper.api.command.PaperCommandExceptionHandler;
+import net.kyori.adventure.text.Component;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Collection;
+import java.util.Optional;
+import java.util.stream.Collectors;
+
+public class PaperBanParser implements PaperArgumentParser<PaperBan>, PaperCommandExceptionHandler<NonexistentBanException> {
+
+    @Override
+    public @NotNull String serialize(@NotNull PaperBan object) {
+        return String.valueOf(object.getID());
+    }
+
+    @Override
+    public @NotNull PaperBan deserialize(@NotNull String input) {
+        PaperBanImplementation paperBanImplementation = Bukkit.getKissen().getImplementation(PaperBanImplementation.class);
+
+        Optional<PaperBan> paperBan = Optional.empty();
+        try
+        {
+            paperBan = paperBanImplementation.getBan(Integer.parseInt(input));
+        } catch (NumberFormatException ignored) {}
+
+        // must be orElse get, otherwise it will execute it even paperBan is not null and might throw an DeserializationException
+        return paperBan.orElseGet(() -> paperBanImplementation.getBanSet().stream()
+                        .filter(ban -> ban.getName().equals(input)).findFirst()
+                        .orElseThrow(() -> new DeserializationException(new NonexistentBanException(input))));
+    }
+
+    @Override
+    public @Nullable String argumentName()
+    {
+        return "banid";
+    }
+
+    @Override
+    public @NotNull Collection<String> tabCompletion(@NotNull CommandPayload<CommandSender> commandPayload) {
+        return Bukkit.getKissen().getImplementation(PaperBanImplementation.class).getBanSet().stream().map(Ban::getID).map(String::valueOf).collect(Collectors.toSet());
+    }
+
+    @Override
+    public boolean handle(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull NonexistentBanException throwable) {
+        commandPayload.getSender().sendMessage(Component.translatable("server.ban.invalid", Component.text(throwable.getBan())));
+        return true;
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/ban/command/PaperPunishmentParser.java b/src/main/java/net/kissenpvp/paper/ban/command/PaperPunishmentParser.java
index 55167ae5fef79f24545df34479443dbb74399a57..fa325b12e4ded7edd98a2a5d9740ccd87d1caa18 100644
--- a/src/main/java/net/kissenpvp/paper/ban/command/PaperPunishmentParser.java
+++ b/src/main/java/net/kissenpvp/paper/ban/command/PaperPunishmentParser.java
@@ -1,19 +1,46 @@
 package net.kissenpvp.paper.ban.command;
 
+import net.kissenpvp.core.api.ban.Punishment;
+import net.kissenpvp.core.api.ban.exception.NonexistentPunishmentException;
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.paper.api.ban.PaperBanImplementation;
 import net.kissenpvp.paper.api.ban.PaperPunishment;
 import net.kissenpvp.paper.api.command.PaperArgumentParser;
+import net.kissenpvp.paper.api.command.PaperCommandExceptionHandler;
+import net.kyori.adventure.text.Component;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
 import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
 
-public class PaperPunishmentParser implements PaperArgumentParser<PaperPunishment>
-{
-    @Override public @NotNull String serialize(@NotNull PaperPunishment object)
-    {
+import java.util.Collection;
+import java.util.stream.Collectors;
+
+public class PaperPunishmentParser implements PaperArgumentParser<PaperPunishment>, PaperCommandExceptionHandler<NonexistentPunishmentException> {
+    @Override
+    public @NotNull String serialize(@NotNull PaperPunishment object) {
         return object.getID();
     }
 
-    @Override public @NotNull PaperPunishment deserialize(@NotNull String input)
+    @Override
+    public @NotNull PaperPunishment deserialize(@NotNull String input) {
+        return Bukkit.getKissen().getImplementation(PaperBanImplementation.class).getPunishmentSet().stream().filter(punishment -> punishment.getID().equals(input)).findFirst().orElseThrow(() -> new NonexistentPunishmentException(input));
+    }
+
+    @Override
+    public @Nullable String argumentName()
     {
-        //TODO
-        return null;
+        return "punishmentid";
+    }
+
+    @Override
+    public @NotNull Collection<String> tabCompletion(@NotNull CommandPayload<CommandSender> commandPayload) {
+        return Bukkit.getKissen().getImplementation(PaperBanImplementation.class).getPunishmentSet().stream().map(Punishment::getID).collect(Collectors.toSet());
+    }
+
+    @Override
+    public boolean handle(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull NonexistentPunishmentException throwable) {
+        commandPayload.getSender().sendMessage(Component.translatable("server.ban.punishment.invalid", Component.text(throwable.getPunishment())));
+        return true;
     }
 }
diff --git a/src/main/java/net/kissenpvp/paper/base/KissenPaperCore.java b/src/main/java/net/kissenpvp/paper/base/KissenPaperCore.java
index 0b60b0ce23e75ccc19b8afcb5a190e73761bf7a8..0272123739ac57d03f50ed1e47373f85310572f5 100644
--- a/src/main/java/net/kissenpvp/paper/base/KissenPaperCore.java
+++ b/src/main/java/net/kissenpvp/paper/base/KissenPaperCore.java
@@ -18,6 +18,7 @@
 
 package net.kissenpvp.paper.base;
 
+import net.kissenpvp.core.api.ban.BanImplementation;
 import net.kissenpvp.core.api.base.Implementation;
 import net.kissenpvp.core.api.base.plugin.KissenPlugin;
 import net.kissenpvp.core.api.database.meta.ObjectMeta;
@@ -31,6 +32,7 @@ import net.kissenpvp.core.permission.PermissionImplementation;
 import net.kissenpvp.paper.api.base.PaperKissen;
 import net.kissenpvp.paper.api.permission.PaperPermissionImplementation;
 import net.kissenpvp.paper.api.command.PaperCommandImplementation;
+import net.kissenpvp.paper.ban.KissenPaperBanImplementation;
 import net.kissenpvp.paper.command.KissenPaperCommandImplementation;
 import net.kissenpvp.paper.command.confirmation.KissenPaperConfirmationImplementation;
 import net.kissenpvp.paper.message.localization.KissenPaperLocalizationImplementation;
@@ -68,6 +70,7 @@ public class KissenPaperCore extends KissenCore implements PaperKissen {
         loader.put(PaperPermissionImplementation.class, permissionImplementation);
         loader.put(LocalizationImplementation.class, new KissenPaperLocalizationImplementation());
         loader.put(PaperCommandImplementation.class, new KissenPaperCommandImplementation());
+        loader.put(BanImplementation.class, new KissenPaperBanImplementation());
         loader.put(KissenConfirmationImplementation.class, new KissenPaperConfirmationImplementation());
         super.loadImplementations(loader);
     }
diff --git a/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
index 06153274bfcaa4c8637b6d7a2496df0d5de38f53..62322448c83f06ea3866354402bf41f720367260 100644
--- a/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
@@ -401,12 +401,55 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener,
                 disconnect(Component.translatable("multiplayer.disconnect.not_whitelisted"));
                 return false;
             }
+
+            net.kissenpvp.paper.api.ban.PaperBanImplementation banImplementation = org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.paper.api.ban.PaperBanImplementation.class);
+            net.kissenpvp.paper.api.ban.PaperPunishment paperPunishment = banImplementation.getLatestPunishment(kissenPaperPublicUser.get("total_id").map(java.util.UUID::fromString).orElse(gameProfile.getId()), net.kissenpvp.core.api.ban.BanType.BAN).orElse(null);
+            if (paperPunishment != null) {
+                disconnect(io.papermc.paper.adventure.PaperAdventure.asVanilla(paperPunishment.getPunishmentText(getLocale(kissenPaperPublicUser))));
+                return false;
+            }
+
         } catch (BackendException backendException) {
             disconnect(Component.translatable("multiplayer.disconnect.unverified_username")); // maybe better message
             return false;
         }
         return true;
     }
+
+    /**
+     * Gets the given KissenPaperPublicUsers locale. The method first attempts to retrieve the locale
+     * identified by the key "forced_locale" from the user's property list. If the "forced_locale" is not defined or its
+     * value cannot be translated into a Locale object by the localizationImplementation, the method then attempts to
+     * retrieve the locale identified by the key "locale". If the "locale" is also absent or invalid, it defaults to
+     * localizationImplementation's default locale.
+     *
+     * <p>The method interacts with the LocalizationImplementation to obtain locale strings
+     * and convert them to Java Locale objects.</p>
+     *
+     * @param kissenPaperPublicUser The KissenPaperPublicUser object from which the locale is retrieved.
+     *                              This parameter must be of type KissenPaperPublicUser and cannot be null.
+     *
+     * @return The Locale object corresponding to the user's forced locale, or their standard locale,
+     *         or the default locale as defined by the LocalizationImplementation API.
+     *         The result will not be null.
+     *
+     * @throws NullPointerException if kissenPaperPublicUser is null.
+     *
+     * @see net.kissenpvp.core.api.message.localization.LocalizationImplementation
+     * @see java.util.Locale
+     * @see java.util.Optional
+     */
+    private @org.jetbrains.annotations.NotNull java.util.Locale getLocale(@org.jetbrains.annotations.NotNull KissenPaperPublicUser kissenPaperPublicUser) {
+        net.kissenpvp.core.api.message.localization.LocalizationImplementation localizationImplementation = Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.message.localization.LocalizationImplementation.class);
+
+        java.util.Optional<java.util.Locale> forcedLocale = kissenPaperPublicUser.get("forced_locale").map(localizationImplementation::getLocale);
+        java.util.Optional<java.util.Locale> locale = kissenPaperPublicUser.get("locale").map(localizationImplementation::getLocale);
+        java.util.Locale defaultLocale = localizationImplementation.getDefaultLocale();
+
+        return forcedLocale.orElse(locale.orElse(defaultLocale));
+    }
+    // KissenPaper end
+
     // KissenPaper end
 
     @Override
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index dec368368fc97aaf777f13a5d88a3326262d1bab..3b897a777cd89394cfc56009576f6c6489242afd 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -163,7 +163,7 @@ public abstract class PlayerList {
         server.console = new com.destroystokyo.paper.console.TerminalConsoleCommandSender(); // Paper
         // CraftBukkit end
 
-        this.bans = new UserBanList(PlayerList.USERBANLIST_FILE);
+        this.bans = /*new UserBanList(PlayerList.USERBANLIST_FILE);*/ new net.kissenpvp.paper.ban.KissenPaperPunishmentList(); // KissenPaper - rework ban system
         this.ipBans = new IpBanList(PlayerList.IPBANLIST_FILE);
         this.ops = /*new ServerOpList(PlayerList.OPLIST_FILE);*/ new net.kissenpvp.paper.user.KissenUserOperatorList(); // KissenPaper
         this.whitelist = /*new UserWhiteList(PlayerList.WHITELIST_FILE);*/ new net.kissenpvp.paper.user.KissenUserWhiteList(); // KissenPaper
@@ -732,37 +732,39 @@ public abstract class PlayerList {
         Player player = entity.getBukkitEntity();
         PlayerLoginEvent event = new PlayerLoginEvent(player, loginlistener.connection.hostname, ((java.net.InetSocketAddress) socketaddress).getAddress(), ((java.net.InetSocketAddress) loginlistener.connection.channel.remoteAddress()).getAddress());
 
-        // Paper start - Fix MC-158900
-        UserBanListEntry gameprofilebanentry;
-        if (getBans().isBanned(gameprofile) && (gameprofilebanentry = getBans().get(gameprofile)) != null) {
-            // Paper end
-
-            ichatmutablecomponent = Component.translatable("multiplayer.disconnect.banned.reason", gameprofilebanentry.getReason());
-            if (gameprofilebanentry.getExpires() != null) {
-                ichatmutablecomponent.append((Component) Component.translatable("multiplayer.disconnect.banned.expiration", PlayerList.BAN_DATE_FORMAT.format(gameprofilebanentry.getExpires())));
-            }
-
-            // return chatmessage;
-            event.disallow(PlayerLoginEvent.Result.KICK_BANNED, io.papermc.paper.adventure.PaperAdventure.asAdventure(ichatmutablecomponent)); // Paper - Adventure
-        } else if (!this.isWhiteListed(gameprofile, event)) { // Paper
-            //ichatmutablecomponent = Component.translatable("multiplayer.disconnect.not_whitelisted"); // Paper
-            //event.disallow(PlayerLoginEvent.Result.KICK_WHITELIST, net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(org.spigotmc.SpigotConfig.whitelistMessage)); // Spigot // Paper - Adventure - moved to isWhitelisted
-        } else if (this.getIpBans().isBanned(socketaddress) && getIpBans().get(socketaddress) != null && !this.getIpBans().get(socketaddress).hasExpired()) { // Paper - fix NPE with temp ip bans
-            IpBanListEntry ipbanentry = this.ipBans.get(socketaddress);
-
-            ichatmutablecomponent = Component.translatable("multiplayer.disconnect.banned_ip.reason", ipbanentry.getReason());
-            if (ipbanentry.getExpires() != null) {
-                ichatmutablecomponent.append((Component) Component.translatable("multiplayer.disconnect.banned_ip.expiration", PlayerList.BAN_DATE_FORMAT.format(ipbanentry.getExpires())));
-            }
-
-            // return chatmessage;
-            event.disallow(PlayerLoginEvent.Result.KICK_BANNED, io.papermc.paper.adventure.PaperAdventure.asAdventure(ichatmutablecomponent)); // Paper - Adventure
-        } else {
+        // KissenPaper start - rework ban system
+//      // Paper start - Fix MC-158900
+//      UserBanListEntry gameprofilebanentry;
+//      if (getBans().isBanned(gameprofile) && (gameprofilebanentry = getBans().get(gameprofile)) != null) {
+//          // Paper end
+//
+//          ichatmutablecomponent = Component.translatable("multiplayer.disconnect.banned.reason", gameprofilebanentry.getReason());
+//          if (gameprofilebanentry.getExpires() != null) {
+//              ichatmutablecomponent.append((Component) Component.translatable("multiplayer.disconnect.banned.expiration", PlayerList.BAN_DATE_FORMAT.format(gameprofilebanentry.getExpires())));
+//          }
+//
+//          // return chatmessage;
+//          event.disallow(PlayerLoginEvent.Result.KICK_BANNED, io.papermc.paper.adventure.PaperAdventure.asAdventure(ichatmutablecomponent)); // Paper - Adventure
+//      } else if (!this.isWhiteListed(gameprofile, event)) { // Paper
+//          //ichatmutablecomponent = Component.translatable("multiplayer.disconnect.not_whitelisted"); // Paper
+//          //event.disallow(PlayerLoginEvent.Result.KICK_WHITELIST, net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(org.spigotmc.SpigotConfig.whitelistMessage)); // Spigot // Paper - Adventure - moved to isWhitelisted
+//      } else if (this.getIpBans().isBanned(socketaddress) && getIpBans().get(socketaddress) != null && !this.getIpBans().get(socketaddress).hasExpired()) { // Paper - fix NPE with temp ip bans
+//          IpBanListEntry ipbanentry = this.ipBans.get(socketaddress);
+//
+//          ichatmutablecomponent = Component.translatable("multiplayer.disconnect.banned_ip.reason", ipbanentry.getReason());
+//          if (ipbanentry.getExpires() != null) {
+//              ichatmutablecomponent.append((Component) Component.translatable("multiplayer.disconnect.banned_ip.expiration", PlayerList.BAN_DATE_FORMAT.format(ipbanentry.getExpires())));
+//          }
+//
+//          // return chatmessage;
+//          event.disallow(PlayerLoginEvent.Result.KICK_BANNED, io.papermc.paper.adventure.PaperAdventure.asAdventure(ichatmutablecomponent)); // Paper - Adventure
+        //} else {
             // return this.players.size() >= this.maxPlayers && !this.canBypassPlayerLimit(gameprofile) ? IChatBaseComponent.translatable("multiplayer.disconnect.server_full") : null;
             if (this.players.size() >= this.maxPlayers && !this.canBypassPlayerLimit(gameprofile)) {
                 event.disallow(PlayerLoginEvent.Result.KICK_FULL, net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(org.spigotmc.SpigotConfig.serverFullMessage)); // Spigot // Paper - Adventure
             }
-        }
+//      }
+        // KissenPaper end
 
         this.cserver.getPluginManager().callEvent(event);
         if (event.getResult() != PlayerLoginEvent.Result.ALLOWED) {
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index a7bbe2bcba76adb9ffff5f98b648e8510e93312e..9b9983de2b345b5d747a3441fa001a8931c6bd98 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -2206,12 +2206,19 @@ public final class CraftServer implements Server {
 
     @Override
     public <T extends BanList<?>> T getBanList(BanList.Type type) {
+        // KissenPaper start - rework ban system
+        return (T) Bukkit.getKissen().getImplementation(net.kissenpvp.paper.api.ban.PaperBanImplementation.class);
+        // The following code is effectively dead
+        /*
         Preconditions.checkArgument(type != null, "BanList.Type cannot be null");
 
         return switch (type) {
             case IP -> (T) new CraftIpBanList(this.playerList.getIpBans());
             case PROFILE, NAME -> (T) new CraftProfileBanList(this.playerList.getBans());
         };
+
+        */
+        // KissenPaper end
     }
 
     @Override
