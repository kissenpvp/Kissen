From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Groldi <chniucg@gmail.com>
Date: Sun, 24 Sep 2023 13:30:00 +0200
Subject: [PATCH] Integrated command system from kissen into paper


diff --git a/src/main/java/io/papermc/paper/plugin/manager/PaperPluginManagerImpl.java b/src/main/java/io/papermc/paper/plugin/manager/PaperPluginManagerImpl.java
index de4811e4ecd81af9055cdad9d3d5677a7406873a..a1fb02924cc8ed43fe6a45ff18427138fe44c309 100644
--- a/src/main/java/io/papermc/paper/plugin/manager/PaperPluginManagerImpl.java
+++ b/src/main/java/io/papermc/paper/plugin/manager/PaperPluginManagerImpl.java
@@ -4,13 +4,13 @@ import com.google.common.graph.MutableGraph;
 import io.papermc.paper.plugin.PermissionManager;
 import io.papermc.paper.plugin.configuration.PluginMeta;
 import io.papermc.paper.plugin.provider.entrypoint.DependencyContext;
+import net.kissenpvp.paper.api.command.CommandImplementation;
 import org.bukkit.Bukkit;
 import org.bukkit.Server;
 import org.bukkit.command.CommandMap;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.event.Event;
 import org.bukkit.event.EventPriority;
-import org.bukkit.event.Listener;
 import org.bukkit.permissions.Permissible;
 import org.bukkit.permissions.Permission;
 import org.bukkit.plugin.EventExecutor;
@@ -259,5 +259,20 @@ public class PaperPluginManagerImpl implements PluginManager, DependencyContext
     public void registerTranslation(@NotNull String key, @NotNull java.text.MessageFormat defaultMessage, @NotNull Plugin plugin) {
         org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.core.api.message.localization.LocalizationImplementation.class).register(plugin, key, defaultMessage);
     }
+
+    @Override
+    public void registerCommand(@NotNull Plugin plugin, @NotNull Object... objects) {
+        org.bukkit.Bukkit.getKissen().getImplementation(CommandImplementation.class).getPluginHandler(plugin).ifPresent(handler -> handler.registerCommand(objects));
+    }
+
+    @Override
+    public void registerExceptionHandler(@NotNull net.kissenpvp.core.api.base.ExceptionHandler<?> exceptionHandler, @NotNull Plugin plugin) {
+        org.bukkit.Bukkit.getKissen().getImplementation(CommandImplementation.class).getPluginHandler(plugin).ifPresent(handler -> handler.registerExceptionHandler(exceptionHandler));
+    }
+
+    @Override
+    public <T> void registerParser(@NotNull Class<T> type, @NotNull net.kissenpvp.paper.api.command.ArgumentParser<T> parser, @NotNull Plugin plugin) {
+        org.bukkit.Bukkit.getKissen().getImplementation(CommandImplementation.class).getPluginHandler(plugin).ifPresent(handler -> handler.registerParser(type, parser));
+    }
     // KissenPaper start
 }
diff --git a/src/main/java/net/kissenpvp/paper/ban/KissenPaperBanImplementation.java b/src/main/java/net/kissenpvp/paper/ban/KissenPaperBanImplementation.java
new file mode 100644
index 0000000000000000000000000000000000000000..dc6bc76ed46223745f235f1c8f03661e6d565a08
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/ban/KissenPaperBanImplementation.java
@@ -0,0 +1,498 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.ban;
+
+import com.destroystokyo.paper.profile.CraftPlayerProfile;
+import com.destroystokyo.paper.profile.PlayerProfile;
+import com.mojang.authlib.GameProfile;
+import net.kissenpvp.core.api.ban.BanType;
+import net.kissenpvp.core.api.database.connection.DatabaseConnection;
+import net.kissenpvp.core.api.database.connection.DatabaseImplementation;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.database.meta.Meta;
+import net.kissenpvp.core.api.database.meta.ObjectMeta;
+import net.kissenpvp.core.api.database.savable.SavableMap;
+import net.kissenpvp.core.api.message.localization.LocalizationImplementation;
+import net.kissenpvp.core.api.networking.client.entitiy.ServerEntity;
+import net.kissenpvp.core.api.time.AccurateDuration;
+import net.kissenpvp.core.api.time.TimeImplementation;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.ban.KissenBanImplementation;
+import net.kissenpvp.core.ban.KissenPunishmentNode;
+import net.kissenpvp.core.base.KissenCore;
+import net.kissenpvp.core.base.KissenImplementation;
+import net.kissenpvp.core.command.InternalCommandImplementation;
+import net.kissenpvp.core.database.KissenTable;
+import net.kissenpvp.core.message.localization.KissenLocalizationImplementation;
+import net.kissenpvp.paper.api.ban.*;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.ban.command.BanCommand;
+import net.kissenpvp.paper.ban.warn.command.WarnCommand;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.BanEntry;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Player;
+import org.bukkit.event.player.PlayerKickEvent;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.text.MessageFormat;
+import java.time.Duration;
+import java.time.Instant;
+import java.time.temporal.ChronoUnit;
+import java.util.*;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public class KissenPaperBanImplementation extends KissenBanImplementation<Ban, Punishment> implements BanImplementation, KissenImplementation {
+
+    private KissenTable privateTable;
+
+    @Override
+    public boolean preStart() {
+        DatabaseImplementation database = Bukkit.getKissen().getImplementation(DatabaseImplementation.class);
+        DatabaseConnection connection = database.getConnection("private").orElseGet(database::getPrimaryConnection);
+        privateTable = (KissenTable) connection.createTable("kissen_private_ban_meta");
+        return super.preStart();
+    }
+
+    @Override
+    public boolean start() {
+        KissenLocalizationImplementation kissenLocalizationImplementation = KissenCore.getInstance().getImplementation(KissenLocalizationImplementation.class);
+        kissenLocalizationImplementation.register("server.ban.created.permanent", new MessageFormat("The ban has been created with the ID {0}, designated with the name {1}, classified under the type {2}, and assigned a permanent duration."));
+        kissenLocalizationImplementation.register("server.ban.created", new MessageFormat("The ban has been created with the ID {0}, designated with the name {1}, classified under the type {2}, and assigned a duration of {3}."));
+        kissenLocalizationImplementation.register("server.ban.deleted", new MessageFormat("The ban with ID {0} was successfully deleted."));
+        kissenLocalizationImplementation.register("server.ban.invalid", new MessageFormat("The ban with ID {0} was not found."));
+        kissenLocalizationImplementation.register("server.ban.punishment.invalid", new MessageFormat("The punishment with ID {0} was not found."));
+        kissenLocalizationImplementation.register("server.ban.punishment.pardoned", new MessageFormat("The ban, bearing the ID {0}, has been revoked."));
+
+        kissenLocalizationImplementation.register("server.ban.punishment.compact", new MessageFormat("[{7}] [{3}] {1} #{0}"));
+        kissenLocalizationImplementation.register("server.ban.compact", new MessageFormat("[{0}] [{2}] {1}"));
+
+        kissenLocalizationImplementation.register("server.ban.punishment.operator", new MessageFormat("Operator"));
+        kissenLocalizationImplementation.register("server.ban.punishment.cause", new MessageFormat("Cause"));
+        kissenLocalizationImplementation.register("server.ban.punishment.start", new MessageFormat("Start"));
+        kissenLocalizationImplementation.register("server.ban.punishment.actual.end", new MessageFormat("Actual End"));
+        kissenLocalizationImplementation.register("server.ban.punishment.predicted.end", new MessageFormat("Expected End"));
+
+        kissenLocalizationImplementation.register("server.ban.punishment.end.never", new MessageFormat("never"));
+        kissenLocalizationImplementation.register("server.ban.history.empty", new MessageFormat("The punishment history of {0} is empty."));
+        kissenLocalizationImplementation.register("server.ban.warn.ban", new MessageFormat("The player {0} already has {1} warn(s). Do you want to punish the player instead?\n{2} {3}"));
+        kissenLocalizationImplementation.register("server.ban.warn.clear", new MessageFormat("The warn(s) of the player {0} have been reset."));
+
+        InternalCommandImplementation<CommandSender> command = Bukkit.getKissen().getImplementation(InternalCommandImplementation.class);
+        command.getInternalHandler().registerParser(Ban.class, new BanParser());
+        command.getInternalHandler().registerParser(Punishment.class, new PunishmentParser());
+        command.getInternalHandler().registerExceptionHandler(new BanParser());
+        command.getInternalHandler().registerExceptionHandler(new PunishmentParser());
+        return super.start();
+    }
+
+    @Override
+    public void setupComplete() {
+        InternalCommandImplementation<CommandSender> command = Bukkit.getKissen().getImplementation(InternalCommandImplementation.class);
+        command.getInternalHandler().registerCommand(new BanCommand());
+        command.getInternalHandler().registerCommand(new WarnCommand());
+    }
+
+    @Override
+    public void applyBan(@NotNull Punishment ban) {
+        ban.getOnlineAffectedPlayers().forEach(player -> applyBan(ban, player));
+    }
+
+    private void applyBan(@NotNull Punishment ban, @NotNull Player player) {
+        switch (ban.getBanType()) {
+            case BAN ->
+                    player.kick(Component.translatable("multiplayer.disconnect.banned"), PlayerKickEvent.Cause.BANNED);
+            case KICK ->
+                    player.kick(Component.translatable("multiplayer.disconnect.kicked"), PlayerKickEvent.Cause.KICK_COMMAND);
+            case MUTE -> player.sendMessage(Component.translatable("chat.filtered_full"));
+        }
+    }
+
+    @Override
+    protected @NotNull @Unmodifiable Set<Ban> fetchBanSet() throws BackendException {
+        return Stream.concat(queryBanStream(getMeta(Context.GLOBAL)), queryBanStream(getMeta(Context.LOCAL))).filter(Objects::nonNull).collect(Collectors.toSet());
+    }
+
+    @Override
+    protected @NotNull Ban buildBan(int id) throws BackendException {
+        KissenPaperBan kissenPaperBan = new KissenPaperBan();
+        kissenPaperBan.setup(id);
+        return kissenPaperBan;
+    }
+
+    @Override
+    protected @NotNull KissenPaperPunishment translatePunishment(@NotNull UUID totalID, @NotNull KissenPunishmentNode kissenPunishmentNode, @NotNull Meta meta) {
+        return new KissenPaperPunishment(totalID, kissenPunishmentNode, record -> set(totalID, record, meta));
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<Punishment> getPunishmentSet(@NotNull Context context) throws BackendException {
+        return getPunishmentSet(getMeta(context));
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<Punishment> getPunishmentSet(@NotNull UUID totalID, @NotNull Context context) throws BackendException {
+        return getPunishmentSet(totalID, getMeta(context));
+    }
+
+    @Override
+    public @NotNull Optional<Punishment> getLatestPunishment(@NotNull UUID totalID, @NotNull Context context) throws BackendException {
+        return getLatestPunishment(totalID, getMeta(context));
+    }
+
+    @Override
+    public @NotNull Optional<Punishment> getLatestPunishment(@NotNull UUID totalID, @NotNull BanType banType, @NotNull Context context) throws BackendException {
+        return getLatestPunishment(totalID, banType, getMeta(context));
+    }
+
+    @Override
+    public @NotNull Punishment punish(@NotNull UUID totalID, @NotNull Ban ban, @NotNull ServerEntity banOperator, @Nullable Component cause, @NotNull Context context) throws BackendException {
+        return punish(totalID, ban, banOperator, true, cause);
+    }
+
+    @Override
+    public @NotNull Punishment punish(@NotNull UUID totalID, @NotNull Ban ban, @NotNull ServerEntity banOperator, @NotNull Context context) throws BackendException {
+        return punish(totalID, ban, banOperator, true, context);
+    }
+
+    @Override
+    public @NotNull Punishment punish(@NotNull UUID totalID, @NotNull Ban ban, @NotNull ServerEntity banOperator, boolean apply, @NotNull Context context) throws BackendException {
+        return punish(totalID, ban, banOperator, apply, null, context);
+    }
+
+    @Override
+    public @NotNull Punishment punish(@NotNull UUID totalID, @NotNull Ban ban, @NotNull ServerEntity banOperator, boolean apply, @Nullable Component cause, @NotNull Context context) throws BackendException {
+        return punish(totalID, ban, banOperator, apply, cause, getMeta(context));
+    }
+
+    protected @NotNull KissenTable getTable(@NotNull Context context) {
+        return switch (context) {
+            case GLOBAL -> super.getTable();
+            case LOCAL -> privateTable;
+        };
+    }
+
+    /**
+     * Retrieves the metadata associated with the specified context.
+     *
+     * <p>The {@code getMeta(Context)} method returns the metadata associated with the specified {@link Context}. It allows access to either the global
+     * metadata or the local metadata, depending on the provided context. The global metadata is obtained by invoking the {@link #getTable()} method,
+     * while the local metadata is accessed through the private {@code privateMeta} field.</p>
+     *
+     * @param context The context to determine which meta information to retrieve.
+     * @return The meta information based on the provided context.
+     */
+    protected @NotNull @Unmodifiable ObjectMeta getMeta(@NotNull Context context) {
+        return getTable(context).setupMeta(null);
+    }
+
+    /**
+     * Queries the ban stream based on the given meta information.
+     * <p>
+     * This method performs a database operation under the hood to fetch a stream of PaperBan
+     * instances. The query operates on the foundations of the supplied meta information. This
+     * metaobject encapsulates essential data that directs the query towards the appropriate
+     * dataset within the database.
+     * <p>
+     * A stream interface is being utilized here due to its advantages in handling large datasets.
+     * It works by loading data on-demand, instead of loading it all at once into memory, making the
+     * process more efficient.
+     * <p>
+     * The function will map over the values returned from the database query by utilizing the
+     * banProcessor() function on each element, further processing the raw data into PaperBan
+     * objects that the application can interact with.
+     * <p>
+     * An important factor to note is that this method throws a BackendException. This exception
+     * is thrown if there are issues encountered when querying the ban stream from the database,
+     * such as connection problems, invalid query syntax.
+     *
+     * @param meta The meta information containing the data to query. This is an instance of
+     *             ObjectMeta which encapsulates the query parameters.
+     * @return The ban stream based on the given meta information. Takes form as a stream of
+     * PaperBan objects each representing a unique ban instance.
+     * @throws BackendException If there is an error querying the ban stream, this exception
+     *                          will be thrown. It signifies an issue with the backend operation.
+     */
+    private @NotNull Stream<Ban> queryBanStream(@NotNull ObjectMeta meta) {
+        return meta.getData(new KissenPaperBan()).thenApply(Map::values).thenApply(Collection::stream).thenApply(s -> s.map(banProcessor())).join();
+    }
+
+    /**
+     * Retrieves the ban processor function, which processes a SavableMap and returns a PaperBan.
+     *
+     * @return The ban processor function.
+     */
+    @Contract(pure = true)
+    private @NotNull Function<SavableMap, Ban> banProcessor() {
+        return savableMap -> createBan(Integer.parseInt(savableMap.getNotNull("id", String.class)));
+    }
+
+    // Bukkit
+
+    @Override
+    public @NotNull <E extends BanEntry<? super PlayerProfile>> Set<E> getEntries() {
+        return getPunishmentSet().stream().map(punishment -> (E) punishment).collect(Collectors.toSet());
+    }
+
+    @Override
+    public <E extends BanEntry<? super PlayerProfile>> @Nullable E getBanEntry(@NotNull String target) {
+        return (E) getBanEntry(Objects.requireNonNull(resolvePlayerProfile(target)));
+    }
+
+    @Override
+    public @Nullable BanEntry<PlayerProfile> getBanEntry(@NotNull PlayerProfile target) {
+        return getLatestPunishment(Objects.requireNonNull(target.getId())).orElse(null);
+    }
+
+    @Override
+    public @NotNull Set<BanEntry> getBanEntries() {
+        return getPunishmentSet().stream().map(punishment -> (BanEntry<?>) punishment).collect(Collectors.toSet());
+    }
+
+    @SuppressWarnings("deprecation")
+    @Override
+    public <E extends BanEntry<? super PlayerProfile>> @Nullable E getBanEntry(org.bukkit.profile.@NotNull PlayerProfile target) {
+        return (E) getLatestPunishment(Objects.requireNonNull(target.getUniqueId())).orElse(null);
+    }
+
+    @Override
+    public boolean isBanned(@NotNull String target) {
+        return isBanned(Objects.requireNonNull(resolvePlayerProfile(target)));
+    }
+
+    @Override
+    public boolean isBanned(@NotNull PlayerProfile target) {
+        return getLatestPunishment(Objects.requireNonNull(target.getId())).isPresent();
+    }
+
+    @SuppressWarnings("deprecation")
+    @Override
+    public boolean isBanned(@NotNull org.bukkit.profile.PlayerProfile target) {
+        return getLatestPunishment(Objects.requireNonNull(target.getUniqueId())).isPresent();
+    }
+
+    @Override
+    public void pardon(@NotNull String target) {
+        //TODO
+    }
+
+    @Override
+    public void pardon(@NotNull PlayerProfile target) {
+        //TODO
+    }
+
+    @SuppressWarnings("deprecation")
+    @Override
+    public void pardon(@NotNull org.bukkit.profile.PlayerProfile target) {
+        //TODO
+    }
+
+    @Override
+    public <E extends BanEntry<? super PlayerProfile>> @Nullable E addBan(@NotNull String target, @Nullable String reason, @Nullable Date expires, @Nullable String source) {
+        return (E) addBan(Objects.requireNonNull(resolvePlayerProfile(target)), reason, expires, source);
+    }
+
+    @SuppressWarnings("deprecation")
+    @Override
+    public <E extends BanEntry<? super PlayerProfile>> @Nullable E addBan(org.bukkit.profile.@NotNull PlayerProfile target, @Nullable String reason, @Nullable Instant expires, @Nullable String source) {
+        return (E) addBan(target.getUser(), reason, getDateTransformer(expires), source);
+    }
+
+    @SuppressWarnings("deprecation")
+    @Override
+    public <E extends BanEntry<? super PlayerProfile>> @Nullable E addBan(org.bukkit.profile.@NotNull PlayerProfile target, @Nullable String reason, @Nullable Duration duration, @Nullable String source) {
+        return (E) addBan(target.getUser(), reason, getDateTransformer(duration), source);
+    }
+
+    @SuppressWarnings("deprecation")
+    @Override
+    public <E extends BanEntry<? super PlayerProfile>> @Nullable E addBan(org.bukkit.profile.@NotNull PlayerProfile target, @Nullable String reason, @Nullable Date expires, @Nullable String source) {
+        return (E) addBan(target.getUser(), reason, getDateTransformer(expires), source);
+    }
+
+    @Override
+    public @Nullable BanEntry<PlayerProfile> addBan(@NotNull PlayerProfile target, @Nullable String reason, @Nullable Instant expires, @Nullable String source) {
+        return addBan(target.getUser(), reason, getDateTransformer(expires), source);
+    }
+
+    @Override
+    public @Nullable BanEntry<PlayerProfile> addBan(@NotNull PlayerProfile target, @Nullable String reason, @Nullable Duration duration, @Nullable String source) {
+        return addBan(target.getUser(), reason, getDateTransformer(duration), source);
+    }
+
+    @Override
+    public @Nullable BanEntry<PlayerProfile> addBan(@NotNull PlayerProfile target, @Nullable String reason, @Nullable Date expires, @Nullable String source) {
+        return addBan(target.getUser(), reason, getDateTransformer(expires), source);
+    }
+
+    private @Nullable PlayerProfile resolvePlayerProfile(@NotNull String target) {
+        GameProfile gameProfile = resolveGameProfile(target);
+        return gameProfile==null ? null:new CraftPlayerProfile(gameProfile.getId(), gameProfile.getName());
+    }
+
+    private @Nullable GameProfile resolveGameProfile(@NotNull String target) {
+        if (target.matches("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$")) {
+            UUID targetUUID = UUID.fromString(target);
+            return Objects.requireNonNull(MinecraftServer.getServer().getProfileCache()).get(targetUUID).orElse(null);
+        }
+        return Objects.requireNonNull(MinecraftServer.getServer().getProfileCache()).get(target).orElse(null);
+    }
+
+    /**
+     * This method is responsible for adding an entry to the ban list for a specific player. This method requires several parameters as described below.
+     * <p>
+     * The action of banning involves communicating with a backend system.
+     * If the system is not reachable, a {@link BackendException} will be thrown.
+     * To handle such situations, this method has a catch block to wrap the {@link BackendException}
+     *
+     * @param target              represents the {@link User} object to be banned.
+     *                            This parameter is annotated with {@link NotNull}
+     *                            which means it must never be null.
+     * @param reason              is a string containing the reason for the ban.
+     *                            This parameter is allowed to be null, represent by {@link Nullable}.
+     *                            If null, the default reason specified by the system will be used.
+     * @param durationTransformer is an instance of {@link DurationTransformer}.
+     *                            This parameter is used to determine the duration of the ban.
+     *                            This cannot be null.
+     * @param source              is a string representing the entity which imposes the ban action.
+     *                            Though this parameter is nullable, a {@link IllegalArgumentException}
+     *                            will be thrown if source is null after an internal checking.
+     * @return An instance of {@link BanEntry}<{@link PlayerProfile}> is created and returned.
+     * The return value encapsulates details such as ban type, ban duration,
+     * operator and reason for the ban.
+     * @throws IllegalArgumentException If the {@code source} parameter is null.
+     * @throws RuntimeException         If the backend system cannot be reached.
+     */
+    private @NotNull BanEntry<PlayerProfile> addBan(@NotNull User target, @Nullable String reason, @NotNull DurationTransformer durationTransformer, @Nullable String source) {
+
+        if (source==null) {
+            throw new IllegalArgumentException("Source must not be null");
+        }
+        // Detect source
+        return punish(target.getPlayerClient().getTotalID(), new MinecraftBan(BanType.BAN, durationTransformer.create()), new ServerEntity() {
+            @Override
+            public @NotNull String getName() {
+                return source;
+            }
+
+            @Override
+            public @NotNull Component displayName() {
+                return Component.text(source);
+            }
+
+            @Override
+            public @NotNull Locale getCurrentLocale() {
+                return Bukkit.getKissen().getImplementation(LocalizationImplementation.class).getDefaultLocale();
+            }
+
+            @Override
+            public boolean isConnected() {
+                return false;
+            }
+
+            @Override
+            public boolean isClient() {
+                return true;
+            }
+        }, reason==null ? null:LegacyComponentSerializer.legacySection().deserialize(reason));
+    }
+
+    /**
+     * The `getDateTransformer` method is overloaded to accept three different types of arguments: {@link Date}, {@link Duration}, and {@link Instant}.
+     * These methods have been contractually defined to produce a new value whenever they're called and are considered to be pure (no side effects).
+     * <p>
+     * Each of these methods is responsible for converting a given {@link Date}, {@link Duration}, or {@link Instant} into an instance of {@link DurationTransformer}, an interface that only contains one method: `create()`, which returns an {@link AccurateDuration} object.
+     * <p>
+     * Note: If the `Date`, `Duration`, or `Instant` provided to these methods is null, the `create()` method of the resultant {@link DurationTransformer} will return null when called.
+     *
+     * @param expires - {@link Date} object representing point of expire instance or null.
+     * @return a new {@link DurationTransformer} that encapsulates the conversion logic from {@link Date} to {@link AccurateDuration}.
+     */
+    @Contract(value = "_ -> new", pure = true)
+    private @NotNull DurationTransformer getDateTransformer(@Nullable Date expires) {
+        return getDateTransformer(expires==null ? null:expires.toInstant());
+    }
+
+    /**
+     * Converts a given {@link Duration} object to a new instance of {@link DurationTransformer}. This method is a part of a suite of transformation methods that handle different types of expire representation.
+     *
+     * @param duration is a {@link Duration} that represents the amount of expire or can potentially be null.
+     *                 If null, the method will delegate to another `getDateTransformer` method with a null {@link Instant} as an argument.
+     *                 If not null, the method will transform it into an {@link Instant} that is the current moment in expire incremented by the
+     *                 number of milliseconds represented by the duration. Then it delegates to another `getDateTransformer` method.
+     * @return a new {@link DurationTransformer}, which is a functional interface for converting different types of expire representation into
+     * an {@link AccurateDuration}. This returned transformer's `create` method will, when called, produce an {@link AccurateDuration}
+     * representing the same expire span as the given duration argument.
+     */
+    @Contract(value = "_ -> new", pure = true)
+    private @NotNull DurationTransformer getDateTransformer(@Nullable Duration duration) {
+        return getDateTransformer(duration==null ? null:Instant.now().plusMillis(duration.toMillis()));
+    }
+
+    /**
+     * Converts a given {@link Instant} object to a new instance of {@link DurationTransformer}. This method is a part of a suite of transformation methods that handle different types of expire representation.
+     *
+     * @param instant is an {@link Instant} that represents a specific moment on a expire-line or can potentially be null.
+     *                If null, the returned {@link DurationTransformer}'s `create` method will produce null when called.
+     *                If not null, the returned {@link DurationTransformer}'s `create` method will produce an {@link AccurateDuration} which represents
+     *                amount of expire between now and the instant when called.
+     * @return a new {@link DurationTransformer}, which is a functional interface for converting different types of expire representation into an
+     * {@link AccurateDuration}. Depending on the arguments it has been passed, the `create` method of returned object will produce different output.
+     */
+    @Contract(value = "_ -> new", pure = true)
+    private @NotNull DurationTransformer getDateTransformer(@Nullable Instant instant) {
+        return new DurationTransformer() {
+            @Override
+            public @Nullable AccurateDuration create() {
+                return instant==null ? null:Bukkit.getKissen().getImplementation(TimeImplementation.class).millis(Instant.now().until(instant, ChronoUnit.MILLIS));
+            }
+        };
+    }
+
+    /**
+     * DurationTransformer is a functional interface which provides a contract for transforming various expire representations into an {@link AccurateDuration}.
+     * It's intended to be utilized by classes that need expire conversion functionalities.
+     * Annotated with {@code @FunctionalInterface}, it ensures that this interface should only have one abstract method, conforming to the Java language specification.
+     */
+    @FunctionalInterface
+    private interface DurationTransformer {
+
+        /**
+         * This abstract method named 'create' is the single method in this functional interface. The duty of exact transformation varies depending on its implementation.
+         * <ul>
+         * <li> In some implementations, the 'create' method will convert a specific point in expire into a duration from that point until the current expire.</li>
+         * <li> In others, it might translate a specific elapsed expire period into a duration.</li>
+         * </ul>
+         *
+         * @return an {@link AccurateDuration} instance representing the result of the transformation, or null if the transformation could not be successfully completed
+         * or resulted in a null value.
+         */
+        @Nullable
+        AccurateDuration create();
+
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/base/KissenPaperCore.java b/src/main/java/net/kissenpvp/paper/base/KissenPaperCore.java
index f320dd0709c6c2f10987d28533e8add87e2ff74f..4e9dd6cb54aa7f3e6f7ea0dd74beedd75232d47b 100644
--- a/src/main/java/net/kissenpvp/paper/base/KissenPaperCore.java
+++ b/src/main/java/net/kissenpvp/paper/base/KissenPaperCore.java
@@ -32,12 +32,10 @@ import net.kissenpvp.core.command.confirmation.KissenConfirmationImplementation;
 import net.kissenpvp.core.event.EventImplementation;
 import net.kissenpvp.core.permission.InternalPermissionImplementation;
 import net.kissenpvp.paper.api.base.PaperKissen;
-import net.kissenpvp.paper.api.command.PaperCommandImplementation;
 import net.kissenpvp.paper.api.permission.PermissionImplementation;
 import net.kissenpvp.paper.database.KissenPaperConfigurationImplementation;
 import net.kissenpvp.paper.database.KissenPaperDatabaseImplementation;
 import net.kissenpvp.paper.event.KissenEventImplementation;
-import net.kissenpvp.paper.message.localization.KissenPaperLocalizationImplementation;
 import net.kissenpvp.paper.permission.KissenPaperPermissionImplementation;
 import net.kissenpvp.paper.user.KissenPaperUserImplementation;
 import net.kissenpvp.paper.user.rank.KissenPaperRankImplementation;
@@ -84,6 +82,10 @@ public class KissenPaperCore extends KissenCore implements PaperKissen {
         loader.put(InternalPermissionImplementation.class, permissionImplementation);
         loader.put(PermissionImplementation.class, permissionImplementation);
         loader.put(net.kissenpvp.core.api.message.localization.LocalizationImplementation.class, new net.kissenpvp.paper.message.localization.KissenPaperLocalizationImplementation());
+        net.kissenpvp.paper.command.KissenPaperCommandImplementation command = new net.kissenpvp.paper.command.KissenPaperCommandImplementation();
+        loader.put(net.kissenpvp.paper.api.command.CommandImplementation.class, command);
+        loader.put(net.kissenpvp.core.command.InternalCommandImplementation.class, command);
+        loader.put(net.kissenpvp.core.command.confirmation.KissenConfirmationImplementation.class, new net.kissenpvp.paper.command.confirmation.KissenPaperConfirmationImplementation());
         super.loadImplementations(loader);
     }
 
diff --git a/src/main/java/net/kissenpvp/paper/command/KissenPaperCommandImplementation.java b/src/main/java/net/kissenpvp/paper/command/KissenPaperCommandImplementation.java
new file mode 100644
index 0000000000000000000000000000000000000000..74642b818953b36e1ee801b44d3607918b3fef0b
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/KissenPaperCommandImplementation.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.command;
+
+import net.kissenpvp.core.api.base.plugin.KissenPlugin;
+import net.kissenpvp.core.api.command.CommandHandler;
+import net.kissenpvp.core.command.InternalCommandImplementation;
+import net.kissenpvp.core.command.TargetValidator;
+import net.kissenpvp.core.command.argument.MethodEvaluator;
+import net.kissenpvp.core.command.handler.InternalCommandHandler;
+import net.kissenpvp.core.command.handler.PluginCommandHandler;
+import net.kissenpvp.core.message.localization.KissenLocalizationImplementation;
+import net.kissenpvp.paper.api.command.CommandImplementation;
+import net.kissenpvp.paper.api.command.KissenCommand;
+import net.kissenpvp.paper.api.command.parser.OfflinePlayerParser;
+import net.kissenpvp.paper.api.command.parser.PlayerParser;
+import net.kissenpvp.paper.command.handler.CompletionExceptionHandler;
+import net.kissenpvp.paper.command.handler.PlayerExceptionHandler;
+import net.kissenpvp.paper.command.handler.ProfileNotFoundExceptionHandler;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.minimessage.MiniMessage;
+import org.bukkit.Bukkit;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+
+import java.text.MessageFormat;
+import java.util.Optional;
+
+/**
+ * Represents a Kissen Paper command implementation that extends the functionality of the Kissen command framework
+ * and is compatible with the Paper server platform.
+ * <p>
+ * This class extends {@link InternalCommandImplementation} and implements the {@link CommandImplementation} interface
+ * to provide specialized command handling and execution functionality tailored for the Paper server platform.
+ * It integrates seamlessly with the Kissen command framework and enhances it with Paper-specific features.
+ */
+public class KissenPaperCommandImplementation extends InternalCommandImplementation<CommandSender> implements CommandImplementation
+{
+
+
+    /**
+     * Constructs a new instance of {@link KissenPaperCommandImplementation}.
+     * <p>
+     * This constructor initializes the {@link MethodEvaluator} and {@link TargetValidator} instances used by this
+     * Kissen Paper command implementation for evaluating command methods and validating command execution targets.
+     */
+    public KissenPaperCommandImplementation()
+    {
+        super();
+
+        // Advanced
+        getInternalHandler().registerParser(Player.class, new PlayerParser());
+        getInternalHandler().registerParser(OfflinePlayer.class, new OfflinePlayerParser());
+
+        //Exception handler
+        getInternalHandler().registerExceptionHandler(new PlayerExceptionHandler());
+        getInternalHandler().registerExceptionHandler(new CompletionExceptionHandler());
+        getInternalHandler().registerExceptionHandler(new ProfileNotFoundExceptionHandler());
+    }
+
+    @Override
+    public boolean start()
+    {
+        KissenLocalizationImplementation kissenLocalizationImplementation = Bukkit.getKissen().getImplementation(
+                KissenLocalizationImplementation.class);
+        kissenLocalizationImplementation.register("server.command.mojang.profile.invalid",
+                new MessageFormat("Mojangs repository does not contain the specified profile."));
+        kissenLocalizationImplementation.register("server.command.player.offline",
+                new MessageFormat("The player {0} seems to be offline."));
+        kissenLocalizationImplementation.register("server.command.failed",
+                new MessageFormat(MiniMessage.miniMessage().serialize(Component.translatable("commands.help.failed"))));
+
+        kissenLocalizationImplementation.register("server.command.general.header",
+                new MessageFormat("===== [ {0} ] ====="));
+        kissenLocalizationImplementation.register("server.command.general.header.paged",
+                new MessageFormat("===== [ {0} ({1}/{2}) ] ====="));
+        kissenLocalizationImplementation.register("server.command.general.footer",
+                new MessageFormat("===== [ {0} ] ====="));
+        kissenLocalizationImplementation.register("server.command.general.footer.paged",
+                new MessageFormat("===== [ {0} ({1}/{2}) ] ====="));
+
+        kissenLocalizationImplementation.register("server.command.general.key.value", new MessageFormat("{0}: {1}"));
+
+        return super.start();
+    }
+
+    @Override
+    protected InternalCommandHandler<CommandSender, ?> constructInternalHandler()
+    {
+        return new KissenPaperInternalCommandHandler();
+    }
+
+    @Override
+    protected @NotNull PluginCommandHandler<CommandSender, ?> constructHandler(@NotNull KissenPlugin kissenPlugin)
+    {
+        return new KissenPaperPluginHandler(kissenPlugin);
+    }
+
+    @Override
+    public @NotNull Optional<CommandHandler<CommandSender, KissenCommand>> getPluginHandler(@NotNull KissenPlugin kissenPlugin)
+    {
+        return getHandler().stream().filter(handler -> handler.getPlugin().equals(kissenPlugin)).map(handler -> (CommandHandler<CommandSender, KissenCommand>) handler).findFirst();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/KissenPaperInternalCommandHandler.java b/src/main/java/net/kissenpvp/paper/command/KissenPaperInternalCommandHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..e4c227cbafb759f581d371ebd228cf221da51b61
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/KissenPaperInternalCommandHandler.java
@@ -0,0 +1,49 @@
+package net.kissenpvp.paper.command;
+
+import net.kissenpvp.core.command.handler.InternalCommandHandler;
+import net.kissenpvp.paper.command.command.system.KissenPaperCommand;
+import org.bukkit.Bukkit;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.CraftServer;
+import org.jetbrains.annotations.NotNull;
+
+public class KissenPaperInternalCommandHandler extends InternalCommandHandler<CommandSender, KissenPaperCommand>
+{
+    @Override
+    protected void registerCommand(@NotNull KissenPaperCommand command)
+    {
+        if(Bukkit.getCommandMap().register("kissenpaper", command))
+        {
+            ((CraftServer) Bukkit.getServer()).syncCommands();
+        }
+    }
+
+    @Override
+    protected void unregisterCommand(@NotNull KissenPaperCommand command) {
+        Command loaded = Bukkit.getCommandMap().getCommand(command.getName());
+        if(loaded != null && loaded.unregister(Bukkit.getCommandMap()))
+        {
+            ((CraftServer) Bukkit.getServer()).syncCommands();
+        }
+    }
+
+    @Override
+    protected @NotNull KissenPaperCommand buildCommand(@NotNull String name)
+    {
+        String rootName = name.split("\\.")[0];
+        KissenPaperCommand command = getCommand(rootName).orElseGet(() ->
+        {
+            KissenPaperCommand kissenCommand = new KissenPaperCommand(rootName, 0, this);
+            getCommands().add(kissenCommand);
+            return kissenCommand;
+        });
+
+        if (!name.equals(rootName))
+        {
+            command = (KissenPaperCommand) command.createRecursive(name);
+            getCommands().add(command);
+        }
+        return command;
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/KissenPaperPluginHandler.java b/src/main/java/net/kissenpvp/paper/command/KissenPaperPluginHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..6262d4d139326dc2372576d37dad6b6564747290
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/KissenPaperPluginHandler.java
@@ -0,0 +1,58 @@
+package net.kissenpvp.paper.command;
+
+import net.kissenpvp.core.api.base.plugin.KissenPlugin;
+import net.kissenpvp.core.command.handler.PluginCommandHandler;
+import net.kissenpvp.paper.command.command.plugin.KissenPaperPluginCommand;
+import org.bukkit.Bukkit;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.plugin.Plugin;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Objects;
+
+public class KissenPaperPluginHandler extends PluginCommandHandler<CommandSender, KissenPaperPluginCommand>
+{
+    public KissenPaperPluginHandler(@NotNull KissenPlugin plugin)
+    {
+        super(plugin);
+    }
+
+    @Override
+    protected void registerCommand(@NotNull KissenPaperPluginCommand command)
+    {
+        if(Bukkit.getCommandMap().register(getPlugin().getName(), command))
+        {
+            ((CraftServer) Bukkit.getServer()).syncCommands();
+        }
+    }
+
+    @Override
+    protected void unregisterCommand(@NotNull KissenPaperPluginCommand command) {
+        Command loaded = Bukkit.getCommandMap().getCommand(command.getName());
+        if(loaded != null && loaded.unregister(Bukkit.getCommandMap()))
+        {
+            ((CraftServer) Bukkit.getServer()).syncCommands();
+        }
+    }
+
+    @Override
+    protected @NotNull KissenPaperPluginCommand buildCommand(@NotNull String name)
+    {
+        String rootName = name.split("\\.")[0];
+        KissenPaperPluginCommand command = getCommand(rootName).orElseGet(() ->
+        {
+            KissenPaperPluginCommand kissenCommand = new KissenPaperPluginCommand((Plugin) getPlugin(), rootName, 0, this);
+            getCommands().add(kissenCommand);
+            return kissenCommand;
+        });
+
+        if (!Objects.equals(name, rootName))
+        {
+            command = (KissenPaperPluginCommand) command.createRecursive(name);
+            getCommands().add(command);
+        }
+        return command;
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/command/KissenPaperAbstractCommand.java b/src/main/java/net/kissenpvp/paper/command/command/KissenPaperAbstractCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..fb700d75c33b4b5cdeb997d585d92ef82fa338a8
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/command/KissenPaperAbstractCommand.java
@@ -0,0 +1,477 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.command.command;
+
+import net.kissenpvp.core.api.command.CommandHandler;
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.core.api.command.CommandTarget;
+import net.kissenpvp.core.api.command.annotations.CommandData;
+import net.kissenpvp.core.api.command.executor.CommandExecutor;
+import net.kissenpvp.core.api.command.executor.TabCompleterExecutor;
+import net.kissenpvp.core.command.CommandHolder;
+import net.kissenpvp.core.command.CommandInfo;
+import net.kissenpvp.core.command.KissenCommandPayload;
+import net.kissenpvp.core.command.TargetValidator;
+import net.kissenpvp.core.command.argument.Argument;
+import net.kissenpvp.core.command.executor.KissenCommandExecutor;
+import net.kissenpvp.paper.api.command.KissenCommand;
+import net.kissenpvp.paper.command.KissenPaperCommandImplementation;
+import net.kissenpvp.paper.command.command.system.KissenPaperChildCommand;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandException;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.*;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+/**
+ * Represents a command implementation specific to the Kissen Paper framework.
+ * <p>
+ * This class extends the {@link KissenCommand} class and serves as a command implementation tailored for the Kissen Paper framework.
+ * It provides functionality for creating and managing sub-commands within the Kissen Paper command hierarchy.
+ */
+public abstract class KissenPaperAbstractCommand<C extends KissenPaperAbstractCommand<C>> extends KissenCommand implements CommandHolder<CommandSender, C>
+{
+    private final int position;
+    private final List<C> children; //C can be plugin child or system child
+    private CommandInfo commandInfo;
+    private CommandExecutor<CommandSender> commandExecutor;
+    private TabCompleterExecutor<CommandSender> tabExecutor;
+    private final CommandHandler<CommandSender, ?> handler;
+
+    /**
+     * Constructs a new {@link KissenPaperAbstractCommand} instance with the provided plugin, name, and position.
+     * <p>
+     * This constructor is used to create a new {@link KissenPaperAbstractCommand} instance with the specified plugin, command name, and position in the command hierarchy.
+     *
+     * @param name     The name of the command. Must not be null.
+     * @param position The position of the command in the command hierarchy.
+     * @throws NullPointerException If either the {@code plugin} or {@code name} parameter is null.
+     */
+    public KissenPaperAbstractCommand(@NotNull String name, int position, @NotNull CommandHandler<CommandSender, ?> handler)
+    {
+        super(name);
+        this.position = position;
+        this.children = new ArrayList<>();
+        this.handler = handler;
+    }
+
+    public @NotNull CommandHandler<CommandSender, ?> getHandler()
+    {
+        return handler;
+    }
+
+    @Override
+    public int getPosition()
+    {
+        return position;
+    }
+
+    @Override
+    public @NotNull CommandExecutor<CommandSender> getExecutor()
+    {
+        return (CommandExecutor<CommandSender>) Objects.requireNonNullElseGet(commandExecutor, () ->
+        {
+            Optional<CommandHolder<?, ?>> parent = getParent();
+            return parent.map(CommandHolder::getExecutor).orElseThrow();
+        });
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<C> getChildCommandList()
+    {
+        return Collections.unmodifiableList(children);
+    }
+
+    @Override
+    public @NotNull Optional<C> getChildCommand(@NotNull String name)
+    {
+        return getChildCommandList().stream().filter(
+                child -> child.equals(name) || child.getAliases().contains(name)).findFirst();
+    }
+
+    @Override
+    public @NotNull Optional<CommandInfo> getCommandInfo()
+    {
+        return Optional.ofNullable(commandInfo);
+    }
+
+    @Override
+    public boolean execute(@NotNull CommandSender sender, @NotNull String commandLabel, @NotNull String[] args)
+    {
+        if (!validate(sender))
+        {
+            return false;
+        }
+
+        if (args.length > 0)
+        {
+            Function<C, Boolean> execute = command ->
+            {
+                String[] newArgs = Arrays.copyOfRange(args, 1, args.length);
+                return command.execute(sender, commandLabel, newArgs);
+            };
+
+            Boolean data = getChildCommand(args[0]).map(execute).orElse(null);
+            if (data != null)
+            {
+                return data;
+            }
+        }
+
+        CommandPayload<CommandSender> payload = getCommandPayload(sender,
+                commandLabel,
+                args,
+                getTargetValidator().parseSender(sender));
+
+        if (commandExecutor == null)
+        {
+            sender.sendMessage(getFormattedUsage(payload));
+            return false;
+        }
+
+        if (commandInfo.isAsync())
+        {
+            runAsync(payload);
+            return true;
+        }
+
+        return commandExecutor.execute(payload);
+    }
+
+    @Override
+    public @NotNull List<String> tabComplete(@NotNull CommandSender sender, @NotNull String alias, @NotNull String[] args) throws IllegalArgumentException
+    {
+        List<String> result = new ArrayList<>();
+
+        if (!validate(sender))
+        {
+            return result;
+        }
+
+        if(Arrays.stream(args).filter(String::isBlank).count() > 1)
+        {
+            return Collections.emptyList();
+        }
+
+        result.addAll(isChildCommand(sender, alias, args).orElseGet(() ->
+        {
+            //TODO add caching
+            CommandTarget target = getTargetValidator().parseSender(sender);
+            CommandPayload<CommandSender> payload = getCommandPayload(sender, alias, args, target);
+            return getTabCompletions(payload);
+        }));
+
+        final String argument = args.length > 0 ? args[args.length - 1] : ""; //namespaces
+        return new ArrayList<>(result).stream().filter(currentSuggestion ->
+        {
+            for (String currentArgument : currentSuggestion.split(":"))
+            {
+                if(currentArgument.toLowerCase().startsWith(argument.toLowerCase()))
+                {
+                    return true;
+                }
+            }
+            return false;
+        }).toList();
+    }
+
+
+    @Override
+    public @NotNull String getFullName()
+    {
+        return getCommandInfo().map(CommandInfo::getName).orElse(getName());
+    }
+
+    @Override
+    public @NotNull String getUsage()
+    {
+        String usage = super.getUsage();
+        if (!usage.isBlank())
+        {
+            return usage;
+        }
+
+        if (getExecutor() instanceof KissenCommandExecutor<CommandSender> executor)
+        {
+            return String.join(";", getUsages(executor).stream().sorted(CharSequence::compare).toArray(String[]::new));
+        }
+
+        return super.getUsage();
+    }
+
+    /**
+     * Initializes the {@link KissenPaperAbstractCommand} with the provided command information and executor.
+     * <p>
+     * This method is used to initialize the properties and behavior of the {@link KissenPaperAbstractCommand} based on the given command information and executor.
+     *
+     * @param commandData     The {@link CommandData} containing details about the command. Must not be null.
+     * @param commandExecutor The {@link CommandExecutor} responsible for executing the command logic. Must not be null.
+     * @throws NullPointerException If either the {@code commandInfo} or {@code commandExecutor} parameter is null.
+     */
+    @Override
+    public void initCommand(@NotNull CommandData commandData, @NotNull CommandExecutor<CommandSender> commandExecutor)
+    {
+        if (isRegistered())
+        {
+            throw new IllegalStateException("This command is already registered.");
+        }
+        this.commandInfo = new CommandInfo(commandData);
+        this.commandExecutor = commandExecutor;
+
+        setAliases(Arrays.asList(commandInfo.getAliases()));
+
+        if (commandInfo.isPermissionRequired() && !commandInfo.getPermission().isBlank())
+        {
+            setPermission(commandInfo.getPermission());
+        }
+
+        setUsage(commandInfo.getUsage()); // might be blank, will be processes later
+
+        String description = commandInfo.getDescription();
+        if (!description.isBlank())
+        {
+            setDescription(description);
+        }
+
+        if (commandExecutor instanceof KissenCommandExecutor<CommandSender> executor)
+        {
+            executor.setCommandHolder(this);
+        }
+    }
+
+    /**
+     * Initializes the tab completer for the {@link KissenPaperAbstractCommand} instance.
+     * <p>
+     * This method is used to set the tab completer for the current {@link KissenPaperAbstractCommand} instance.
+     * It allows the registration of a {@link TabCompleterExecutor} to handle tab completion logic for the command.
+     *
+     * @param tabExecutor The {@link TabCompleterExecutor} responsible for tab completion of the command. Must not be null.
+     * @throws IllegalStateException If the tab completer has already been initialized for this command.
+     */
+    public final void initCompleter(@NotNull TabCompleterExecutor<CommandSender> tabExecutor)
+    {
+        if (this.tabExecutor != null)
+        {
+            throw new IllegalStateException("Initialization of Completer already executed.");
+        }
+
+        this.tabExecutor = tabExecutor;
+    }
+
+    /**
+     * Creates a recursive {@link KissenPaperAbstractCommand} hierarchy based on the given sub-command name.
+     * <p>
+     * This method is used to create a recursive hierarchy of {@link KissenPaperAbstractCommand} instances based on a provided sub-command name.
+     * The hierarchy is established by traversing the sub-command name and creating child commands accordingly.
+     * If the sub-command name is already at the current command's position, the method returns the current command itself.
+     *
+     * @param name The sub-command name representing the recursive hierarchy. Must not be null.
+     * @return The final {@link KissenPaperAbstractCommand} instance at the bottom of the recursive hierarchy.
+     * @throws NullPointerException If the provided {@code name} parameter is null.
+     */
+    public @NotNull KissenPaperAbstractCommand<C> createRecursive(@NotNull String name)
+    {
+
+        int position = getPosition() + (name.split("\\.").length - 1);
+        if (position == getPosition())
+        {
+            return this;
+        }
+
+        String subName = name.substring(Math.max(name.indexOf('.') + 1, 0));
+
+        int index = subName.indexOf('.');
+        String nextSubCommand;
+        if (index != -1)
+        {
+            nextSubCommand = subName.substring(0, index);
+        }
+        else
+        {
+            nextSubCommand = subName;
+        }
+
+        if(!isRegistered())
+        {
+            setUsage("");
+        }
+
+        return getChildCommand(nextSubCommand).orElseGet(() ->
+        {
+            C child = createChildCommand(nextSubCommand, KissenPaperAbstractCommand.this);
+            children.add(child);
+            return child;
+        }).createRecursive(subName);
+    }
+
+
+    private @NotNull List<String> getUsages(@NotNull KissenCommandExecutor<CommandSender> executor)
+    {
+        List<String> usages = new ArrayList<>();
+        String prefix = "/" + String.join(" ", getFullName().split("\\.")) + " ";
+
+        String builtUsage = executor.getEvaluator().buildUsage("").strip();
+        if (!builtUsage.isBlank() && commandExecutor != null)
+        {
+            usages.add(prefix + builtUsage);
+        }
+
+        for (C child : children)
+        {
+            KissenCommandExecutor<CommandSender> childExecutor = ((KissenCommandExecutor<CommandSender>) child.getExecutor());
+            usages.addAll(((KissenPaperAbstractCommand<?>) child).getUsages(childExecutor));
+        }
+        return usages;
+    }
+
+    private @NotNull Optional<List<String>> isChildCommand(@NotNull CommandSender commandSender, @NotNull String alias, @NotNull String @NotNull [] arguments)
+    {
+        for (var iterator = new Object()
+        {
+            private int index = 0;
+
+            private int getIndex()
+            {
+                return index;
+            }
+        }; iterator.index < arguments.length; iterator.index++)
+        {
+            Optional<C> commandHolder = getChildCommand(arguments[iterator.getIndex()]);
+            if (commandHolder.isPresent())
+            {
+                return commandHolder.map(child -> child.tabComplete(commandSender, alias,
+                        Arrays.copyOfRange(arguments, iterator.getIndex() + 1, arguments.length)));
+            }
+        }
+        return Optional.empty();
+    }
+
+    private @NotNull List<String> getTabCompletions(@NotNull CommandPayload<CommandSender> commandPayload)
+    {
+        List<String> suggestions = new ArrayList<>(
+                (tabExecutor != null ? tabExecutor.execute(commandPayload) : getAutoTabCompletion(
+                        commandPayload)).stream().filter(Objects::nonNull).toList());
+        suggestions.sort(String.CASE_INSENSITIVE_ORDER);
+        return suggestions;
+    }
+
+    private @NotNull Set<String> getAutoTabCompletion(@NotNull CommandPayload<CommandSender> commandPayload)
+    {
+        int index = commandPayload.getArgumentCount();
+        Set<String> data = getChildCommandList().stream().filter(
+                child -> child.getPosition() == index + getPosition()).flatMap(
+                command -> Stream.concat(Stream.of(command.getName()), command.getAliases().stream())).collect(
+                Collectors.toSet());
+
+        if (hasOwnExecutor() && getExecutor() instanceof KissenCommandExecutor<CommandSender> executor)
+        {
+            if (executor.getEvaluator().arguments().size() > index)
+            {
+                Argument<?, CommandSender> argument = executor.getEvaluator().arguments().get(index);
+                if (argument.argumentParser() != null)
+                {
+                    data.addAll(argument.argumentParser().tabCompletion(commandPayload));
+                }
+            }
+        }
+        return data;
+    }
+
+    /**
+     * Creates and registers a new {@link KissenPaperChildCommand} as a child command of this command.
+     * <p>
+     * This method is used to create a new {@link KissenPaperChildCommand} instance with the provided subcommand name and
+     * registers it as a child command of the current command. The newly created child command is added to the list of children
+     * for this command.
+     *
+     * @param nextSubCommand The name of the subcommand to create. Must not be null.
+     * @return The newly created and registered {@link KissenPaperChildCommand} instance.
+     * @throws NullPointerException If the {@code nextSubCommand} parameter is null.
+     */
+    protected abstract @NotNull C createChildCommand(@NotNull String nextSubCommand, @NotNull KissenPaperAbstractCommand<C> parent);
+
+    /**
+     * Validates whether a command can be executed by the given {@link CommandSender}.
+     * <p>
+     * This method is used to validate whether a command can be executed by the provided {@link CommandSender}.
+     * Validation checks may include verifying the plugin's enabled status, the type of command sender, and other conditions.
+     *
+     * @param commandSender The {@link CommandSender} attempting to execute the command. Must not be null.
+     * @return {@code true} if the command can be executed by the given command sender, {@code false} otherwise.
+     * @throws CommandException     If the plugin associated with the command is not enabled.
+     * @throws NullPointerException If the provided {@code commandSender} parameter is null.
+     */
+    public boolean validate(@NotNull CommandSender commandSender)
+    {
+        return getTargetValidator().validate(getCommandInfo().map(CommandInfo::getTarget).orElse(CommandTarget.ALL),
+                commandSender);
+    }
+
+    /**
+     * Retrieves the {@link TargetValidator} associated with the command implementation.
+     * <p>
+     * This method is used to obtain the {@link TargetValidator} that is responsible for validating target entities
+     * related to the execution of a command. The validator is specific to the Kissen Paper command implementation.
+     *
+     * @return The {@link TargetValidator} associated with the command implementation.
+     */
+    public @NotNull TargetValidator getTargetValidator()
+    {
+        return Bukkit.getKissen().getImplementation(
+                KissenPaperCommandImplementation.class).getTargetValidator();
+    }
+
+    /**
+     * Asynchronously executes the function defined in the command payload.
+     *
+     * <p>This abstract method facilitates asynchronous execution of code paths within commands,
+     * which can be useful when performing potentially lengthy operations such as file access or network communication.
+     * This prevents blocking operations from freezing the thread that the command is currently executing on,
+     * helping avoid potential server lag or non-responsiveness.</p>
+     *
+     * <p>All subclasses must provide an implementation for this method, ensuring that the command payload function is task asynchronously.
+     * The implementation may use the server's scheduler, a thread pool, or any other method of asynchronous execution.</p>
+     *
+     * @param payload A CommandPayload object that encapsulates the command, sender, command related data and a function to execute.
+     *                The exact function varies among different commands and is defined when the payload is constructed.
+     */
+    public abstract void runAsync(@NotNull CommandPayload<CommandSender> payload);
+
+    private boolean hasOwnExecutor()
+    {
+        return commandExecutor != null;
+    }
+
+    private @NotNull CommandPayload<CommandSender> getCommandPayload(@NotNull CommandSender sender, @NotNull String alias, @NotNull String @NotNull [] args, CommandTarget target)
+    {
+        return new KissenCommandPayload<>(alias, sender, target, args, KissenPaperAbstractCommand.this)
+        {
+            @Override
+            protected @NotNull CommandHandler<CommandSender, ?> getHandler()
+            {
+                return KissenPaperAbstractCommand.this.getHandler();
+            }
+        };
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/command/plugin/KissenPaperPluginChildCommand.java b/src/main/java/net/kissenpvp/paper/command/command/plugin/KissenPaperPluginChildCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..f8426bfac3f3b607fb6f36e1090eae9c031db829
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/command/plugin/KissenPaperPluginChildCommand.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.command.command.plugin;
+
+import net.kissenpvp.core.command.CommandHolder;
+import net.kissenpvp.paper.command.command.KissenPaperAbstractCommand;
+import org.bukkit.plugin.Plugin;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Optional;
+
+/**
+ * Represents a child command within the Kissen Paper command framework, specifically designed for plugin-related commands.
+ * <p>
+ * This class extends {@link KissenPaperPluginCommand} and provides functionality for creating and managing child commands
+ * related to a specific plugin. Child commands of this type belong to a parent plugin command and are organized in a hierarchical structure.
+ */
+public class KissenPaperPluginChildCommand extends KissenPaperPluginCommand {
+    private final KissenPaperAbstractCommand<KissenPaperPluginChildCommand> parent;
+
+    /**
+     * Constructs a new {@link KissenPaperPluginChildCommand} with the specified plugin, name, and parent command.
+     *
+     * @param plugin The plugin to which this child command belongs. Must not be null.
+     * @param name   The name of the child command. Must not be null.
+     * @param parent The parent command to which this child command belongs. Must not be null.
+     * @throws NullPointerException If any of the parameters is null.
+     */
+    public KissenPaperPluginChildCommand(@NotNull Plugin plugin, @NotNull String name, @NotNull KissenPaperAbstractCommand<KissenPaperPluginChildCommand> parent) {
+        super(plugin, name, parent.getPosition() + 1, parent.getHandler());
+        this.parent = parent;
+    }
+
+    @Override
+    public @NotNull String getFullName() {
+        return parent.getFullName() + " " + getName();
+    }
+
+
+    @Override
+    public @NotNull Optional<CommandHolder<?, ?>> getParent()
+    {
+        return Optional.of(parent);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/command/plugin/KissenPaperPluginCommand.java b/src/main/java/net/kissenpvp/paper/command/command/plugin/KissenPaperPluginCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..2f906c7d6f53ae1bb5c35602865cd63a4185632c
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/command/plugin/KissenPaperPluginCommand.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.command.command.plugin;
+
+import net.kissenpvp.core.api.command.CommandHandler;
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.paper.command.command.KissenPaperAbstractCommand;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandException;
+import org.bukkit.command.CommandSender;
+import org.bukkit.plugin.Plugin;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Optional;
+
+/**
+ * Represents a top-level Kissen Paper command specifically designed for plugin-related commands.
+ * <p>
+ * This class extends {@link KissenPaperAbstractCommand} and provides functionality for creating and managing plugin-related commands.
+ * It is used as a container for subcommands related to a specific plugin and supports the creation of child commands using the specified parent command.
+ */
+public class KissenPaperPluginCommand extends KissenPaperAbstractCommand<KissenPaperPluginChildCommand> {
+
+    private final Plugin plugin;
+
+    /**
+     * Constructs a new {@link KissenPaperAbstractCommand} instance with the provided plugin, name, and position.
+     * <p>
+     * This constructor is used to create a new {@link KissenPaperAbstractCommand} instance with the specified plugin, command name, and position in the command hierarchy.
+     *
+     * @param plugin   The {@link Plugin} that owns this command. Must not be null.
+     * @param name     The name of the command. Must not be null.
+     * @param position The position of the command in the command hierarchy.
+     * @throws NullPointerException If either the {@code plugin} or {@code name} parameter is null.
+     */
+    public KissenPaperPluginCommand(@NotNull Plugin plugin, @NotNull String name, int position, CommandHandler<CommandSender, ?> handler) {
+        super(name, position, handler);
+        this.plugin = plugin;
+    }
+
+    @Override
+    public @NotNull Optional<KissenPaperPluginChildCommand> getChildCommand(@NotNull String name) {
+        return super.getChildCommand(name);
+    }
+
+    @Override
+    public void runAsync(@NotNull CommandPayload<CommandSender> payload) {
+        Bukkit.getAsyncScheduler().runNow(getPlugin(), scheduledTask -> getExecutor().execute(payload));
+    }
+
+    @Override
+    protected @NotNull KissenPaperPluginChildCommand createChildCommand(@NotNull String nextSubCommand, @NotNull KissenPaperAbstractCommand<KissenPaperPluginChildCommand> parent) {
+        return new KissenPaperPluginChildCommand(plugin, nextSubCommand, parent);
+    }
+
+    @Override
+    public boolean validate(@NotNull CommandSender commandSender) {
+        if (!this.plugin.isEnabled()) {
+            throw new CommandException(String.format("Plugin '%s' is not enabled.", plugin.getName()), new IllegalStateException());
+        }
+
+        return super.validate(commandSender);
+    }
+
+    /**
+     * Retrieves the Plugin associated with this command execution.
+     *
+     * @return The Plugin instance representing the plugin responsible for handling the command.
+     */
+    public @NotNull Plugin getPlugin() {
+        return plugin;
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/command/system/KissenPaperChildCommand.java b/src/main/java/net/kissenpvp/paper/command/command/system/KissenPaperChildCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..c0590602b820f39e4c10016274e2082da55b7b1a
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/command/system/KissenPaperChildCommand.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.command.command.system;
+
+import net.kissenpvp.core.command.CommandHolder;
+import net.kissenpvp.paper.command.command.KissenPaperAbstractCommand;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Optional;
+
+/**
+ * Represents a child command within the Kissen Paper command framework.
+ * <p>
+ * This class extends {@link KissenPaperCommand} and provides functionality for creating and managing child commands.
+ * Child commands are subcommands that belong to a parent command and are organized in a hierarchical structure.
+ */
+public class KissenPaperChildCommand extends KissenPaperCommand {
+
+    private final KissenPaperAbstractCommand<KissenPaperChildCommand> parent;
+
+    /**
+     * Constructs a new {@link KissenPaperChildCommand} with the specified name and parent command.
+     *
+     * @param name   The name of the child command. Must not be null.
+     * @param parent The parent command to which this child command belongs. Must not be null.
+     * @throws IllegalArgumentException If the {@code name} is null.
+     * @throws NullPointerException     If the {@code parent} is null.
+     */
+    public KissenPaperChildCommand(@NotNull String name, @NotNull KissenPaperAbstractCommand<KissenPaperChildCommand> parent) {
+        super(name, parent.getPosition() + 1, parent.getHandler());
+        this.parent = parent;
+    }
+
+    @Override
+    public @NotNull String getFullName() {
+        return parent.getFullName() + " " + getName();
+    }
+
+    @Override
+    public @NotNull Optional<CommandHolder<?, ?>> getParent()
+    {
+        return Optional.of(parent);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/command/system/KissenPaperCommand.java b/src/main/java/net/kissenpvp/paper/command/command/system/KissenPaperCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..1e5ad4fe9ab90bef9e2a5c8b5c3b58f18d5080ab
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/command/system/KissenPaperCommand.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.command.command.system;
+
+import net.kissenpvp.core.api.command.CommandHandler;
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.paper.command.command.KissenPaperAbstractCommand;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+/**
+ * Represents a top-level Kissen Paper command within the command hierarchy.
+ * <p>
+ * This class extends {@link KissenPaperAbstractCommand} and provides functionality for creating and managing top-level Kissen Paper commands.
+ * It is used as a container for subcommands and supports the creation of child commands using the specified parent command.
+ */
+public class KissenPaperCommand extends KissenPaperAbstractCommand<KissenPaperChildCommand>
+{
+    private static final ExecutorService executorService;
+
+    static
+    {
+        executorService = Executors.newSingleThreadExecutor();
+    }
+
+    /**
+     * Constructs a new {@link KissenPaperCommand} with the specified name and position.
+     *
+     * @param name     The name of the command. Must not be null.
+     * @param position The position of the command. Must be non-negative.
+     * @throws IllegalArgumentException If the {@code name} is null or if the {@code position} is negative.
+     */
+    public KissenPaperCommand(@NotNull String name, int position, @NotNull CommandHandler<CommandSender, ?> handler) {
+        super(name, position, handler);
+    }
+
+    @Override
+    public void runAsync(@NotNull CommandPayload<CommandSender> payload) {
+        executorService.execute(() -> getExecutor().execute(payload));
+    }
+
+    @Override
+    protected @NotNull KissenPaperChildCommand createChildCommand(@NotNull String nextSubCommand, @NotNull KissenPaperAbstractCommand<KissenPaperChildCommand> parent) {
+        return new KissenPaperChildCommand(nextSubCommand, parent);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/confirmation/ConfirmCommand.java b/src/main/java/net/kissenpvp/paper/command/confirmation/ConfirmCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..daeefc739da245544c09aeb33f4b5871c8dbf1a5
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/confirmation/ConfirmCommand.java
@@ -0,0 +1,67 @@
+package net.kissenpvp.paper.command.confirmation;
+
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.core.api.command.annotations.CommandData;
+import net.kyori.adventure.text.Component;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * The {@code ConfirmCommand} class provides command handlers for confirming and canceling actions with a confirmation request.
+ * It is part of the KissenPvP command framework and is designed to work in conjunction with the confirmation system provided by the KissenPaper plugin.
+ * The class includes methods for confirming and canceling actions, using a confirmation implementation obtained from the KissenPvP plugin.
+ *
+ * <p>The confirmation commands are defined using the {@link CommandData} annotation, specifying the command labels "confirm" and "cancel" respectively.
+ * When executed, these commands interact with the associated confirmation implementation to confirm or cancel actions based on the sender's request.</p>
+ *
+ * <p>The class uses the {@link CommandPayload} interface to handle command execution payloads, providing access to the command sender and related information.</p>
+ *
+ * @see CommandData
+ * @see CommandPayload
+ * @see KissenPaperConfirmationImplementation
+ * @see Component
+ */
+public class ConfirmCommand
+{
+
+    /**
+     * Handles the execution of the "confirm" command, confirming a pending action.
+     * Uses the KissenPaperConfirmationImplementation to perform the confirmation action.
+     *
+     * @param commandPayload The CommandPayload containing information about the command execution.
+     */
+    @CommandData("confirm")
+    public void confirm(@NotNull CommandPayload<CommandSender> commandPayload)
+    {
+        if(!getImplementation().execute(commandPayload.getSender(), false))
+        {
+            commandPayload.getSender().sendMessage(Component.translatable("server.command.confirm.no.request"));
+        }
+    }
+
+    /**
+     * Handles the execution of the "cancel" command, canceling a pending action.
+     * Uses the KissenPaperConfirmationImplementation to perform the cancellation action.
+     *
+     * @param commandPayload The CommandPayload containing information about the command execution.
+     */
+    @CommandData("cancel")
+    public void cancel(@NotNull CommandPayload<CommandSender> commandPayload)
+    {
+        if(!getImplementation().execute(commandPayload.getSender(), true))
+        {
+            commandPayload.getSender().sendMessage(Component.translatable("server.command.confirm.no.request"));
+        }
+    }
+
+    /**
+     * Retrieves the KissenPaperConfirmationImplementation responsible for handling confirmation requests.
+     *
+     * @return The KissenPaperConfirmationImplementation instance associated with the KissenPvP plugin.
+     */
+    private @NotNull KissenPaperConfirmationImplementation getImplementation()
+    {
+        return Bukkit.getKissen().getImplementation(KissenPaperConfirmationImplementation.class);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/confirmation/KissenPaperConfirmationImplementation.java b/src/main/java/net/kissenpvp/paper/command/confirmation/KissenPaperConfirmationImplementation.java
new file mode 100644
index 0000000000000000000000000000000000000000..f303a2ec9b2075b0f30fd8cb1f818246a280bab5
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/confirmation/KissenPaperConfirmationImplementation.java
@@ -0,0 +1,36 @@
+package net.kissenpvp.paper.command.confirmation;
+
+
+import net.kissenpvp.core.api.command.CommandHandler;
+import net.kissenpvp.core.command.confirmation.KissenConfirmationImplementation;
+import net.kissenpvp.paper.command.KissenPaperCommandImplementation;
+import org.bukkit.Bukkit;
+
+/**
+ * The {@code KissenPaperConfirmationImplementation} class extends {@code KissenConfirmationImplementation} and
+ * provides platform-specific functionality for handling confirmation requests in the KissenPvP plugin on the Paper platform.
+ * It overrides methods from its superclass to customize setup and check whether the server is running.
+ *
+ * <p>During the setup, it registers the confirmation-related command handlers, such as the "confirm" and "cancel" commands,
+ * using the {@link ConfirmCommand} class.</p>
+ *
+ * <p>This class is intended to be used in conjunction with the confirmation system in the KissenPvP, extending and
+ * adapting the functionality for the Paper platform.</p>
+ *
+ * @see KissenConfirmationImplementation
+ * @see KissenPaperCommandImplementation
+ * @see ConfirmCommand
+ */
+public class KissenPaperConfirmationImplementation extends KissenConfirmationImplementation {
+
+    @Override
+    public void setupComplete() {
+        CommandHandler<?, ?> handler = Bukkit.getKissen().getImplementation(KissenPaperCommandImplementation.class).getInternalHandler();
+        handler.registerCommand(new ConfirmCommand());
+    }
+
+    @Override
+    protected boolean isServerRunning() {
+        return !Bukkit.getServer().isStopping();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/handler/CompletionExceptionHandler.java b/src/main/java/net/kissenpvp/paper/command/handler/CompletionExceptionHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..3b7db415a1f2b0f2760ec5b7c14563a18763b72b
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/handler/CompletionExceptionHandler.java
@@ -0,0 +1,16 @@
+package net.kissenpvp.paper.command.handler;
+
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.paper.api.command.CommandExceptionHandler;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.concurrent.CompletionException;
+
+public class CompletionExceptionHandler implements CommandExceptionHandler<CompletionException> {
+    @Override
+    public boolean handle(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull CompletionException throwable) {
+        return true;
+        // TODO return Optional.ofNullable(throwable.getCause()).map(cause -> KissenCore.getInstance().getImplementation(KissenCommandImplementation.class).handle(commandPayload, cause)).orElse(false);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/handler/PlayerExceptionHandler.java b/src/main/java/net/kissenpvp/paper/command/handler/PlayerExceptionHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..61923aa34a3729604916ed327650e0b0a5b6b20e
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/handler/PlayerExceptionHandler.java
@@ -0,0 +1,17 @@
+package net.kissenpvp.paper.command.handler;
+
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.core.api.networking.client.entitiy.PlayerOfflineException;
+import net.kissenpvp.paper.api.command.CommandExceptionHandler;
+import net.kyori.adventure.text.Component;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+
+public class PlayerExceptionHandler implements CommandExceptionHandler<PlayerOfflineException> {
+    @Override
+    public boolean handle(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PlayerOfflineException throwable) {
+
+        commandPayload.getSender().sendMessage(Component.translatable("server.command.player.offline", Component.text(throwable.getName())));
+        return true;
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/handler/ProfileNotFoundExceptionHandler.java b/src/main/java/net/kissenpvp/paper/command/handler/ProfileNotFoundExceptionHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..d52a036a0b8f5ac5d0f1ec29fa4a5aa06e4e3587
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/handler/ProfileNotFoundExceptionHandler.java
@@ -0,0 +1,17 @@
+package net.kissenpvp.paper.command.handler;
+
+import com.mojang.authlib.yggdrasil.ProfileNotFoundException;
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.paper.api.command.CommandExceptionHandler;
+import net.kyori.adventure.text.Component;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+
+public class ProfileNotFoundExceptionHandler implements CommandExceptionHandler<ProfileNotFoundException> {
+    @Override
+    public boolean handle(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull ProfileNotFoundException throwable) {
+
+        commandPayload.getSender().sendMessage(Component.translatable("server.command.mojang.profile.invalid"));
+        return true;
+    }
+}
