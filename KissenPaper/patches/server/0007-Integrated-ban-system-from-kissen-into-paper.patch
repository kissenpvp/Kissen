From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Groldi <chniucg@gmail.com>
Date: Sun, 24 Sep 2023 13:30:52 +0200
Subject: [PATCH] Integrated ban system from kissen into paper


diff --git a/src/main/java/io/papermc/paper/adventure/ChatProcessor.java b/src/main/java/io/papermc/paper/adventure/ChatProcessor.java
index e4fd372a1d585887287253a02531cd192929377b..5ad9e4c034c317eef3e723f0b420e315ef9a666f 100644
--- a/src/main/java/io/papermc/paper/adventure/ChatProcessor.java
+++ b/src/main/java/io/papermc/paper/adventure/ChatProcessor.java
@@ -175,9 +175,14 @@ public final class ChatProcessor {
     }
 
     private void processModern(final ChatRenderer renderer, final Set<Audience> viewers, final Component message, final Player player, final boolean cancelled) {
+        // KissenPaper start - integrate mute
+        net.kissenpvp.paper.api.ban.BanImplementation paperBanImplementation = org.bukkit.Bukkit.getKissen().getImplementation(net.kissenpvp.paper.api.ban.BanImplementation.class);
+        java.util.Optional<net.kissenpvp.paper.api.ban.Punishment> mute = paperBanImplementation.getLatestPunishment(player.getTotalID(), net.kissenpvp.core.api.ban.BanType.MUTE);
+        // KissenPaper end
+
         final PlayerChatMessage.AdventureView signedMessage = this.message.adventureView();
         final AsyncChatEvent ae = new AsyncChatEvent(this.async, player, viewers, renderer, message, this.paper$originalMessage, signedMessage);
-        ae.setCancelled(cancelled); // propagate cancelled state
+        ae.setCancelled(cancelled || mute.isPresent()); // propagate cancelled state // KissenPaper - set true if muted
         this.post(ae);
         final boolean listenersOnSyncEvent = canYouHearMe(ChatEvent.getHandlerList());
         if (listenersOnSyncEvent) {
@@ -188,13 +193,22 @@ public final class ChatProcessor {
                     se.setCancelled(ae.isCancelled()); // propagate cancelled state
                     ChatProcessor.this.post(se);
                     ChatProcessor.this.readModernModifications(se, renderer);
-                    ChatProcessor.this.complete(se);
+                    // KissenPaper start - integrate mute
+                    if(allowedToSend(player, mute.orElse(null), se.isCancelled()))
+                    {
+                        ChatProcessor.this.complete(se);
+                    }
                     return null;
                 }
             });
         } else {
             this.readModernModifications(ae, renderer);
-            this.complete(ae);
+            // KissenPaper start - integrate mute
+            if(allowedToSend(player, mute.orElse(null), ae.isCancelled()))
+            {
+                this.complete(ae);
+            }
+            // KissenPaper end
         }
     }
 
@@ -419,4 +433,33 @@ public final class ChatProcessor {
     static boolean canYouHearMe(final HandlerList handlers) {
         return handlers.getRegisteredListeners().length > 0;
     }
+
+    // KissenPaper start
+    /**
+     * Determines whether a player is allowed to send a message based on specified conditions.
+     * <p>
+     * This method evaluates the provided parameters and decides whether the player is allowed to send a message.
+     * The decision depends on the values of the 'muted' and 'cancelled' parameters. If both parameters are true,
+     * indicating that the player is both muted and the action is cancelled, a message is sent to the player
+     * notifying them about being muted, and the method returns false to indicate that the player is not allowed
+     * to send the message. Otherwise, the method returns true, allowing the player to send the message.
+     *
+     * @param player The player who intends to send a message. Must not be null.
+     * @param mute  A boolean flag indicating whether the player is muted. If true, the player is considered muted.
+     * @param cancelled A boolean flag indicating whether the action is cancelled. If true, the action is considered cancelled.
+     * @return true if the player is allowed to send the message, false otherwise.
+     *
+     * @throws NullPointerException If the 'player' parameter is null.
+     */
+    private boolean allowedToSend(@org.jetbrains.annotations.NotNull Player player, @org.jetbrains.annotations.Nullable net.kissenpvp.paper.api.ban.Punishment mute, boolean cancelled)
+    {
+        if(mute != null && cancelled)
+        {
+            //mute is not null
+            player.sendMessage(mute.getPunishmentText(player.getCurrentLocale()));
+            return false;
+        }
+        return true;
+    }
+    // KissenPaper end
 }
diff --git a/src/main/java/net/kissenpvp/paper/ban/KissenPaperBan.java b/src/main/java/net/kissenpvp/paper/ban/KissenPaperBan.java
new file mode 100644
index 0000000000000000000000000000000000000000..aa933e5bfb91819c1b0e5d9eba415134f8d898e6
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/ban/KissenPaperBan.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.ban;
+
+import net.kissenpvp.core.api.networking.socket.DataPackage;
+import net.kissenpvp.core.ban.KissenBan;
+import net.kissenpvp.paper.api.ban.Ban;
+import org.jetbrains.annotations.NotNull;
+
+public class KissenPaperBan extends KissenBan implements Ban {
+    @Override
+    public void sendData(@NotNull DataPackage dataPackage) {
+        //TODO
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/ban/KissenPaperBanImplementation.java b/src/main/java/net/kissenpvp/paper/ban/KissenPaperBanImplementation.java
index dc6bc76ed46223745f235f1c8f03661e6d565a08..52fd271f084dd796479dfb175dbe86d1e7b8c302 100644
--- a/src/main/java/net/kissenpvp/paper/ban/KissenPaperBanImplementation.java
+++ b/src/main/java/net/kissenpvp/paper/ban/KissenPaperBanImplementation.java
@@ -268,6 +268,7 @@ public class KissenPaperBanImplementation extends KissenBanImplementation<Ban, P
         return getLatestPunishment(Objects.requireNonNull(target.getId())).orElse(null);
     }
 
+    @SuppressWarnings("rawtypes") // overridden (minecraft)
     @Override
     public @NotNull Set<BanEntry> getBanEntries() {
         return getPunishmentSet().stream().map(punishment -> (BanEntry<?>) punishment).collect(Collectors.toSet());
diff --git a/src/main/java/net/kissenpvp/paper/ban/KissenPaperPunishment.java b/src/main/java/net/kissenpvp/paper/ban/KissenPaperPunishment.java
new file mode 100644
index 0000000000000000000000000000000000000000..ee153c87d87dfff216f93dfbaae734d2c5ee56d6
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/ban/KissenPaperPunishment.java
@@ -0,0 +1,131 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.paper.ban;
+
+import com.destroystokyo.paper.profile.PlayerProfile;
+import net.kissenpvp.core.api.database.DataWriter;
+import net.kissenpvp.core.ban.KissenPunishment;
+import net.kissenpvp.core.ban.KissenPunishmentNode;
+import net.kissenpvp.paper.api.ban.Punishment;
+import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;
+import org.bukkit.Bukkit;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Date;
+import java.util.Set;
+import java.util.UUID;
+import java.util.stream.Collectors;
+
+/**
+ * The {@code KissenPaperPunishment} class is a specific implementation of {@code KissenPunishment}, representing
+ * punishment data in a Paper server context. This class additionally implements the {@code PaperPunishment}
+ * interface, hence making it a Paper-specific extension of the {@code KissenPunishment}.
+ * <p>
+ * This class is designed to work with in-game Players and their associated punishment data, including
+ * PunishmentNode, DataWriter and much more. It provides operations to manipulate the punishment data such as
+ * {@code getOnlineAffectedPlayers()}, {@code getBanTarget()}, {@code getCreated()} etc.
+ * <p>
+ * The instances of this class are mutable but do not allow direct mutation of the created and source fields.
+ * Mutating operations for these fields will throw an {@code UnsupportedOperationException}.
+ *
+ * @see KissenPunishment
+ * @see Punishment
+ * @author User
+ */
+public class KissenPaperPunishment extends KissenPunishment<Player> implements Punishment {
+
+    /**
+     * Instantiates a {@code KissenPaperPunishment}.
+     *
+     * @param totalID The UUID of the dataset for which the punishment data is to be created.
+     * @param kissenPunishmentNode The data container for this punishment.
+     * @param dataWriter (Nullable) The DataWriter that will be used for updating the punishment data.
+     */
+    public KissenPaperPunishment(@NotNull UUID totalID, @NotNull KissenPunishmentNode kissenPunishmentNode, @Nullable DataWriter<KissenPunishmentNode> dataWriter) {
+        super(totalID, kissenPunishmentNode, dataWriter);
+    }
+
+    @Override
+    public @Unmodifiable Set<Player> getOnlineAffectedPlayers() {
+        return Bukkit.getOnlinePlayers().stream().filter(player -> player.getTotalID().equals(getTotalID())).collect(Collectors.toSet());
+    }
+
+    @Override
+    public @NotNull String getTarget() {
+        return null; //TODO
+    }
+
+    @Override
+    public @NotNull PlayerProfile getBanTarget() {
+        return null; //TODO
+    }
+
+    @Override
+    public @NotNull Date getCreated() {
+        return Date.from(getStart());
+    }
+
+    @Override
+    public void setCreated(@NotNull Date created) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public @NotNull String getSource() {
+        return getBanOperator();
+    }
+
+    @Override
+    public void setSource(@NotNull String source) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public @Nullable Date getExpiration() {
+        return getEnd().map(Date::from).orElse(null);
+    }
+
+    @Override
+    public void setExpiration(@Nullable Date expiration) {
+        setEnd(expiration == null ? null : expiration.toInstant());
+    }
+
+    @Override
+    public @Nullable String getReason() {
+        return getCause().map(cause -> LegacyComponentSerializer.legacyAmpersand().serialize(cause)).orElse(null);
+    }
+
+    @Override
+    public void setReason(@Nullable String reason) {
+        setCause(reason == null ? null : LegacyComponentSerializer.legacySection().deserialize(reason));
+    }
+
+    @Override
+    public void save() {
+        // not used
+    }
+
+    @Override
+    public void remove() {
+        // not used
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/ban/KissenPaperPunishmentList.java b/src/main/java/net/kissenpvp/paper/ban/KissenPaperPunishmentList.java
new file mode 100644
index 0000000000000000000000000000000000000000..b05abe4ce48e1facd73b5eb571da45cb19651c5b
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/ban/KissenPaperPunishmentList.java
@@ -0,0 +1,167 @@
+package net.kissenpvp.paper.ban;
+
+import com.google.gson.JsonObject;
+import com.mojang.authlib.GameProfile;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.api.user.UserInfo;
+import net.kissenpvp.paper.api.ban.BanImplementation;
+import net.kissenpvp.paper.api.ban.Punishment;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.MutableComponent;
+import net.minecraft.server.players.StoredUserEntry;
+import net.minecraft.server.players.UserBanList;
+import net.minecraft.server.players.UserBanListEntry;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Collection;
+import java.util.List;
+import java.util.Objects;
+import java.util.stream.Collectors;
+
+public class KissenPaperPunishmentList extends UserBanList {
+
+    public KissenPaperPunishmentList() {
+        super(null);
+    }
+
+
+    
+    @Override
+    protected @NotNull StoredUserEntry<GameProfile> createEntry(JsonObject json) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean isBanned(GameProfile profile) {
+        return getBanImplementation().isBanned(String.valueOf(profile.getId()));
+    }
+
+    @Override
+    public String @NotNull [] getUserList() {
+        return new String[0]; // too performance consuming and not even necessary.
+    }
+
+    @Override
+    public @NotNull File getFile() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void add(UserBanListEntry entry) {
+        getBanImplementation().addBan(String.valueOf(Objects.requireNonNull(entry.getUser()).getId()), entry.getReason(), entry.getExpires(), entry.getSource());
+    }
+
+    @Nullable
+    @Override
+    public UserBanListEntry get(@NotNull GameProfile key) {
+        try {
+            return getBanImplementation().getLatestPunishment(key.getId()).map(this::translate).orElse(null); //TODO use totalID instead.
+        }catch (BackendException backendException)
+        {
+            return null;
+        }
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return getBanImplementation().getEntries().isEmpty();
+    }
+
+    @Override
+    protected boolean contains(@NotNull GameProfile k0) {
+        return getEntries().stream().anyMatch(entry -> Objects.equals(entry.getUser(), k0));
+    }
+
+    @Override
+    public @NotNull Collection<UserBanListEntry> getEntries() {
+        return getBanImplementation().getEntries().stream().map(ban -> translate((Punishment) ban)).collect(Collectors.toSet());
+    }
+
+    @Override
+    public void save() throws IOException {
+        // ignored
+    }
+
+    @Override
+    public void load()  {
+        // ignored
+    }
+
+    @Override
+    public void remove(@NotNull GameProfile key) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void remove(@NotNull StoredUserEntry<GameProfile> entry) {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Retrieves the PaperBanImplementation instance.
+     *
+     * @return The PaperBanImplementation instance. This method returns the implementation of the PaperBan plugin
+     *         registered with Bukkit's implementation provider.
+     * @throws IllegalStateException if the PaperBanImplementation has not been registered with the implementation provider.
+     */
+    private @NotNull BanImplementation getBanImplementation()
+    {
+        return Bukkit.getKissen().getImplementation(BanImplementation.class);
+    }
+
+    /**
+     * Translates a PaperPunishment object into a UserBanListEntry object.
+     *
+     * @param paperPunishment The PaperPunishment object to be translated.
+     * @return The translated UserBanListEntry object.
+     */
+    @Contract("_ -> new")
+    private @NotNull UserBanListEntry translate(@NotNull Punishment paperPunishment)
+    {
+        return new KissenPaperPunishmentListEntry(paperPunishment);
+    }
+
+    private final static class KissenPaperPunishmentListEntry extends UserBanListEntry
+    {
+        private final Punishment paperPunishment;
+
+        public KissenPaperPunishmentListEntry(@NotNull Punishment paperPunishment)
+        {
+            super(null, paperPunishment.getCreated(), paperPunishment.getSource(), paperPunishment.getExpiration(),
+                    paperPunishment.getName());
+            this.paperPunishment = paperPunishment;
+        }
+
+        @Override
+        public @NotNull Component getDisplayName()
+        {
+
+            UserImplementation userImplementation = Bukkit.getKissen().getImplementation(UserImplementation.class);
+            List<MutableComponent> componentStream = paperPunishment.getAffectedPlayers().stream().map(
+                    uuid -> userImplementation.getCachedUserProfile(uuid).map(UserInfo::getName).map(
+                            Component::literal).orElse(Component.translatable("commands.banlist.entry.unknown"))).toList();
+
+            MutableComponent names = Component.empty();
+            for (int i = 0; i < componentStream.size(); i++)
+            {
+                names.append(componentStream.get(i));
+                if(i < componentStream.size() - 2)
+                {
+                    names.append(", ");
+                }
+                else if(i < componentStream.size() - 1)
+                {
+                    names.append(" and ");
+                }
+            }
+
+            return names;
+        }
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/ban/MinecraftBan.java b/src/main/java/net/kissenpvp/paper/ban/MinecraftBan.java
new file mode 100644
index 0000000000000000000000000000000000000000..740b0b953e493eaf45acf6458ffdbe69c0bc646c
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/ban/MinecraftBan.java
@@ -0,0 +1,61 @@
+package net.kissenpvp.paper.ban;
+
+import net.kissenpvp.core.api.ban.BanType;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.time.AccurateDuration;
+import net.kissenpvp.paper.api.ban.Ban;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Optional;
+
+public class MinecraftBan implements Ban {
+
+    private final BanType banType;
+    private final AccurateDuration duration;
+
+    public MinecraftBan(BanType banType, AccurateDuration duration) {
+        this.banType = banType;
+        this.duration = duration;
+    }
+
+    @Override
+    public int getID() {
+        return -1;
+    }
+
+    @Override
+    public @NotNull String getName() {
+        return "Minecraft";
+    }
+
+    @Override
+    public void setName(@NotNull String name) throws EventCancelledException {
+        throw new EventCancelledException(new UnsupportedOperationException());
+    }
+
+    @Override
+    public @NotNull BanType getBanType() {
+        return banType;
+    }
+
+    @Override
+    public void setBanType(@NotNull BanType banType) throws EventCancelledException {
+        throw new EventCancelledException(new UnsupportedOperationException());
+    }
+
+    @Override
+    public @NotNull Optional<AccurateDuration> getDuration() {
+        return Optional.ofNullable(duration);
+    }
+
+    @Override
+    public void setDuration(@Nullable AccurateDuration duration) throws EventCancelledException {
+        throw new EventCancelledException(new UnsupportedOperationException());
+    }
+
+    @Override
+    public int delete()  {
+        throw new EventCancelledException(new UnsupportedOperationException());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/ban/command/BanCommand.java b/src/main/java/net/kissenpvp/paper/ban/command/BanCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..1be51ac8ee07d7d56e8d726acd6530f2a8d73b05
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/ban/command/BanCommand.java
@@ -0,0 +1,142 @@
+package net.kissenpvp.paper.ban.command;
+
+import net.kissenpvp.core.api.ban.AbstractPunishment;
+import net.kissenpvp.core.api.ban.BanType;
+import net.kissenpvp.core.api.ban.exception.NonexistentPunishmentException;
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.core.api.command.annotations.ArgumentName;
+import net.kissenpvp.core.api.command.annotations.CommandData;
+import net.kissenpvp.core.api.command.annotations.Optional;
+import net.kissenpvp.core.api.command.annotations.TabCompleter;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.time.AccurateDuration;
+import net.kissenpvp.core.api.time.TemporalObject;
+import net.kissenpvp.paper.api.ban.Ban;
+import net.kissenpvp.paper.api.ban.BanImplementation;
+import net.kissenpvp.paper.api.ban.Punishment;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;
+import org.bukkit.Bukkit;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+
+import java.time.Instant;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+public class BanCommand {
+
+    /**
+     * Executes the ban command to punish a specific user by removing their access rights from the server.
+     *
+     * @param payload     the command payload containing the sender information
+     * @param player      the offline player to be banned
+     * @param paperBan    the PaperBan representing the type of ban
+     * @param reasonArray the optional reason for the ban
+     * @throws BackendException if there is an error in the backend
+     */
+    @CommandData(value = "ban", aliases = {"punish", "mute", "kick"}, description = "This command is used to ban or punish a specific user by removing their access rights from the server.")
+    public void ban(@NotNull CommandPayload<CommandSender> payload, @NotNull OfflinePlayer player, @NotNull Ban paperBan, @NotNull @Optional @ArgumentName("reason") String[] reasonArray) throws BackendException {
+        if (payload.getSender() instanceof OfflinePlayer && player.getRank().getSource().getPriority() < player.getRank().getSource().getPriority()) {
+            payload.getSender().sendMessage(Component.translatable("server.ban.player.not.allowed", player.displayName()));
+            return;
+        }
+        java.util.Optional<Component> reason = getReason(reasonArray);
+        Punishment punishment = player.punish(paperBan, payload.getSender(), reason.orElse(null));
+
+        Component displayName = player.displayName();
+        Component message = messages().punishComponent(displayName, punishment.getBanType(), reason.orElse(null));
+        payload.getSender().sendMessage(message);
+    }
+
+    /**
+     * This method is responsible for executing the command to create predefined ban types
+     * with a specified duration which can serve as templates for different banning situations.
+     * CommandData annotation is used to provide command metadata.
+     *
+     * @param payload          The information about the command including sender and command details.
+     * @param name             The name of the ban template.
+     * @param id               The identifier for the ban template.
+     * @param banType          The type of ban that this template represents.
+     * @param accurateDuration The duration which the ban (derived from this template) will last.
+     * @throws BackendException If any error occurs during the creation of the ban template at the backend.
+     */
+    @CommandData(value = "banidcreate", aliases = {"bidc", "createidban"}, description = "Command to create predefined ban types with a specified duration. These can be used as templates for various ban situations.")
+    public void create(@NotNull CommandPayload<CommandSender> payload, @ArgumentName("id") int id, @NotNull @ArgumentName("name") String name, @NotNull @ArgumentName("type") BanType banType, @NotNull java.util.Optional<AccurateDuration> accurateDuration) throws BackendException {
+        BanImplementation paperBanImplementation = Bukkit.getKissen().getImplementation(BanImplementation.class);
+
+        Runnable runnable = () -> {
+            Ban paperBan = paperBanImplementation.createBan(id, name, banType, accurateDuration.orElse(null));
+
+            Component idComponent = Component.text(paperBan.getID()), nameComponent = Component.text(paperBan.getName()), banTypeComponent = Component.text(paperBan.getBanType().toString());
+            if (accurateDuration.isPresent()) {
+                Component[] args = {idComponent, nameComponent, banTypeComponent, accurateDuration.get().toComponent(payload.getSender().getCurrentLocale())};
+                payload.getSender().sendMessage(Component.translatable("server.ban.created", args));
+                return;
+            }
+            Component[] args = {idComponent, nameComponent, banTypeComponent};
+            payload.getSender().sendMessage(Component.translatable("server.ban.created.permanent", args));
+        };
+
+        //Ask for confirmation if ban exists.
+        if (paperBanImplementation.getBan(id).isPresent()) {
+            payload.confirmRequest(runnable).send();
+            return;
+        }
+        runnable.run();
+    }
+
+    @CommandData(value = "baniddelete", aliases = {"bidd", "deleteidban"})
+    public void delete(@NotNull CommandPayload<CommandSender> payload, @NotNull Ban paperBan) throws BackendException {
+        paperBan.delete();
+        payload.getSender().sendMessage(Component.translatable("server.ban.deleted", Component.text(paperBan.getID())));
+    }
+
+    @CommandData(value = "unban", description = "This command is used to disable a specific ban, identifying it by its unique ID.")
+    public void unban(@NotNull CommandPayload<CommandSender> payload, @NotNull Punishment punishment) {
+        if (!punishment.isValid()) {
+            throw new NonexistentPunishmentException(punishment.getID());
+        }
+        punishment.setEnd(Instant.now());
+
+        Component idComponent = Component.text(punishment.getID());
+        payload.getSender().sendMessage(Component.translatable("server.ban.punishment.pardoned", idComponent));
+    }
+
+    @TabCompleter("unban")
+    public @NotNull Set<String> tabUnban() {
+        BanImplementation ban = Bukkit.getKissen().getImplementation(BanImplementation.class);
+        return ban.getPunishmentSet().stream().filter(TemporalObject::isValid).map(AbstractPunishment::getID).collect(Collectors.toSet());
+    }
+
+    @CommandData(value = "banhistory", aliases = "bh")
+    public void history(@NotNull CommandPayload<CommandSender> payload, @NotNull OfflinePlayer offlinePlayer, @NotNull @ArgumentName("page") java.util.Optional<Integer> page) {
+        payload.getSender().sendMessage(messages().getHistory(payload, offlinePlayer, page.orElse(1)));
+    }
+
+    @CommandData(value = "baninfo", aliases = {"punishmentinfo"})
+    public void banInfo(@NotNull CommandPayload<CommandSender> payload, @NotNull Punishment paperPunishment) {
+        payload.getSender().sendMessage(messages().punishmentInfo(payload, paperPunishment));
+    }
+
+
+    @Contract(pure = true, value = "-> new")
+    private @NotNull BanCommandMessages messages() {
+        return new BanCommandMessages();
+    }
+
+    /**
+     * Retrieves the reason as a {@link Component} object.
+     *
+     * @param reason the array of strings representing the reason
+     * @return the reason as a Component object, or null if the reason is empty
+     */
+    private @NotNull java.util.Optional<Component> getReason(@NotNull String @NotNull [] reason) {
+        if (reason.length!=0) {
+            return java.util.Optional.of(LegacyComponentSerializer.legacyAmpersand().deserialize(String.join(" ", reason).strip()));
+        }
+        return java.util.Optional.empty();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/ban/command/BanCommandMessages.java b/src/main/java/net/kissenpvp/paper/ban/command/BanCommandMessages.java
new file mode 100644
index 0000000000000000000000000000000000000000..2bf02e734e4696fe0b6e7a87f1a3e951eb79b78d
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/ban/command/BanCommandMessages.java
@@ -0,0 +1,256 @@
+package net.kissenpvp.paper.ban.command;
+
+import net.kissenpvp.core.api.ban.AbstractBan;
+import net.kissenpvp.core.api.ban.BanType;
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.core.api.util.PageBuilder;
+import net.kissenpvp.core.api.util.PageImplementation;
+import net.kissenpvp.core.util.KissenPageBuilder;
+import net.kissenpvp.paper.api.ban.Ban;
+import net.kissenpvp.paper.api.ban.BanImplementation;
+import net.kissenpvp.paper.api.ban.Punishment;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.TextComponent;
+import net.kyori.adventure.text.TranslatableComponent;
+import net.kyori.adventure.text.event.ClickEvent;
+import net.kyori.adventure.text.event.HoverEvent;
+import org.bukkit.Bukkit;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.time.ZoneId;
+import java.time.format.DateTimeFormatter;
+import java.time.format.FormatStyle;
+import java.util.Comparator;
+import java.util.List;
+
+/**
+ * Utility class for providing messages related to the ban command.
+ */
+public class BanCommandMessages
+{
+    /**
+     * Retrieves a paginated list of ban IDs along with associated information for the specified page.
+     *
+     * @param payload The command payload containing information about the sender and context.
+     * @param page The page number to retrieve ban IDs for.
+     * @return A formatted Component containing the paginated ban IDs and associated information.
+     *         If no ban IDs are found, a message indicating their absence is returned.
+     * @throws IllegalArgumentException if the payload or any of its required components are null.
+     * @throws UnsupportedOperationException if the ban system implementation is not available.
+     */
+    public @NotNull Component getBanIDList(@NotNull CommandPayload<CommandSender> payload, final int page)
+    {
+        PageImplementation pageImplementation = Bukkit.getKissen().getImplementation(PageImplementation.class);
+        BanImplementation banSystem = Bukkit.getKissen().getImplementation(BanImplementation.class);
+
+        List<Ban> sorted = banSystem.getBanSet().stream().sorted(Comparator.comparingInt(AbstractBan::getID)).toList();
+        if (sorted.isEmpty())
+        {
+            return Component.text("Gibt keine ban ids");
+        }
+        PageBuilder<Ban> banIDPageBuilder = pageImplementation.createPageBuilder(sorted);
+
+        Component header = banIDPageBuilder.getHeader(Component.text("BanIDs"), page);
+        Component footer = banIDPageBuilder.getFooter(Component.text("BanIDs"), page);
+
+        TextComponent.Builder builder = Component.text().append(header);
+        for (Ban currentBan : banIDPageBuilder.getEntries(page))
+        {
+            Component[] args = {
+                    Component.text(currentBan.getID()), Component.text(currentBan.getName()), Component.text(currentBan.getBanType().toString())
+            };
+            Component time = currentBan.getDuration().map(duration -> duration.toComponent(payload.getSender())).orElse(Component.translatable("mco.configure.world.subscription.unknown"));
+            builder.appendNewline().append(Component.translatable("server.ban.banid.compact", args).hoverEvent(HoverEvent.showText(time)));
+        }
+
+        builder.appendNewline().append(footer);
+        return builder.asComponent();
+    }
+
+    /**
+     * Retrieves a paginated history of punishments for the specified player.
+     *
+     * @param payload The command payload containing information about the sender and context.
+     * @param player The player for whom to retrieve the punishment history.
+     * @param page The page number to retrieve the punishment history for.
+     * @return A formatted Component containing the paginated punishment history for the player.
+     *         If the player has no history, a message indicating the absence of history is returned.
+     * @throws IllegalArgumentException if the payload, player, or any of their required components are null.
+     */
+    public @NotNull Component getHistory(@NotNull CommandPayload<CommandSender> payload, @NotNull OfflinePlayer player, int page)
+    {
+        List<Punishment> playerHistory = player.getPunishmentHistory();
+        if (playerHistory.isEmpty())
+        {
+            return Component.translatable("server.ban.history.empty", player.displayName());
+        }
+        PageBuilder<Punishment> pageBuilder = new KissenPageBuilder<>(playerHistory);
+
+        Component header = pageBuilder.getHeader(player.displayName(), page);
+        Component footer = pageBuilder.getFooter(player.displayName(), page);
+
+        TextComponent.Builder builder = Component.text().append(header);
+        builder.append(compactHistory(payload, pageBuilder.getEntries(page)));
+
+        return builder.appendNewline().append(footer).asComponent();
+    }
+
+    /**
+     * This method is responsible for building the information of a punishment given on a server.
+     * The necessary parameters are a payload and a specific instance of a PaperPunishment.
+     * <p>
+     * The method first checks if the punishment is still valid. Depending on the validity, it sets the text color of the punishment name to either
+     * enabled or disabled using the ThemeProvider class.
+     * It then creates a header and footer for the punishment information with the punishment name in the appropriate color.
+     * Next, it creates Component instances for the punishment details including: ID, operator, start date, predicted end date, and actual end date.
+     * It then sets up a builder object to start constructing the punishment information block.
+     * The constructed information block consists of key-value pairs of punishment detail labels and their corresponding values.
+     * For each detail, it appends a new line with translated key-value pairs to the message.
+     * In the case of a cause for the punishment being present, it includes this in the message as well.
+     * This method also formats the start, predicted end, and the actual end dates according to a specific date format style.
+     * If the punishment doesn't have an end (is permanent), it reflects this in the result as well.
+     * Finally, this method appends the footer to the information block and returns the constructed Component.
+     *
+     * @param payload         the CommandPayload that contains the context for this command execution.
+     *                        It contains information about the command sender and any possible arguments used in the command.
+     * @param paperPunishment the instance of the PaperPunishment class which contains the information of the punishment.
+     *                        It includes details such as the ID, the operator who imposed the punishment, the start and end of the punishment, and the reason for the punishment if applicable.
+     * @return a Component that contains the punishment information block to be displayed to the command sender.
+     * @throws NullPointerException if either payload or paperPunishment is null.
+     */
+    public @NotNull Component punishmentInfo(@NotNull CommandPayload<CommandSender> payload, @NotNull Punishment paperPunishment)
+    {
+        Component header = Component.translatable("server.command.general.header", Component.text(paperPunishment.getName()));
+        Component footer = Component.translatable("server.command.general.footer", Component.text(paperPunishment.getName()));
+
+        Component id = Component.translatable("server.general.id");
+        Component by = Component.translatable("server.ban.punishment.operator");
+        Component start = Component.translatable("server.ban.punishment.start");
+        Component predictedEnd = Component.translatable("server.ban.punishment.predicted.end");
+        Component end = Component.translatable("server.ban.punishment.actual.end");
+
+        TranslatableComponent banInfo = Component.translatable("server.command.general.key.value");
+
+        TextComponent.Builder builder = Component.text().append(header);
+        builder.appendNewline().append(banInfo.arguments(id, constructCopyable(paperPunishment.getID())));
+        builder.appendNewline().append(banInfo.arguments(by, Component.text(paperPunishment.getBanOperator())));
+        paperPunishment.getCause().ifPresent(cause -> builder.appendNewline().append(
+                banInfo.arguments(Component.translatable("server.ban.punishment.cause"),
+                        cause)));
+
+        DateTimeFormatter formatter = payload.getSender().getFormatter(FormatStyle.SHORT);
+        builder.appendNewline().append(
+                banInfo.arguments(start, Component.text(formatter.format(paperPunishment.getStart()))));
+        builder.appendNewline().append(banInfo.arguments(predictedEnd, paperPunishment.endComponent(formatter)));
+        if (!paperPunishment.getEnd().equals(paperPunishment.getPredictedEnd()))
+        {
+            Component date = paperPunishment.endComponent(payload.getSender().getFormatter(FormatStyle.SHORT));
+            builder.appendNewline().append(banInfo.arguments(end, date));
+        }
+
+        builder.appendNewline().append(footer);
+        return builder.asComponent();
+    }
+
+    /**
+     * This method builds a compact history of punishments based on a provided list of PaperPunishment instances.
+     * This version of punishment history is intended to provide a brief snapshot of several punishments with their essential information in a compact format.
+     * <p>
+     * The method first sets up a DateTimeFormatter that formats dates in a localized short style,
+     * using the locale of the command sender and the system default timezone.
+     * It then creates an empty Component builder that will be used to build the result history block.
+     * It then traverses the list of punishments, and for each punishment:
+     * It figures out the status color based on whether the punishment is still valid.
+     * It builds an array of arguments containing essential information of the punishment formatted as Components.
+     * These arguments include: ID, name, operating user, ban type, total ID, start date, end date (or "permanent" if not applicable)
+     * and a validity status ('✔' if valid, '❌' if not).
+     * These arguments are then appended to the builder with a new line and a translatable history entry string.
+     * After traversing all punishments, this method calls asComponent() on the builder to build the compact punishment history,
+     * which is then returned as a Component.
+     *
+     * @param payload           the CommandPayload that contains the context for this command execution.
+     *                          It contains information about the command sender and any possible arguments used in the command.
+     * @param punishmentHistory a List of PaperPunishment instances that represent the punishment history for a user/server.
+     * @return a Component that represents a compact history of paper punishments in the form of key-value pairs.
+     * @throws NullPointerException if either payload or punishmentHistory is null.
+     */
+    private @NotNull Component compactHistory(@NotNull CommandPayload<CommandSender> payload, @NotNull List<Punishment> punishmentHistory)
+    {
+        DateTimeFormatter formatter = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT).withZone(
+                ZoneId.systemDefault()).withLocale(payload.getSender().getCurrentLocale());
+        TextComponent.Builder component = Component.text();
+        for (Punishment paperPunishment : punishmentHistory)
+        {
+            Component[] arguments = {
+                    Component.text(paperPunishment.getID()).hoverEvent(
+                            HoverEvent.showText(Component.translatable("server.general.show.more"))).clickEvent(
+                            ClickEvent.clickEvent(ClickEvent.Action.RUN_COMMAND,
+                                    "/baninfo " + paperPunishment.getID())),
+                    Component.text(paperPunishment.getName()),
+                    Component.text(paperPunishment.getBanOperator()),
+                    Component.text(paperPunishment.getBanType().toString()),
+                    Component.text(paperPunishment.getTotalID().toString()),
+                    Component.text(formatter.format(paperPunishment.getStart())),
+                    paperPunishment.endComponent(payload.getSender().getFormatter(FormatStyle.SHORT)),
+                    Component.text(paperPunishment.isValid() ? "✔" : "❌")
+            };
+            component.appendNewline().append(Component.translatable("server.ban.punishment.compact", arguments));
+        }
+
+        return component.asComponent();
+    }
+
+    /**
+     * Obtain the punished message for a given display name, ban type, and reason component.
+     *
+     * @param displayName     The display name of the punished player.
+     * @param banType         The type of punishment (BAN, MUTE, KICK).
+     * @param reasonComponent The reason for the punishment (optional).
+     * @return The punished message as a Component object.
+     * @throws NullPointerException if display name or ban type is null.
+     */
+    public @NotNull Component punishComponent(@NotNull Component displayName, @NotNull BanType banType, @Nullable Component reasonComponent)
+    {
+        StringBuilder translationKey = new StringBuilder("server.ban.player.");
+        switch (banType)
+        {
+            case BAN -> translationKey.append("banned");
+            case MUTE -> translationKey.append("muted");
+            case KICK -> translationKey.append("kicked");
+        }
+
+        if (reasonComponent != null)
+        {
+            return Component.translatable(translationKey.append(".cause").toString(), displayName, reasonComponent);
+        }
+        return Component.translatable(translationKey.toString(), displayName);
+    }
+
+    /**
+     * This method is responsible for constructing a clickable text component that,
+     * when clicked, copies the provided text to the clipboard.
+     * On hovering over this component, a tooltip saying "copy to clipboard" is shown.
+     * <p>
+     * The method first calls Component.text() to convert the raw string into a Component.
+     * It then sets up a clickEvent for this Component using ClickEvent.copyToClipboard().
+     * This click event will copy the provided raw string to the user's clipboard when the Component is clicked.
+     * Further, it sets up a hover event for this Component using HoverEvent.showText() to show a tooltip when the user hovers over this Component.
+     * The text of the tooltip is set to "copy to clipboard".
+     * This method could be used to construct clickable and copyable command outputs, URLs, token strings, etc
+     * for an interactive and user-friendly experience.
+     *
+     * @param text the raw string that will be converted into a Component,
+     *             and also the string that will be copied to the clipboard when the user clicks the resulting Component.
+     * @return a Component that, when clicked, copies the provided string to the clipboard and shows a tooltip on hover.
+     * @throws NullPointerException if text is null.
+     */
+    private @NotNull Component constructCopyable(@NotNull String text)
+    {
+        return Component.text(text).clickEvent(ClickEvent.copyToClipboard(text)).hoverEvent(
+                HoverEvent.showText(Component.text("copy to clipboard")));
+    }
+
+}
diff --git a/src/main/java/net/kissenpvp/paper/ban/warn/KissenWarn.java b/src/main/java/net/kissenpvp/paper/ban/warn/KissenWarn.java
new file mode 100644
index 0000000000000000000000000000000000000000..ad03c6037b1fb062b9aacafba91a03726eea6bb0
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/ban/warn/KissenWarn.java
@@ -0,0 +1,15 @@
+package net.kissenpvp.paper.ban.warn;
+
+import net.kissenpvp.core.ban.warn.KissenAbstractWarn;
+import net.kissenpvp.core.ban.warn.WarnNode;
+import net.kissenpvp.paper.api.ban.Ban;
+import net.kissenpvp.paper.api.ban.warn.Warn;
+import org.jetbrains.annotations.NotNull;
+
+public class KissenWarn extends KissenAbstractWarn<Ban> implements Warn
+{
+    public KissenWarn(@NotNull WarnNode warnNode)
+    {
+        super(warnNode);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/ban/warn/command/WarnCommand.java b/src/main/java/net/kissenpvp/paper/ban/warn/command/WarnCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..68af27b44a8919bf06de084b714f6ef05176be47
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/ban/warn/command/WarnCommand.java
@@ -0,0 +1,151 @@
+package net.kissenpvp.paper.ban.warn.command;
+
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.core.api.command.annotations.ArgumentName;
+import net.kissenpvp.core.api.command.annotations.CommandData;
+import net.kissenpvp.core.api.command.annotations.Optional;
+import net.kissenpvp.core.api.time.TemporalObject;
+import net.kissenpvp.core.api.util.PageBuilder;
+import net.kissenpvp.core.api.util.PageImplementation;
+import net.kissenpvp.paper.api.ban.Ban;
+import net.kissenpvp.paper.api.ban.warn.Warn;
+import net.kissenpvp.paper.ban.command.BanCommand;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.TextComponent;
+import net.kyori.adventure.text.event.ClickEvent;
+import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;
+import org.bukkit.Bukkit;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.time.format.FormatStyle;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+public class WarnCommand
+{
+
+    /**
+     * Executes the "warn" command to warn a specific user to refrain from inappropriate behavior.
+     *
+     * @param payload     The command payload containing the command sender.
+     * @param player      The player to be warned.
+     * @param paperBan    The PaperBan instance for warning the player.
+     * @param reasonArray (Optional) The reason for the warning.
+     */
+    @CommandData(value = "warn", description = "This command is used to warn a specific user to refrain from inappropriate behavior.")
+    public void warn(@NotNull CommandPayload<CommandSender> payload, @NotNull OfflinePlayer player, @NotNull Ban paperBan, @NotNull @Optional @ArgumentName("reason") String[] reasonArray)
+    {
+        java.util.Optional<Component> transformedReason = getReason(reasonArray);
+        List<Warn> currentWarns = player.getWarnHistory().stream().filter(TemporalObject::isValid).toList();
+
+        Runnable runnable = () ->
+        {
+            player.warn(paperBan, payload.getSender(), transformedReason.orElse(null));
+            payload.getSender().sendMessage(warnMessage(player.displayName(), Component.text(currentWarns.size() + 1),
+                    transformedReason.orElse(null)));
+        };
+
+        if (currentWarns.size() > 1)
+        {
+            Component[] args = {
+                    player.displayName(),
+                    Component.text(currentWarns.size()),
+                    getClickable("gui.yes", "/confirm"),
+                    getClickable("gui.no", "/cancel")
+            };
+            payload.getSender().sendMessage(Component.translatable("server.ban.warn.ban", args));
+
+            Runnable ban = () -> new BanCommand().ban(payload, player, paperBan, reasonArray);
+            payload.confirmRequest(ban).onCancel(runnable).onTime(runnable).suppressMessage(true).send();
+            return;
+        }
+        runnable.run();
+    }
+
+    @CommandData("warnhistory")
+    public void warnHistory(@NotNull CommandPayload<CommandSender> payload, @NotNull OfflinePlayer player, @NotNull java.util.Optional<Integer> page)
+    {
+        List<Warn> paperWarns = new ArrayList<>(player.getWarnHistory());
+        if (paperWarns.isEmpty())
+        {
+            payload.getSender().sendMessage(Component.text("no warns")); //TODO
+            return;
+        }
+        Collections.reverse(paperWarns);
+        PageBuilder<Warn> warnPages = Bukkit.getKissen().getImplementation(
+                PageImplementation.class).createPageBuilder(paperWarns);
+
+
+        TextComponent.Builder builder = Component.text().append(
+                warnPages.getHeader(player.displayName(), page.orElse(1)));
+
+
+        for (Warn warn : warnPages.getEntries(page.orElse(1)))
+        {
+            Component unknown = Component.text("commands.banlist.entry.unknown");
+            Component banid = warn.getBan().map(ban -> (Component) Component.text(ban.getName())).orElse(unknown);
+            String time = payload.getSender().getFormatter(FormatStyle.MEDIUM).format(warn.getStart());
+
+            Component[] arguments = {Component.text(warn.isValid() ? "✔":"❌"), banid, Component.text(time)};
+
+            builder.appendNewline().append(Component.translatable("server.ban.compact", arguments));
+        }
+        builder.appendNewline().append(warnPages.getFooter(player.displayName(), page.orElse(1)));
+        payload.getSender().sendMessage(builder.asComponent());
+    }
+
+    @CommandData(value = "warnreset", aliases = "resetwarn")
+    public void warnClear(@NotNull CommandPayload<CommandSender> payload, @NotNull OfflinePlayer player)
+    {
+        payload.confirmRequest(() ->
+        {
+            player.clearActiveWarns();
+            payload.getSender().sendMessage(Component.translatable("server.ban.warn.clear", player.displayName()));
+        }).send();
+    }
+
+    /**
+     * Obtains the warned message with the given components.
+     *
+     * @param displayName     The display name component.
+     * @param warningCount    The warning count component.
+     * @param reasonComponent The optional reason component.
+     * @return The warned message component.
+     */
+    private @NotNull Component warnMessage(@NotNull Component displayName, @NotNull Component warningCount, @Nullable Component reasonComponent)
+    {
+        if (reasonComponent == null)
+        {
+            return Component.translatable("server.ban.player.warned", displayName, warningCount);
+        }
+        return Component.translatable("server.ban.player.warned.cause", displayName, warningCount, reasonComponent);
+    }
+
+    /**
+     * Retrieves the reason as a {@link Component} object.
+     *
+     * @param reason the array of strings representing the reason
+     * @return the reason as a Component object, or null if the reason is empty
+     */
+    private @NotNull java.util.Optional<Component> getReason(@NotNull String @NotNull [] reason)
+    {
+        if (reason.length != 0)
+        {
+            return java.util.Optional.of(
+                    LegacyComponentSerializer.legacyAmpersand().deserialize(String.join(" ", reason).strip()));
+        }
+        return java.util.Optional.empty();
+    }
+
+    @Contract(pure = true, value = "_, _ -> new")
+    private @NotNull Component getClickable(@NotNull String translationKey, @NotNull String command)
+    {
+        Component confirm = Component.translatable(translationKey).clickEvent(ClickEvent.runCommand(command));
+        return Component.text("[").append(confirm).append(Component.text("]"));
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/base/KissenPaperCore.java b/src/main/java/net/kissenpvp/paper/base/KissenPaperCore.java
index 4e9dd6cb54aa7f3e6f7ea0dd74beedd75232d47b..2267da3befed100a6b4c338515d83b9dff682191 100644
--- a/src/main/java/net/kissenpvp/paper/base/KissenPaperCore.java
+++ b/src/main/java/net/kissenpvp/paper/base/KissenPaperCore.java
@@ -18,17 +18,14 @@
 
 package net.kissenpvp.paper.base;
 
-import net.kissenpvp.core.api.ban.AbstractBanImplementation;
 import net.kissenpvp.core.api.base.Implementation;
 import net.kissenpvp.core.api.base.plugin.KissenPlugin;
 import net.kissenpvp.core.api.config.ConfigurationImplementation;
 import net.kissenpvp.core.api.database.connection.DatabaseImplementation;
-import net.kissenpvp.core.api.message.localization.LocalizationImplementation;
 import net.kissenpvp.core.api.networking.client.entitiy.ConsoleClient;
 import net.kissenpvp.core.api.user.UserImplementation;
 import net.kissenpvp.core.api.user.rank.AbstractRankImplementation;
 import net.kissenpvp.core.base.KissenCore;
-import net.kissenpvp.core.command.confirmation.KissenConfirmationImplementation;
 import net.kissenpvp.core.event.EventImplementation;
 import net.kissenpvp.core.permission.InternalPermissionImplementation;
 import net.kissenpvp.paper.api.base.PaperKissen;
@@ -86,6 +83,7 @@ public class KissenPaperCore extends KissenCore implements PaperKissen {
         loader.put(net.kissenpvp.paper.api.command.CommandImplementation.class, command);
         loader.put(net.kissenpvp.core.command.InternalCommandImplementation.class, command);
         loader.put(net.kissenpvp.core.command.confirmation.KissenConfirmationImplementation.class, new net.kissenpvp.paper.command.confirmation.KissenPaperConfirmationImplementation());
+        loader.put(net.kissenpvp.paper.api.ban.BanImplementation.class, new net.kissenpvp.paper.ban.KissenPaperBanImplementation());
         super.loadImplementations(loader);
     }
 
diff --git a/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperPlayerClient.java b/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperPlayerClient.java
index 73b6c2ce091dc9e1a26ce4df5804938be78d0be5..aa751cf45091f3c4ead54ade1cf414b33451929e 100644
--- a/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperPlayerClient.java
+++ b/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperPlayerClient.java
@@ -39,6 +39,7 @@ import net.kissenpvp.paper.api.permission.Permission;
 import net.kissenpvp.paper.api.user.playersetting.BoundPlayerSetting;
 import net.kissenpvp.paper.api.user.playersetting.PlayerSetting;
 import net.kissenpvp.paper.api.user.rank.PlayerRank;
+import net.kissenpvp.paper.ban.warn.KissenWarn;
 import net.kissenpvp.paper.permission.permissible.KissenPaperPermissible;
 import net.kissenpvp.paper.user.KissenPaperPublicUser;
 import net.kissenpvp.paper.user.rank.KissenPaperKissenPlayerRank;
@@ -145,6 +146,6 @@ public abstract class KissenPaperPlayerClient extends KissenPlayerClient<Permiss
 
     @Contract(pure = true, value = "-> new")
     protected @NotNull Function<WarnNode, Warn> transformWarn() {
-        return (w) -> null; //TODO
+        return KissenWarn::new;
     }
 }
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 21519967a792b76c61af753a430ad5fa638ec919..96af226e2c613498203304166534ccd8b61b342a 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -164,7 +164,7 @@ public abstract class PlayerList {
         server.console = new com.destroystokyo.paper.console.TerminalConsoleCommandSender(); // Paper
         // CraftBukkit end
 
-        this.bans = new UserBanList(PlayerList.USERBANLIST_FILE);
+        this.bans = /*new UserBanList(PlayerList.USERBANLIST_FILE);*/ new net.kissenpvp.paper.ban.KissenPaperPunishmentList(); // KissenPaper - rework ban system
         this.ipBans = new IpBanList(PlayerList.IPBANLIST_FILE);
         this.ops = /*new ServerOpList(PlayerList.OPLIST_FILE);*/ new net.kissenpvp.paper.user.KissenUserOperatorList(); // KissenPaper
         this.whitelist = /*new UserWhiteList(PlayerList.WHITELIST_FILE);*/ new net.kissenpvp.paper.user.KissenUserWhiteList(); // KissenPaper
@@ -738,6 +738,8 @@ public abstract class PlayerList {
         Player player = entity.getBukkitEntity();
         PlayerLoginEvent event = new PlayerLoginEvent(player, loginlistener.connection.hostname, ((java.net.InetSocketAddress) socketaddress).getAddress(), ((java.net.InetSocketAddress) loginlistener.connection.channel.remoteAddress()).getAddress());
 
+        // KissenPaper start - Integrate ban system from kissen into paper
+        /*
         // Paper start - Fix MC-158900
         UserBanListEntry gameprofilebanentry;
         if (this.bans.isBanned(gameprofile) && (gameprofilebanentry = this.bans.get(gameprofile)) != null) {
@@ -769,6 +771,8 @@ public abstract class PlayerList {
                 event.disallow(PlayerLoginEvent.Result.KICK_FULL, net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(org.spigotmc.SpigotConfig.serverFullMessage)); // Spigot // Paper - Adventure
             }
         }
+        */
+        // KissenPaper end - Integrate ban system from kissen into paper
 
         this.cserver.getPluginManager().callEvent(event);
         if (event.getResult() != PlayerLoginEvent.Result.ALLOWED) {
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 07af353c39e93a01575096176af8b17af7406961..6648b9447c9d226a699407f8037e3c4acf2a6342 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -2237,6 +2237,11 @@ public final class CraftServer implements Server {
 
     @Override
     public <T extends BanList<?>> T getBanList(BanList.Type type) {
+        if(true)
+        {
+            // KissenPaper start - rework ban system
+            return (T) Bukkit.getKissen().getImplementation(net.kissenpvp.paper.api.ban.BanImplementation.class).getPunishmentSet();
+        }
         Preconditions.checkArgument(type != null, "BanList.Type cannot be null");
 
         return switch (type) {
@@ -2249,6 +2254,11 @@ public final class CraftServer implements Server {
     @SuppressWarnings("unchecked")
     @Override
     public <B extends BanList<E>, E> B getBanList(final io.papermc.paper.ban.BanListType<B> type) {
+        if(true)
+        {
+            // KissenPaper start - rework ban system
+            return (B) Bukkit.getKissen().getImplementation(net.kissenpvp.paper.api.ban.BanImplementation.class);
+        }
         Preconditions.checkArgument(type != null, "BanList.BanType cannot be null");
        if (type == io.papermc.paper.ban.BanListType.IP) {
            return (B) new CraftIpBanList(this.playerList.getIpBans());
