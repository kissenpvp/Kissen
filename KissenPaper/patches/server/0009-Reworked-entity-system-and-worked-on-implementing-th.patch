From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Groldi <chniucg@gmail.com>
Date: Sun, 13 Aug 2023 02:52:51 +0200
Subject: [PATCH] Reworked entity system and worked on implementing the ban
 system.


diff --git a/src/main/java/io/papermc/paper/commands/FeedbackForwardingSender.java b/src/main/java/io/papermc/paper/commands/FeedbackForwardingSender.java
index 4b6128174e53a2026e431352b802a7a2fe3ef029..183dd024b76b89a860382f6755c2964f1ceeb7fc 100644
--- a/src/main/java/io/papermc/paper/commands/FeedbackForwardingSender.java
+++ b/src/main/java/io/papermc/paper/commands/FeedbackForwardingSender.java
@@ -49,7 +49,7 @@ public final class FeedbackForwardingSender extends ServerCommandSender {
     }
 
     @Override
-    public String getName() {
+    public @NotNull String getName() {
         return "FeedbackForwardingSender";
     }
 
diff --git a/src/main/java/net/kissenpvp/paper/KissenPaperBan.java b/src/main/java/net/kissenpvp/paper/KissenPaperBan.java
new file mode 100644
index 0000000000000000000000000000000000000000..d95f9404e4bff52abb2440d9ea496bcb20063320
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/KissenPaperBan.java
@@ -0,0 +1,13 @@
+package net.kissenpvp.paper;
+
+import net.kissenpvp.core.api.networking.socket.DataPackage;
+import net.kissenpvp.core.ban.KissenBan;
+import net.kissenpvp.paper.api.ban.PaperBan;
+import org.jetbrains.annotations.NotNull;
+
+public class KissenPaperBan extends KissenBan implements PaperBan {
+    @Override
+    public void sendData(@NotNull DataPackage dataPackage) {
+        //TODO
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/ban/KissenPaperBan.java b/src/main/java/net/kissenpvp/paper/ban/KissenPaperBan.java
new file mode 100644
index 0000000000000000000000000000000000000000..e284c572caa8de7a041efb1817d3c30f55a25fb8
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/ban/KissenPaperBan.java
@@ -0,0 +1,13 @@
+package net.kissenpvp.paper.ban;
+
+import net.kissenpvp.core.api.networking.socket.DataPackage;
+import net.kissenpvp.core.ban.KissenBan;
+import net.kissenpvp.paper.api.ban.PaperBan;
+import org.jetbrains.annotations.NotNull;
+
+public class KissenPaperBan extends KissenBan implements PaperBan {
+    @Override
+    public void sendData(@NotNull DataPackage dataPackage) {
+        //TODO
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/ban/KissenPaperBanImplementation.java b/src/main/java/net/kissenpvp/paper/ban/KissenPaperBanImplementation.java
new file mode 100644
index 0000000000000000000000000000000000000000..88a08eac7ce71eb9a15248dbd73ff51da1917a89
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/ban/KissenPaperBanImplementation.java
@@ -0,0 +1,120 @@
+package net.kissenpvp.paper.ban;
+
+import net.kissenpvp.core.api.ban.BanOperator;
+import net.kissenpvp.core.api.ban.BanType;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.database.meta.Meta;
+import net.kissenpvp.core.api.database.meta.ObjectMeta;
+import net.kissenpvp.core.api.database.savable.SavableMap;
+import net.kissenpvp.core.ban.KissenBanImplementation;
+import net.kissenpvp.core.ban.KissenPunishmentNode;
+import net.kissenpvp.paper.KissenPaperBan;
+import net.kissenpvp.paper.api.ban.PaperBan;
+import net.kissenpvp.paper.api.ban.PaperBanImplementation;
+import net.kissenpvp.paper.api.ban.PaperPunishment;
+import net.kissenpvp.paper.api.base.Context;
+import net.kyori.adventure.text.Component;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.*;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public class KissenPaperBanImplementation extends KissenBanImplementation<PaperBan, PaperPunishment> implements PaperBanImplementation {
+
+    @Override
+    protected @NotNull @Unmodifiable Set<PaperBan> fetchCache() throws BackendException {
+        return Stream.concat(
+                        // get global
+                        getMeta().getData(new KissenPaperBan()).values().stream().map(banProcessor()),
+                        // get local
+                        getMeta(Context.LOCAL).getData(new KissenPaperBan()).values().stream().map(banProcessor()))
+                .filter(Objects::nonNull)
+                .collect(Collectors.toSet());
+    }
+
+    @Override
+    protected @NotNull @Unmodifiable ObjectMeta getMeta() {
+        return Bukkit.getKissen().getPublicMeta();
+    }
+
+    @Override
+    protected @NotNull PaperBan constructBan(int id, @NotNull Map<String, String> data) throws BackendException {
+        KissenPaperBan kissenPaperBan = new KissenPaperBan();
+        kissenPaperBan.setup(String.valueOf(id), data);
+        return kissenPaperBan;
+    }
+
+    @Override
+    protected @NotNull PaperPunishment translatePunishment(@NotNull UUID totalID, @NotNull KissenPunishmentNode kissenPunishmentNode, @NotNull Meta meta) {
+        return new KissenPaperPunishment(totalID, kissenPunishmentNode, record -> {
+            try {
+                set(totalID, (KissenPunishmentNode) record, meta);
+            } catch (BackendException backendException) {
+                Bukkit.getKissen()
+                        .getLogger()
+                        .error("The punishment '{}' from total id '{}' could not be updated due to a backend exception. It is advised to shut down the server to prevent further damage to the servers data.", ((KissenPunishmentNode) record).id(), totalID, backendException);
+            }
+        });
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPunishment> getPlayerBanSet(@NotNull Context context) throws BackendException {
+        return getPlayerBanSet(getMeta(context));
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPunishment> getPlayerBanSet(@NotNull UUID totalID, @NotNull Context context) throws BackendException {
+        return getPlayerBanSet(totalID, getMeta(context));
+    }
+
+    @Override
+    public @NotNull Optional<@Nullable PaperPunishment> getCurrentBan(@NotNull UUID totalID, Context context) throws BackendException {
+        return getCurrentBan(totalID, getMeta(context));
+    }
+
+    @Override
+    public @NotNull Optional<@Nullable PaperPunishment> getCurrentBan(@NotNull UUID totalID, @NotNull BanType banType, Context context) throws BackendException {
+        return getCurrentBan(totalID, banType, getMeta(context));
+    }
+
+    @Override
+    public @NotNull PaperPunishment ban(@NotNull UUID totalID, @NotNull PaperBan ban, @NotNull BanOperator banOperator, @Nullable Component reason, @NotNull Context context) throws BackendException {
+        return ban(totalID, ban, banOperator, reason, getMeta(context));
+    }
+
+    /**
+     * Retrieves the meta information based on the provided context.
+     *
+     * @param context The context to determine which meta information to retrieve.
+     * @return The meta information based on the provided context.
+     */
+    protected @NotNull @Unmodifiable ObjectMeta getMeta(@NotNull Context context) {
+        return switch (context) {
+            case GLOBAL -> getMeta();
+            case LOCAL -> Bukkit.getKissen().getPrivateMeta();
+        };
+    }
+
+    /**
+     * Retrieves the ban processor function, which processes a SavableMap and returns a PaperBan.
+     *
+     * @return The ban processor function.
+     */
+    @Contract(pure = true)
+    private @NotNull Function<SavableMap, PaperBan> banProcessor() {
+        return savableMap -> {
+            try {
+                return createBan(Integer.parseInt(savableMap.getNotNull("id")), savableMap);
+            } catch (BackendException | NumberFormatException exception) {
+                Bukkit.getKissen().getLogger().error("Error parsing ban entry with id {}.", savableMap.getNotNull("id"), exception);
+            }
+            return null;
+        };
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/ban/KissenPaperPunishment.java b/src/main/java/net/kissenpvp/paper/ban/KissenPaperPunishment.java
new file mode 100644
index 0000000000000000000000000000000000000000..90a88b13952f9b35eae3062d26b0b15905a305ae
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/ban/KissenPaperPunishment.java
@@ -0,0 +1,26 @@
+package net.kissenpvp.paper.ban;
+
+import net.kissenpvp.core.ban.KissenPunishmentNode;
+import net.kissenpvp.core.ban.KissenPunishment;
+import net.kissenpvp.core.database.DataWriter;
+import net.kissenpvp.paper.api.ban.PaperPunishment;
+import org.bukkit.Bukkit;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Set;
+import java.util.UUID;
+import java.util.stream.Collectors;
+
+public class KissenPaperPunishment extends KissenPunishment<Player> implements PaperPunishment {
+    public KissenPaperPunishment(@NotNull UUID totalID, @NotNull KissenPunishmentNode kissenPunishmentNode, @Nullable DataWriter dataWriter) {
+        super(totalID, kissenPunishmentNode, dataWriter);
+    }
+
+    @Override
+    public @Unmodifiable Set<Player> getOnlineAffectedPlayers() {
+        return Bukkit.getOnlinePlayers().stream().filter(player -> player.getTotalID().equals(getTotalID())).collect(Collectors.toSet());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/base/KissenPaperCore.java b/src/main/java/net/kissenpvp/paper/base/KissenPaperCore.java
index 185601aca6de6346061d1c2f97f7a2742c96f486..6c1faf68b7758ae7c350515699edc552d55548a5 100644
--- a/src/main/java/net/kissenpvp/paper/base/KissenPaperCore.java
+++ b/src/main/java/net/kissenpvp/paper/base/KissenPaperCore.java
@@ -13,6 +13,11 @@ import java.util.UUID;
 // KissenPaper
 public class KissenPaperCore extends KissenCore implements PaperKissen {
 
+    /**
+     * Constructs a new instance of the KissenPaperCore class.
+     *
+     * @param logger The logger to be used for logging.
+     */
     public KissenPaperCore(@NotNull Logger logger) {
         super(logger);
     }
diff --git a/src/main/java/net/kissenpvp/paper/command/KissenPaperCommandImplementation.java b/src/main/java/net/kissenpvp/paper/command/KissenPaperCommandImplementation.java
index 31340c6b82396ca668acb74a8fbb464552cd30c7..bc44ae33411463743eeb9b6a148a3d2d1cca68c0 100644
--- a/src/main/java/net/kissenpvp/paper/command/KissenPaperCommandImplementation.java
+++ b/src/main/java/net/kissenpvp/paper/command/KissenPaperCommandImplementation.java
@@ -1,31 +1,39 @@
 package net.kissenpvp.paper.command;
 
+import net.kissenpvp.core.api.command.CommandPayload;
 import net.kissenpvp.core.api.command.annotations.CommandData;
 import net.kissenpvp.core.api.command.annotations.TabCompleter;
 import net.kissenpvp.core.api.command.executor.TabCompleterExecutor;
+import net.kissenpvp.core.api.message.localization.LocalizationImplementation;
 import net.kissenpvp.core.base.KissenImplementation;
-import net.kissenpvp.core.command.CommandInfo;
 import net.kissenpvp.core.command.KissenCommandImplementation;
 import net.kissenpvp.core.command.argument.MethodEvaluator;
+import net.kissenpvp.core.message.localization.KissenLocalizationImplementation;
 import net.kissenpvp.paper.api.command.KissenCommand;
+import net.kissenpvp.paper.api.command.PaperArgumentParser;
 import net.kissenpvp.paper.api.command.PaperCommandImplementation;
 import net.kissenpvp.paper.command.command.KissenPaperAbstractCommand;
 import net.kissenpvp.paper.command.command.plugin.KissenPaperPluginCommand;
 import net.kissenpvp.paper.command.command.system.KissenPaperCommand;
 import net.kissenpvp.paper.command.executor.KissenPaperCommandExecutor;
 import net.kissenpvp.paper.command.executor.KissenPaperCompleteExecutor;
+import net.kissenpvp.paper.command.parser.*;
 import net.kissenpvp.paper.command.target.KissenPaperTargetValidator;
+import net.kyori.adventure.text.format.NamedTextColor;
 import org.bukkit.Bukkit;
 import org.bukkit.command.Command;
 import org.bukkit.command.CommandMap;
 import org.bukkit.command.CommandSender;
 import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.entity.Player;
 import org.bukkit.plugin.Plugin;
 import org.jetbrains.annotations.NotNull;
 
 import java.lang.reflect.Method;
+import java.text.MessageFormat;
+import java.util.Collection;
+import java.util.List;
 import java.util.Optional;
-import java.util.function.Consumer;
 
 /**
  * Represents a Kissen Paper command implementation that extends the functionality of the Kissen command framework
@@ -37,7 +45,7 @@ import java.util.function.Consumer;
  */
 public class KissenPaperCommandImplementation extends KissenCommandImplementation implements PaperCommandImplementation, KissenImplementation {
 
-    private final MethodEvaluator methodEvaluator;
+    private final MethodEvaluator<CommandSender> methodEvaluator;
     private final KissenPaperTargetValidator kissenPaperTargetValidator;
 
     /**
@@ -49,8 +57,44 @@ public class KissenPaperCommandImplementation extends KissenCommandImplementatio
     public KissenPaperCommandImplementation() {
         super();
 
-        this.methodEvaluator = new MethodEvaluator();
+        this.methodEvaluator = new MethodEvaluator<>();
         this.kissenPaperTargetValidator = new KissenPaperTargetValidator();
+
+        registerParser(String.class, new StringParser());
+        registerParser(Byte.class, new ByteParser());
+        registerParser(Short.class, new ShortParser());
+        registerParser(Integer.class, new IntegerParser());
+        registerParser(Float.class, new FloatParser());
+        registerParser(Double.class, new DoubleParser());
+        registerParser(Long.class, new LongParser());
+        registerParser(Character.class, new CharacterParser());
+        registerParser(Boolean.class, new BooleanParser());
+
+        // we love java, right?
+        registerParser(Byte.TYPE, new ByteParser());
+        registerParser(Short.TYPE, new ShortParser());
+        registerParser(Integer.TYPE, new IntegerParser());
+        registerParser(Float.TYPE, new FloatParser());
+        registerParser(Double.TYPE, new DoubleParser());
+        registerParser(Long.TYPE, new LongParser());
+        registerParser(Character.TYPE, new CharacterParser());
+        registerParser(Boolean.TYPE, new BooleanParser());
+
+        // Advanced
+        registerParser(Player.class, new PlayerParser());
+        registerParser(NamedTextColor.class, new NamedTextColorParser());
+
+    }
+
+    @Override
+    public boolean start() {
+
+        KissenLocalizationImplementation localizationImplementation = Bukkit.getKissen().getImplementation(KissenLocalizationImplementation.class);
+        localizationImplementation.register("messages.command.error.incorrect-usage", new MessageFormat("It appears that the command usage is not correct. Please refer to the commands help."));
+        localizationImplementation.register("messages.command.error.player-offline", new MessageFormat("The player {0} seems to be offline."));
+        localizationImplementation.register("messages.command.error.unknown-command", new MessageFormat("Unknown command. Type \"/help\" for help."));
+
+        return super.start();
     }
 
     @Override
@@ -81,11 +125,12 @@ public class KissenPaperCommandImplementation extends KissenCommandImplementatio
 
     @Override
     public void registerCompleter(@NotNull Plugin plugin, @NotNull String name, @NotNull TabCompleterExecutor<CommandSender> tabCompleterExecutor) {
-        //TODO
+        getCommand(name).filter(kissenCommand -> kissenCommand instanceof KissenPaperPluginCommand kissenPaperPluginCommand && kissenPaperPluginCommand.getPlugin()
+                .equals(plugin)).orElse(buildCommand(plugin, name)).initCompleter(tabCompleterExecutor);
     }
 
     public void registerCompleter(@NotNull String name, @NotNull TabCompleterExecutor<CommandSender> tabCompleterExecutor) {
-        //TODO
+        getCommand(name).filter(kissenCommand -> kissenCommand instanceof KissenPaperCommand).orElse(buildCommand(name)).initCompleter(tabCompleterExecutor);
     }
 
     @Override
@@ -95,6 +140,11 @@ public class KissenPaperCommandImplementation extends KissenCommandImplementatio
                 .remove(name) != null;
     }
 
+    @Override
+    public <T> void registerParser(@NotNull Class<T> type, @NotNull PaperArgumentParser<T> argumentParser) {
+        super.registerParser(type, argumentParser);
+    }
+
     /**
      * Returns the {@link MethodEvaluator} associated with this Kissen Paper command executor.
      * <p>
@@ -103,7 +153,7 @@ public class KissenPaperCommandImplementation extends KissenCommandImplementatio
      *
      * @return The {@link MethodEvaluator} associated with this Kissen Paper command executor.
      */
-    public MethodEvaluator getMethodEvaluator() {
+    public MethodEvaluator<CommandSender> getMethodEvaluator() {
         return methodEvaluator;
     }
 
@@ -119,22 +169,11 @@ public class KissenPaperCommandImplementation extends KissenCommandImplementatio
         return kissenPaperTargetValidator;
     }
 
-    /**
-     * Injects a method from an object as a command or tab completer into the Kissen Paper command framework.
-     * <p>
-     * This method is used to register a method from an object as a command or tab completer within the Kissen Paper command framework.
-     * The method's annotations are inspected to determine whether it should be registered as a command or tab completer.
-     *
-     * @param plugin The {@link Plugin} that owns the command or tab completer. Must not be null.
-     * @param object The object containing the method to be registered. Must not be null.
-     * @param method The method to be registered as a command or tab completer. Must not be null.
-     * @throws NullPointerException If any of the {@code plugin}, {@code object}, or {@code method} parameters is null.
-     */
     private void injectObjectMethod(@NotNull Plugin plugin, @NotNull Object object, @NotNull Method method) {
         final CommandData command = method.getAnnotation(CommandData.class);
         if (command != null) {
-            KissenPaperPluginCommand kissenPaperPluginCommand = internalCommandRegister(plugin, command, (var) -> {});
-            kissenPaperPluginCommand.initCommand(new CommandInfo(command), new KissenPaperCommandExecutor(method, object));
+            KissenPaperPluginCommand kissenPaperPluginCommand = buildCommand(plugin, command.name());
+            kissenPaperPluginCommand.initCommand(command, new KissenPaperCommandExecutor(method, object));
         }
 
         TabCompleter completer = method.getAnnotation(TabCompleter.class);
@@ -146,8 +185,8 @@ public class KissenPaperCommandImplementation extends KissenCommandImplementatio
     private void injectObjectMethod(@NotNull Object object, @NotNull Method method) {
         final CommandData command = method.getAnnotation(CommandData.class);
         if (command != null) {
-            KissenPaperCommand kissenPaperCommand = internalCommandRegister(command, (var) -> {});
-            kissenPaperCommand.initCommand(new CommandInfo(command), new KissenPaperCommandExecutor(method, object));
+            KissenPaperCommand kissenPaperCommand = buildCommand(command.name());
+            kissenPaperCommand.initCommand(command, new KissenPaperCommandExecutor(method, object));
         }
 
         TabCompleter completer = method.getAnnotation(TabCompleter.class);
@@ -156,60 +195,49 @@ public class KissenPaperCommandImplementation extends KissenCommandImplementatio
         }
     }
 
-    /**
-     * Registers a new {@link KissenCommand} with the provided plugin and commandData using a command consumer.
-     * <p>
-     * This method is used to create and register a new {@link KissenCommand} instance under the given commandData within the Kissen Paper command framework.
-     * A command consumer is used to configure and customize the newly created command before registration.
-     *
-     * @param plugin          The {@link Plugin} that owns the command. Must not be null.
-     * @param commandData     The commandData of the command. Must not be null.
-     * @param commandConsumer A {@link Consumer} that configures the properties of the command. Must not be null.
-     * @return The registered {@link KissenCommand} instance.
-     * @throws NullPointerException If any of the {@code plugin}, {@code commandData}, or {@code commandConsumer} parameters is null.
-     */
-    private @NotNull KissenPaperPluginCommand internalCommandRegister(@NotNull Plugin plugin, @NotNull CommandData commandData, @NotNull Consumer<KissenPaperPluginCommand> commandConsumer) {
-        return (KissenPaperPluginCommand) registerCommandObject(commandData, new RootCommandFactory() {
+    private @NotNull KissenPaperPluginCommand buildCommand(@NotNull Plugin plugin, @NotNull String name) {
+        return (KissenPaperPluginCommand) buildCommand(name, new RootCommandFactory() {
             @Override
             public @NotNull KissenPaperAbstractCommand<?> constructCommand(@NotNull String name) {
-                return new KissenPaperPluginCommand(plugin, commandData.name().split("\\.")[0], 0);
+                return new KissenPaperPluginCommand(plugin, name.split("\\.")[0], 0);
             }
         }, plugin.getName());
     }
 
-    private @NotNull KissenPaperCommand internalCommandRegister(@NotNull CommandData commandData, @NotNull Consumer<KissenPaperCommand> commandConsumer) {
-        return (KissenPaperCommand) registerCommandObject(commandData, new RootCommandFactory() {
+    private @NotNull KissenPaperCommand buildCommand(@NotNull String name) {
+        return (KissenPaperCommand) buildCommand(name, new RootCommandFactory() {
             @Override
             public @NotNull KissenPaperAbstractCommand<?> constructCommand(@NotNull String name) {
-                return new KissenPaperCommand(commandData.name().split("\\.")[0], 0);
+                return new KissenPaperCommand(name.split("\\.")[0], 0);
             }
         }, "kissenpaper");
     }
 
-    private @NotNull KissenCommand registerCommandObject(@NotNull CommandData commandData, @NotNull KissenPaperCommandImplementation.RootCommandFactory rootCommandFactory, @NotNull String fallback) {
-        String rootName = commandData.name().split("\\.")[0];
-        KissenPaperAbstractCommand<?> command = (KissenPaperAbstractCommand<?>) getCommand(rootName).orElseGet(() ->
-        {
-            CommandMap commandMap = getCommandMap();
-            KissenCommand kissenCommand = rootCommandFactory.constructCommand(rootName);
-            kissenCommand.register(commandMap);
-            commandMap.register(fallback, kissenCommand);
-            ((CraftServer) Bukkit.getServer()).syncCommands();
-            return kissenCommand;
-        });
-
-        if (!commandData.name().equals(rootName)) {
-            command = command.createRecursive(commandData.name());
+    private @NotNull KissenCommand buildCommand(@NotNull String name, @NotNull KissenPaperCommandImplementation.RootCommandFactory rootCommandFactory, @NotNull String fallback) {
+        String rootName = name.split("\\.")[0];
+        KissenPaperAbstractCommand<?> command = (KissenPaperAbstractCommand<?>) getCommand(rootName).orElseGet(() -> buildRootCommand(rootCommandFactory, fallback, rootName));
+        if (!name.equals(rootName)) {
+            command = command.createRecursive(name);
         }
         return command;
     }
 
-    @FunctionalInterface
-    private interface RootCommandFactory {
-        @NotNull KissenPaperAbstractCommand<?> constructCommand(@NotNull String name);
+    @NotNull
+    private KissenCommand buildRootCommand(@NotNull RootCommandFactory rootCommandFactory, @NotNull String fallback, String rootName) {
+        CommandMap commandMap = getCommandMap();
+        KissenCommand kissenCommand = rootCommandFactory.constructCommand(rootName);
+        kissenCommand.register(commandMap);
+        commandMap.register(fallback, kissenCommand);
+        ((CraftServer) Bukkit.getServer()).syncCommands();
+        return kissenCommand;
     }
 
     private @NotNull CommandMap getCommandMap() {
         return Bukkit.getCommandMap();
     }
+
+    @FunctionalInterface
+    private interface RootCommandFactory {
+        @NotNull KissenPaperAbstractCommand<?> constructCommand(@NotNull String name);
+    }
 }
diff --git a/src/main/java/net/kissenpvp/paper/command/command/KissenPaperAbstractCommand.java b/src/main/java/net/kissenpvp/paper/command/command/KissenPaperAbstractCommand.java
index be3cf48bd2e75f0ababedf161dd37c20dd9c57cf..5141ab53499ef6a876aae40b7347ca63a01030bd 100644
--- a/src/main/java/net/kissenpvp/paper/command/command/KissenPaperAbstractCommand.java
+++ b/src/main/java/net/kissenpvp/paper/command/command/KissenPaperAbstractCommand.java
@@ -1,5 +1,7 @@
 package net.kissenpvp.paper.command.command;
 
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.core.api.command.annotations.CommandData;
 import net.kissenpvp.core.api.command.executor.CommandExecutor;
 import net.kissenpvp.core.api.command.executor.TabCompleterExecutor;
 import net.kissenpvp.core.command.CommandHolder;
@@ -31,6 +33,10 @@ public abstract class KissenPaperAbstractCommand<C extends KissenPaperAbstractCo
     private CommandExecutor<CommandSender> commandExecutor;
     private TabCompleterExecutor<CommandSender> tabExecutor;
 
+    protected @NotNull CommandExecutor<CommandSender> getCommandExecutor() {
+        return commandExecutor;
+    }
+
     /**
      * Constructs a new {@link KissenPaperAbstractCommand} instance with the provided plugin, name, and position.
      * <p>
@@ -90,42 +96,30 @@ public abstract class KissenPaperAbstractCommand<C extends KissenPaperAbstractCo
             return false;
         }
 
-        final KissenPaperCommandContext kissenPaperCommandContext = new KissenPaperCommandContext(commandLabel, sender, getTargetValidator().parseSender(sender),
-                args, this);
-        //TODO maybe async
-        return commandExecutor.execute(kissenPaperCommandContext);
+        final KissenPaperCommandPayload kissenPaperCommandPayload = new KissenPaperCommandPayload(commandLabel, sender, getTargetValidator().parseSender(sender), args, this);
+
+        if(commandInfo.isAsync()) {
+            runAsync(kissenPaperCommandPayload);
+            return true;
+        }
+
+        return commandExecutor.execute(kissenPaperCommandPayload);
     }
 
     @Override
     public @NotNull List<String> tabComplete(@NotNull CommandSender sender, @NotNull String alias, @NotNull String[] args) throws IllegalArgumentException {
+
         List<String> result = new ArrayList<>();
+
         if (!validate(sender)) {
             return result;
         }
 
-        if (tabExecutor != null) {
-            result.addAll(tabExecutor.execute(new KissenPaperCommandContext(alias, sender, getTargetValidator().parseSender(sender),
-                    args, this)));
+        if (!(result = obtainChildrenTabSuggestions(sender, alias, args).orElse(obtainTabSuggestions(sender, args, new KissenPaperCommandPayload(alias, sender, getTargetValidator().parseSender(sender), args, this)))).isEmpty())
+        {
             return result;
         }
 
-        if (!getChildCommandList().isEmpty() && args.length != 0) {
-            List<String> matchedChildCommands = new ArrayList<>();
-
-            for (C command : getChildCommandList()) {
-                if (command.getPosition() == args.length && (command.getName()
-                        .toLowerCase()
-                        .startsWith(args[args.length - 1].toLowerCase())) && command.testPermissionSilent(sender)) {
-                    matchedChildCommands.add(command.getName());
-                }
-            }
-
-            if (!matchedChildCommands.isEmpty()) {
-                matchedChildCommands.sort(String.CASE_INSENSITIVE_ORDER);
-                return matchedChildCommands;
-            }
-        }
-
         return super.tabComplete(sender, alias, args);
     }
 
@@ -139,12 +133,12 @@ public abstract class KissenPaperAbstractCommand<C extends KissenPaperAbstractCo
      * <p>
      * This method is used to initialize the properties and behavior of the {@link KissenPaperAbstractCommand} based on the given command information and executor.
      *
-     * @param commandInfo     The {@link CommandInfo} containing details about the command. Must not be null.
+     * @param commandData     The {@link CommandData} containing details about the command. Must not be null.
      * @param commandExecutor The {@link CommandExecutor} responsible for executing the command logic. Must not be null.
      * @throws NullPointerException If either the {@code commandInfo} or {@code commandExecutor} parameter is null.
      */
-    public void initCommand(@NotNull CommandInfo commandInfo, @NotNull CommandExecutor<CommandSender> commandExecutor) {
-        this.commandInfo = commandInfo;
+    public void initCommand(@NotNull CommandData commandData, @NotNull CommandExecutor<CommandSender> commandExecutor) {
+        this.commandInfo = new CommandInfo(commandData);
         this.commandExecutor = commandExecutor;
 
         setAliases(Arrays.asList(commandInfo.getAliases()));
@@ -156,7 +150,7 @@ public abstract class KissenPaperAbstractCommand<C extends KissenPaperAbstractCo
         String usage = commandInfo.getUsage();
         if (!usage.isBlank()) {
             setUsage(usage);
-        } else if (commandExecutor instanceof KissenPaperCommandExecutor kissenPaperCommandExecutor) {
+        } else if (getCommandExecutor() instanceof KissenPaperCommandExecutor kissenPaperCommandExecutor) {
             setUsage(kissenPaperCommandExecutor.getEvaluator().buildUsage(getName()));
         }
 
@@ -179,7 +173,7 @@ public abstract class KissenPaperAbstractCommand<C extends KissenPaperAbstractCo
      * @param tabExecutor The {@link TabCompleterExecutor} responsible for tab completion of the command. Must not be null.
      * @throws IllegalStateException If the tab completer has already been initialized for this command.
      */
-    public final void initCompleter(TabCompleterExecutor<CommandSender> tabExecutor) {
+    public final void initCompleter(@NotNull TabCompleterExecutor<CommandSender> tabExecutor) {
         if (this.tabExecutor != null) {
             throw new IllegalStateException("Completer already initialized");
         }
@@ -266,4 +260,115 @@ public abstract class KissenPaperAbstractCommand<C extends KissenPaperAbstractCo
                 .getImplementation(KissenPaperCommandImplementation.class)
                 .getKissenPaperTargetValidator();
     }
+
+    /**
+     * Asynchronously executes the function defined in the command payload.
+     *
+     * <p>This abstract method facilitates asynchronous execution of code paths within commands,
+     * which can be useful when performing potentially lengthy operations such as file access or network communication.
+     * This prevents blocking operations from freezing the thread that the command is currently executing on,
+     * helping avoid potential server lag or non-responsiveness.</p>
+     *
+     * <p>All subclasses must provide an implementation for this method, ensuring that the command payload function is run asynchronously.
+     * The implementation may use the server's scheduler, a thread pool, or any other method of asynchronous execution.</p>
+     *
+     * @param payload A CommandPayload object that encapsulates the command, sender, command related data and a function to execute.
+     *                The exact function varies among different commands and is defined when the payload is constructed.
+     */
+    public abstract void runAsync(@NotNull CommandPayload<CommandSender> payload);
+
+    /**
+     * Attempts to obtain tab completion suggestions from child commands based on the user's current input.
+     *
+     * <p>This method is mainly used to delegate tab completion to child commands when the user has already entered at least one argument and a space.</p>
+     *
+     * <p>When the length of the provided arguments array is greater than 1 (indicating the user has entered some command followed by a space),
+     * the method retrieves the corresponding child command from the second to the last argument provided by the sender.</p>
+     *
+     * <p>If a corresponding child command is found, it delegates the tab completion to that command, passing the sender, alias, and all
+     * arguments excluding the first one (considering command as first). The result of this tab completion is then returned as an Optional.</p>
+     *
+     * <p>If no corresponding child command is found or if the length of provided argument array is less or equal to 1 (indicating user didn't type space after the command),
+     * the method returns an empty Optional.</p>
+     *
+     * @param sender The initiator of the command, used to provide context for the child command's tab completion
+     * @param alias The used alias of the command, provided to offer context for child command's tab completion
+     * @param args An array encapsulating the arguments inputted by the sender, used to deduce the corresponding child command and to provide
+     *             content to the child command's tab completion
+     * @return An Optional encapsulating a List of Strings which, if present, includes tab completion suggestions derived from the relevant child command
+     */
+    private @NotNull Optional<List<String>> obtainChildrenTabSuggestions(@NotNull CommandSender sender, @NotNull String alias, @NotNull String[] args) {
+        if(args.length > 1)
+        {
+            return getChildCommand(args[args.length - 2]).map(commandHolders -> commandHolders.tabComplete(sender, alias, Arrays.copyOfRange(args, 1, args.length)));
+        }
+        return Optional.empty();
+    }
+
+
+    /**
+     * Obtains a list of tab completion suggestions for a given command.
+     *
+     * <p>This function primarily retrieves possible suggestions either from a custom tabExecutor or an automatic
+     * suggestion generator based on defined child commands and the command executor.</p>
+     *
+     * <p>If a tabExecutor is defined (not null), it is used to execute the commandSenderCommandPayload and generates a list of suggestions.</p>
+     *
+     * <p>If there is no tabExecutor assigned (null), the method defaults to obtaining suggestions through the obtainAutoSuggestions method,
+     * which populates suggestions based on child commands and the command executor (if applicable).</p>
+     *
+     * <p>The collected suggestions are sorted in ascending order (case-insensitive) and returned as a list.</p>
+     *
+     * @param sender            The sender of the command. It serves as a reference for permission checks and establishes context for suggestion generation.
+     * @param args              An array containing the arguments provided by the sender. It is used in the obtainAutoSuggestions method to generate relevant command completions.
+     * @param commandSenderCommandPayload A CommandPayload object encapsulating command related data. It is passed to either the tabExecutor or the obtainAutoSuggestions method for further processing.
+     * @return A List of Strings representing possible command completions. The list is sorted in case-insensitive order.
+     */
+    private @NotNull List<String> obtainTabSuggestions(@NotNull CommandSender sender, @NotNull String @NotNull [] args, CommandPayload<CommandSender> commandSenderCommandPayload) {
+        List<String> suggestions = new ArrayList<>(tabExecutor != null ?
+                tabExecutor.execute(commandSenderCommandPayload) :
+                obtainAutoSuggestions(sender, args, commandSenderCommandPayload));
+        suggestions.sort(String.CASE_INSENSITIVE_ORDER);
+        return suggestions;
+    }
+
+    /**
+     * This method retrieves auto suggestions for command completion based on the user's current input.
+     *
+     * <p>The primary function of this method is to generate automatic suggestions using the list
+     * of child commands and the command executor (if applicable).</p>
+     *
+     * <p>The method starts by checking if any child commands exist and whether the command sender has supplied any arguments.
+
+     * <p>Moreover, if the a command executor belongs to instance of KissenPaperCommandExecutor, the evaluator corresponding to
+     * the user's current command is retrieved based on the number of arguments provided by the sender. The argument parser from the
+     * evaluator then provides tab completion options based on the context of the sender's current command. These options are also added to the
+     * list of auto suggestions provided.</p>
+     *
+     * @param sender The identifier of the command, used to check permissions and providing command context to the command executor and tab completion options
+     * @param args An array of arguments that command sender provided, used to find the next expected argument in the child command
+     *             and to find the last argument for comparison with child command names
+     * @param commandSenderCommandPayload A command payload object containing context for the command sender, arguments and other command-related data.
+     *                                    It is used to get the completion options from the evaluator's command argument parser.
+     * @return A List of Strings populated with auto suggestions for the user's current command input
+     */
+    private @NotNull List<String> obtainAutoSuggestions(@NotNull CommandSender sender, @NotNull String @NotNull [] args, CommandPayload<CommandSender> commandSenderCommandPayload) {
+        List<String> suggestions = new ArrayList<>();
+        if (!getChildCommandList().isEmpty() && args.length != 0) {
+
+            for (C command : getChildCommandList()) {
+                if (command.getPosition() == args.length && (command.getName()
+                        .toLowerCase()
+                        .startsWith(args[args.length - 1].toLowerCase())) && command.testPermissionSilent(sender)) {
+                    suggestions.add(command.getName());
+                }
+            }
+        }
+
+        if(getCommandExecutor() instanceof KissenPaperCommandExecutor kissenPaperCommandExecutor)
+        {
+            suggestions.addAll(kissenPaperCommandExecutor.getEvaluator().arguments().get(commandSenderCommandPayload.getArgumentCount()).argumentParser().tabCompletion(commandSenderCommandPayload));
+        }
+        return suggestions;
+    }
 }
diff --git a/src/main/java/net/kissenpvp/paper/command/command/KissenPaperCommandContext.java b/src/main/java/net/kissenpvp/paper/command/command/KissenPaperCommandPayload.java
similarity index 92%
rename from src/main/java/net/kissenpvp/paper/command/command/KissenPaperCommandContext.java
rename to src/main/java/net/kissenpvp/paper/command/command/KissenPaperCommandPayload.java
index 560091331e8e2922af00af30951d0c7c861bd57d..2a200f6850dbd69a940f9c1377390cbfff878bb6 100644
--- a/src/main/java/net/kissenpvp/paper/command/command/KissenPaperCommandContext.java
+++ b/src/main/java/net/kissenpvp/paper/command/command/KissenPaperCommandPayload.java
@@ -13,7 +13,7 @@ import org.jetbrains.annotations.NotNull;
 
 import java.lang.reflect.Array;
 
-public class KissenPaperCommandContext implements CommandPayload<CommandSender> {
+public class KissenPaperCommandPayload implements CommandPayload<CommandSender> {
 
     private final String label;
     private final CommandSender sender;
@@ -21,7 +21,7 @@ public class KissenPaperCommandContext implements CommandPayload<CommandSender>
     private final String[] args;
     private final CommandHolder<?, ?> commandHolder;
 
-    public KissenPaperCommandContext(String label, CommandSender sender, CommandTarget target, String[] args, CommandHolder<?, ?> commandHolder) {
+    public KissenPaperCommandPayload(String label, CommandSender sender, CommandTarget target, String[] args, CommandHolder<?, ?> commandHolder) {
         this.label = label;
         this.sender = sender;
         this.target = target;
@@ -59,7 +59,7 @@ public class KissenPaperCommandContext implements CommandPayload<CommandSender>
         KissenPaperCommandImplementation kissenPaperCommandImplementation = Bukkit.getKissen()
                 .getImplementation(KissenPaperCommandImplementation.class);
 
-        final ArgumentParser<?> adapter = kissenPaperCommandImplementation.getParserList().get(type);
+        final ArgumentParser<?, ?> adapter = kissenPaperCommandImplementation.getParserList().get(type);
         final T[] instance = (T[]) Array.newInstance(type, to - from);
 
         for (int i = from; i <= to; i++) {
diff --git a/src/main/java/net/kissenpvp/paper/command/command/plugin/KissenPaperPluginCommand.java b/src/main/java/net/kissenpvp/paper/command/command/plugin/KissenPaperPluginCommand.java
index de50ed583b786f63c997122245d611926130ddde..ec8178bc1688301d9272ec366eef96a0294f93ba 100644
--- a/src/main/java/net/kissenpvp/paper/command/command/plugin/KissenPaperPluginCommand.java
+++ b/src/main/java/net/kissenpvp/paper/command/command/plugin/KissenPaperPluginCommand.java
@@ -1,5 +1,7 @@
 package net.kissenpvp.paper.command.command.plugin;
 
+import io.papermc.paper.threadedregions.scheduler.ScheduledTask;
+import net.kissenpvp.core.api.command.CommandPayload;
 import net.kissenpvp.paper.command.command.KissenPaperAbstractCommand;
 import org.bukkit.command.CommandException;
 import org.bukkit.command.CommandSender;
@@ -18,6 +20,10 @@ public class KissenPaperPluginCommand extends KissenPaperAbstractCommand<KissenP
 
     private final Plugin plugin;
 
+    public Plugin getPlugin() {
+        return plugin;
+    }
+
     /**
      * Constructs a new {@link KissenPaperAbstractCommand} instance with the provided plugin, name, and position.
      * <p>
@@ -38,6 +44,11 @@ public class KissenPaperPluginCommand extends KissenPaperAbstractCommand<KissenP
         return super.getChildCommand(name);
     }
 
+    @Override
+    public void runAsync(@NotNull CommandPayload<CommandSender> payload) {
+        Bukkit.getAsyncScheduler().runNow(getPlugin(), scheduledTask -> getCommandExecutor().execute(payload));
+    }
+
     @Override
     protected @NotNull KissenPaperPluginChildCommand createChildCommand(@NotNull String nextSubCommand, @NotNull KissenPaperAbstractCommand<KissenPaperPluginChildCommand> parent) {
         return new KissenPaperPluginChildCommand(plugin, nextSubCommand, parent);
diff --git a/src/main/java/net/kissenpvp/paper/command/command/system/KissenPaperCommand.java b/src/main/java/net/kissenpvp/paper/command/command/system/KissenPaperCommand.java
index 613db2789c984799f16f04b1b3b837f81731a195..76773747d9ebf60d04b509bbb0506872ff2006a4 100644
--- a/src/main/java/net/kissenpvp/paper/command/command/system/KissenPaperCommand.java
+++ b/src/main/java/net/kissenpvp/paper/command/command/system/KissenPaperCommand.java
@@ -1,6 +1,10 @@
 package net.kissenpvp.paper.command.command.system;
 
+import net.kissenpvp.core.api.command.CommandPayload;
 import net.kissenpvp.paper.command.command.KissenPaperAbstractCommand;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.scheduler.MinecraftInternalPlugin;
 import org.jetbrains.annotations.NotNull;
 
 /**
@@ -11,6 +15,13 @@ import org.jetbrains.annotations.NotNull;
  */
 public class KissenPaperCommand extends KissenPaperAbstractCommand<KissenPaperChildCommand> {
 
+    static final MinecraftInternalPlugin MINECRAFT;
+
+    static
+    {
+        MINECRAFT = new MinecraftInternalPlugin();
+    }
+
     /**
      * Constructs a new {@link KissenPaperCommand} with the specified name and position.
      *
@@ -22,6 +33,11 @@ public class KissenPaperCommand extends KissenPaperAbstractCommand<KissenPaperCh
         super(name, position);
     }
 
+    @Override
+    public void runAsync(@NotNull CommandPayload<CommandSender> payload) {
+        Bukkit.getAsyncScheduler().runNow(MINECRAFT, (scheduledTask) -> getCommandExecutor().execute(payload));
+    }
+
     @Override
     protected @NotNull KissenPaperChildCommand createChildCommand(@NotNull String nextSubCommand, @NotNull KissenPaperAbstractCommand<KissenPaperChildCommand> parent) {
         return new KissenPaperChildCommand(nextSubCommand, parent);
diff --git a/src/main/java/net/kissenpvp/paper/command/executor/KissenPaperCommandExecutor.java b/src/main/java/net/kissenpvp/paper/command/executor/KissenPaperCommandExecutor.java
index ddc79d3d53009bdee0505bc7ec0eba88e62834e2..88b7b16f775bf9d0a7924832d07e0d85073b447f 100644
--- a/src/main/java/net/kissenpvp/paper/command/executor/KissenPaperCommandExecutor.java
+++ b/src/main/java/net/kissenpvp/paper/command/executor/KissenPaperCommandExecutor.java
@@ -1,11 +1,15 @@
 package net.kissenpvp.paper.command.executor;
 
+import net.kissenpvp.core.api.command.ArgumentParser;
 import net.kissenpvp.core.api.command.CommandPayload;
 import net.kissenpvp.core.api.command.exception.CommandException;
 import net.kissenpvp.core.api.command.executor.CommandExecutor;
+import net.kissenpvp.core.api.networking.client.entitiy.PlayerOfflineException;
+import net.kissenpvp.core.command.argument.Argument;
 import net.kissenpvp.core.command.argument.ArgumentEvaluator;
 import net.kissenpvp.paper.command.KissenPaperCommandImplementation;
 import net.kissenpvp.paper.command.command.KissenPaperAbstractCommand;
+import net.kyori.adventure.text.Component;
 import org.bukkit.Bukkit;
 import org.bukkit.command.CommandSender;
 import org.jetbrains.annotations.NotNull;
@@ -17,6 +21,7 @@ import java.lang.reflect.Method;
 public class KissenPaperCommandExecutor implements CommandExecutor<CommandSender> {
 
     private final Method method;
+
     private final Object holder;
 
     private final ArgumentEvaluator<CommandSender> evaluator;
@@ -95,6 +100,22 @@ public class KissenPaperCommandExecutor implements CommandExecutor<CommandSender
      * @throws NullPointerException If the provided {@code cause} parameter is null.
      */
     private void processError(@NotNull CommandPayload<CommandSender> context, @NotNull Throwable cause) {
+
+        Component component = null;
+        if(cause instanceof NullPointerException)
+        {
+            component = Component.translatable("messages.command.error.incorrect-usage");
+        } else if(cause instanceof PlayerOfflineException playerOfflineException)
+        {
+            component = Component.translatable("messages.command.error.player-offline", Component.text(playerOfflineException.getName()));
+        }
+
+        if(component != null)
+        {
+            context.getSender().sendMessage(component);
+            return;
+        }
+
         throw new CommandException(cause);
     }
 
diff --git a/src/main/java/net/kissenpvp/paper/command/executor/KissenPaperCompleteExecutor.java b/src/main/java/net/kissenpvp/paper/command/executor/KissenPaperCompleteExecutor.java
index 78b5c4029816403517767b01372e0a156eb2d49d..c37029b6a29b165395d9d404755943f724b0064a 100644
--- a/src/main/java/net/kissenpvp/paper/command/executor/KissenPaperCompleteExecutor.java
+++ b/src/main/java/net/kissenpvp/paper/command/executor/KissenPaperCompleteExecutor.java
@@ -9,9 +9,9 @@ import org.bukkit.command.CommandSender;
 import org.jetbrains.annotations.NotNull;
 
 import java.lang.reflect.Method;
+import java.util.Collection;
 import java.util.HashSet;
 import java.util.List;
-import java.util.Set;
 
 public class KissenPaperCompleteExecutor implements TabCompleterExecutor<CommandSender> {
 
@@ -22,7 +22,7 @@ public class KissenPaperCompleteExecutor implements TabCompleterExecutor<Command
         final Class<?> returnType = method.getReturnType();
         final Class<?>[] parameters = method.getParameterTypes();
 
-        if (!List.class.isAssignableFrom(returnType)) {
+        if (!Collection.class.isAssignableFrom(returnType)) {
             throw new IllegalReturnValueException(returnType, List.class);
         }
 
@@ -35,15 +35,15 @@ public class KissenPaperCompleteExecutor implements TabCompleterExecutor<Command
     }
 
     @Override
-    public @NotNull Set<String> execute(@NotNull CommandPayload<CommandSender> context) {
+    public @NotNull Collection<String> execute(@NotNull CommandPayload<CommandSender> context) {
         final Class<?>[] types = method.getParameterTypes();
         try {
             if (types.length == 0) {
-                return (Set<String>) method.invoke(holder);
+                return (Collection<String>) method.invoke(holder);
             }
 
             if (types.length == 1 && types[0] == CommandPayload.class) {
-                return (Set<String>) method.invoke(holder, context);
+                return (Collection<String>) method.invoke(holder, context);
             }
 
             return new HashSet<>();
@@ -51,4 +51,5 @@ public class KissenPaperCompleteExecutor implements TabCompleterExecutor<Command
             throw new CommandException(String.format("An error occurred while processing the tab request for command '%s'.", context.getLabel()), exception);
         }
     }
+
 }
diff --git a/src/main/java/net/kissenpvp/paper/command/parser/BooleanParser.java b/src/main/java/net/kissenpvp/paper/command/parser/BooleanParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..fcd6ef1ca4ae70ef81b270f2ea0dcc3edfe97eff
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/parser/BooleanParser.java
@@ -0,0 +1,26 @@
+package net.kissenpvp.paper.command.parser;
+
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.paper.api.command.PaperArgumentParser;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collection;
+import java.util.List;
+
+public class BooleanParser implements PaperArgumentParser<Boolean> {
+    @Override
+    public @NotNull String serialize(@NotNull Boolean object) {
+        return object.toString();
+    }
+
+    @Override
+    public @NotNull Boolean deserialize(@NotNull String input) {
+        return Boolean.parseBoolean(input);
+    }
+
+    @Override
+    public @NotNull Collection<String> tabCompletion(@NotNull CommandPayload<CommandSender> commandPayload) {
+        return List.of("true", "false");
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/parser/ByteParser.java b/src/main/java/net/kissenpvp/paper/command/parser/ByteParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..56f1b8b9717cee571aef6adb464da8925b7ce12c
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/parser/ByteParser.java
@@ -0,0 +1,17 @@
+package net.kissenpvp.paper.command.parser;
+
+import net.kissenpvp.paper.api.command.PaperArgumentParser;
+import org.jetbrains.annotations.NotNull;
+
+public class ByteParser implements PaperArgumentParser<Byte> {
+
+    @Override
+    public @NotNull String serialize(@NotNull Byte object) {
+        return String.valueOf(object);
+    }
+
+    @Override
+    public @NotNull Byte deserialize(@NotNull String input) {
+        return Byte.parseByte(input);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/parser/CharacterParser.java b/src/main/java/net/kissenpvp/paper/command/parser/CharacterParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..9bda06fe3baa11ce685ddf2df90bd8660bfb5c82
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/parser/CharacterParser.java
@@ -0,0 +1,17 @@
+package net.kissenpvp.paper.command.parser;
+
+import net.kissenpvp.paper.api.command.PaperArgumentParser;
+import org.jetbrains.annotations.NotNull;
+
+public class CharacterParser implements PaperArgumentParser<Character> {
+
+    @Override
+    public @NotNull String serialize(@NotNull Character object) {
+        return String.valueOf(object);
+    }
+
+    @Override
+    public @NotNull Character deserialize(@NotNull String input) {
+        return input.charAt(0);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/parser/DoubleParser.java b/src/main/java/net/kissenpvp/paper/command/parser/DoubleParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..53bd0ef9de222a95eee99ae8431f69d01047aa32
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/parser/DoubleParser.java
@@ -0,0 +1,17 @@
+package net.kissenpvp.paper.command.parser;
+
+import net.kissenpvp.paper.api.command.PaperArgumentParser;
+import org.jetbrains.annotations.NotNull;
+
+public class DoubleParser implements PaperArgumentParser<Double> {
+
+    @Override
+    public @NotNull String serialize(@NotNull Double object) {
+        return String.valueOf(object);
+    }
+
+    @Override
+    public @NotNull Double deserialize(@NotNull String input) {
+        return Double.parseDouble(input);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/parser/FloatParser.java b/src/main/java/net/kissenpvp/paper/command/parser/FloatParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..5a0cc33fedf9d747c43f2d27708893972ae3041c
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/parser/FloatParser.java
@@ -0,0 +1,17 @@
+package net.kissenpvp.paper.command.parser;
+
+import net.kissenpvp.paper.api.command.PaperArgumentParser;
+import org.jetbrains.annotations.NotNull;
+
+public class FloatParser implements PaperArgumentParser<Float> {
+
+    @Override
+    public @NotNull String serialize(@NotNull Float object) {
+        return String.valueOf(object);
+    }
+
+    @Override
+    public @NotNull Float deserialize(@NotNull String input) {
+        return Float.parseFloat(input);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/parser/IntegerParser.java b/src/main/java/net/kissenpvp/paper/command/parser/IntegerParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..2e02a161f7ed9bab43b5989e8efc186f873ac722
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/parser/IntegerParser.java
@@ -0,0 +1,17 @@
+package net.kissenpvp.paper.command.parser;
+
+import net.kissenpvp.paper.api.command.PaperArgumentParser;
+import org.jetbrains.annotations.NotNull;
+
+public class IntegerParser implements PaperArgumentParser<Integer> {
+
+    @Override
+    public @NotNull String serialize(@NotNull Integer object) {
+        return String.valueOf(object);
+    }
+
+    @Override
+    public @NotNull Integer deserialize(@NotNull String input) {
+        return Integer.parseInt(input);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/parser/LongParser.java b/src/main/java/net/kissenpvp/paper/command/parser/LongParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..60244eae4890c2282f5ee06c1a4b17288ca60405
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/parser/LongParser.java
@@ -0,0 +1,17 @@
+package net.kissenpvp.paper.command.parser;
+
+import net.kissenpvp.paper.api.command.PaperArgumentParser;
+import org.jetbrains.annotations.NotNull;
+
+public class LongParser implements PaperArgumentParser<Long> {
+
+    @Override
+    public @NotNull String serialize(@NotNull Long object) {
+        return String.valueOf(object);
+    }
+
+    @Override
+    public @NotNull Long deserialize(@NotNull String input) {
+        return Long.parseLong(input);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/parser/NamedTextColorParser.java b/src/main/java/net/kissenpvp/paper/command/parser/NamedTextColorParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..c727d375a674306a04bb46d4b5f5204a88573de2
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/parser/NamedTextColorParser.java
@@ -0,0 +1,27 @@
+package net.kissenpvp.paper.command.parser;
+
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.paper.api.command.PaperArgumentParser;
+import net.kyori.adventure.text.format.NamedTextColor;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collection;
+import java.util.Objects;
+
+public class NamedTextColorParser implements PaperArgumentParser<NamedTextColor> {
+    @Override
+    public @NotNull String serialize(@NotNull NamedTextColor object) {
+        return object.examinableName();
+    }
+
+    @Override
+    public @NotNull NamedTextColor deserialize(@NotNull String input) {
+        return Objects.requireNonNull(NamedTextColor.NAMES.value(input));
+    }
+
+    @Override
+    public @NotNull Collection<String> tabCompletion(@NotNull CommandPayload<CommandSender> commandPayload) {
+        return NamedTextColor.NAMES.keys();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/parser/PlayerParser.java b/src/main/java/net/kissenpvp/paper/command/parser/PlayerParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..2179be8fc71ad69879f8d55e6c026e22d919048c
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/parser/PlayerParser.java
@@ -0,0 +1,49 @@
+package net.kissenpvp.paper.command.parser;
+
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.core.api.networking.client.entitiy.PlayerOfflineException;
+import net.kissenpvp.paper.api.command.PaperArgumentParser;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collection;
+import java.util.UUID;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+
+public class PlayerParser implements PaperArgumentParser<Player> {
+    @Override
+    public @NotNull String serialize(@NotNull Player object) {
+        return object.getName();
+    }
+
+    @Override
+    public @NotNull Player deserialize(@NotNull String input) {
+        Player player;
+        Pattern pattern = Pattern.compile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$");
+        Matcher matcher = pattern.matcher(input);
+        if(matcher.matches())
+        {
+            player = Bukkit.getPlayer(UUID.fromString(input));
+        }
+        else
+        {
+            player = Bukkit.getPlayer(input);
+        }
+
+        if(player == null)
+        {
+            throw new PlayerOfflineException(input);
+        }
+
+        return player;
+    }
+
+    @Override
+    public @NotNull Collection<String> tabCompletion(@NotNull CommandPayload<CommandSender> commandPayload) {
+        return Bukkit.getOnlinePlayers().stream().map(Player::getName).collect(Collectors.toSet());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/parser/ShortParser.java b/src/main/java/net/kissenpvp/paper/command/parser/ShortParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..ac394d4ff01ebd90a9cd003eaa8f79cbc6cc625c
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/parser/ShortParser.java
@@ -0,0 +1,17 @@
+package net.kissenpvp.paper.command.parser;
+
+import net.kissenpvp.paper.api.command.PaperArgumentParser;
+import org.jetbrains.annotations.NotNull;
+
+public class ShortParser implements PaperArgumentParser<Short> {
+
+    @Override
+    public @NotNull String serialize(@NotNull Short object) {
+        return String.valueOf(object);
+    }
+
+    @Override
+    public @NotNull Short deserialize(@NotNull String input) {
+        return Short.parseShort(input);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/parser/StringParser.java b/src/main/java/net/kissenpvp/paper/command/parser/StringParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..ab25c40527cfc1b8f0ddfbc0bb855e68ac66a80e
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/command/parser/StringParser.java
@@ -0,0 +1,16 @@
+package net.kissenpvp.paper.command.parser;
+
+import net.kissenpvp.paper.api.command.PaperArgumentParser;
+import org.jetbrains.annotations.NotNull;
+
+public class StringParser implements PaperArgumentParser<String> {
+    @Override
+    public @NotNull String serialize(@NotNull String object) {
+        return object;
+    }
+
+    @Override
+    public @NotNull String deserialize(@NotNull String input) {
+        return input;
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/command/target/KissenPaperTargetValidator.java b/src/main/java/net/kissenpvp/paper/command/target/KissenPaperTargetValidator.java
index 900cc29bd4a7d5167692a4681b34bf9098808310..d5f457a0797705853d4ef582a4cac607e9062f78 100644
--- a/src/main/java/net/kissenpvp/paper/command/target/KissenPaperTargetValidator.java
+++ b/src/main/java/net/kissenpvp/paper/command/target/KissenPaperTargetValidator.java
@@ -15,22 +15,14 @@ import org.jetbrains.annotations.NotNull;
  * the type of server entity and provides methods to parse the sender's server entity into a valid command target.
  */
 public class KissenPaperTargetValidator implements TargetValidator {
+
     @Override
     public boolean validate(@NotNull CommandTarget commandTarget, @NotNull ServerEntity serverEntity) {
-        switch (commandTarget) { //TODO when updated to newer java use new functions
-            case PLAYER -> {
-                return serverEntity instanceof PlayerClient<?>;
-            }
-            case SYSTEM -> {
-                return serverEntity instanceof ConsoleClient;
-            }
-            case ALL -> {
-                return true;
-            }
-            default -> {
-                return false;
-            }
-        }
+        return switch (commandTarget) {
+            case PLAYER -> serverEntity instanceof PlayerClient<?, ?, ?>;
+            case SYSTEM -> serverEntity instanceof ConsoleClient;
+            case ALL -> true;
+        };
     }
 
     @Override
@@ -39,7 +31,7 @@ public class KissenPaperTargetValidator implements TargetValidator {
             return CommandTarget.SYSTEM;
         }
 
-        if (serverEntity instanceof PlayerClient<?>) {
+        if (serverEntity instanceof PlayerClient<?, ?, ?>) {
             return CommandTarget.PLAYER;
         }
 
diff --git a/src/main/java/net/kissenpvp/paper/message/localization/KissenPaperLocalizationImplementation.java b/src/main/java/net/kissenpvp/paper/message/localization/KissenPaperLocalizationImplementation.java
index 49cede20d40758bd9650bc0f41340d84f22978f4..a69f4b52b4a890605195b1a6478241699b396ffa 100644
--- a/src/main/java/net/kissenpvp/paper/message/localization/KissenPaperLocalizationImplementation.java
+++ b/src/main/java/net/kissenpvp/paper/message/localization/KissenPaperLocalizationImplementation.java
@@ -11,18 +11,14 @@ public class KissenPaperLocalizationImplementation extends KissenLocalizationImp
     @Override
     public boolean postStart() {
 
-        // bukkit
-        register("bukkit.shutdown-message", getTranslation("multiplayer.disconnect.server_shutdown"));
-
-        // spigot
-        register("spigot.whitelist", getTranslation("multiplayer.disconnect.not_whitelisted"));
-        register("spigot.server-full", getTranslation("multiplayer.disconnect.server_full"));
-        register("spigot.outdated-client", getTranslation("multiplayer.disconnect.outdated_client"));
-        register("spigot.outdated-server", getTranslation("multiplayer.disconnect.outdated_server"));
-        register("spigot.restart", getTranslation("multiplayer.disconnect.server_shutdown"));
-        register("spigot.unknown-command", new MessageFormat("Unknown command. Type \"/help\" for help."));
-
-        // paper
+        //I love disconnect messages
+        register("messages.server.disconnect.server-shutdown", getTranslation("multiplayer.disconnect.server_shutdown"));
+        register("messages.server.disconnect.not-whitelisted", getTranslation("multiplayer.disconnect.not_whitelisted"));
+        register("messages.server.disconnect.server-full", getTranslation("multiplayer.disconnect.server_full"));
+        register("messages.server.disconnect.outdated-client", getTranslation("multiplayer.disconnect.outdated_client"));
+        register("messages.server.disconnect.outdated-server", getTranslation("multiplayer.disconnect.outdated_server"));
+        register("messages.server.disconnect.server-restart", getTranslation("multiplayer.disconnect.server_shutdown"));
+
         register("paper.kick.connection-throttle", new MessageFormat("Connection throttled! Please wait before reconnecting."));
         register("paper.unauthorized", new MessageFormat("You do not have the permission to perform this command."));
 
diff --git a/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperOnlinePlayerClient.java b/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperOnlinePlayerClient.java
index 5dc375c1023c582d0b106f6316a8e9bee841f1b4..7b70073d96ced079e19e6909b625ea40975cdf06 100644
--- a/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperOnlinePlayerClient.java
+++ b/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperOnlinePlayerClient.java
@@ -1,34 +1,68 @@
 package net.kissenpvp.paper.networking.client.entity;
 
+import io.netty.channel.Channel;
 import net.kissenpvp.core.api.ban.Ban;
-import net.kissenpvp.core.api.message.Theme;
 import net.kissenpvp.core.api.networking.client.entitiy.ServerEntity;
-import net.kissenpvp.core.message.PlayerTheme;
-import net.kissenpvp.core.networking.client.entity.KissenOnlinePlayerClient;
+import net.kissenpvp.core.message.KissenComponentSerializer;
 import net.kissenpvp.paper.api.networking.client.entity.PaperOnlinePlayerClient;
+import net.kissenpvp.paper.permission.permissible.KissenPaperPlayerPermissible;
+import net.kyori.adventure.audience.Audience;
+import net.kyori.adventure.text.Component;
+import net.minecraft.network.protocol.Packet;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
-public interface KissenPaperOnlinePlayerClient extends KissenOnlinePlayerClient, KissenPaperPlayerClient, PaperOnlinePlayerClient {
+public class KissenPaperOnlinePlayerClient extends KissenPaperPlayerClient implements PaperOnlinePlayerClient {
 
+    private final CraftPlayer craftPlayer;
+    public KissenPaperOnlinePlayerClient(@NotNull KissenPaperPlayerPermissible parent) {
+        super(parent);
+        this.craftPlayer = (CraftPlayer) parent.getPlayer();
+    }
 
     @Override
-    default @Nullable String getCurrentServer() {
-        return null; //TODO Create class for the core presenting a server
+    public final boolean isConnected() {
+        return true;
     }
 
     @Override
-    default int warn(@NotNull Ban ban, @NotNull ServerEntity warnOperator) {
-        return 0; //TODO (lazy)
+    public void kick(@NotNull String message) {
+        kick(KissenComponentSerializer.getInstance().getMiniSerializer().deserialize(message));
     }
 
     @Override
-    default @NotNull Theme getTheme() {
-        return new PlayerTheme(this);
+    public void kick(@NotNull Component component) {
+        craftPlayer.kick(component);
     }
 
     @Override
-    default boolean isConnected() {
-        return true;
+    public void killConnection() {
+        getConnection().close();
+    }
+
+    @Override
+    public @NotNull Channel getConnection() {
+        return craftPlayer.getHandle().connection.connection.channel;
+    }
+
+    @Override
+    public void sendPacket(@NotNull Object object) throws ClassNotFoundException, ClassCastException {
+        craftPlayer.getHandle().connection.send((Packet<?>) object);
+    }
+
+    @Override
+    public @Nullable String getCurrentServer() {
+        return null;
+    }
+
+    @Override
+    public @NotNull Audience getKyoriAudience() {
+        return craftPlayer;
+    }
+
+    @Override
+    public int warn(@NotNull Ban ban, @NotNull ServerEntity warnOperator) {
+        return 0;
     }
 }
diff --git a/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperPlayerClient.java b/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperPlayerClient.java
index 0242030d771fc91b5460a9215628d7bde23e4081..2ec49e2f5d5314e4646e3ee46f447d87250c9616 100644
--- a/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperPlayerClient.java
+++ b/src/main/java/net/kissenpvp/paper/networking/client/entity/KissenPaperPlayerClient.java
@@ -1,117 +1,141 @@
 package net.kissenpvp.paper.networking.client.entity;
 
-import net.kissenpvp.core.api.ban.Ban;
-import net.kissenpvp.core.api.ban.PlayerBan;
-import net.kissenpvp.core.api.networking.client.entitiy.ServerEntity;
-import net.kissenpvp.core.api.permission.GroupablePermissionEntry;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.permission.PermissionGroup;
 import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.api.user.UserImplementation;
 import net.kissenpvp.core.api.user.suffix.Suffix;
 import net.kissenpvp.core.database.DataWriter;
 import net.kissenpvp.core.networking.client.entity.KissenPlayerClient;
 import net.kissenpvp.core.user.rank.KissenPlayerRankNode;
+import net.kissenpvp.paper.api.ban.PaperPunishment;
 import net.kissenpvp.paper.api.base.Context;
 import net.kissenpvp.paper.api.networking.client.entity.PaperOnlinePlayerClient;
 import net.kissenpvp.paper.api.networking.client.entity.PaperPlayerClient;
+import net.kissenpvp.paper.api.permission.PaperPermissible;
 import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.api.permission.PermissibleOverriddenException;
 import net.kissenpvp.paper.api.user.rank.PaperPlayerRank;
+import net.kissenpvp.paper.permission.permissible.KissenPaperPermissible;
+import net.kissenpvp.paper.permission.permissible.KissenPaperPlayerPermissible;
 import net.kissenpvp.paper.user.KissenPaperPublicUser;
 import net.kissenpvp.paper.user.rank.KissenPaperPlayerFallBackRank;
 import net.kissenpvp.paper.user.rank.KissenPaperPlayerRank;
 import net.kyori.adventure.text.Component;
+import org.bukkit.Bukkit;
+import org.bukkit.permissions.Permission;
+import org.bukkit.permissions.PermissionAttachment;
+import org.bukkit.permissions.PermissionAttachmentInfo;
+import org.bukkit.plugin.Plugin;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 import org.jetbrains.annotations.Unmodifiable;
 
+import java.util.HashSet;
 import java.util.Optional;
 import java.util.Set;
+import java.util.UUID;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
-public interface KissenPaperPlayerClient extends KissenPlayerClient<PaperPlayerRank>, PaperPlayerClient {
+public abstract class KissenPaperPlayerClient extends KissenPlayerClient<PaperPermission, PaperPlayerRank, PaperPunishment> implements PaperPlayerClient {
+
+    private final KissenPaperPermissible permissible;
+
+    public KissenPaperPlayerClient(@NotNull KissenPaperPermissible parent) {
+        this.permissible = parent;
+    }
+    @Override
+    public @NotNull User getUser() {
+        return Bukkit.getKissen()
+                .getImplementation(UserImplementation.class)
+                .getOnlineUser(getUniqueId())
+                .orElseThrow(IllegalStateException::new);
+    }
     @Override
-    default @NotNull PaperPlayerRank translateRank(@NotNull KissenPlayerRankNode kissenPlayerRankNode, @Nullable DataWriter dataWriter) {
+    protected @NotNull PaperPlayerRank translateRank(@NotNull KissenPlayerRankNode kissenPlayerRankNode, @Nullable DataWriter dataWriter) {
         return new KissenPaperPlayerRank(kissenPlayerRankNode, dataWriter);
     }
 
     @Override
-    default @NotNull @Unmodifiable Set<@NotNull PaperOnlinePlayerClient> getOnlineAltAccounts() {
-        return null; //TODO
+    protected @NotNull PaperPlayerRank fallbackRank() {
+        return new KissenPaperPlayerFallBackRank();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<@NotNull PaperOnlinePlayerClient> getOnlineAltAccounts() {
+        return Bukkit.getOnlinePlayers().stream().filter(client -> client.getTotalID().equals(getTotalID())).collect(Collectors.toSet());
     }
 
     @Override
-    @NotNull
-    default Set<Suffix> getSuffixSet() {
-        return Stream.concat(getSuffixSet(Context.LOCAL).stream(), getSuffixSet(Context.GLOBAL).stream()).collect(Collectors.toUnmodifiableSet());
+    public @NotNull Set<Suffix> getSuffixSet() {
+        return Stream.concat(getSuffixSet(Context.LOCAL).stream(), getSuffixSet(Context.GLOBAL).stream()).collect(Collectors.toSet());
     }
 
     @Override
-    default @NotNull Set<Suffix> getSuffixSet(@NotNull Context context) {
-        return null; //TODO
+    public @NotNull Set<Suffix> getSuffixSet(@NotNull Context context) {
+        //TODO
+        return new HashSet<>();
     }
 
     @Override
-    @NotNull
-    default Optional<@Nullable Suffix> getSuffix(@NotNull String name) {
-        return getSuffix(name, Context.LOCAL).or(() -> getSuffix(name, Context.GLOBAL));
+    public @NotNull Optional<@Nullable Suffix> getSuffix(@NotNull String name) {
+        return getSuffix(name, Context.LOCAL).or(() -> super.getSuffix(name));
     }
 
     @Override
-    default @NotNull Optional<@Nullable Suffix> getSuffix(@NotNull String name, @NotNull Context context) {
+    public @NotNull Optional<@Nullable Suffix> getSuffix(@NotNull String name, @NotNull Context context) {
         return Optional.empty(); //TODO
     }
 
+
     @Override
-    @NotNull
-    default Optional<@Nullable Suffix> setSuffix(@NotNull String name, @NotNull Component content) {
+    public @NotNull Optional<@Nullable Suffix> setSuffix(@NotNull String name, @NotNull Component content) {
         return setSuffix(name, content, Context.LOCAL);
     }
 
     @Override
-    default @NotNull Optional<@Nullable Suffix> setSuffix(@NotNull String name, @NotNull Component content, Context context) {
+    public @NotNull Optional<@Nullable Suffix> setSuffix(@NotNull String name, @NotNull Component content, Context context) {
         return Optional.empty(); //TODO
     }
 
     @Override
-    default boolean deleteSuffix(@NotNull String name) {
-        return getSuffix(name, Context.LOCAL).map((suffix) -> deleteSuffix(name, Context.LOCAL)).orElse(deleteSuffix(name, Context.GLOBAL));
+    public boolean deleteSuffix(@NotNull String name) {
+        return getSuffix(name, Context.LOCAL).map((suffix) -> deleteSuffix(name, Context.LOCAL)).orElse(false) || super.deleteSuffix(name);
     }
 
     @Override
-    default boolean deleteSuffix(@NotNull String name, @NotNull Context context) {
+    public boolean deleteSuffix(@NotNull String name, @NotNull Context context) {
         return false; //TODO
     }
 
     @Override
-    default void setSelectedSuffix(@NotNull String name) throws NullPointerException {
-        setSelectedSuffix(name, getSuffix(name, Context.LOCAL).map(suffix -> Context.LOCAL).or(() -> getSuffix(name, Context.GLOBAL).map(suffix -> Context.GLOBAL)).orElseThrow(NullPointerException::new));
+    public void setSelectedSuffix(@NotNull String name) throws NullPointerException {
+        setSelectedSuffix(name, Context.LOCAL);
     }
 
     @Override
-    default void setSelectedSuffix(@NotNull String name, @NotNull Context context) throws NullPointerException {
+    public void setSelectedSuffix(@NotNull String name, @NotNull Context context) throws NullPointerException {
+        //TODO
     }
 
     @Override
-    default long getOnlineTime(@NotNull Context context) {
-        return getOnlineTime(getUser(context));
+    public long getOnlineTime() {
+        return getOnlineTime(Context.LOCAL);
     }
 
     @Override
-    default long getLastPlayed(@NotNull Context context) {
+    public long getOnlineTime(@NotNull Context context) {
         return getOnlineTime(getUser(context));
     }
 
     @Override
-    default @NotNull PlayerBan ban(@NotNull Ban ban, @NotNull ServerEntity banOperator, @NotNull Context context) {
-        return null; //TODO
-    }
-
-    @Override
-    default @NotNull PlayerBan ban(@NotNull Ban ban, @NotNull ServerEntity banOperator, @Nullable Component reason, @NotNull Context context) {
-        return null; //TODO
+    public long getLastPlayed(@NotNull Context context) {
+        return getLastPlayed(getUser(context));
     }
 
     @Override
-    default @NotNull User getUser(@NotNull Context context) {
+    public @NotNull User getUser(@NotNull Context context) {
         KissenPaperPublicUser kissenPublicUser = (KissenPaperPublicUser) getUser();
         return switch (context) {
             case GLOBAL -> kissenPublicUser;
@@ -120,12 +144,196 @@ public interface KissenPaperPlayerClient extends KissenPlayerClient<PaperPlayerR
     }
 
     @Override
-    default @NotNull PaperPlayerRank getRank() {
-        int index = getRankIndex();
-        return index == -1 ? new KissenPaperPlayerFallBackRank() : getRankHistory().get(index);
+    public @NotNull PaperPermissible getPermissible() throws PermissibleOverriddenException {
+        return (PaperPermissible) permissible;
+    }
+
+    public @NotNull KissenPaperPermissible getPermissionContext() throws PermissibleOverriddenException {
+        return permissible;
+    }
+
+    @Override
+    public boolean isPermissionSet(@NotNull String name) {
+        return getPermissionContext().isPermissionSet(name);
+    }
+
+    @Override
+    public boolean isPermissionSet(@NotNull Permission perm) {
+        return getPermissionContext().isPermissionSet(perm);
+    }
+
+    @Override
+    public @NotNull String getPermissionID() {
+        return getPermissionContext().getPermissionID();
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission) throws EventCancelledException {
+        return getPermissionContext().setPermission(permission);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, boolean value) throws EventCancelledException {
+        return getPermissionContext().setPermission(permission, value);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission) {
+        return getPermissionContext().unsetPermission(permission);
+    }
+
+    @Override
+    public int wipePermissions() {
+        return getPermissionContext().wipePermissions();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList() {
+        return getPermissionContext().getPermissionList();
+    }
+
+    @Override
+    public @NotNull Optional<@Nullable PaperPermission> getPermission(@NotNull String permission) {
+        return getPermissionContext().getPermission(permission);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAffectedPermissionPlayer() {
+        return getPermissionContext().getAffectedPermissionPlayer();
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull PaperPermission permission) throws EventCancelledException {
+        return getPermissionContext().setPermission(permission);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String name) {
+        return getPermissionContext().hasPermission(name);
+    }
+
+    @Override
+    public void permissionUpdate() {
+        getPermissionContext().permissionUpdate();
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull Permission perm) {
+        return getPermissionContext().hasPermission(perm);
+    }
+
+    @Override
+    public @NotNull PermissionAttachment addAttachment(@NotNull Plugin plugin, @NotNull String name, boolean value) {
+        return getPermissionContext().addAttachment(plugin, name, value);
+    }
+
+    @Override
+    public @NotNull PermissionAttachment addAttachment(@NotNull Plugin plugin) {
+        return getPermissionContext().addAttachment(plugin);
+    }
+
+    @Override
+    public @Nullable PermissionAttachment addAttachment(@NotNull Plugin plugin, @NotNull String name, boolean value, int ticks) {
+        return getPermissionContext().addAttachment(plugin, name, value, ticks);
+    }
+
+    @Override
+    public @Nullable PermissionAttachment addAttachment(@NotNull Plugin plugin, int ticks) {
+        return getPermissionContext().addAttachment(plugin, ticks);
+    }
+
+    @Override
+    public void removeAttachment(@NotNull PermissionAttachment attachment) {
+        getPermissionContext().removeAttachment(attachment);
+    }
+
+    @Override
+    public void recalculatePermissions() {
+        getPermissionContext().recalculatePermissions();
+    }
+
+    @Override
+    public @NotNull Set<PermissionAttachmentInfo> getEffectivePermissions() {
+        return getPermissionContext().getEffectivePermissions();
+    }
+
+    @Override
+    public boolean isOp() {
+        return getPermissionContext().isOp();
+    }
+
+    @Override
+    public void setOp(boolean value) {
+        getPermissionContext().setOp(value);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getOwnPermissions() {
+        return getPermissionContext().getOwnPermissions();
+    }
+
+    @Override
+    public int wipeGroups() {
+        return getPermissionContext().wipeGroups();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups() {
+        return getPermissionContext().getPermissionGroups();
     }
 
-    default @NotNull GroupablePermissionEntry<PaperPermission> getPermissionEntry(@NotNull Context context) {
-        return (GroupablePermissionEntry<PaperPermission>) getUser(context);
+    @Override
+    public boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup) {
+        return getPermissionContext().inGroup(permissionGroup);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getOwnPermissions(@NotNull Context context) {
+        return getPermissionContext().getOwnPermissions(context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups(@NotNull Context context) {
+        return getPermissionContext().getPermissionGroups(context);
+    }
+
+    @Override
+    public boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup, @NotNull Context context) {
+        return getPermissionContext().inGroup(permissionGroup, context);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, @NotNull Context context) throws EventCancelledException {
+        return getPermissionContext().setPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, boolean value, @NotNull Context context) throws EventCancelledException {
+        return getPermissionContext().setPermission(permission, value, context);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull PaperPermission permission, @NotNull Context context) throws EventCancelledException {
+        return getPermissionContext().setPermission(permission, context);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission, @NotNull Context context) {
+        return getPermissionContext().unsetPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList(@NotNull Context context) {
+        return getPermissionContext().getPermissionList(context);
+    }
+
+    @Override
+    public @NotNull Optional<@Nullable PaperPermission> getPermission(@NotNull String permission, @NotNull Context context) {
+        return getPermissionContext().getPermission(permission, context);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String permission, @NotNull Context context) {
+        return getPermissionContext().hasPermission(permission, context);
     }
 }
diff --git a/src/main/java/net/kissenpvp/paper/permission/PermissionCommand.java b/src/main/java/net/kissenpvp/paper/permission/PermissionCommand.java
deleted file mode 100644
index 247583731ed0056c7a5808e0c7f6420bc5100dcf..0000000000000000000000000000000000000000
--- a/src/main/java/net/kissenpvp/paper/permission/PermissionCommand.java
+++ /dev/null
@@ -1,21 +0,0 @@
-package net.kissenpvp.paper.permission;
-
-import net.kissenpvp.core.api.command.CommandPayload;
-import net.kissenpvp.core.api.command.annotations.CommandData;
-import org.bukkit.command.CommandSender;
-import org.jetbrains.annotations.NotNull;
-
-public class PermissionCommand {
-
-
-    @CommandData(name = "test")
-    public void test(@NotNull CommandPayload<CommandSender> commandSender, @NotNull String permission) {
-        commandSender.getSender().sendMessage(permission);
-    }
-
-    @CommandData(name = "test.group")
-    public void testGroup(@NotNull CommandPayload<CommandSender> commandSender, @NotNull String group) {
-        commandSender.getSender().sendMessage(group);
-    }
-
-}
diff --git a/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPermissionGroup.java b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPermissionGroup.java
index 015647eda8d09f7facb1fe3c92da4135f938dab8..21636a1ec24219d91bd859c2719f824d4c6e9759 100644
--- a/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPermissionGroup.java
+++ b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPermissionGroup.java
@@ -11,7 +11,7 @@ import net.kissenpvp.paper.api.permission.PaperPermission;
 import net.kissenpvp.paper.api.permission.PaperPermissionGroup;
 import net.kissenpvp.paper.api.permission.PaperPublicPermissionGroup;
 import net.kissenpvp.paper.permission.KissenPaperAttachmentPermission;
-import net.kissenpvp.paper.permission.KissenPaperPermissible;
+import net.kissenpvp.paper.permission.permissible.KissenPaperPermissible;
 import net.kyori.adventure.text.Component;
 import org.bukkit.Bukkit;
 import org.bukkit.permissions.Permissible;
diff --git a/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPublicPermissionGroup.java b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPublicPermissionGroup.java
index 861f8ec4bca4d48796efeba8b8eaa6ff3c20b600..28d1fef8309efe16c182dd8e0202bd3029483f98 100644
--- a/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPublicPermissionGroup.java
+++ b/src/main/java/net/kissenpvp/paper/permission/group/KissenPaperPublicPermissionGroup.java
@@ -4,7 +4,7 @@ import net.kissenpvp.core.api.database.meta.BackendException;
 import net.kissenpvp.core.api.networking.socket.DataPackage;
 import net.kissenpvp.paper.api.permission.PaperPrivatePermissionGroup;
 import net.kissenpvp.paper.api.permission.PaperPublicPermissionGroup;
-import net.kissenpvp.paper.permission.KissenPaperPermissionImplementation;
+import net.kissenpvp.paper.permission.permissible.KissenPaperPermissionImplementation;
 import org.bukkit.Bukkit;
 import org.jetbrains.annotations.NotNull;
 
diff --git a/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperOfflinePlayerPermissible.java b/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperOfflinePlayerPermissible.java
new file mode 100644
index 0000000000000000000000000000000000000000..aa4bb17fa0e8143e55e10a2cc8b3692bbd310515
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperOfflinePlayerPermissible.java
@@ -0,0 +1,92 @@
+package net.kissenpvp.paper.permission.permissible;
+
+import net.kissenpvp.core.api.permission.GroupablePermissionEntry;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kyori.adventure.text.Component;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.permissions.PermissionAttachment;
+import org.bukkit.plugin.Plugin;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Collections;
+import java.util.Set;
+import java.util.UUID;
+
+public class KissenPaperOfflinePlayerPermissible extends KissenPaperPermissible {
+
+    public KissenPaperOfflinePlayerPermissible(@NotNull OfflinePlayer parent) {
+        super(parent);
+    }
+
+    private @NotNull OfflinePlayer getPlayer() {
+        return (OfflinePlayer) parent;
+    }
+
+    @Override
+    public @NotNull GroupablePermissionEntry<PaperPermission> getPermissionEntry(@NotNull Context context) {
+        return (GroupablePermissionEntry<PaperPermission>) getPlayer().getUser(context);
+    }
+
+    @Override
+    public @NotNull String getPermissionID() {
+        return getPermissionEntry(Context.GLOBAL).getPermissionID();
+    }
+
+    @Override
+    public @NotNull Component displayName() {
+        return getPlayer().displayName();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAffectedPermissionPlayer() {
+        return Collections.singleton(getPlayer().getUniqueId());
+    }
+
+    @Override
+    public boolean isOp() {
+        return getPlayer().isOp();
+    }
+
+    @Override
+    public void setOp(boolean value) {
+        getPlayer().setOp(value);
+    }
+
+    @Override
+    public void permissionUpdate() {
+    }
+
+    @Override
+    public @NotNull PermissionAttachment addAttachment(@NotNull Plugin plugin) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public @NotNull PermissionAttachment addAttachment(@NotNull Plugin plugin, @NotNull String name, boolean value) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public @Nullable PermissionAttachment addAttachment(@NotNull Plugin plugin, @NotNull String name, boolean value, int ticks) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public @Nullable PermissionAttachment addAttachment(@NotNull Plugin plugin, int ticks) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void removeAttachment(@NotNull PermissionAttachment attachment) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void recalculatePermissions() {}
+
+    @Override
+    public void unsubscribe() {}
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperOnlinePlayerPermissible.java b/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperOnlinePlayerPermissible.java
new file mode 100644
index 0000000000000000000000000000000000000000..94dab8510fff9e1eeb072b775e8d50ec9d960925
--- /dev/null
+++ b/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperOnlinePlayerPermissible.java
@@ -0,0 +1,54 @@
+package net.kissenpvp.paper.permission.permissible;
+
+import net.kissenpvp.core.api.permission.GroupablePermissionEntry;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kyori.adventure.text.Component;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Collections;
+import java.util.Set;
+import java.util.UUID;
+
+public class KissenPaperOnlinePlayerPermissible extends KissenPaperPermissible {
+
+    public KissenPaperOnlinePlayerPermissible(@NotNull Player parent) {
+        super(parent);
+    }
+
+    private @NotNull Player getPlayer() {
+        return (Player) parent;
+    }
+
+    @Override
+    public @NotNull GroupablePermissionEntry<PaperPermission> getPermissionEntry(@NotNull Context context) {
+        return (GroupablePermissionEntry<PaperPermission>) getPlayer().getUser(context);
+    }
+
+    @Override
+    public @NotNull String getPermissionID() {
+        return getPermissionEntry(Context.GLOBAL).getPermissionID();
+    }
+
+    @Override
+    public @NotNull Component displayName() {
+        return getPlayer().displayName();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAffectedPermissionPlayer() {
+        return Collections.singleton(getPlayer().getUniqueId());
+    }
+
+    @Override
+    public boolean isOp() {
+        return getPlayer().isOp();
+    }
+
+    @Override
+    public void setOp(boolean value) {
+        getPlayer().setOp(value);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermissible.java b/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPermissible.java
similarity index 94%
rename from src/main/java/net/kissenpvp/paper/permission/KissenPaperPermissible.java
rename to src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPermissible.java
index 768cac091136d1991e09d5a4956d403843e8eb51..18452f91d17c612e7ffa8c55f1d7e18e747f09d9 100644
--- a/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermissible.java
+++ b/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPermissible.java
@@ -1,7 +1,11 @@
-package net.kissenpvp.paper.permission;
+package net.kissenpvp.paper.permission.permissible;
 
 import net.kissenpvp.core.api.message.ComponentSerializer;
+import net.kissenpvp.paper.api.permission.PaperPermissible;
 import net.kissenpvp.paper.api.permission.PaperPermission;
+import net.kissenpvp.paper.permission.KissenPaperAttachmentPermission;
+import net.kissenpvp.paper.permission.KissenPaperGroupablePermissionEntry;
+import net.kissenpvp.paper.permission.RemoveAttachmentRunnable;
 import org.bukkit.Bukkit;
 import org.bukkit.OfflinePlayer;
 import org.bukkit.permissions.*;
@@ -16,7 +20,7 @@ import java.util.logging.Level;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
-public abstract class KissenPaperPermissible implements KissenPaperGroupablePermissionEntry {
+public abstract class KissenPaperPermissible implements KissenPaperGroupablePermissionEntry, PaperPermissible {
 
     protected final Permissible parent;
     protected final Set<PermissionAttachment> attachments;
diff --git a/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermissionImplementation.java b/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPermissionImplementation.java
similarity index 97%
rename from src/main/java/net/kissenpvp/paper/permission/KissenPaperPermissionImplementation.java
rename to src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPermissionImplementation.java
index a90a024c16c2b1e467584e5cfdc1f103c0ca96ad..e85cbbb4bb3ad511ccb3400d5ec62d0f0d495d78 100644
--- a/src/main/java/net/kissenpvp/paper/permission/KissenPaperPermissionImplementation.java
+++ b/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPermissionImplementation.java
@@ -1,4 +1,4 @@
-package net.kissenpvp.paper.permission;
+package net.kissenpvp.paper.permission.permissible;
 
 import net.kissenpvp.core.api.database.meta.BackendException;
 import net.kissenpvp.core.api.event.EventCancelledException;
@@ -38,13 +38,6 @@ public class KissenPaperPermissionImplementation implements PaperPermissionImple
         this.cachedGroups = new HashSet<>();
     }
 
-    @Override
-    public void setupComplete() {
-        Bukkit.getKissen()
-            .getImplementation(KissenPaperCommandImplementation.class)
-            .registerCommand(new PermissionCommand());
-    }
-
     @Override
     public boolean postStart() {
         try {
diff --git a/src/main/java/net/kissenpvp/paper/permission/KissenPaperPlayerPermissible.java b/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPlayerPermissible.java
similarity index 93%
rename from src/main/java/net/kissenpvp/paper/permission/KissenPaperPlayerPermissible.java
rename to src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPlayerPermissible.java
index d6b2c370b2fcf538359a1f5fc452c0eaace3d0f1..5bdd283dcf595f720adf4536fd90f97d54309c6f 100644
--- a/src/main/java/net/kissenpvp/paper/permission/KissenPaperPlayerPermissible.java
+++ b/src/main/java/net/kissenpvp/paper/permission/permissible/KissenPaperPlayerPermissible.java
@@ -1,4 +1,4 @@
-package net.kissenpvp.paper.permission;
+package net.kissenpvp.paper.permission.permissible;
 
 import net.kissenpvp.core.api.permission.GroupablePermissionEntry;
 import net.kissenpvp.paper.api.base.Context;
@@ -19,7 +19,7 @@ public class KissenPaperPlayerPermissible extends KissenPaperPermissible {
         super(parent);
     }
 
-    private @NotNull OfflinePlayer getPlayer() {
+    public @NotNull OfflinePlayer getPlayer() {
         return (OfflinePlayer) parent; // Can be offline or online, does not matter
     }
 
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenPaperPrivateUser.java b/src/main/java/net/kissenpvp/paper/user/KissenPaperPrivateUser.java
index 8a3b77d63565e8c7932536e8b92bd8eeef39ce7b..f520730205acfcd41f40918617c539b0c0b64a82 100644
--- a/src/main/java/net/kissenpvp/paper/user/KissenPaperPrivateUser.java
+++ b/src/main/java/net/kissenpvp/paper/user/KissenPaperPrivateUser.java
@@ -9,6 +9,7 @@ import net.kissenpvp.core.database.DataWriter;
 import net.kissenpvp.core.networking.client.entity.KissenPlayerClient;
 import net.kissenpvp.core.permission.KissenPermissionNode;
 import net.kissenpvp.core.user.KissenUser;
+import net.kissenpvp.paper.api.ban.PaperPunishment;
 import net.kissenpvp.paper.api.networking.client.entity.PaperPlayerClient;
 import net.kissenpvp.paper.api.permission.PaperPermission;
 import net.kissenpvp.paper.api.permission.PaperPermissionImplementation;
@@ -46,11 +47,11 @@ public class KissenPaperPrivateUser extends KissenUser<PaperPermission> {
     }
 
     @Override
-    public PlayerClient<?> getPlayerClient() {
+    public PlayerClient<?, ?, ?> getPlayerClient() {
         if (!getStorage().containsKey("player_client")) {
             getStorage().put("player_client", injectPlayerClient());
         }
-        return (KissenPlayerClient<PaperPlayerRank>) getStorage().get("player_client");
+        return (KissenPlayerClient<PaperPermission, PaperPlayerRank, PaperPunishment>) getStorage().get("player_client");
     }
 
     protected @NotNull PaperPlayerClient injectPlayerClient() {
diff --git a/src/main/java/net/kissenpvp/paper/user/KissenPaperPublicUser.java b/src/main/java/net/kissenpvp/paper/user/KissenPaperPublicUser.java
index 5b0cb15c1e13a552e0baf4207cae48ff3eef045d..a6da446478ee23b50d3939eb4c34dd1004532fe5 100644
--- a/src/main/java/net/kissenpvp/paper/user/KissenPaperPublicUser.java
+++ b/src/main/java/net/kissenpvp/paper/user/KissenPaperPublicUser.java
@@ -42,7 +42,7 @@ public class KissenPaperPublicUser extends KissenPublicUser<PaperPermission> {
     }
 
     @Override
-    public PlayerClient<?> getPlayerClient() {
+    public PlayerClient<?, ?, ?> getPlayerClient() {
         return getPrivateUserEntry().getPlayerClient();
     }
 
@@ -60,7 +60,7 @@ public class KissenPaperPublicUser extends KissenPublicUser<PaperPermission> {
     public void login() {
         super.login();
         KissenPaperPlayerClient kissenPaperPlayerClient = ((KissenPaperPlayerClient) getPlayerClient());
-        getStorage().put("visual_hash", kissenPaperPlayerClient.visualHash());
+        //getStorage().put("visual_hash", kissenPaperPlayerClient.visualHash()); //TODO
         getStorage().put("time_joined", System.currentTimeMillis());
         ((KissenUser<?>) getPrivateUserEntry()).login();
         getStorage().put("tick", true);
diff --git a/src/main/java/net/minecraft/commands/Commands.java b/src/main/java/net/minecraft/commands/Commands.java
index 4cc703e8e02c9b5e50f3afe295a35e8738bb1353..50031269ec77b046492e943c2871bdcbdd1eb44d 100644
--- a/src/main/java/net/minecraft/commands/Commands.java
+++ b/src/main/java/net/minecraft/commands/Commands.java
@@ -251,7 +251,7 @@ public class Commands {
                     .getLegacySerializer()
                     .serialize(KissenCore.getInstance()
                             .getImplementation(KissenLocalizationImplementation.class)
-                            .translate("spigot.unknown-command", senderLocale));
+                            .translate("messages.command.error.unknown-command", senderLocale));
             // KissenPaper end
 
             try {
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 7b5c8d4da64ac06960c64d7c3947cd3c41bb3d30..d0774ab17bc05554bf33061a3fa820348119a6d8 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -2177,7 +2177,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 if (!whitelist.isWhiteListed(entityplayer.getGameProfile()) && !this.getPlayerList()
                         .isOp(entityplayer.getGameProfile())) { // Paper - Fix kicking ops when whitelist is reloaded (MC-171420)
                     // KissenPaper start
-                    entityplayer.connection.disconnect(/* KissenPaper */ kissenLocalizationImplementation.translate("spigot.whitelist", entityplayer.getBukkitEntity()
+                    entityplayer.connection.disconnect(/* KissenPaper */ kissenLocalizationImplementation.translate("messages.server.disconnect.not-whitelisted", entityplayer.getBukkitEntity()
                             .getCurrentLocale()), org.bukkit.event.player.PlayerKickEvent.Cause.WHITELIST); // Paper - use configurable message
                     //entityplayer.connection.disconnect(org.spigotmc.SpigotConfig.whitelistMessage, org.bukkit.event.player.PlayerKickEvent.Cause.WHITELIST); // Paper - use configurable message
                     // KissenPaper end
diff --git a/src/main/java/net/minecraft/server/network/ServerHandshakePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerHandshakePacketListenerImpl.java
index 42e11a16b4c52e304964d77fd315e6d0157fb726..a5f07eba98c45ab64401db716c27bc762270b307 100644
--- a/src/main/java/net/minecraft/server/network/ServerHandshakePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerHandshakePacketListenerImpl.java
@@ -91,14 +91,14 @@ public class ServerHandshakePacketListenerImpl implements ServerHandshakePacketL
                             .getProtocolVersion()) { // Paper - Fix incorrect message for outdated clients
                         ichatmutablecomponent = io.papermc.paper.adventure.PaperAdventure.asVanilla(
                                 kissenLocalizationImplementation.
-                                        translate("spigot.outdated-client",
+                                        translate("messages.server.disconnect.outdated-client",
                                                 kissenLocalizationImplementation.getDefaultLocale(),
                                                 SharedConstants.getCurrentVersion().getName()));
                         //ichatmutablecomponent = org.bukkit.craftbukkit.util.CraftChatMessage.fromString(java.text.MessageFormat.format(org.spigotmc.SpigotConfig.outdatedClientMessage.replaceAll("'", "''"), SharedConstants.getCurrentVersion().getName()), true)[0]; // Spigot // Paper - Fix hex colors not working in some kick messages
                     } else {
                         ichatmutablecomponent = io.papermc.paper.adventure.PaperAdventure.asVanilla(
                                 kissenLocalizationImplementation.
-                                        translate("spigot.outdated-server",
+                                        translate("messages.server.disconnect.outdated-server",
                                                 kissenLocalizationImplementation.getDefaultLocale(),
                                                 SharedConstants.getCurrentVersion().getName()));
                         //ichatmutablecomponent = org.bukkit.craftbukkit.util.CraftChatMessage.fromString(java.text.MessageFormat.format(org.spigotmc.SpigotConfig.outdatedServerMessage.replaceAll("'", "''"), SharedConstants.getCurrentVersion().getName()), true)[0]; // Spigot // Paper - Fix hex colors not working in some kick messages
diff --git a/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
index 323d556e5050f06aa03dad03f38d73be8dcfe042..ce8ff51e2e049bca155632e6da3469eabe61bba6 100644
--- a/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
@@ -73,7 +73,7 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener,
             // KissenPaper start
             KissenLocalizationImplementation kissenLocalizationImplementation = Bukkit.getKissen()
                     .getImplementation(KissenLocalizationImplementation.class);
-            Component shutdownMessage = io.papermc.paper.adventure.PaperAdventure.asVanilla(kissenLocalizationImplementation.translate("bukkit.shutdown-message", kissenLocalizationImplementation.getDefaultLocale()));
+            Component shutdownMessage = io.papermc.paper.adventure.PaperAdventure.asVanilla(kissenLocalizationImplementation.translate("messages.server.disconnect.server-shutdown", kissenLocalizationImplementation.getDefaultLocale()));
             this.disconnect(/* KissenPaper */ shutdownMessage /* org.bukkit.craftbukkit.util.CraftChatMessage.fromString(org.spigotmc.SpigotConfig.restartMessage)[0] */);
             // KissenPaper end
             return;
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index d2871f3011949da5f2b970300aa06033ee0b7a8f..7d0b3d7bdfd4ffde2604b5d8e4039364f1414432 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -725,7 +725,7 @@ public abstract class PlayerList {
                         .getLegacySerializer()
                         .serialize(KissenCore.getInstance()
                                 .getImplementation(KissenLocalizationImplementation.class)
-                                .translate("spigot.server-full", entityplayer.getBukkitEntity().getCurrentLocale()));
+                                .translate("messages.server.disconnect.server-full", entityplayer.getBukkitEntity().getCurrentLocale()));
                 // KissenPaper end
 
                 event.disallow(PlayerLoginEvent.Result.KICK_FULL, net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection()
@@ -1164,7 +1164,7 @@ public abstract class PlayerList {
                 .getImplementation(KissenLocalizationImplementation.class);
         String whitelistMessage = KissenComponentSerializer.getInstance()
                 .getLegacySerializer()
-                .serialize(kissenLocalizationImplementation.translate("spigot.whitelist", loginEvent.getPlayer()
+                .serialize(kissenLocalizationImplementation.translate("messages.server.disconnect.not-whitelisted", loginEvent.getPlayer()
                         .locale()));
         // KissenPaper end
         boolean isWhitelisted = !this.doWhiteList || isOp || this.whitelist.contains(gameprofile);
@@ -1361,12 +1361,12 @@ public abstract class PlayerList {
         for (ServerPlayer player : this.players) {
             if (isRestarting) {
                 // Kissenpaper start
-                net.kyori.adventure.text.Component restartMessage = kissenLocalizationImplementation.translate("spigot.restart", player.getBukkitEntity()
+                net.kyori.adventure.text.Component restartMessage = kissenLocalizationImplementation.translate("messages.server.disconnect.server-restart", player.getBukkitEntity()
                         .locale());
                 player.connection.disconnect(/* KissenPaper */ restartMessage /* org.spigotmc.SpigotConfig.restartMessage */, org.bukkit.event.player.PlayerKickEvent.Cause.UNKNOWN);
             } else // Paper - kick event cause (cause is never used here)
             {
-                net.kyori.adventure.text.Component shutdownMessage = kissenLocalizationImplementation.translate("bukkit.shutdown-message", player.getBukkitEntity()
+                net.kyori.adventure.text.Component shutdownMessage = kissenLocalizationImplementation.translate("messages.server.disconnect.server-shutdown", player.getBukkitEntity()
                         .locale());
                 player.connection.disconnect(/* KissenPaper */  shutdownMessage /* this.server.server.shutdownMessage() */, org.bukkit.event.player.PlayerKickEvent.Cause.UNKNOWN); // CraftBukkit - add custom shutdown message // Paper - Adventure & KickEventCause (cause is never used here)
             }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java b/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java
index 7e7d2014bd856d5804d5c9a96b88f33489412803..d6c3998915cf57f403c0e04e075d31e8c2fc8c81 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java
@@ -1,13 +1,26 @@
 package org.bukkit.craftbukkit;
 
 import com.mojang.authlib.GameProfile;
+import net.kissenpvp.core.api.ban.Ban;
+import net.kissenpvp.core.api.ban.BanOperator;
 import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.message.Theme;
+import net.kissenpvp.core.api.permission.PermissionGroup;
 import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.api.user.rank.Rank;
+import net.kissenpvp.core.api.user.suffix.Suffix;
+import net.kissenpvp.core.api.user.usersetttings.PlayerSetting;
+import net.kissenpvp.core.api.user.usersetttings.UserSetting;
+import net.kissenpvp.paper.api.ban.PaperPunishment;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.networking.client.entity.PaperOnlinePlayerClient;
 import net.kissenpvp.paper.api.permission.PaperPermissible;
+import net.kissenpvp.paper.api.permission.PaperPermission;
 import net.kissenpvp.paper.api.permission.PermissibleOverriddenException;
+import net.kissenpvp.paper.api.user.rank.PaperPlayerRank;
 import net.kissenpvp.paper.networking.client.entity.KissenPaperPlayerClient;
-import net.kissenpvp.paper.permission.KissenPaperPlayerPermissible;
-import net.kissenpvp.paper.user.KissenPaperPublicUser;
+import net.kissenpvp.paper.permission.permissible.KissenPaperOfflinePlayerPermissible;
 import net.kyori.adventure.text.Component;
 import net.minecraft.core.GlobalPos;
 import net.minecraft.nbt.CompoundTag;
@@ -23,13 +36,13 @@ import org.bukkit.craftbukkit.entity.memory.CraftMemoryMapper;
 import org.bukkit.entity.EntityType;
 import org.bukkit.entity.Player;
 import org.bukkit.metadata.MetadataValue;
-import org.bukkit.permissions.Permissible;
 import org.bukkit.permissions.Permission;
 import org.bukkit.permissions.PermissionAttachment;
 import org.bukkit.permissions.PermissionAttachmentInfo;
 import org.bukkit.plugin.Plugin;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
 
 import java.io.File;
 import java.time.Duration;
@@ -37,24 +50,28 @@ import java.time.Instant;
 import java.util.*;
 
 @SerializableAs("Player")
-public class CraftOfflinePlayer implements OfflinePlayer, ConfigurationSerializable, /* KissenPaper */ KissenPaperPlayerClient {
+public class CraftOfflinePlayer implements OfflinePlayer, ConfigurationSerializable {
     private static final org.slf4j.Logger LOGGER = com.mojang.logging.LogUtils.getLogger(); // Paper
     private final GameProfile profile;
     private final CraftServer server;
     private final PlayerDataStorage storage;
 
     // KissenPaper start
-    private final Permissible permissible;
-
     private User cachedUser;
     private User cachePublicUser;
+    private KissenPaperPlayerClient kissenPaperPlayerClient;
     // KissenPaper end
 
     protected CraftOfflinePlayer(CraftServer server, GameProfile profile) {
         this.server = server;
         this.profile = profile;
         this.storage = server.console.playerDataStorage;
-        this.permissible = new KissenPaperPlayerPermissible(this);
+        this.kissenPaperPlayerClient = new KissenPaperPlayerClient(new KissenPaperOfflinePlayerPermissible(this)) {
+            @Override
+            public boolean isConnected() {
+                return false;
+            }
+        };
     }
 
     @Override
@@ -63,7 +80,7 @@ public class CraftOfflinePlayer implements OfflinePlayer, ConfigurationSerializa
     }
 
     @Override
-    public String getName() {
+    public @NotNull String getName() {
         Player player = this.getPlayer();
         if (player != null) {
             return player.getName();
@@ -86,17 +103,10 @@ public class CraftOfflinePlayer implements OfflinePlayer, ConfigurationSerializa
     }
 
     @Override
-    public UUID getUniqueId() {
+    public @NotNull UUID getUniqueId() {
         return this.profile.getId();
     }
 
-    // KissenPaper start
-    @Override
-    public @NotNull Component displayName() {
-        return Component.text(getName()); //no custom display name set
-    }
-    // KissenPaper end
-
     @Override
     public com.destroystokyo.paper.profile.PlayerProfile getPlayerProfile() { // Paper
         return new com.destroystokyo.paper.profile.CraftPlayerProfile(this.profile); // Paper
@@ -273,22 +283,6 @@ public class CraftOfflinePlayer implements OfflinePlayer, ConfigurationSerializa
         }
     }
 
-    // KissenPaper start
-    @Override
-    public @NotNull User getUser() {
-        if (cachePublicUser == null) {
-            try {
-
-                cachePublicUser = new KissenPaperPublicUser(getUniqueId(), getName());
-            } catch (BackendException backendException) {
-                backendException.printStackTrace();
-            }
-        }
-
-        return cachePublicUser;
-    }
-    // KissenPaper end
-
     @Override
     public boolean hasPlayedBefore() {
         return this.getData() != null;
@@ -597,73 +591,356 @@ public class CraftOfflinePlayer implements OfflinePlayer, ConfigurationSerializa
         }
     }
 
-    // KissenPaper start
+    // KissenPaper start - integrate user things
+
+    @Override
+    public final boolean isClient() {
+        return true;
+    }
+
     @Override
-    public boolean isConnected() {
+    public final boolean isConnected() {
         return false;
     }
 
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAltAccounts() throws BackendException {
+        return kissenPaperPlayerClient.getAltAccounts();
+    }
+
+    @Override
+    public @NotNull UUID getTotalID() {
+        return kissenPaperPlayerClient.getTotalID();
+    }
+
+    @Override
+    public @NotNull PaperPunishment ban(@NotNull Ban ban, @NotNull BanOperator banOperator) throws BackendException {
+        return kissenPaperPlayerClient.ban(ban, banOperator);
+    }
+
+    @Override
+    public @NotNull PaperPunishment ban(@NotNull Ban ban, @NotNull BanOperator banOperator, @Nullable Component reason) throws BackendException {
+        return kissenPaperPlayerClient.ban(ban, banOperator, reason);
+    }
+
+    @Override
+    public @NotNull Optional<@Nullable PaperPunishment> getBan(@NotNull String id) throws BackendException {
+        return kissenPaperPlayerClient.getBan(id);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<PaperPunishment> getBanHistory() throws BackendException {
+        return kissenPaperPlayerClient.getBanHistory();
+    }
+
+    @Override
+    public @NotNull Component displayName() {
+        return kissenPaperPlayerClient.displayName();
+    }
+
+    @Override
+    public @NotNull Component styledRankName() {
+        return kissenPaperPlayerClient.styledRankName();
+    }
+
+    @Override
+    public @NotNull Set<Suffix> getSuffixSet() {
+        return kissenPaperPlayerClient.getSuffixSet();
+    }
+
+    @Override
+    public @NotNull Optional<@Nullable Suffix> getSuffix(@NotNull String name) {
+        return kissenPaperPlayerClient.getSuffix(name);
+    }
+
+    @Override
+    public @NotNull Optional<@Nullable Suffix> setSuffix(@NotNull String name, @NotNull Component content) {
+        return kissenPaperPlayerClient.setSuffix(name, content);
+    }
+
+    @Override
+    public boolean deleteSuffix(@NotNull String name) {
+        return kissenPaperPlayerClient.deleteSuffix(name);
+    }
+
+    @Override
+    public @NotNull Optional<@Nullable Suffix> getSelectedSuffix() {
+        return kissenPaperPlayerClient.getSelectedSuffix();
+    }
+
+    @Override
+    public void setSelectedSuffix(@NotNull String name) throws NullPointerException {
+        kissenPaperPlayerClient.setSelectedSuffix(name);
+    }
+
+    @Override
+    public long getOnlineTime() {
+        return kissenPaperPlayerClient.getOnlineTime();
+    }
+
+    @Override
+    public @NotNull User getUser() {
+        return kissenPaperPlayerClient.getUser();
+    }
+
+    @Override
+    public @NotNull <X> UserSetting<X> getUserSetting(Class<? extends PlayerSetting<X>> settingClass) {
+        return kissenPaperPlayerClient.getUserSetting(settingClass);
+    }
+
+    @Override
+    public @NotNull Theme getTheme() {
+        return kissenPaperPlayerClient.getTheme();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<PaperPlayerRank> getRankHistory() {
+        return kissenPaperPlayerClient.getRankHistory();
+    }
+
+    @Override
+    public @NotNull PaperPlayerRank getRank() {
+        return kissenPaperPlayerClient.getRank();
+    }
+
+    @Override
+    public @NotNull PaperPlayerRank grantRank(@NotNull Rank rank) {
+        return kissenPaperPlayerClient.grantRank(rank);
+    }
+
+    @Override
+    public @NotNull PaperPlayerRank grantRank(@NotNull Rank rank, @Nullable Duration duration) {
+        return kissenPaperPlayerClient.grantRank(rank, duration);
+    }
+
+    @Override
+    public @NotNull Locale getCurrentLocale() {
+        return kissenPaperPlayerClient.getCurrentLocale();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<@NotNull PaperOnlinePlayerClient> getOnlineAltAccounts() {
+        return kissenPaperPlayerClient.getOnlineAltAccounts();
+    }
+
+    @Override
+    public @NotNull Set<Suffix> getSuffixSet(@NotNull Context context) {
+        return kissenPaperPlayerClient.getSuffixSet(context);
+    }
+
+    @Override
+    public @NotNull Optional<@Nullable Suffix> getSuffix(@NotNull String name, @NotNull Context context) {
+        return kissenPaperPlayerClient.getSuffix(name, context);
+    }
+
+    @Override
+    public @NotNull Optional<@Nullable Suffix> setSuffix(@NotNull String name, @NotNull Component content, Context context) {
+        return kissenPaperPlayerClient.setSuffix(name, content, context);
+    }
+
+    @Override
+    public boolean deleteSuffix(@NotNull String name, @NotNull Context context) {
+        return kissenPaperPlayerClient.deleteSuffix(name, context);
+    }
+
+    @Override
+    public void setSelectedSuffix(@NotNull String name, @NotNull Context context) throws NullPointerException {
+        kissenPaperPlayerClient.setSelectedSuffix(name, context);
+    }
+
+    @Override
+    public long getOnlineTime(@NotNull Context context) {
+        return kissenPaperPlayerClient.getOnlineTime(context);
+    }
+
+    @Override
+    public long getLastPlayed(@NotNull Context context) {
+        return kissenPaperPlayerClient.getLastPlayed(context);
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull Context context) {
+        return kissenPaperPlayerClient.getUser(context);
+    }
+
     @Override
     public @NotNull PaperPermissible getPermissible() throws PermissibleOverriddenException {
-        if (permissible instanceof PaperPermissible paperPermissible) {
-            return paperPermissible;
-        }
-        throw new PermissibleOverriddenException();
+        return kissenPaperPlayerClient.getPermissible();
     }
 
     @Override
     public boolean isPermissionSet(@NotNull String name) {
-        return permissible.isPermissionSet(name);
+        return kissenPaperPlayerClient.isPermissionSet(name);
     }
 
     @Override
     public boolean isPermissionSet(@NotNull Permission perm) {
-        return permissible.isPermissionSet(perm);
+        return kissenPaperPlayerClient.isPermissionSet(perm);
     }
 
     @Override
     public boolean hasPermission(@NotNull String name) {
-        return permissible.hasPermission(name);
+        return kissenPaperPlayerClient.hasPermission(name);
     }
 
     @Override
     public boolean hasPermission(@NotNull Permission perm) {
-        return permissible.hasPermission(perm);
+        return kissenPaperPlayerClient.hasPermission(perm);
     }
 
     @Override
     public @NotNull PermissionAttachment addAttachment(@NotNull Plugin plugin, @NotNull String name, boolean value) {
-        throw new UnsupportedOperationException("Attachment cannot be added to an offline player.");
+        return kissenPaperPlayerClient.addAttachment(plugin, name, value);
     }
 
     @Override
     public @NotNull PermissionAttachment addAttachment(@NotNull Plugin plugin) {
-        throw new UnsupportedOperationException("Attachment cannot be added to an offline player.");
+        return kissenPaperPlayerClient.addAttachment(plugin);
     }
 
     @Override
     public @Nullable PermissionAttachment addAttachment(@NotNull Plugin plugin, @NotNull String name, boolean value, int ticks) {
-        throw new UnsupportedOperationException("Attachment cannot be added to an offline player.");
+        return kissenPaperPlayerClient.addAttachment(plugin, name, value, ticks);
     }
 
     @Override
     public @Nullable PermissionAttachment addAttachment(@NotNull Plugin plugin, int ticks) {
-        throw new UnsupportedOperationException("Attachment cannot be added to an offline player.");
+        return kissenPaperPlayerClient.addAttachment(plugin, ticks);
     }
 
     @Override
     public void removeAttachment(@NotNull PermissionAttachment attachment) {
-        throw new UnsupportedOperationException("Attachment cannot be added to an offline player.");
+        kissenPaperPlayerClient.removeAttachment(attachment);
     }
 
     @Override
     public void recalculatePermissions() {
-        permissible.recalculatePermissions(); // won't do anything
+        kissenPaperPlayerClient.recalculatePermissions();
     }
 
     @Override
     public @NotNull Set<PermissionAttachmentInfo> getEffectivePermissions() {
-        return permissible.getEffectivePermissions();
+        return kissenPaperPlayerClient.getEffectivePermissions();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getOwnPermissions() {
+        return kissenPaperPlayerClient.getOwnPermissions();
+    }
+
+    @Override
+    public int wipeGroups() {
+        return kissenPaperPlayerClient.wipeGroups();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups() {
+        return kissenPaperPlayerClient.getPermissionGroups();
+    }
+
+    @Override
+    public boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup) {
+        return kissenPaperPlayerClient.inGroup(permissionGroup);
+    }
+
+    @Override
+    public @NotNull String getPermissionID() {
+        return kissenPaperPlayerClient.getPermissionID();
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission) throws EventCancelledException {
+        return kissenPaperPlayerClient.setPermission(permission);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, boolean value) throws EventCancelledException {
+        return kissenPaperPlayerClient.setPermission(permission, value);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull PaperPermission permission) throws EventCancelledException {
+        return kissenPaperPlayerClient.setPermission(permission);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission) {
+        return kissenPaperPlayerClient.unsetPermission(permission);
+    }
+
+    @Override
+    public int wipePermissions() {
+        return kissenPaperPlayerClient.wipePermissions();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList() {
+        return kissenPaperPlayerClient.getPermissionList();
+    }
+
+    @Override
+    public @NotNull Optional<@Nullable PaperPermission> getPermission(@NotNull String permission) {
+        return kissenPaperPlayerClient.getPermission(permission);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAffectedPermissionPlayer() {
+        return kissenPaperPlayerClient.getAffectedPermissionPlayer();
+    }
+
+    @Override
+    public void permissionUpdate() {
+        kissenPaperPlayerClient.permissionUpdate();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getOwnPermissions(@NotNull Context context) {
+        return kissenPaperPlayerClient.getOwnPermissions(context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups(@NotNull Context context) {
+        return kissenPaperPlayerClient.getPermissionGroups(context);
+    }
+
+    @Override
+    public boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup, @NotNull Context context) {
+        return kissenPaperPlayerClient.inGroup(permissionGroup, context);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, @NotNull Context context) throws EventCancelledException {
+        return kissenPaperPlayerClient.setPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, boolean value, @NotNull Context context) throws EventCancelledException {
+        return kissenPaperPlayerClient.setPermission(permission, value, context);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull PaperPermission permission, @NotNull Context context) throws EventCancelledException {
+        return kissenPaperPlayerClient.setPermission(permission, context);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission, @NotNull Context context) {
+        return kissenPaperPlayerClient.unsetPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList(@NotNull Context context) {
+        return kissenPaperPlayerClient.getPermissionList(context);
+    }
+
+    @Override
+    public @NotNull Optional<@Nullable PaperPermission> getPermission(@NotNull String permission, @NotNull Context context) {
+        return kissenPaperPlayerClient.getPermission(permission, context);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String permission, @NotNull Context context) {
+        return kissenPaperPlayerClient.hasPermission(permission, context);
     }
     // KissenPaper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 34463796fa75e2a223c034bef19e764e4252f106..aeedb87258d0156f70ab9faa48922d1f88718902 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -959,9 +959,9 @@ public final class CraftServer implements Server {
         // KissenPaper start
         KissenLocalizationImplementation localizationImplementation = KissenCore.getInstance()
                 .getImplementation(KissenLocalizationImplementation.class);
-        Component unknownCommandMessageComponent = localizationImplementation.translate("spigot.unknown-command", localizationImplementation.getDefaultLocale());
+        Component unknownCommandMessageComponent = localizationImplementation.translate("messages.command.error.unknown-command", localizationImplementation.getDefaultLocale());
         if (sender instanceof Player player) {
-            unknownCommandMessageComponent = localizationImplementation.translate("spigot.unknown-command", player.getCurrentLocale());
+            unknownCommandMessageComponent = localizationImplementation.translate("messages.command.error.unknown-command", player.getCurrentLocale());
         }
         String unknownCommandMessage = KissenComponentSerializer.getInstance()
                 .getLegacySerializer()
@@ -1719,7 +1719,7 @@ public final class CraftServer implements Server {
                 .getImplementation(KissenLocalizationImplementation.class);
         return KissenComponentSerializer.getInstance()
                 .getLegacySerializer()
-                .serialize(kissenLocalizationImplementation.translate("bukkit.shutdown-message", kissenLocalizationImplementation.getDefaultLocale()));
+                .serialize(kissenLocalizationImplementation.translate("messages.server.disconnect.server-shutdown", kissenLocalizationImplementation.getDefaultLocale()));
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/command/CraftBlockCommandSender.java b/src/main/java/org/bukkit/craftbukkit/command/CraftBlockCommandSender.java
index f767131230d774b488ad00553defc5de8713640d..b29e4c18793024e3b8786c26c5e8d131ec9f2a00 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/CraftBlockCommandSender.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/CraftBlockCommandSender.java
@@ -42,7 +42,7 @@ public class CraftBlockCommandSender extends ServerCommandSender implements Bloc
     }
 
     @Override
-    public String getName() {
+    public @NotNull String getName() {
         return this.block.getTextName();
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java b/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java
index 1d60bc1a334d8a5f095f0a4b8e963a249493272d..b885cdbf6581d28b4a94be53981031569e039bd0 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java
@@ -1,7 +1,5 @@
 package org.bukkit.craftbukkit.command;
 
-import net.kissenpvp.core.networking.client.entity.KissenConsoleClient;
-import net.kyori.adventure.audience.Audience;
 import org.bukkit.ChatColor;
 import org.bukkit.command.ConsoleCommandSender;
 import org.bukkit.conversations.Conversation;
@@ -15,7 +13,7 @@ import java.util.UUID;
 /**
  * Represents CLI input from a console
  */
-public class CraftConsoleCommandSender extends ServerCommandSender implements ConsoleCommandSender, /* KissenPaper */ KissenConsoleClient {
+public class CraftConsoleCommandSender extends ServerCommandSender implements ConsoleCommandSender {
 
     protected final ConversationTracker conversationTracker = new ConversationTracker();
 
@@ -45,15 +43,8 @@ public class CraftConsoleCommandSender extends ServerCommandSender implements Co
         }
     }
 
-    // KissenPaper start
     @Override
-    public @NotNull Audience getKyoriAudience() {
-        return this;
-    }
-    // KissenPaper end
-
-    @Override
-    public String getName() {
+    public @NotNull String getName() {
         return "CONSOLE";
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/command/CraftRemoteConsoleCommandSender.java b/src/main/java/org/bukkit/craftbukkit/command/CraftRemoteConsoleCommandSender.java
index 48766cdafcf8871a39312ce1da2dbcf04879f0fd..2ff1a2d1e2b2ec5e98a142262dfb0e862c283d31 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/CraftRemoteConsoleCommandSender.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/CraftRemoteConsoleCommandSender.java
@@ -26,7 +26,7 @@ public class CraftRemoteConsoleCommandSender extends ServerCommandSender impleme
     }
 
     @Override
-    public String getName() {
+    public @NotNull String getName() {
         return "Rcon";
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/command/ProxiedNativeCommandSender.java b/src/main/java/org/bukkit/craftbukkit/command/ProxiedNativeCommandSender.java
index 47c509876d011d3da0dee0200bb2eddb8f978bd8..5340298abfe3e007b1a29f913375e9c83ac61f87 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/ProxiedNativeCommandSender.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/ProxiedNativeCommandSender.java
@@ -67,7 +67,7 @@ public class ProxiedNativeCommandSender implements ProxiedCommandSender {
     }
 
     @Override
-    public String getName() {
+    public @NotNull String getName() {
         return this.getCallee().getName();
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index 344e1c40de51a73d1465f8e2427fb93fd2b3e365..79ba5124c8502420ed5c215a3c63f900197ee7f2 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -785,7 +785,7 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
     }
 
     @Override
-    public UUID getUniqueId() {
+    public @NotNull UUID getUniqueId() {
         return this.getHandle().getUUID();
     }
 
@@ -1011,7 +1011,7 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
     }
 
     @Override
-    public String getName() {
+    public @NotNull String getName() {
         return CraftChatMessage.fromComponent(this.getHandle().getName());
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
index e2978399f9a1e111ac8bd82eddb7839b8ad91485..6f8dee4dabc5c8d64cef347289d7b33aaaa8f13c 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
@@ -2,7 +2,7 @@ package org.bukkit.craftbukkit.entity;
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableSet;
-import net.kissenpvp.paper.permission.KissenPaperPlayerPermissible;
+import net.kissenpvp.paper.permission.permissible.KissenPaperPlayerPermissible;
 import net.minecraft.core.BlockPos;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.network.chat.Component;
@@ -49,6 +49,7 @@ import org.bukkit.permissions.Permission;
 import org.bukkit.permissions.PermissionAttachment;
 import org.bukkit.permissions.PermissionAttachmentInfo;
 import org.bukkit.plugin.Plugin;
+import org.jetbrains.annotations.NotNull;
 
 import java.util.*;
 
@@ -195,7 +196,7 @@ public class CraftHumanEntity extends CraftLivingEntity implements HumanEntity {
     }
 
     @Override
-    public String getName() {
+    public @NotNull String getName() {
         return this.getHandle().getScoreboardName();
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftMinecartCommand.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftMinecartCommand.java
index b709a1d909c189f60d0c3aa97b4b96623e7c1db0..02ecae0b4cc3203397635b52fd88c89e652742f3 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftMinecartCommand.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftMinecartCommand.java
@@ -13,6 +13,7 @@ import org.bukkit.permissions.Permission;
 import org.bukkit.permissions.PermissionAttachment;
 import org.bukkit.permissions.PermissionAttachmentInfo;
 import org.bukkit.plugin.Plugin;
+import org.jetbrains.annotations.NotNull;
 
 public class CraftMinecartCommand extends CraftMinecart implements CommandMinecart, io.papermc.paper.commands.PaperCommandBlockHolder {
     private final PermissibleBase perm = new PermissibleBase(this);
@@ -61,7 +62,7 @@ public class CraftMinecartCommand extends CraftMinecart implements CommandMineca
     }
 
     @Override
-    public String getName() {
+    public @NotNull String getName() {
         return CraftChatMessage.fromComponent(this.getHandle().getCommandBlock().getName());
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 507c233374dedbafc23c787fc66e2ff3b67f5649..1259b1bb82b4c2bdf2b73fd0ca2246384155b137 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -11,15 +11,29 @@ import io.netty.channel.Channel;
 import it.unimi.dsi.fastutil.shorts.ShortArraySet;
 import it.unimi.dsi.fastutil.shorts.ShortSet;
 import net.kissenpvp.core.api.ban.Ban;
+import net.kissenpvp.core.api.ban.BanOperator;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.message.Theme;
 import net.kissenpvp.core.api.networking.client.entitiy.ServerEntity;
+import net.kissenpvp.core.api.permission.PermissionGroup;
 import net.kissenpvp.core.api.user.User;
-import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.api.user.rank.Rank;
+import net.kissenpvp.core.api.user.suffix.Suffix;
+import net.kissenpvp.core.api.user.usersetttings.PlayerSetting;
+import net.kissenpvp.core.api.user.usersetttings.UserSetting;
 import net.kissenpvp.core.base.KissenCore;
 import net.kissenpvp.core.user.KissenUserImplementation;
+import net.kissenpvp.paper.api.ban.PaperPunishment;
+import net.kissenpvp.paper.api.base.Context;
+import net.kissenpvp.paper.api.networking.client.entity.PaperOnlinePlayerClient;
 import net.kissenpvp.paper.api.permission.PaperPermissible;
+import net.kissenpvp.paper.api.permission.PaperPermission;
 import net.kissenpvp.paper.api.permission.PermissibleOverriddenException;
+import net.kissenpvp.paper.api.user.rank.PaperPlayerRank;
 import net.kissenpvp.paper.networking.client.entity.KissenPaperOnlinePlayerClient;
-import net.kissenpvp.paper.permission.KissenPaperPermissible;
+import net.kissenpvp.paper.permission.permissible.KissenPaperPermissible;
+import net.kissenpvp.paper.permission.permissible.KissenPaperPlayerPermissible;
 import net.kyori.adventure.audience.Audience;
 import net.md_5.bungee.api.chat.BaseComponent;
 import net.minecraft.advancements.AdvancementProgress;
@@ -100,6 +114,7 @@ import org.bukkit.plugin.Plugin;
 import org.bukkit.plugin.messaging.StandardMessenger;
 import org.bukkit.scoreboard.Scoreboard;
 import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
 
 import javax.annotation.Nullable;
 import java.io.ByteArrayOutputStream;
@@ -115,7 +130,7 @@ import java.util.logging.Level;
 import java.util.logging.Logger;
 
 @DelegateDeserialization(CraftOfflinePlayer.class)
-public class CraftPlayer extends CraftHumanEntity implements Player, /* KissenPaper */ KissenPaperOnlinePlayerClient {
+public class CraftPlayer extends CraftHumanEntity implements Player {
     private long firstPlayed = 0;
     private long lastPlayed = 0;
     private boolean hasPlayedBefore = false;
@@ -136,6 +151,10 @@ public class CraftPlayer extends CraftHumanEntity implements Player, /* KissenPa
     private long lastSaveTime;
     // Paper end
 
+    // KissenPaper start
+    private final KissenPaperOnlinePlayerClient kissenPaperPlayer = new KissenPaperOnlinePlayerClient(new KissenPaperPlayerPermissible(this));
+    // KissenPaper end
+
     public CraftPlayer(CraftServer server, ServerPlayer entity) {
         super(server, entity);
 
@@ -556,7 +575,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player, /* KissenPa
     }
 
     @Override
-    public void kick(final net.kyori.adventure.text.Component message) {
+    public void kick(final net.kyori.adventure.text.@NotNull Component message) {
         kick(message, org.bukkit.event.player.PlayerKickEvent.Cause.PLUGIN);
     }
 
@@ -576,7 +595,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player, /* KissenPa
     }
 
     @Override
-    public void sendPacket(Object o) {
+    public void sendPacket(@NotNull Object o) {
         getHandle().connection.connection.send((Packet<?>) o);
     }
     // KissenPaper end
@@ -945,18 +964,6 @@ public class CraftPlayer extends CraftHumanEntity implements Player, /* KissenPa
         this.sendBlockChanges(blocks);
     }
 
-    // KissenPaper start
-    @Override
-    public @org.jetbrains.annotations.Nullable String getCurrentServer() {
-        return KissenPaperOnlinePlayerClient.super.getCurrentServer();
-    }
-
-    @Override
-    public int warn(@NotNull Ban ban, @NotNull ServerEntity warnOperator) {
-        return KissenPaperOnlinePlayerClient.super.warn(ban, warnOperator);
-    }
-    // KissenPaper end
-
     private record ChunkSectionChanges(ShortSet positions,
                                        List<net.minecraft.world.level.block.state.BlockState> blockData) {
 
@@ -3261,21 +3268,301 @@ public class CraftPlayer extends CraftHumanEntity implements Player, /* KissenPa
     }
     // Spigot end
 
-    // KissenPaper start
+    // KissenPaper start - integrate user things
+
     @Override
-    public @NotNull PaperPermissible getPermissible() throws PermissibleOverriddenException {
-        if (perm instanceof PaperPermissible permissible) {
-            return permissible;
-        }
-        throw new PermissibleOverriddenException();
+    public @NotNull @Unmodifiable Set<UUID> getAltAccounts() throws BackendException {
+        return kissenPaperPlayer.getAltAccounts();
+    }
+
+    @Override
+    public @NotNull UUID getTotalID() {
+        return kissenPaperPlayer.getTotalID();
+    }
+
+    @Override
+    public @NotNull PaperPunishment ban(@NotNull Ban ban, @NotNull BanOperator banOperator) throws BackendException {
+        return kissenPaperPlayer.ban(ban, banOperator);
+    }
+
+    @Override
+    public @NotNull PaperPunishment ban(@NotNull Ban ban, @NotNull BanOperator banOperator, net.kyori.adventure.text.@org.jetbrains.annotations.Nullable Component reason) throws BackendException {
+        return kissenPaperPlayer.ban(ban, banOperator, reason);
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable PaperPunishment> getBan(@NotNull String id) throws BackendException {
+        return kissenPaperPlayer.getBan(id);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<PaperPunishment> getBanHistory() throws BackendException {
+        return kissenPaperPlayer.getBanHistory();
+    }
+
+    @Override
+    public net.kyori.adventure.text.@NotNull Component styledRankName() {
+        return kissenPaperPlayer.styledRankName();
+    }
+
+    @Override
+    public @NotNull Set<Suffix> getSuffixSet() {
+        return kissenPaperPlayer.getSuffixSet();
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable Suffix> getSuffix(@NotNull String name) {
+        return kissenPaperPlayer.getSuffix(name);
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable Suffix> setSuffix(@NotNull String name, net.kyori.adventure.text.@NotNull Component content) {
+        return kissenPaperPlayer.setSuffix(name, content);
+    }
+
+    @Override
+    public boolean deleteSuffix(@NotNull String name) {
+        return kissenPaperPlayer.deleteSuffix(name);
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable Suffix> getSelectedSuffix() {
+        return kissenPaperPlayer.getSelectedSuffix();
+    }
+
+    @Override
+    public void setSelectedSuffix(@NotNull String name) throws NullPointerException {
+        kissenPaperPlayer.setSelectedSuffix(name);
+    }
+
+    @Override
+    public long getOnlineTime() {
+        return kissenPaperPlayer.getOnlineTime();
     }
 
     @Override
     public @NotNull User getUser() {
-        return Bukkit.getKissen()
-                .getImplementation(UserImplementation.class)
-                .getOnlineUser(getUniqueId())
-                .orElseThrow(IllegalStateException::new);
+        return kissenPaperPlayer.getUser();
+    }
+
+    @Override
+    public @NotNull <X> UserSetting<X> getUserSetting(Class<? extends PlayerSetting<X>> settingClass) {
+        return kissenPaperPlayer.getUserSetting(settingClass);
+    }
+
+    @Override
+    public @NotNull Theme getTheme() {
+        return kissenPaperPlayer.getTheme();
+    }
+
+    @Override
+    public void kick(@NotNull String message) {
+        kissenPaperPlayer.kick(message);
+    }
+
+    @Override
+    public void killConnection() {
+        kissenPaperPlayer.killConnection();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.Nullable String getCurrentServer() {
+        return kissenPaperPlayer.getCurrentServer();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<PaperPlayerRank> getRankHistory() {
+        return kissenPaperPlayer.getRankHistory();
+    }
+
+    @Override
+    public @NotNull PaperPlayerRank getRank() {
+        return kissenPaperPlayer.getRank();
+    }
+
+    @Override
+    public @NotNull PaperPlayerRank grantRank(@NotNull Rank rank) {
+        return kissenPaperPlayer.grantRank(rank);
+    }
+
+    @Override
+    public @NotNull PaperPlayerRank grantRank(@NotNull Rank rank, @org.jetbrains.annotations.Nullable Duration duration) {
+        return kissenPaperPlayer.grantRank(rank, duration);
+    }
+
+    @Override
+    public int warn(@NotNull Ban ban, @NotNull ServerEntity warnOperator) {
+        return kissenPaperPlayer.warn(ban, warnOperator);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<@NotNull PaperOnlinePlayerClient> getOnlineAltAccounts() {
+        return kissenPaperPlayer.getOnlineAltAccounts();
+    }
+
+    @Override
+    public @NotNull Set<Suffix> getSuffixSet(@NotNull Context context) {
+        return kissenPaperPlayer.getSuffixSet(context);
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable Suffix> getSuffix(@NotNull String name, @NotNull Context context) {
+        return kissenPaperPlayer.getSuffix(name, context);
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable Suffix> setSuffix(@NotNull String name, net.kyori.adventure.text.@NotNull Component content, Context context) {
+        return kissenPaperPlayer.setSuffix(name, content);
+    }
+
+    @Override
+    public boolean deleteSuffix(@NotNull String name, @NotNull Context context) {
+        return kissenPaperPlayer.deleteSuffix(name, context);
+    }
+
+    @Override
+    public void setSelectedSuffix(@NotNull String name, @NotNull Context context) throws NullPointerException {
+        kissenPaperPlayer.setSelectedSuffix(name, context);
+    }
+
+    @Override
+    public long getOnlineTime(@NotNull Context context) {
+        return kissenPaperPlayer.getOnlineTime(context);
+    }
+
+    @Override
+    public long getLastPlayed(@NotNull Context context) {
+        return kissenPaperPlayer.getLastPlayed(context);
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull Context context) {
+        return kissenPaperPlayer.getUser(context);
+    }
+
+    @Override
+    public @NotNull PaperPermissible getPermissible() throws PermissibleOverriddenException {
+        return kissenPaperPlayer.getPermissible();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getOwnPermissions() {
+        return kissenPaperPlayer.getOwnPermissions();
+    }
+
+    @Override
+    public int wipeGroups() {
+        return kissenPaperPlayer.wipeGroups();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups() {
+        return kissenPaperPlayer.getPermissionGroups();
+    }
+
+    @Override
+    public boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup) {
+        return kissenPaperPlayer.inGroup(permissionGroup);
+    }
+
+    @Override
+    public @NotNull String getPermissionID() {
+        return kissenPaperPlayer.getPermissionID();
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission) throws EventCancelledException {
+        return kissenPaperPlayer.setPermission(permission);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, boolean value) throws EventCancelledException {
+        return kissenPaperPlayer.setPermission(permission, value);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull PaperPermission permission) throws EventCancelledException {
+        return kissenPaperPlayer.setPermission(permission);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission) {
+        return kissenPaperPlayer.unsetPermission(permission);
+    }
+
+    @Override
+    public int wipePermissions() {
+        return kissenPaperPlayer.wipePermissions();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList() {
+        return kissenPaperPlayer.getPermissionList();
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable PaperPermission> getPermission(@NotNull String permission) {
+        return kissenPaperPlayer.getPermission(permission);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAffectedPermissionPlayer() {
+        return kissenPaperPlayer.getAffectedPermissionPlayer();
+    }
+
+    @Override
+    public void permissionUpdate() {
+        kissenPaperPlayer.permissionUpdate();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getOwnPermissions(@NotNull Context context) {
+        return kissenPaperPlayer.getOwnPermissions(context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup<PaperPermission>> getPermissionGroups(@NotNull Context context) {
+        return kissenPaperPlayer.getPermissionGroups(context);
+    }
+
+    @Override
+    public boolean inGroup(@NotNull PermissionGroup<PaperPermission> permissionGroup, @NotNull Context context) {
+        return kissenPaperPlayer.inGroup(permissionGroup, context);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, @NotNull Context context) throws EventCancelledException {
+        return kissenPaperPlayer.setPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull String permission, boolean value, @NotNull Context context) throws EventCancelledException {
+        return kissenPaperPlayer.setPermission(permission, value, context);
+    }
+
+    @Override
+    public @NotNull PaperPermission setPermission(@NotNull PaperPermission permission, @NotNull Context context) throws EventCancelledException {
+        return kissenPaperPlayer.setPermission(permission, context);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission, @NotNull Context context) {
+        return kissenPaperPlayer.unsetPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PaperPermission> getPermissionList(@NotNull Context context) {
+        return kissenPaperPlayer.getPermissionList(context);
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable PaperPermission> getPermission(@NotNull String permission, @NotNull Context context) {
+        return kissenPaperPlayer.getPermission(permission, context);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String permission, @NotNull Context context) {
+        return kissenPaperPlayer.hasPermission(permission, context);
     }
     // KissenPaper end
 }
diff --git a/src/main/java/org/spigotmc/RestartCommand.java b/src/main/java/org/spigotmc/RestartCommand.java
index b25e0271365519e5941dbc24af85143f04007095..c3f3e9d2500b340254a12dc3b9e82af5ae0b9381 100644
--- a/src/main/java/org/spigotmc/RestartCommand.java
+++ b/src/main/java/org/spigotmc/RestartCommand.java
@@ -66,8 +66,7 @@ public class RestartCommand extends Command {
             // Kick all players
             for (ServerPlayer p : com.google.common.collect.ImmutableList.copyOf(MinecraftServer.getServer()
                     .getPlayerList().players)) {
-                Component restartMessage = kissenLocalizationImplementation.translate("spigot.restart", p.getBukkitEntity()
-                        .getCurrentLocale());
+                Component restartMessage = kissenLocalizationImplementation.translate("messages.server.disconnect.server-restart", p.getBukkitEntity().getCurrentLocale());
                 p.connection.disconnect(/* KissenPaper */ restartMessage /* SpigotConfig.restartMessage */, org.bukkit.event.player.PlayerKickEvent.Cause.RESTART_COMMAND); // Paper - kick event reason (cause is never used))
             }
             // KissenPaper end
