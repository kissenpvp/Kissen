From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Groldi <chniucg@gmail.com>
Date: Fri, 15 Sep 2023 22:45:32 +0200
Subject: [PATCH] Implemented core player system


diff --git a/src/main/java/com/destroystokyo/paper/profile/CraftPlayerProfile.java b/src/main/java/com/destroystokyo/paper/profile/CraftPlayerProfile.java
index cbe2789f8a055550dd7840a7bed980efd65eb9a1..fb9c49ada7695b5bba2528404903cbc71db79cfb 100644
--- a/src/main/java/com/destroystokyo/paper/profile/CraftPlayerProfile.java
+++ b/src/main/java/com/destroystokyo/paper/profile/CraftPlayerProfile.java
@@ -419,4 +419,12 @@ public class CraftPlayerProfile implements PlayerProfile, SharedPlayerProfile {
             }
         }
     }
+
+    // Pulvinar start
+    @Override
+    public @org.jetbrains.annotations.NotNull net.kissenpvp.core.api.user.User getUser()
+    {
+        return org.bukkit.Bukkit.getPulvinar().getImplementation(net.kissenpvp.core.api.user.UserImplementation.class).getUser(java.util.Objects.requireNonNull(getId()));
+    }
+    // Pulvinar end
 }
diff --git a/src/main/java/io/papermc/paper/brigadier/NullCommandSender.java b/src/main/java/io/papermc/paper/brigadier/NullCommandSender.java
index 367ef7e0769537e8c13c7fd818a1249e15a28a65..faf8f4edad25c6fbacef2de47b02cab553cd20e2 100644
--- a/src/main/java/io/papermc/paper/brigadier/NullCommandSender.java
+++ b/src/main/java/io/papermc/paper/brigadier/NullCommandSender.java
@@ -1,5 +1,6 @@
 package io.papermc.paper.brigadier;
 
+import java.util.Locale;
 import java.util.Set;
 import java.util.UUID;
 import net.kyori.adventure.text.Component;
@@ -148,4 +149,21 @@ public final class NullCommandSender implements CommandSender {
     @Override
     public void setOp(final boolean value) {
     }
+    
+    // Pulvinar start
+    @Override
+    public @NotNull Locale getCurrentLocale() {
+        return org.bukkit.Bukkit.getPulvinar().getImplementation(net.kissenpvp.core.api.message.localization.LocalizationImplementation.class).getDefaultLocale();
+    }
+
+    @Override
+    public boolean isConnected() {
+        return true;
+    }
+
+    @Override
+    public boolean isClient() {
+        return true;
+    }
+    // Pulvinar end
 }
diff --git a/src/main/java/io/papermc/paper/plugin/manager/PaperPluginManagerImpl.java b/src/main/java/io/papermc/paper/plugin/manager/PaperPluginManagerImpl.java
index 83717633afdf4d97ea3cf58dcc4dcda675c79b31..341bd527b6d5a955f23f22b352d14a4df964b353 100644
--- a/src/main/java/io/papermc/paper/plugin/manager/PaperPluginManagerImpl.java
+++ b/src/main/java/io/papermc/paper/plugin/manager/PaperPluginManagerImpl.java
@@ -249,5 +249,10 @@ public class PaperPluginManagerImpl implements PluginManager, DependencyContext
     {
         org.bukkit.Bukkit.getPulvinar().getImplementation(net.kissenpvp.core.api.config.ConfigurationImplementation.class).registerSetting(plugin, setting);
     }
+
+    @Override
+    public void registerPlayerSetting(@NotNull net.kissenpvp.core.api.user.playersettting.AbstractPlayerSetting<?, ? extends org.bukkit.OfflinePlayer> playerSetting, @NotNull Plugin plugin) {
+        org.bukkit.Bukkit.getPulvinar().getImplementation(net.kissenpvp.core.api.user.UserImplementation.class).registerPlayerSetting(plugin, playerSetting);
+    }
     // Pulvinar end
 }
diff --git a/src/main/java/net/kissenpvp/pulvinar/base/PulvinarCore.java b/src/main/java/net/kissenpvp/pulvinar/base/PulvinarCore.java
index dc322ad654a8a879d5b11c0bec6c704927366099..2bdd4e9ff1b7ebf5c820c17010c663dccd314c39 100644
--- a/src/main/java/net/kissenpvp/pulvinar/base/PulvinarCore.java
+++ b/src/main/java/net/kissenpvp/pulvinar/base/PulvinarCore.java
@@ -49,6 +49,11 @@ public class PulvinarCore extends KissenCore implements Pulvinar {
     protected void loadImplementations(@NotNull Map<Class<? extends Implementation>, Implementation> loader) {
         loader.put(net.kissenpvp.core.api.config.ConfigurationImplementation.class, new net.kissenpvp.pulvinar.config.PulvinarConfigurationImplementation());
         loader.put(net.kissenpvp.core.event.EventImplementation.class, new net.kissenpvp.pulvinar.event.KissenEventImplementation());
+        loader.put(net.kissenpvp.core.api.user.UserImplementation.class, new net.kissenpvp.pulvinar.user.PulvinarUserImplementation());
+        loader.put(net.kissenpvp.pulvinar.api.user.rank.RankImplementation.class, new net.kissenpvp.pulvinar.user.rank.PulvinarRankImplementation());
+        net.kissenpvp.pulvinar.permission.PulvinarPermissionImplementation permissionImplementation = new net.kissenpvp.pulvinar.permission.PulvinarPermissionImplementation();
+        loader.put(net.kissenpvp.pulvinar.api.permission.PermissionImplementation.class, permissionImplementation);
+        loader.put(net.kissenpvp.core.permission.InternalPermissionImplementation.class, permissionImplementation);
         super.loadImplementations(loader);
     }
 
diff --git a/src/main/java/net/kissenpvp/pulvinar/networking/client/entity/InternalPulvinarOnlinePlayerClient.java b/src/main/java/net/kissenpvp/pulvinar/networking/client/entity/InternalPulvinarOnlinePlayerClient.java
new file mode 100644
index 0000000000000000000000000000000000000000..6bf95a6ba833df5733076befc3d3d030548fa289
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/networking/client/entity/InternalPulvinarOnlinePlayerClient.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.pulvinar.networking.client.entity;
+
+import net.kissenpvp.core.api.ban.AbstractBanTemplate;
+import net.kissenpvp.pulvinar.api.ban.BanTemplate;
+import net.kissenpvp.pulvinar.api.ban.warn.Warn;
+import io.netty.channel.Channel;
+import net.kissenpvp.core.api.base.KissenServer;
+import net.kissenpvp.core.api.networking.client.entitiy.ServerEntity;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.pulvinar.api.base.Context;
+import net.kissenpvp.pulvinar.api.networking.client.entity.PulvinarOnlinePlayerClient;
+import net.kyori.adventure.audience.Audience;
+import net.kyori.adventure.key.Key;
+import net.kyori.adventure.sound.Sound;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.kyori.adventure.text.minimessage.MiniMessage;
+import net.kyori.adventure.title.Title;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.entity.Player;
+import org.bukkit.potion.PotionEffect;
+import org.bukkit.potion.PotionEffectType;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Objects;
+
+public abstract class InternalPulvinarOnlinePlayerClient extends InternalPulvinarPlayerClient implements PulvinarOnlinePlayerClient {
+
+    public abstract @NotNull CraftPlayer getCraftPlayer();
+
+    @Override
+    public @NotNull User getUser() {
+        return getCraftPlayer().getUser();
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull Context context) {
+        return getCraftPlayer().getUser(context);
+    }
+
+    @Override
+    public @NotNull Warn warn(@NotNull BanTemplate ban, @NotNull ServerEntity warnOperator, @Nullable Component reason)
+    {
+        Component title = Component.translatable("server.ban.player.warned.target", Component.text(ban.getName())).color(NamedTextColor.RED);
+
+        Player player = Bukkit.getPlayer(getUniqueId());
+        assert player != null;
+        player.showTitle(Title.title(title, Objects.requireNonNullElseGet(reason, Component::empty)));
+        player.playSound(Sound.sound(Key.key("minecraft:block.anvil.destroy"), Sound.Source.MASTER, .5f, 1f));
+        player.addPotionEffect(new PotionEffect(PotionEffectType.BLINDNESS, 100, 255));
+
+        return super.warn(ban, warnOperator, reason);
+    }
+
+    @Override
+    public final boolean isConnected() {
+        return true;
+    }
+
+    @Override
+    public void kick(@NotNull String message) {
+        kick(MiniMessage.miniMessage().deserialize(message));
+    }
+
+    @Override
+    public void kick(@NotNull Component component) {
+        getCraftPlayer().kick(component);
+    }
+
+    @Override
+    public void killConnection() {
+        getConnection().close();
+    }
+
+    @Override
+    public @NotNull Channel getConnection() {
+        return getCraftPlayer().getHandle().connection.connection.channel;
+    }
+
+    @Override
+    public void sendPacket(@NotNull Object object) throws ClassCastException {
+        getCraftPlayer().getHandle().connection.send((Packet<?>) object);
+    }
+
+    @Override
+    public @Nullable KissenServer getCurrentServer() {
+        return MinecraftServer.getServer();
+    }
+
+    @Override
+    public @NotNull Audience getKyoriAudience() {
+        return getCraftPlayer();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/networking/client/entity/InternalPulvinarPlayerClient.java b/src/main/java/net/kissenpvp/pulvinar/networking/client/entity/InternalPulvinarPlayerClient.java
new file mode 100644
index 0000000000000000000000000000000000000000..d637dfb63bb0866be7377d8e8a8d72bc6335d174
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/networking/client/entity/InternalPulvinarPlayerClient.java
@@ -0,0 +1,180 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.pulvinar.networking.client.entity;
+
+import net.kissenpvp.core.api.database.DataWriter;
+import net.kissenpvp.core.api.time.AccurateDuration;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.api.user.UserImplementation;
+<<<<<<< Updated upstream
+<<<<<<< Updated upstream
+<<<<<<< Updated upstream
+=======
+=======
+import net.kissenpvp.core.api.user.rank.event.AbstractAsyncRankExpiredEvent;
+import net.kissenpvp.core.ban.warn.WarnNode;
+>>>>>>> Stashed changes
+import net.kissenpvp.core.api.user.rank.event.AbstractAsyncRankExpireEvent;
+<<<<<<< Updated upstream
+import net.kissenpvp.core.ban.warn.WarnNode;
+>>>>>>> Stashed changes
+=======
+import net.kissenpvp.core.api.user.rank.event.AbstractAsyncRankExpireEvent;
+import net.kissenpvp.core.api.user.rank.event.AbstractPostAsyncRankExpireEvent;
+>>>>>>> Stashed changes
+import net.kissenpvp.core.networking.client.entity.KissenPlayerClient;
+import net.kissenpvp.core.user.rank.PlayerRankNode;
+import net.kissenpvp.core.user.rank.event.InternalAsyncRankExpireEvent;
+import net.kissenpvp.core.user.rank.event.InternalAsyncRankExpiredEvent;
+=======
+import net.kissenpvp.core.networking.client.entity.KissenPlayerClient;
+import net.kissenpvp.core.user.rank.PlayerRankNode;
+import net.kissenpvp.core.user.rank.event.InternalAsyncRankExpireEvent;
+>>>>>>> Stashed changes
+import net.kissenpvp.core.user.rank.event.InternalRankGrantEvent;
+import net.kissenpvp.pulvinar.api.ban.Punishment;
+import net.kissenpvp.pulvinar.api.base.Context;
+import net.kissenpvp.pulvinar.api.networking.client.entity.PulvinarOnlinePlayerClient;
+import net.kissenpvp.pulvinar.api.networking.client.entity.PulvinarPlayerClient;
+import net.kissenpvp.pulvinar.api.permission.PermissibleOverriddenException;
+import net.kissenpvp.pulvinar.api.user.playersetting.BoundPlayerSetting;
+import net.kissenpvp.pulvinar.api.user.playersetting.PlayerSetting;
+import net.kissenpvp.pulvinar.api.user.rank.PlayerRank;
+import net.kissenpvp.pulvinar.api.user.rank.event.AsyncRankExpireEvent;
+import net.kissenpvp.pulvinar.api.user.rank.event.PostAsyncRankExpireEvent;
+import net.kissenpvp.pulvinar.api.user.rank.event.RankGrantEvent;
+import net.kissenpvp.pulvinar.permission.permissible.PulvinarPermissible;
+import net.kissenpvp.pulvinar.user.PulvinarPublicUser;
+import net.kissenpvp.pulvinar.user.playersetting.PulvinarBoundPlayerSetting;
+import net.kissenpvp.pulvinar.user.rank.PulvinarPlayerRank;
+import net.kissenpvp.pulvinar.user.rank.PulvinarPlayerFallBackRank;
+import net.kissenpvp.pulvinar.user.rank.event.PulvinarAsyncRankExpireEvent;
+import net.kissenpvp.pulvinar.user.rank.event.PulvinarPostAsyncRankExpireEvent;
+import net.kissenpvp.pulvinar.user.rank.event.PulvinarRankGrantEvent;
+import org.bukkit.Bukkit;
+import org.bukkit.OfflinePlayer;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Set;
+import java.util.stream.Collectors;
+
+<<<<<<< Updated upstream
+=======
+// Ban System
+import net.kissenpvp.core.api.time.TemporalData;
+import net.kissenpvp.core.api.database.meta.list.MetaList;
+import net.kissenpvp.core.api.networking.client.entitiy.ServerEntity;
+import net.kissenpvp.pulvinar.api.ban.BanTemplate;
+import net.kissenpvp.pulvinar.api.ban.warn.Warn;
+import net.kyori.adventure.text.Component;
+import org.jetbrains.annotations.Contract;
+import java.time.Period;
+import java.util.List;
+import java.util.function.Function;
+
+>>>>>>> Stashed changes
+public abstract class InternalPulvinarPlayerClient extends KissenPlayerClient<PlayerRank, Punishment> implements PulvinarPlayerClient {
+
+    @Override
+    public @NotNull User getUser() {
+        return Bukkit.getPulvinar().getImplementation(UserImplementation.class).getUser(getUniqueId());
+    }
+
+    @Override
+    protected @NotNull PlayerRank translateRank(@NotNull PlayerRankNode playerRankNode, @Nullable DataWriter<PlayerRankNode> dataWriter) {
+        return new PulvinarPlayerRank(Bukkit.getOfflinePlayer(getUniqueId()), playerRankNode, dataWriter);
+    }
+
+    @Override
+    protected @NotNull PlayerRank fallbackRank() {
+        return new PulvinarPlayerFallBackRank(Bukkit.getOfflinePlayer(getUniqueId()));
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<@NotNull PulvinarOnlinePlayerClient> getOnlineAltAccounts() {
+        return Bukkit.getOnlinePlayers().stream().filter(client -> client.getTotalID().equals(getTotalID())).collect(Collectors.toSet());
+    }
+
+    @Override
+    public @NotNull AccurateDuration getOnlineTime() {
+        return getOnlineTime(Context.LOCAL);
+    }
+
+    @Override
+    protected @NotNull InternalAsyncRankExpireEvent<PlayerRank> rankExpireEvent(@NotNull PlayerRank rank) {
+        AsyncRankExpireEvent rankExpireEvent = new PulvinarAsyncRankExpireEvent(AbstractAsyncRankExpireEvent.ExpiryCause.AUTOMATIC, rank);
+        Bukkit.getPluginManager().callEvent(rankExpireEvent);
+        return (InternalAsyncRankExpireEvent<PlayerRank>) rankExpireEvent;
+    }
+
+    @Override
+    protected void rankExpiredEvent(@NotNull PlayerRank rank) {
+        PostAsyncRankExpireEvent rankExpireEvent = new PulvinarPostAsyncRankExpireEvent(AbstractPostAsyncRankExpireEvent.ExpiryCause.AUTOMATIC, rank);
+        Bukkit.getPluginManager().callEvent(rankExpireEvent);
+    }
+
+    @Override
+    protected @NotNull InternalRankGrantEvent<PlayerRank> grantRankEvent(@NotNull PlayerRank rank) {
+        RankGrantEvent rankGrantEvent = new PulvinarRankGrantEvent(getRank(), rank);
+        Bukkit.getPluginManager().callEvent(rankGrantEvent);
+        return (InternalRankGrantEvent<PlayerRank>) rankGrantEvent;
+    }
+
+    @Override
+    public @NotNull AccurateDuration getOnlineTime(@NotNull Context context) {
+        return getOnlineTime(getUser(context));
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull Context context) {
+        PulvinarPublicUser pulvinarUser = (PulvinarPublicUser) getUser();
+        return switch (context) {
+            case GLOBAL -> pulvinarUser;
+            case LOCAL -> pulvinarUser.getPrivateUserEntry();
+        };
+    }
+
+    @Override
+    public @NotNull <X> BoundPlayerSetting<X> getSetting(@NotNull Class<? extends PlayerSetting<X>> settingClass) {
+        return getSetting(settingClass, Context.LOCAL);
+    }
+
+    @Override
+    public @NotNull <X> BoundPlayerSetting<X> getSetting(@NotNull Class<? extends PlayerSetting<X>> settingClass, @NotNull Context context) {
+        OfflinePlayer offlinePlayer = Bukkit.getOfflinePlayer(getUniqueId());
+        return new PulvinarBoundPlayerSetting<>(getPlayerSetting(settingClass), offlinePlayer);
+    }
+
+    /**
+     * Returns the permissible as a {@link PulvinarPermissible} featuring advanced permission features.
+     *
+     * @return the context as permissible
+     * @throws PermissibleOverriddenException when a plugin has been installed which alters the permissible
+     */
+    public @NotNull PulvinarPermissible getPermissionContext() throws PermissibleOverriddenException {
+        return (PulvinarPermissible) getPermissible();
+    }
+
+    @Override
+    public void clearActiveWarns() {
+        //TODO
+    }
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/permission/AttachmentAbstractPermission.java b/src/main/java/net/kissenpvp/pulvinar/permission/AttachmentAbstractPermission.java
new file mode 100644
index 0000000000000000000000000000000000000000..9290ffe3bf54efe1271d8613a304b9420a26a44f
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/permission/AttachmentAbstractPermission.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.pulvinar.permission;
+
+import net.kissenpvp.core.api.permission.AbstractPermission;
+import net.kissenpvp.core.api.permission.AbstractPermissionEntry;
+import net.kissenpvp.core.permission.PermissionNode;
+import net.kissenpvp.core.api.time.TemporalData;
+import org.bukkit.permissions.PermissionAttachment;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class AttachmentAbstractPermission extends PulvinarPermission {
+
+    private final PermissionAttachment permissionAttachment;
+
+    public AttachmentAbstractPermission(@NotNull String permission, boolean value, @NotNull AbstractPermissionEntry<? extends AbstractPermission> permissionEntry, boolean immutable) {
+        this(null, permission, value, permissionEntry, immutable);
+    }
+
+    public AttachmentAbstractPermission(@Nullable PermissionAttachment permissionAttachment, @NotNull String permission, boolean value, @NotNull AbstractPermissionEntry<? extends AbstractPermission> permissionEntry, boolean immutable) {
+        super(new PermissionNode(permission, permissionEntry, value, new TemporalData()), permissionEntry, immutable ? null : (record) -> { /* ignored */ });
+        this.permissionAttachment = permissionAttachment;
+    }
+
+    public PermissionAttachment getPermissionAttachment() {
+        return permissionAttachment;
+    }
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/permission/PermissionCommand.java b/src/main/java/net/kissenpvp/pulvinar/permission/PermissionCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..1f467f4d9285c779260c9a6f6a62f1c9adb2f3c1
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/permission/PermissionCommand.java
@@ -0,0 +1,287 @@
+package net.kissenpvp.pulvinar.permission;
+
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.core.api.command.annotations.ArgumentName;
+import net.kissenpvp.core.api.command.annotations.CommandData;
+import net.kissenpvp.core.api.util.PageBuilder;
+import net.kissenpvp.pulvinar.api.base.Context;
+import net.kissenpvp.pulvinar.api.permission.*;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.TextComponent;
+import net.kyori.adventure.text.TranslatableComponent;
+import org.bukkit.Bukkit;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.*;
+import java.util.function.Function;
+
+public class PermissionCommand {
+
+    private static final Context CONTEXT = Context.LOCAL;
+
+    @CommandData(value = "permission.user", permission = "*")
+    public void permissionUser(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull OfflinePlayer player, @NotNull PermissionParser.PermissionArgument permission, @NotNull @ArgumentName("value") Optional<PermissionAction> value) {
+        commandPayload.confirmRequest(() -> {
+            Component response = setPermission(player, permission.permission(), value.orElse(null));
+            commandPayload.getSender().sendMessage(response);
+        }).send();
+    }
+
+    @CommandData(value = "permission.user.wipe", permission = "*")
+    public void permissionUserWipe(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull OfflinePlayer player) {
+        Component wipeCount = Component.text(player.wipePermissions());
+        commandPayload.getSender().sendMessage(Component.translatable("server.permission.wiped", wipeCount));
+    }
+
+    @CommandData(value = "permission.group", permission = "*")
+    public void permissionGroup(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PermissionGroup group, @NotNull PermissionParser.PermissionArgument permission, @NotNull @ArgumentName("value") Optional<PermissionAction> value) {
+        commandPayload.confirmRequest(() -> {
+            Component response = setPermission(group, permission.permission(), value.orElse(null));
+            commandPayload.getSender().sendMessage(response);
+        }).send();
+    }
+
+    @CommandData(value = "permission.group.create", permission = "*")
+    public void permissionGroupCreate(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull String group) {
+        PermissionImplementation implementation = Bukkit.getPulvinar().getImplementation(PermissionImplementation.class);
+        PermissionGroup permissionGroup = implementation.getGroupNotNull(group);
+        Component message = Component.translatable("server.permission.group.created", permissionGroup.displayName());
+        commandPayload.getSender().sendMessage(message);
+    }
+
+    @CommandData(value = "permission.group.delete", permission = "*")
+    public void permissionGroupCreate(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PermissionGroup group) {
+        Component displayName = group.displayName();
+        group.delete();
+        Component message = Component.translatable("server.permission.group.deleted", displayName);
+        commandPayload.getSender().sendMessage(message);
+    }
+
+    @CommandData(value = "permission.group.wipe", permission = "*")
+    public void permissionGroupWipe(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PermissionGroup group) {
+        Component wiped = Component.text(group.wipeGroups());
+        Component displayName = commandPayload.getSender().displayName();
+        Component message = Component.translatable("server.permission.groups.clear", displayName, wiped);
+        commandPayload.getSender().sendMessage(message);
+    }
+
+    @CommandData(value = "permission.group.add.user", permission = "*")
+    public void groupAddUser(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull OfflinePlayer player, @NotNull PermissionGroup group) {
+        commandPayload.getSender().sendMessage(setGroup(false, player, group));
+    }
+
+    @CommandData(value = "permission.group.wipe.user", permission = "*")
+    public void groupWipeUser(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull OfflinePlayer player) {
+        commandPayload.getSender().sendMessage(Component.translatable("server.permission.groups.clear", player.displayName(), Component.text(player.wipeGroups())));
+    }
+
+    @CommandData(value = "permission.group.remove.user", permission = "*")
+    public void groupRemoveUser(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull OfflinePlayer player, @NotNull PermissionGroup group) {
+        commandPayload.getSender().sendMessage(setGroup(false, player, group));
+    }
+
+    @CommandData(value = "permission.group.add.group", permission = "*")
+    public void groupAddGroup(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PermissionGroup group, @NotNull PermissionGroup group1) {
+        commandPayload.getSender().sendMessage(setGroup(true, group, group1));
+    }
+
+    @CommandData(value = "permission.group.remove.group", permission = "*")
+    public void groupRemoveGroup(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PermissionGroup group, @NotNull PermissionGroup group1) {
+        commandPayload.getSender().sendMessage(setGroup(false, group, group1));
+    }
+
+    @CommandData(value = "permission.group.wipe.group", permission = "*")
+    public void groupWipeGroup(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PermissionGroup group) {
+        commandPayload.getSender().sendMessage(Component.translatable("server.permission.permissions.clear", group.displayName(), Component.text(group.wipeGroups())));
+    }
+
+    @CommandData(value = "permissioninfo.user")
+    public void permissionInfoUser(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull OfflinePlayer player, @NotNull @ArgumentName("page/permission") Optional<String> data) {
+        commandPayload.getSender().sendMessage(info(player, data.orElse(null)));
+    }
+
+    @CommandData(value = "permissioninfo.group")
+    public void permissionInfoGroup(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull PermissionGroup group, @NotNull @ArgumentName("page/permission") Optional<String> data) {
+        commandPayload.getSender().sendMessage(info(group, data.orElse(null)));
+    }
+
+    /**
+     * Generates an information Component based on the provided PaperGroupablePermissionEntry and optional data.
+     *
+     * @param entry The PaperGroupablePermissionEntry for which information is generated.
+     * @param data  Optional data, can be null or a String representation of an integer.
+     *              If null, a default information Component is generated.
+     *              If a valid integer string, information Component is generated based on the parsed integer.
+     *              If an invalid integer string, information Component is generated based on the raw data.
+     * @return A Component representing the generated information.
+     * @throws NullPointerException if entry is null.
+     */
+    private @NotNull Component info(@NotNull GroupablePermissionEntry entry, @Nullable String data) {
+        if (Objects.isNull(data)) {
+            return infoComponent(entry, 1);
+        }
+
+        if (data.matches("-?\\d+(\\.\\d+)?")) {
+            return infoComponent(entry, Integer.parseInt(data));
+        }
+
+        return infoComponent(entry, data);
+    }
+
+    /**
+     * Generates an information {@link Component} displaying details about the permissions of a {@link GroupablePermissionEntry}.
+     *
+     * @param permissionEntry The {@link GroupablePermissionEntry} for which information is displayed.
+     * @param page            The page number for paginating the information (if applicable).
+     * @return A formatted {@link Component} containing information about the permissions of the specified entry.
+     */
+    private @NotNull Component infoComponent(@NotNull GroupablePermissionEntry permissionEntry, int page) {
+        Set<Permission> permissionSet = permissionEntry.getPermissionList();
+        if (permissionSet.isEmpty()) {
+            return Component.translatable("server.permission.info.clear", permissionEntry.displayName());
+        }
+
+        Comparator<Permission> comparator = (a, b) -> CharSequence.compare(a.getOwner().getPermissionID(), b.getOwner().getPermissionID());
+        List<Permission> sorted = permissionSet.stream().sorted(comparator).toList();
+        PageBuilder<Permission> permissions = new PageBuilder<>(sorted);
+        Component header = permissions.getHeader(permissionEntry.displayName(), page);
+        Component footer = permissions.getFooter(permissionEntry.displayName(), page);
+
+        TextComponent.Builder builder = Component.text().append(header);
+        permissions.getEntries(page).forEach(permission -> {
+            Component[] args = {
+                    Component.text(permission.getValue() ? "✔" : "❌"),
+                    permission.getOwner().displayName(),
+                    Component.text(permission.getName())
+            };
+            builder.appendNewline().append(Component.translatable("server.permission.info.compact", args));
+        });
+        return builder.appendNewline().append(footer).asComponent();
+    }
+
+    /**
+     * Generates an information {@link Component} displaying details about a specific permission of a {@link GroupablePermissionEntry}.
+     *
+     * @param permissionEntry The {@link GroupablePermissionEntry} for which information is displayed.
+     * @param permission      The name of the specific permission.
+     * @return A formatted {@link Component} containing information about the specified permission of the entry.
+     */
+    private @NotNull Component infoComponent(@NotNull GroupablePermissionEntry permissionEntry, @NotNull String permission) {
+        return permissionEntry.getPermission(permission).map(paperPermission -> {
+
+            Component header = Component.translatable("server.command.general.header", permissionEntry.displayName());
+            Component footer = Component.translatable("server.command.general.footer", permissionEntry.displayName());
+            TranslatableComponent keyValue = Component.translatable("server.command.general.key.value");
+
+            Component id = Component.translatable("server.general.id");
+            Component owner = Component.translatable("server.permission.owner");
+
+            TextComponent.Builder builder = Component.text().appendNewline().append(header);
+            builder.appendNewline().append(keyValue.arguments(id, Component.text(paperPermission.getName())));
+            builder.appendNewline().append(keyValue.arguments(owner, paperPermission.getOwner().displayName()));
+            builder.appendNewline().append(footer);
+            return builder.asComponent();
+        }).orElseGet(() -> Component.translatable("server.permission.entity.failed", permissionEntry.displayName(), Component.text(permission)));
+    }
+
+    /**
+     * Sets or removes a {@link GroupablePermissionEntry} from a {@link PermissionGroup}.
+     *
+     * @param add             {@code true} to add the entry to the group, {@code false} to remove it.
+     * @param permissionEntry The {@link GroupablePermissionEntry} to be added or removed.
+     * @param permissionGroup The target {@link PermissionGroup} for the operation.
+     * @return A {@link Component} indicating the success or failure of the operation.
+     */
+    private @NotNull Component setGroup(boolean add, @NotNull GroupablePermissionEntry permissionEntry, @NotNull PermissionGroup permissionGroup) {
+        if (!(add ? permissionGroup.addMember(permissionEntry, CONTEXT) : permissionGroup.removeMember(permissionEntry, CONTEXT))) {
+            TranslatableComponent message = Component.translatable("server.permission.group.failed");
+            return message.arguments(permissionEntry.displayName(), permissionGroup.displayName());
+        }
+        return Component.translatable("server.permission.group.success", permissionEntry.displayName());
+    }
+
+    /**
+     * Executes a permission-related operation based on the provided parameters.
+     *
+     * @param entry      The PaperGroupablePermissionEntry to perform the operation on.
+     * @param permission The permission string involved in the operation.
+     * @param action     The PermissionAction indicating the action to be performed.
+     *                   If null, the permission will be set without considering a specific action.
+     * @return A Component representing the result of the permission operation.
+     * @throws NullPointerException if entry, permission, or executor() result in null.
+     */
+    private @NotNull Component setPermission(@NotNull GroupablePermissionEntry entry, @NotNull String permission, @Nullable PermissionAction action) {
+        if (action == null) {
+            return setInternalPermission(entry, permission, null);
+        }
+
+        if (action.equals(PermissionAction.UNSET)) {
+            return unsetPermission(entry, permission);
+        }
+
+        return setInternalPermission(entry, permission, Boolean.parseBoolean(action.name()));
+    }
+
+    /**
+     * Sets a permission for a {@link GroupablePermissionEntry}.
+     *
+     * @param permissionEntry The {@link GroupablePermissionEntry} for which the permission is set.
+     * @param permission      The name of the permission.
+     * @param unparsedBoolean An optional boolean value. If {@code null}, the opposite of the current value is used.
+     * @return A {@link Component} indicating the success or failure of the operation.
+     */
+    private @NotNull Component setInternalPermission(@NotNull GroupablePermissionEntry permissionEntry, @NotNull String permission, @Nullable Boolean unparsedBoolean) {
+        boolean value = Optional.ofNullable(unparsedBoolean).orElseGet(() -> permissionEntry.getOwnPermission(permission, CONTEXT).map(current -> !current.getValue()).orElse(true));
+
+        Component[] args = {permissionEntry.displayName(), Component.text(permission), Component.text(value)};
+
+        Component component = Component.translatable("server.permission.set.success", args);
+        Component failed = Component.translatable("server.permission.set.failed", args);
+
+        Function<Permission, Component> mapper = paperPermission -> component;
+        return permissionMapper(permissionEntry, permission, value).map(mapper).orElse(failed);
+    }
+
+    /**
+     * Unsets a permission for a {@link PermissionEntry}.
+     *
+     * @param permissionEntry The {@link PermissionEntry} for which the permission is unset.
+     * @param permission      The name of the permission.
+     * @return A {@link Component} indicating the success or failure of the operation.
+     */
+    private @NotNull Component unsetPermission(@NotNull PermissionEntry permissionEntry, @NotNull String permission) {
+        Component[] args = {permissionEntry.displayName(), Component.text(permission)};
+        if (!permissionEntry.unsetPermission(permission, CONTEXT)) {
+            return Component.translatable("server.permission.entity.failed", args);
+        }
+        return Component.translatable("server.permission.unset.success", args);
+    }
+
+    /**
+     * Sets a permission for a {@link GroupablePermissionEntry} and returns an Optional result.
+     * This method is used internally to perform the permission setting operation.
+     *
+     * @param permissionEntry The {@link GroupablePermissionEntry} for which the permission is set.
+     * @param permission      The name of the permission.
+     * @param value           The boolean value to set for the permission.
+     * @return An {@link Optional} containing the resulting {@link Permission} if the operation is successful;
+     * empty otherwise.
+     */
+    private @NotNull Optional<Permission> permissionMapper(@NotNull GroupablePermissionEntry permissionEntry, @NotNull String permission, boolean value) {
+        Function<Permission, Boolean> mapper = (paperPermission -> paperPermission.getValue() == value);
+        if (permissionEntry.getOwnPermission(permission).map(mapper).orElse(false)) {
+            return Optional.empty();
+        }
+        return Optional.of(permissionEntry.setPermission(permission, value, CONTEXT));
+    }
+
+    /**
+     * Enum representing possible actions for permission operations.
+     */
+    public enum PermissionAction {
+        TRUE, FALSE, UNSET
+    }
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/permission/PulvinarGroupablePermissionEntry.java b/src/main/java/net/kissenpvp/pulvinar/permission/PulvinarGroupablePermissionEntry.java
new file mode 100644
index 0000000000000000000000000000000000000000..e788f98f91ef8151c22ac29ed03b296a5d741d64
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/permission/PulvinarGroupablePermissionEntry.java
@@ -0,0 +1,300 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.pulvinar.permission;
+
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.permission.AbstractGroupablePermissionEntry;
+import net.kissenpvp.core.api.permission.AbstractPermissionEntry;
+import net.kissenpvp.core.api.permission.AbstractPermissionGroup;
+import net.kissenpvp.core.permission.KissenGroupablePermissionEntry;
+import net.kissenpvp.core.permission.KissenPermissionSet;
+import net.kissenpvp.pulvinar.api.base.Context;
+import net.kissenpvp.pulvinar.api.permission.GroupablePermissionEntry;
+import net.kissenpvp.pulvinar.api.permission.Permission;
+import net.kyori.adventure.text.Component;
+import org.bukkit.permissions.PermissionAttachment;
+import org.bukkit.permissions.PermissionAttachmentInfo;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.*;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public abstract class PulvinarGroupablePermissionEntry implements GroupablePermissionEntry
+{
+    @Override
+    public @NotNull Component displayName()
+    {
+        return getContext(Context.LOCAL).map(AbstractPermissionEntry::displayName).orElseGet(() -> getContext(Context.GLOBAL).map(AbstractPermissionEntry::displayName).orElseThrow());
+    }
+
+    @Override
+    public int wipePermissions()
+    {
+        return wipePermissions(Context.LOCAL) + wipePermissions(Context.GLOBAL);
+    }
+
+    @Override
+    public int wipeGroups()
+    {
+        int local = getContext(Context.LOCAL).map(AbstractGroupablePermissionEntry::wipeGroups).orElse(0);
+        int global = getContext(Context.GLOBAL).map(AbstractGroupablePermissionEntry::wipeGroups).orElse(0);
+        return local + global;
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<AbstractPermissionGroup<Permission>> getOwnPermissionGroups()
+    {
+        LinkedHashSet<AbstractPermissionGroup<Permission>> groups = new LinkedHashSet<>(getOwnPermissionsGroups(Context.LOCAL));
+        groups.addAll(getOwnPermissionsGroups(Context.GLOBAL));
+        return groups.stream().toList();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<AbstractPermissionGroup<Permission>> getPermissionGroups()
+    {
+        LinkedHashSet<AbstractPermissionGroup<Permission>> groups = new LinkedHashSet<>(getPermissionGroups(Context.LOCAL));
+        groups.addAll(getPermissionGroups(Context.GLOBAL));
+        return groups.stream().toList();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<Permission> getOwnPermissions()
+    {
+
+        Stream<Permission> local = getOwnPermissions(Context.LOCAL).stream();
+        Stream<Permission> global = getOwnPermissions(Context.GLOBAL).stream();
+
+        return Stream.concat(local, global).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @NotNull Optional<Permission> getOwnPermission(@NotNull String permission)
+    {
+        return getOwnPermission(permission, Context.LOCAL).or(() -> getOwnPermission(permission, Context.GLOBAL));
+    }
+
+    @Override
+    @NotNull
+    public Set<Permission> getOwnPermissions(@NotNull Context context)
+    {
+
+        return getContext(context).map(AbstractGroupablePermissionEntry::getOwnPermissions).orElse(Collections.emptySet());
+    }
+
+    @Override
+    public @NotNull Optional<Permission> getOwnPermission(@NotNull String permission, @NotNull Context context)
+    {
+        return getContextNotNull(context).getOwnPermission(permission);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<AbstractPermissionGroup<Permission>> getOwnPermissionsGroups(@NotNull Context context)
+    {
+        return getContext(context).map(AbstractGroupablePermissionEntry::getOwnPermissionGroups).orElse(Collections.emptyList());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<AbstractPermissionGroup<Permission>> getPermissionGroups(@NotNull Context context)
+    {
+        return getContext(context).map(AbstractGroupablePermissionEntry::getPermissionGroups).orElse(Collections.emptyList());
+    }
+
+    @Override
+    public boolean inGroup(@NotNull AbstractPermissionGroup<Permission> permissionGroup)
+    {
+        return inGroup(permissionGroup, Context.LOCAL) || inGroup(permissionGroup, Context.GLOBAL);
+    }
+
+    @Override
+    public boolean inGroup(@NotNull AbstractPermissionGroup<Permission> permissionGroup, @NotNull Context context)
+    {
+        return getContext(context).map(group -> group.inGroup(permissionGroup)).orElse(false);
+    }
+
+    @Override
+    public int wipeGroups(@NotNull Context context)
+    {
+        return getContext(context).map(AbstractPermissionEntry::wipePermissions).orElse(0);
+    }
+
+    @Override
+    @NotNull
+    public Permission setPermission(@NotNull String s) throws EventCancelledException
+    {
+        return setPermission(s, Context.LOCAL);
+    }
+
+    @Override
+    @NotNull
+    public Permission setPermission(@NotNull String permission, @NotNull Context context) throws EventCancelledException
+    {
+        return getContextNotNull(context).setPermission(permission);
+    }
+
+    @Override
+    @NotNull
+    public Permission setPermission(@NotNull String permission, boolean value) throws EventCancelledException
+    {
+        return setPermission(permission, value, Context.LOCAL);
+    }
+
+    @Override
+    @NotNull
+    public Permission setPermission(@NotNull String permission, boolean value, @NotNull Context context) throws EventCancelledException
+    {
+        return getContextNotNull(context).setPermission(permission, value);
+    }
+
+    @Override
+    @NotNull
+    public Permission setPermission(@NotNull Permission paperPermission) throws EventCancelledException
+    {
+        return setPermission(paperPermission, Context.LOCAL);
+    }
+
+    @Override
+    @NotNull
+    public Permission setPermission(@NotNull Permission permission, @NotNull Context context) throws EventCancelledException
+    {
+        return getContextNotNull(context).setPermission(permission);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String s)
+    {
+        return unsetPermission(s, Context.LOCAL) || unsetPermission(s, Context.GLOBAL);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission, @NotNull Context context)
+    {
+        return getContext(context).map(group -> group.unsetPermission(permission)).orElse(false);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<Permission> getPermissionList()
+    {
+        KissenPermissionSet<Permission> permission = new KissenPermissionSet<>(getOwnPermissions(Context.LOCAL));
+        permission.addAll(getPermissionList(Context.GLOBAL));
+        return permission;
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<Permission> getPermissionList(@NotNull Context context)
+    {
+        return getContext(context).map(AbstractPermissionEntry::getPermissionList).orElse(Collections.emptySet());
+    }
+
+    @Override
+    public @NotNull Optional<Permission> getPermission(@NotNull String permission)
+    {
+        return getPermission(permission, Context.LOCAL).or(() -> getPermission(permission, Context.GLOBAL));
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAffectedUsers()
+    {
+        Function<AbstractGroupablePermissionEntry<Permission>, Stream<UUID>> toStream = entry -> entry.getAffectedUsers().stream();
+        Stream<UUID> local = getContext(Context.LOCAL).map(toStream).orElse(Stream.empty());
+        Stream<UUID> global = getContext(Context.GLOBAL).map(toStream).orElse(Stream.empty());
+
+        return Stream.concat(local, global).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<AbstractGroupablePermissionEntry<Permission>> getConnectedEntries()
+    {
+        var stream = new Object()
+        {
+            private @NotNull Stream<AbstractGroupablePermissionEntry<Permission>> getStream(@NotNull Context context)
+            {
+                return getContext(context).map(entry -> entry.getConnectedEntries().stream()).orElseGet(Stream::empty);
+            }
+        };
+
+        Stream<AbstractGroupablePermissionEntry<Permission>> local = stream.getStream(Context.LOCAL);
+        Stream<AbstractGroupablePermissionEntry<Permission>> global = stream.getStream(Context.GLOBAL);
+
+        return Stream.concat(local, global).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    @NotNull
+    public Optional<Permission> getPermission(@NotNull String permission, @NotNull Context context)
+    {
+        return getContext(context).flatMap(group -> group.getPermission(permission));
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String permission)
+    {
+        return hasPermission(permission, Context.LOCAL) || hasPermission(permission, Context.GLOBAL);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String permission, @NotNull Context context)
+    {
+        return getContext(context).flatMap(group -> hasInternalPermission(permission, context)).orElse(isOp());
+    }
+
+    @Override
+    public void permissionUpdate()
+    {
+        getContext(Context.LOCAL).ifPresent(AbstractPermissionEntry::permissionUpdate);
+        getContext(Context.GLOBAL).ifPresent(AbstractPermissionEntry::permissionUpdate);
+        getConnectedEntries().forEach(AbstractPermissionEntry::permissionUpdate);
+    }
+
+    @Override
+    public int wipePermissions(@NotNull Context context)
+    {
+        return getContext(Context.LOCAL).map(AbstractPermissionEntry::wipePermissions).orElse(0);
+    }
+
+    @NotNull
+    public abstract Optional<? extends AbstractGroupablePermissionEntry<Permission>> getContext(@NotNull Context context);
+
+    @NotNull
+    public abstract AbstractGroupablePermissionEntry<Permission> getContextNotNull(@NotNull Context context);
+
+    public @NotNull @Unmodifiable Set<PermissionAttachmentInfo> getEffectivePermissions()
+    {
+        return getPermissionList().stream().map(permission ->
+        {
+            PermissionAttachment attachment = null;
+            if (permission instanceof AttachmentAbstractPermission attachmentPermission)
+            {
+                attachment = attachmentPermission.getPermissionAttachment();
+            }
+            return new PermissionAttachmentInfo(this, permission.getName(), attachment, permission.getValue());
+        }).collect(Collectors.toUnmodifiableSet());
+    }
+
+    private @NotNull Optional<Boolean> hasInternalPermission(@NotNull String permission, @NotNull Context context)
+    {
+        return getContext(context).flatMap(group ->
+        {
+            KissenGroupablePermissionEntry<?, Permission> internal = (KissenGroupablePermissionEntry<?, Permission>) group;
+            return internal.getInternalPermission(permission);
+        });
+    }
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/permission/PulvinarPermission.java b/src/main/java/net/kissenpvp/pulvinar/permission/PulvinarPermission.java
new file mode 100644
index 0000000000000000000000000000000000000000..4bd6d66ea7737798187653e2af2da9ca53dec3af
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/permission/PulvinarPermission.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.pulvinar.permission;
+
+import net.kissenpvp.core.api.database.DataWriter;
+import net.kissenpvp.core.api.permission.AbstractPermission;
+import net.kissenpvp.core.api.permission.AbstractPermissionEntry;
+import net.kissenpvp.core.permission.KissenPermission;
+import net.kissenpvp.core.permission.PermissionNode;
+import net.kissenpvp.pulvinar.api.permission.Permission;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class PulvinarPermission extends KissenPermission implements Permission {
+    public PulvinarPermission(@NotNull PermissionNode permissionNode, @NotNull AbstractPermissionEntry<? extends AbstractPermission> permissionEntry, @Nullable DataWriter<PermissionNode> dataWriter) {
+        super(permissionNode, permissionEntry, dataWriter);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/permission/PulvinarPermissionImplementation.java b/src/main/java/net/kissenpvp/pulvinar/permission/PulvinarPermissionImplementation.java
new file mode 100644
index 0000000000000000000000000000000000000000..cb0a8dfc81400c728f288a552e34c2ca279a0c87
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/permission/PulvinarPermissionImplementation.java
@@ -0,0 +1,319 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.pulvinar.permission;
+
+import net.kissenpvp.core.api.database.connection.DatabaseImplementation;
+import net.kissenpvp.core.api.database.meta.Meta;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.permission.AbstractPermissionGroup;
+import net.kissenpvp.core.base.KissenCore;
+import net.kissenpvp.core.base.KissenImplementation;
+import net.kissenpvp.core.command.InternalCommandImplementation;
+import net.kissenpvp.core.database.KissenTable;
+import net.kissenpvp.core.message.localization.KissenLocalizationImplementation;
+import net.kissenpvp.core.permission.InternalKissenPermissionImplementation;
+import net.kissenpvp.core.permission.InternalPermissionImplementation;
+import net.kissenpvp.pulvinar.api.base.Context;
+import net.kissenpvp.pulvinar.api.permission.*;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.bukkit.permissions.PermissionDefault;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.text.MessageFormat;
+import java.util.*;
+import java.util.stream.Collectors;
+
+public class PulvinarPermissionImplementation extends InternalKissenPermissionImplementation<Permission> implements PermissionImplementation, InternalPermissionImplementation<Permission>, KissenImplementation {
+
+    private static final Logger log = LoggerFactory.getLogger("Kissen");
+
+    private final Set<GroupHolder> cachedHolder;
+    private KissenTable privateTable;
+
+    public PulvinarPermissionImplementation() {
+        this.cachedHolder = new HashSet<>();
+    }
+
+    @Override
+    public boolean preStart() {
+        DatabaseImplementation implementation = KissenCore.getInstance().getImplementation(DatabaseImplementation.class);
+        privateTable = (KissenTable) implementation.getConnection("private").map(table -> table.createTable("kissen_private_permission_group_table")).orElse(null);
+        return super.preStart();
+    }
+
+    @Override
+    public boolean start() {
+        String prefix = "The permission entry {0}";
+
+        Class<KissenLocalizationImplementation> clazz = KissenLocalizationImplementation.class;
+        KissenLocalizationImplementation localize = Bukkit.getPulvinar().getImplementation(clazz);
+
+        localize.register("server.permission.set.success", new MessageFormat(prefix + " was successfully set {1} to {2}."));
+        localize.register("server.permission.set.failed", new MessageFormat(prefix + " has already set {1} to {2}."));
+        localize.register("server.permission.wiped", new MessageFormat("{0} permission(s) were removed from permission entry {0}."));
+        localize.register("server.permission.group.failed", new MessageFormat(prefix + " is already in this state within the relation to group {1}."));
+        localize.register("server.permission.group.success", new MessageFormat(prefix + " has been set to the state."));
+        localize.register("server.permission.unset.success", new MessageFormat("The permission {1} from the permission entry {0} was successfully unset."));
+        localize.register("server.permission.entity.failed", new MessageFormat(prefix + " does not have the permission {1}."));
+
+        localize.register("server.permission.group.created", new MessageFormat(prefix + " has been created."));
+        localize.register("server.permission.group.deleted", new MessageFormat(prefix + " has been deleted."));
+
+        localize.register("server.permission.info.compact", new MessageFormat("[{0}] [{1}] {2}"));
+
+        localize.register("server.permission.owner", new MessageFormat("Owner"));
+        localize.register("server.permission.info.clear", new MessageFormat(prefix + " has no permissions."));
+
+        localize.register("server.permission.groups.clear", new MessageFormat(prefix + " is no part of any groups ({1} groups removed)."));
+        localize.register("server.permission.permissions.clear", new MessageFormat(prefix + " has no more permissions ({1} permissions removed)."));
+
+        InternalCommandImplementation<CommandSender> command = Bukkit.getPulvinar().getImplementation(InternalCommandImplementation.class);
+        command.getInternalHandler().registerParser(PermissionGroup.class, new PermissionGroupParser());
+        command.getInternalHandler().registerParser(PermissionParser.PermissionArgument.class, new PermissionParser());
+        return PermissionImplementation.super.start();
+    }
+
+    @Override
+    public boolean postStart() {
+        log.info("Successfully loaded {} permission group(s) from the database.", cachedHolder.size());
+        return PermissionImplementation.super.postStart();
+    }
+
+    @Override
+    public void setupComplete() {
+        InternalCommandImplementation<CommandSender> command = Bukkit.getPulvinar().getImplementation(InternalCommandImplementation.class);
+        command.getInternalHandler().registerCommand(new PermissionCommand());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<PermissionGroup> getGroups() {
+        return cachedHolder.stream().map(GroupHolder::toGroup).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<AbstractPermissionGroup<Permission>> getInternalGroups() {
+        return getGroups().stream().collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @NotNull Optional<AbstractPermissionGroup<?>> getPermissionGroupSavable(@NotNull String name) {
+        return getGroup(name).flatMap(group -> ((net.kissenpvp.pulvinar.permission.group.PulvinarPermissionGroup) group).getContext(Context.GLOBAL));
+    }
+
+    @Override
+    public void removePermissionGroup(@NotNull String name) {
+        cachedHolder.removeIf(group -> group.getPermissionID().equals(name));
+    }
+
+    @Override
+    public @NotNull Optional<PermissionGroup> getGroup(@NotNull String group) {
+        return getGroups().stream().filter(currentGroup -> currentGroup.getPermissionID().equals(group)).findFirst();
+    }
+
+    @Override
+    public @NotNull PermissionGroup getGroupNotNull(@NotNull String group) throws EventCancelledException {
+        return getGroup(group).orElseGet(() -> create(group, Context.LOCAL));
+    }
+
+    @Override
+    public void addPermission(@NotNull String permission) {
+        if (Bukkit.getPluginManager().getPermission(permission)==null) {
+            Bukkit.getPluginManager().addPermission(new org.bukkit.permissions.Permission(permission, PermissionDefault.OP));
+        }
+    }
+
+    @Override
+    public @NotNull PermissionGroup create(@NotNull String name) throws EventCancelledException {
+        return create(name, Context.GLOBAL);
+    }
+
+    public @NotNull KissenTable getTable(@NotNull Context context) {
+        return switch (context) {
+            case GLOBAL -> super.getTable();
+            case LOCAL -> Objects.requireNonNullElseGet(privateTable, super::getTable);
+        };
+    }
+
+    public @NotNull Meta getMeta(@NotNull Context context) {
+        return getTable(context).setupMeta(null);
+    }
+
+    public @NotNull PermissionGroup create(@NotNull String name, @NotNull Context context) throws EventCancelledException {
+        return this.createInternal(name, context).toGroup();
+    }
+
+    /**
+     * Retrieves an optional {@link AbstractPermissionGroup} of type {@link Permission} associated with the specified name
+     * and context. The result is wrapped in an {@link Optional} to handle cases where the group is not present.
+     *
+     * @param name    The name of the permission group to retrieve.
+     * @param context The context in which to retrieve the permission group.
+     * @return An {@link Optional} containing the requested {@link AbstractPermissionGroup}, or an empty {@link Optional}
+     * if the group is not found.
+     * @throws NullPointerException If either the 'name' or 'context' parameters are {@code null}.
+     */
+    public @NotNull Optional<AbstractPermissionGroup<Permission>> getGroup(@NotNull String name, @NotNull Context context) {
+        return getHolder(name).flatMap(groupHolder -> groupHolder.getGroup(context));
+    }
+
+    /**
+     * Retrieves a non-null {@link AbstractPermissionGroup} of type {@link Permission} associated with the specified name
+     * and context. If the group is not present, it creates a new group using the {@code createInternal} method and returns it.
+     *
+     * @param name    The name of the permission group to retrieve.
+     * @param context The context in which to retrieve the permission group.
+     * @return The requested {@link AbstractPermissionGroup}, either existing or newly created.
+     * @throws NullPointerException If either the 'name' or 'context' parameters are {@code null}.
+     */
+    public @NotNull AbstractPermissionGroup<Permission> getGroupNotNull(@NotNull String name, @NotNull Context context) {
+        return getGroup(name, context).orElseGet(() -> createInternal(name, context).getGroupOrThrow(context));
+    }
+
+    /**
+     * Retrieves an optional {@link GroupHolder} associated with the specified name from the cached holders.
+     * The result is wrapped in an {@link Optional} to handle cases where the holder is not present.
+     *
+     * @param name The name of the group holder to retrieve.
+     * @return An {@link Optional} containing the requested {@link GroupHolder}, or an empty {@link Optional}
+     * if the holder is not found.
+     * @throws NullPointerException If the 'name' parameter is {@code null}.
+     */
+    private @NotNull Optional<GroupHolder> getHolder(@NotNull String name) {
+        return cachedHolder.stream().filter(groupHolder -> groupHolder.getPermissionID().equals(name)).findFirst();
+    }
+
+    /**
+     * Retrieves a non-null {@link GroupHolder} associated with the specified name from the cached holders.
+     * If the holder is not present, it creates a new one, adds it to the cache, and returns the new holder.
+     *
+     * @param name The name of the group holder to retrieve.
+     * @return The requested {@link GroupHolder}, either existing or newly created.
+     * @throws NullPointerException If the 'name' parameter is {@code null}.
+     */
+    private @NotNull GroupHolder getHolderNotNull(@NotNull String name) {
+        return getHolder(name).orElseGet(() -> {
+            GroupHolder groupHolder = new GroupHolder(name);
+            cachedHolder.add(groupHolder);
+            return groupHolder;
+        });
+    }
+
+    /**
+     * Creates and returns a non-null {@link GroupHolder} associated with the specified name, data, and context.
+     * If a holder with the specified name already exists, it retrieves and returns the existing one.
+     * Otherwise, it creates a new holder, sets up the group based on the provided context, and returns the new holder.
+     *
+     * @param name    The name of the group holder to create or retrieve.
+     * @param context The context in which to set up the group.
+     * @return The created or retrieved {@link GroupHolder} with the associated group set up.
+     * @throws NullPointerException If either the 'name' or 'context' parameters are {@code null}.
+     */
+    private @NotNull GroupHolder createInternal(@NotNull String name, @NotNull Context context) {
+        GroupHolder holder = getHolderNotNull(name);
+        holder.setGroup(switch (context) {
+            case GLOBAL -> new net.kissenpvp.pulvinar.permission.group.PulvinarPrivatePermissionGroup.PulvinarPublicPermissionGroup();
+            case LOCAL -> new net.kissenpvp.pulvinar.permission.group.PulvinarPrivatePermissionGroup();
+        }, context).setup(name);
+
+        return holder;
+    }
+
+    /**
+     * A static nested class representing a holder for a permission group.
+     * It contains methods for retrieving, setting up, and converting the associated permission group.
+     */
+    private static final class GroupHolder {
+        private final String permissionID;
+        private net.kissenpvp.pulvinar.permission.group.PulvinarPrivatePermissionGroup privateGroup;
+        private net.kissenpvp.pulvinar.permission.group.PulvinarPrivatePermissionGroup.PulvinarPublicPermissionGroup publicGroup;
+
+        /**
+         * Constructs a new GroupHolder with the specified permission ID.
+         *
+         * @param permissionID The unique identifier for the permission group held by this holder.
+         */
+        private GroupHolder(@NotNull String permissionID) {
+            this.permissionID = permissionID;
+        }
+
+        /**
+         * Retrieves the permission ID associated with this GroupHolder.
+         *
+         * @return The permission ID.
+         */
+        private @NotNull String getPermissionID() {
+            return permissionID;
+        }
+
+        /**
+         * Retrieves an optional {@link net.kissenpvp.pulvinar.permission.group.PulvinarAbstractPermissionGroup} associated with the specified context.
+         *
+         * @param context The context in which to retrieve the permission group.
+         * @return An {@link Optional} containing the requested {@link net.kissenpvp.pulvinar.permission.group.PulvinarAbstractPermissionGroup},
+         * or an empty {@link Optional} if the group is not found.
+         * @throws NullPointerException If the 'context' parameter is {@code null}.
+         */
+        private @NotNull Optional<net.kissenpvp.pulvinar.permission.group.PulvinarAbstractPermissionGroup> getGroup(@NotNull Context context) {
+            return Optional.ofNullable(switch (context) {
+                case GLOBAL -> publicGroup;
+                case LOCAL -> privateGroup;
+            });
+        }
+
+        /**
+         * Retrieves the associated {@link net.kissenpvp.pulvinar.permission.group.PulvinarAbstractPermissionGroup} for the specified context.
+         * Throws {@link NullPointerException} if the group is not present.
+         *
+         * @param context The context in which to retrieve the permission group.
+         * @return The requested {@link net.kissenpvp.pulvinar.permission.group.PulvinarAbstractPermissionGroup}.
+         * @throws NoSuchElementException If the 'context' parameter is {@code null} or the group is not found.
+         */
+        private @NotNull net.kissenpvp.pulvinar.permission.group.PulvinarAbstractPermissionGroup getGroupOrThrow(@NotNull Context context) {
+            return getGroup(context).orElseThrow();
+        }
+
+        /**
+         * Sets the associated permission group for the specified context.
+         *
+         * @param group   The permission group to set.
+         * @param context The context in which to set the permission group.
+         * @return The set permission group.
+         */
+        private @NotNull net.kissenpvp.pulvinar.permission.group.PulvinarAbstractPermissionGroup setGroup(@NotNull net.kissenpvp.pulvinar.permission.group.PulvinarAbstractPermissionGroup group, @NotNull Context context) {
+            switch (context) {
+                case GLOBAL -> publicGroup = (net.kissenpvp.pulvinar.permission.group.PulvinarPrivatePermissionGroup.PulvinarPublicPermissionGroup) group;
+                case LOCAL -> privateGroup = (net.kissenpvp.pulvinar.permission.group.PulvinarPrivatePermissionGroup) group;
+            }
+            return group;
+        }
+
+        /**
+         * Converts the GroupHolder to a non-null {@link PermissionGroup}.
+         *
+         * @return A {@link PermissionGroup} representation of the GroupHolder.
+         */
+        private @NotNull PermissionGroup toGroup() {
+            return new net.kissenpvp.pulvinar.permission.group.PulvinarPermissionGroup(getPermissionID());
+        }
+    }
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/permission/RemoveAttachmentRunnable.java b/src/main/java/net/kissenpvp/pulvinar/permission/RemoveAttachmentRunnable.java
new file mode 100644
index 0000000000000000000000000000000000000000..acf50b8a6956d4f89e730e7e5c8f493c01150ba3
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/permission/RemoveAttachmentRunnable.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.pulvinar.permission;
+
+import org.bukkit.permissions.PermissionAttachment;
+import org.jetbrains.annotations.NotNull;
+
+public record RemoveAttachmentRunnable(PermissionAttachment attachment) implements Runnable {
+    public RemoveAttachmentRunnable(@NotNull PermissionAttachment attachment) {
+        this.attachment = attachment;
+    }
+
+    @Override
+    public void run() {
+        attachment.remove();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/permission/group/PulvinarAbstractPermissionGroup.java b/src/main/java/net/kissenpvp/pulvinar/permission/group/PulvinarAbstractPermissionGroup.java
new file mode 100644
index 0000000000000000000000000000000000000000..77f747a694b075e7add98ef253bdeca2b308eabb
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/permission/group/PulvinarAbstractPermissionGroup.java
@@ -0,0 +1,38 @@
+package net.kissenpvp.pulvinar.permission.group;
+
+import net.kissenpvp.core.api.database.DataWriter;
+import net.kissenpvp.core.api.permission.AbstractPermissionEntry;
+import net.kissenpvp.core.permission.KissenPermissionGroup;
+import net.kissenpvp.core.permission.PermissionNode;
+import net.kissenpvp.pulvinar.api.base.Context;
+import net.kissenpvp.pulvinar.api.permission.Permission;
+import net.kissenpvp.pulvinar.api.permission.PermissionImplementation;
+import net.kissenpvp.pulvinar.permission.PulvinarPermission;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public abstract class PulvinarAbstractPermissionGroup extends KissenPermissionGroup<Permission>
+{
+
+    @Override
+    public void permissionUpdate()
+    {
+        // instead update paper permission group
+        Class<PermissionImplementation> clazz = PermissionImplementation.class;
+        PermissionImplementation permission = Bukkit.getPulvinar().getImplementation(clazz);
+        permission.getGroup(getPermissionID()).ifPresent(AbstractPermissionEntry::permissionUpdate);
+    }
+
+    public void internalPermissionUpdate()
+    {
+        super.permissionUpdate();
+    }
+
+    @Override
+    protected @NotNull PulvinarPermission translatePermission(@NotNull PermissionNode permissionNode, @Nullable DataWriter<PermissionNode> dataWriter) {
+        return new PulvinarPermission(permissionNode, this, dataWriter);
+    }
+
+    protected abstract @NotNull Context getContext();
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/permission/group/PulvinarPermissionGroup.java b/src/main/java/net/kissenpvp/pulvinar/permission/group/PulvinarPermissionGroup.java
new file mode 100644
index 0000000000000000000000000000000000000000..429ae3c45171cdcce704ca1d5d4ab788ef485ff8
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/permission/group/PulvinarPermissionGroup.java
@@ -0,0 +1,163 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.pulvinar.permission.group;
+
+import net.kissenpvp.core.api.database.savable.Savable;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.permission.AbstractGroupablePermissionEntry;
+import net.kissenpvp.core.api.permission.AbstractPermissionEntry;
+import net.kissenpvp.core.api.permission.AbstractPermissionGroup;
+import net.kissenpvp.pulvinar.api.base.Context;
+import net.kissenpvp.pulvinar.api.permission.Permission;
+import net.kissenpvp.pulvinar.api.permission.PermissionGroup;
+import net.kissenpvp.pulvinar.permission.PulvinarPermissionImplementation;
+import net.kissenpvp.pulvinar.permission.permissible.PulvinarPermissible;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Collections;
+import java.util.Optional;
+import java.util.Set;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public class PulvinarPermissionGroup extends PulvinarPermissible implements PermissionGroup
+{
+    @Override
+    public void permissionUpdate()
+    {
+        Consumer<AbstractPermissionGroup<Permission>> internalUpdate = entry ->
+        {
+            if(entry instanceof PulvinarAbstractPermissionGroup permissioNGroup)
+            {
+                permissioNGroup.internalPermissionUpdate();
+            }
+        };
+
+        getContext(Context.LOCAL).ifPresent(internalUpdate);
+        getContext(Context.GLOBAL).ifPresent(internalUpdate);
+
+        getConnectedEntries().forEach(AbstractPermissionEntry::permissionUpdate);
+    }
+
+    private final String permissionID;
+
+    public PulvinarPermissionGroup(@NotNull String permissionID)
+    {
+        this.permissionID = permissionID;
+    }
+
+    @Override
+    public @NotNull String getPermissionID() {
+        return permissionID;
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<String> getMember() {
+        Stream<String> local = getMember(Context.LOCAL).stream(), global = getMember(Context.GLOBAL).stream();
+        return Stream.concat(local, global).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<String> getOwnMember()
+    {
+        Stream<String> local = getOwnMember(Context.LOCAL).stream(), global = getOwnMember(Context.GLOBAL).stream();
+        return Stream.concat(local, global).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<String> getMember(@NotNull Context context)
+    {
+        return getContext(context).map(AbstractPermissionGroup::getMember).orElse(Collections.emptySet());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<String> getOwnMember(@NotNull Context context)
+    {
+        return getContext(context).map(AbstractPermissionGroup::getOwnMember).orElse(Collections.emptySet());
+    }
+
+    @Override
+    public boolean addMember(@NotNull AbstractGroupablePermissionEntry<?> groupablePermissionEntry) {
+        return addMember(groupablePermissionEntry, Context.GLOBAL);
+    }
+
+    @Override
+    public boolean addMember(@NotNull AbstractGroupablePermissionEntry<?> groupablePermissionEntry, @NotNull Context context) {
+        return getContext(context).map(group -> group.addMember(groupablePermissionEntry)).orElse(false);
+    }
+
+    @Override
+    public boolean removeMember(@NotNull AbstractGroupablePermissionEntry<?> groupablePermissionEntry) {
+        return removeMember(groupablePermissionEntry, Context.GLOBAL);
+    }
+
+    @Override
+    public int delete()
+    {
+        PulvinarPermissionImplementation implementation = Bukkit.getPulvinar().getImplementation(PulvinarPermissionImplementation.class);
+        implementation.removePermissionGroup(getPermissionID());
+
+        Function<AbstractGroupablePermissionEntry<Permission>, Integer> delete = group -> ((Savable<?>) group).delete();
+        return getContext(Context.LOCAL).map(delete).orElse(0) + getContext(Context.GLOBAL).map(delete).orElse(0);
+    }
+
+    @Override
+    public boolean removeMember(@NotNull AbstractGroupablePermissionEntry<?> groupablePermissionEntry, @NotNull Context context) {
+        return getContext(context).map(group -> group.removeMember(groupablePermissionEntry)).orElse(false);
+    }
+
+    @Override
+    public @NotNull Optional<AbstractPermissionGroup<Permission>> getContext(@NotNull Context context)
+    {
+        Class<PulvinarPermissionImplementation> clazz = PulvinarPermissionImplementation.class;
+        PulvinarPermissionImplementation permissionImplementation = Bukkit.getPulvinar().getImplementation(clazz);
+        return permissionImplementation.getGroup(getPermissionID(), context);
+    }
+
+    @Override
+    public @NotNull AbstractGroupablePermissionEntry<Permission> getContextNotNull(@NotNull Context context)
+    {
+        Class<PulvinarPermissionImplementation> clazz = PulvinarPermissionImplementation.class;
+        PulvinarPermissionImplementation permissionImplementation = Bukkit.getPulvinar().getImplementation(clazz);
+        return permissionImplementation.getGroupNotNull(getPermissionID(), context);
+    }
+
+    @Override
+    public boolean isOp() {
+        return hasPermission("*");
+    }
+
+    @Override
+    public void setOp(boolean value) {
+        if (isOp() && !value) {
+            unsetPermission("*");
+            return;
+        }
+
+        try {
+            setPermission("*", value);
+        } catch (EventCancelledException eventCancelledException) {
+            throw new RuntimeException(eventCancelledException);
+        }
+    }
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/permission/group/PulvinarPrivatePermissionGroup.java b/src/main/java/net/kissenpvp/pulvinar/permission/group/PulvinarPrivatePermissionGroup.java
new file mode 100644
index 0000000000000000000000000000000000000000..efd6417c929309526167d1a19166ede72b6b1632
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/permission/group/PulvinarPrivatePermissionGroup.java
@@ -0,0 +1,67 @@
+package net.kissenpvp.pulvinar.permission.group;
+
+import net.kissenpvp.core.api.base.Kissen;
+import net.kissenpvp.core.api.networking.socket.DataPackage;
+import net.kissenpvp.core.api.permission.AbstractPermissionGroup;
+import net.kissenpvp.core.base.KissenCore;
+import net.kissenpvp.core.database.KissenTable;
+import net.kissenpvp.pulvinar.api.base.Context;
+import net.kissenpvp.pulvinar.api.permission.Permission;
+import net.kissenpvp.pulvinar.api.permission.PrivatePermissionGroup;
+import net.kissenpvp.pulvinar.api.permission.PublicPermissionGroup;
+import net.kissenpvp.pulvinar.permission.PulvinarPermissionImplementation;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Optional;
+
+public class PulvinarPrivatePermissionGroup extends PulvinarAbstractPermissionGroup implements PrivatePermissionGroup
+{
+    @Override
+    public @NotNull String getSaveID()
+    {
+        return "privatepermissiongroup";
+    }
+
+    @Override
+    public @NotNull Optional<AbstractPermissionGroup<Permission>> getPublicGroup()
+    {
+        Kissen kissen = Bukkit.getPulvinar();
+        PulvinarPermissionImplementation implementation = kissen.getImplementation(PulvinarPermissionImplementation.class);
+        return implementation.getGroup(getPermissionID(), Context.GLOBAL);
+    }
+
+    @Override
+    protected @NotNull Context getContext()
+    {
+        return Context.LOCAL;
+    }
+
+    public static class PulvinarPublicPermissionGroup extends PulvinarAbstractPermissionGroup implements PublicPermissionGroup
+    {
+        @Override
+        public @NotNull String getSaveID()
+        {
+            return "publicpermissiongroup";
+        }
+
+        @Override
+        public @NotNull KissenTable getTable() {
+            return KissenCore.getInstance().getImplementation(PulvinarPermissionImplementation.class).getTable(Context.LOCAL);
+        }
+
+        @Override
+        public @NotNull Optional<AbstractPermissionGroup<Permission>> getPrivateGroup()
+        {
+            Kissen kissen = Bukkit.getPulvinar();
+            PulvinarPermissionImplementation implementation = kissen.getImplementation(PulvinarPermissionImplementation.class);
+            return implementation.getGroup(getPermissionID(), Context.LOCAL);
+        }
+
+        @Override
+        protected @NotNull Context getContext()
+        {
+            return Context.GLOBAL;
+        }
+    }
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/permission/permissible/PulvinarPermissible.java b/src/main/java/net/kissenpvp/pulvinar/permission/permissible/PulvinarPermissible.java
new file mode 100644
index 0000000000000000000000000000000000000000..901faf9d4e37a99358c53db40871a996802e8d38
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/permission/permissible/PulvinarPermissible.java
@@ -0,0 +1,183 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.pulvinar.permission.permissible;
+
+import net.kissenpvp.core.api.permission.AbstractPermission;
+import net.kissenpvp.pulvinar.api.permission.PaperPermissible;
+import net.kissenpvp.pulvinar.api.permission.Permission;
+import net.kissenpvp.pulvinar.permission.AttachmentAbstractPermission;
+import net.kissenpvp.pulvinar.permission.PulvinarGroupablePermissionEntry;
+import net.kissenpvp.pulvinar.permission.RemoveAttachmentRunnable;
+import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;
+import org.bukkit.Bukkit;
+import org.bukkit.permissions.Permissible;
+import org.bukkit.permissions.PermissionAttachment;
+import org.bukkit.permissions.PermissionRemovedExecutor;
+import org.bukkit.plugin.Plugin;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.function.BiConsumer;
+import java.util.logging.Level;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public abstract class PulvinarPermissible extends PulvinarGroupablePermissionEntry implements PaperPermissible {
+
+    protected final Permissible parent;
+    protected final Set<PermissionAttachment> attachments;
+    private boolean initialized;
+
+    public PulvinarPermissible() {
+        this(null);
+    }
+
+    public PulvinarPermissible(@Nullable Permissible parent) {
+        this.attachments = new HashSet<>();
+        this.parent = parent == null ? this : parent;
+        this.initialized = false;
+    }
+
+    @Override
+    public boolean isPermissionSet(@NotNull String name) {
+        return getPermission(name).isPresent();
+    }
+
+    @Override
+    public boolean isPermissionSet(@NotNull org.bukkit.permissions.Permission perm) {
+        return isPermissionSet(perm.getName());
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull org.bukkit.permissions.Permission perm) {
+        return hasPermission(perm.getName());
+    }
+
+    @Override
+    public @NotNull PermissionAttachment addAttachment(@NotNull Plugin plugin) {
+        PermissionAttachment result = new PermissionAttachment(plugin, parent);
+
+        attachments.add(result);
+        permissionUpdate();
+
+        return result;
+    }
+
+    @Override
+    public @NotNull PermissionAttachment addAttachment(@NotNull Plugin plugin, @NotNull String name, boolean value) {
+        PermissionAttachment permissionAttachment = addAttachment(plugin);
+        permissionAttachment.setPermission(name, value);
+        return permissionAttachment;
+    }
+
+    @Override
+    public @Nullable PermissionAttachment addAttachment(@NotNull Plugin plugin, @NotNull String name, boolean value, int ticks) {
+        PermissionAttachment permissionAttachment = addAttachment(plugin, ticks);
+        if (permissionAttachment != null) {
+            permissionAttachment.setPermission(name, value);
+        }
+        return permissionAttachment;
+    }
+
+    @Override
+    public @Nullable PermissionAttachment addAttachment(@NotNull Plugin plugin, int ticks) {
+        PermissionAttachment result = addAttachment(plugin);
+
+        if (Bukkit.getServer()
+                .getScheduler()
+                .scheduleSyncDelayedTask(plugin, new RemoveAttachmentRunnable(result), ticks) == -1) {
+            Bukkit.getServer()
+                    .getLogger()
+                    .log(Level.WARNING, "Could not add PermissionAttachment to " + LegacyComponentSerializer.legacySection().serialize(displayName()) + " for plugin " + plugin.getPluginMeta()
+                            .getDisplayName() + ": Scheduler returned -1");
+            result.remove();
+            return null;
+        } else {
+            return result;
+        }
+    }
+
+    @Override
+    public void removeAttachment(@NotNull PermissionAttachment attachment) {
+        if (attachments.remove(attachment)) {
+            PermissionRemovedExecutor permissionRemovedExecutor = attachment.getRemovalCallback();
+
+            if (permissionRemovedExecutor != null) {
+                permissionRemovedExecutor.attachmentRemoved(attachment);
+            }
+
+            permissionUpdate();
+        } else {
+            throw new IllegalArgumentException("Given attachment is not part of Permissible object " + LegacyComponentSerializer.legacySection().serialize(displayName()));
+        }
+    }
+
+    @Override
+    public void recalculatePermissions() {
+        if(initialized)
+        {
+            unsubscribe();
+        }
+
+        Bukkit.getServer().getPluginManager().subscribeToDefaultPerms(isOp() || hasPermission("*"), parent);
+        for (Permission permission : getPermissionList()) {
+            Bukkit.getServer().getPluginManager().subscribeToPermission(permission.getName(), parent);
+        }
+        initialized = true;
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<Permission> getPermissionList() {
+        Set<AttachmentAbstractPermission> permissions = new HashSet<>();
+        for (PermissionAttachment attachment : attachments)
+        {
+            BiConsumer<String, Boolean> transform = (key, value) -> permissions.add(
+                    new AttachmentAbstractPermission(attachment, key, value, PulvinarPermissible.this, true));
+            attachment.getPermissions().forEach(transform);
+        }
+
+        return Stream.concat(super.getPermissionList().stream(), permissions.stream()).collect(Collectors.toSet());
+    }
+
+    /**
+     * The <code>unsubscribe</code> method is used to deregister all permissions from a parent permission holder in the Bukkit server.
+     *
+     * <p>As a result of calling this method, the permission holder specified by 'parent' would not hold the permissions anymore until re-registered.</p>
+     *
+     * <p>Note: Parent could be a Player, a Group, or any entity that can hold permissions in Bukkit.</p>
+     *
+     * <p>It is advised to call this method when you no longer need the permissions to be associated with the parent or want to clear current permissions before setting new ones.</p>
+     *
+     * @see AbstractPermission
+     * @see Permissible
+     */
+    public void unsubscribe() {
+        for (String name : getPermissionList().stream()
+                .map(AbstractPermission::getName)
+                .collect(Collectors.toSet())) {
+            Bukkit.getServer().getPluginManager().unsubscribeFromPermission(name, parent);
+        }
+
+        Bukkit.getServer().getPluginManager().unsubscribeFromDefaultPerms(false, parent);
+        Bukkit.getServer().getPluginManager().unsubscribeFromDefaultPerms(true, parent);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/permission/permissible/PulvinarPlayerPermissible.java b/src/main/java/net/kissenpvp/pulvinar/permission/permissible/PulvinarPlayerPermissible.java
new file mode 100644
index 0000000000000000000000000000000000000000..f284409ad89e0b37ed42ece3b51b77714d2a732d
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/permission/permissible/PulvinarPlayerPermissible.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.pulvinar.permission.permissible;
+
+import net.kissenpvp.core.api.permission.AbstractGroupablePermissionEntry;
+import net.kissenpvp.pulvinar.api.base.Context;
+import net.kissenpvp.pulvinar.api.permission.Permission;
+import net.kyori.adventure.text.Component;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.permissions.Permissible;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Collections;
+import java.util.Optional;
+import java.util.Set;
+import java.util.UUID;
+
+public class PulvinarPlayerPermissible extends PulvinarPermissible {
+
+    public PulvinarPlayerPermissible(@NotNull Permissible parent) {
+        super(parent);
+    }
+
+    @Override
+    public void unsubscribe()
+    {
+        if (getPlayer().isConnected())
+        {
+            super.unsubscribe();
+        }
+    }
+
+    public @NotNull OfflinePlayer getPlayer() {
+        return (OfflinePlayer) parent; // Can be offline or online, does not matter
+    }
+
+    @Override
+    public @NotNull String getPermissionID() {
+        return getContextNotNull(Context.GLOBAL).getPermissionID();
+    }
+
+    @Override
+    public @NotNull Component displayName() {
+        return getPlayer().displayName();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAffectedUsers() {
+        return Collections.singleton(getPlayer().getUniqueId());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<AbstractGroupablePermissionEntry<Permission>> getConnectedEntries()
+    {
+        return getPlayer().isConnected() ? Collections.singleton((AbstractGroupablePermissionEntry<Permission>) parent) : Collections.EMPTY_SET;
+    }
+
+    @Override
+    public void permissionUpdate()
+    {
+        OfflinePlayer player = getPlayer();
+        if (player.isConnected())
+        {
+            ServerPlayer serverPlayer = ((CraftPlayer) player).getHandle();
+            MinecraftServer.getServer().getPlayerList().sendPlayerPermissionLevel(serverPlayer, true);
+        }
+    }
+
+    @Override
+    public @NotNull Optional<AbstractGroupablePermissionEntry<Permission>> getContext(@NotNull Context context)
+    {
+        return Optional.of(getContextNotNull(context));
+    }
+
+    @Override
+    public boolean isOp() {
+        return getPlayer().isOp();
+    }
+
+    @Override
+    public void setOp(boolean value) {
+        getPlayer().setOp(value);
+    }
+
+    @Override
+    public @NotNull AbstractGroupablePermissionEntry<Permission> getContextNotNull(@NotNull Context context)
+    {
+        return (AbstractGroupablePermissionEntry<Permission>) getPlayer().getUser(context);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/user/PlayerSettingCommand.java b/src/main/java/net/kissenpvp/pulvinar/user/PlayerSettingCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..52f25171564f1dc9ebad1e11d3cb0c8f7bef08e5
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/user/PlayerSettingCommand.java
@@ -0,0 +1,108 @@
+package net.kissenpvp.pulvinar.user;
+
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.core.api.command.CommandTarget;
+import net.kissenpvp.core.api.command.annotations.ArgumentName;
+import net.kissenpvp.core.api.command.annotations.CommandData;
+import net.kissenpvp.core.api.command.annotations.TabCompleter;
+import net.kissenpvp.core.api.networking.client.entitiy.PlayerClient;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.api.user.exception.UnauthorizedException;
+import net.kissenpvp.core.api.user.playersettting.RegisteredPlayerSetting;
+import net.kissenpvp.core.api.user.playersettting.UserValue;
+import net.kissenpvp.core.user.playersetting.IllegalSettingException;
+import net.kissenpvp.pulvinar.api.command.CommandExceptionHandler;
+import net.kissenpvp.pulvinar.user.playersetting.PulvinarBoundPlayerSetting;
+import net.kyori.adventure.text.Component;
+import org.bukkit.Bukkit;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Objects;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public class PlayerSettingCommand implements CommandExceptionHandler<IllegalSettingException>
+{
+    @Override
+    public boolean handle(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull IllegalSettingException throwable)
+    {
+        Component setting = Component.text(throwable.getSettingsKey());
+        commandPayload.getSender().sendMessage(Component.translatable("server.user.setting.not.found", setting));
+        return true;
+    }
+
+    @CommandData(value = "setting", runAsync = true, aliases = "settings", target = CommandTarget.PLAYER)
+    public void settingCommand(@NotNull CommandPayload<CommandSender> sender, @NotNull @ArgumentName("setting") String setting, @NotNull @ArgumentName("value") String... value) throws UnauthorizedException
+    {
+        sender.getSender().sendMessage(setSetting(sender, deserialize(setting), String.join(" ", value)));
+    }
+
+    private <T> @NotNull Component setSetting(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull RegisteredPlayerSetting<T, OfflinePlayer> settingsKey, @NotNull String value) throws UnauthorizedException
+    {
+        Component setting = Component.text(settingsKey.getParent().getKey());
+        try
+        {
+            boolean reset = value.equalsIgnoreCase("reset");
+            Player player = (Player) commandPayload.getSender();
+            PulvinarBoundPlayerSetting<T> stetting = new PulvinarBoundPlayerSetting<>(settingsKey, player);
+
+            T newValue = reset ? settingsKey.getParent().getDefaultValue(player):settingsKey.getParent().deserialize(value);
+            stetting.setValue(newValue);
+
+            String langKey = reset ? "server.user.setting.reset" : "server.user.setting.changed";
+            Component changedTo = Component.text(stetting.getSetting().getParent().serialize(newValue));
+            return Component.translatable(langKey, setting, changedTo);
+        }
+        catch (ClassCastException | IllegalArgumentException exception)
+        {
+            return Component.translatable("server.user.setting.value.invalid", setting, Component.text(value));
+        }
+    }
+
+    @TabCompleter("setting")
+    public @NotNull <S extends PlayerClient<?, ?>> Collection<String> settingCommand(@NotNull CommandPayload<CommandSender> payload)
+    {
+        try
+        {
+            if (payload.getArguments().length < 2)
+            {
+                return tabCompletion();
+            }
+
+            RegisteredPlayerSetting<?, S> setting = deserialize(payload.getArguments()[0]);
+            Stream<UserValue<?>> stream = Arrays.stream(setting.getParent().getPossibleValues((S) payload.getSender()));
+            Stream<String> possibilities = stream.map(value -> castUnknownValue(value, setting));
+            return Stream.concat(Stream.of("reset"), possibilities).collect(Collectors.toSet());
+        }
+        catch (IllegalSettingException ignored) {}
+        return Collections.EMPTY_SET;
+    }
+
+    public <S extends PlayerClient<?, ?>> @NotNull RegisteredPlayerSetting<?, S> deserialize(@NotNull String input)
+    {
+        UserImplementation userImplementation = Bukkit.getPulvinar().getImplementation(UserImplementation.class);
+        Stream<RegisteredPlayerSetting<?, ?>> settings = userImplementation.getPlayerSettings().stream();
+        return (RegisteredPlayerSetting<?, S>) settings.filter(userSetting -> {
+            String parentKey = userSetting.getParent().getKey();
+            return Objects.equals(parentKey, input);
+        }).findFirst().orElseThrow(() -> new IllegalSettingException(input));
+    }
+
+    public @NotNull Collection<String> tabCompletion()
+    {
+        UserImplementation userImplementation = Bukkit.getPulvinar().getImplementation(UserImplementation.class);
+        Stream<RegisteredPlayerSetting<?, ?>> settings = userImplementation.getPlayerSettings().stream();
+        return settings.map(setting -> setting.getParent().getKey()).collect(Collectors.toSet());
+    }
+
+    private <T> @NotNull String castUnknownValue(@NotNull Object value, @NotNull RegisteredPlayerSetting<T, ?> setting)
+    {
+        return setting.getParent().serialize(((UserValue<T>) value).value());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/user/PulvinarOperatorList.java b/src/main/java/net/kissenpvp/pulvinar/user/PulvinarOperatorList.java
new file mode 100644
index 0000000000000000000000000000000000000000..ff16cd47708d851542bf2e2fb2bce202c4508856
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/user/PulvinarOperatorList.java
@@ -0,0 +1,247 @@
+package net.kissenpvp.pulvinar.user;
+
+import com.google.gson.JsonObject;
+import com.mojang.authlib.GameProfile;
+import net.kissenpvp.core.api.database.meta.Meta;
+import net.kissenpvp.core.api.database.meta.list.MetaList;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.api.user.UserInfo;
+import net.kissenpvp.pulvinar.api.base.Context;
+import net.minecraft.server.players.ServerOpList;
+import net.minecraft.server.players.ServerOpListEntry;
+import net.minecraft.server.players.StoredUserEntry;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.File;
+import java.util.*;
+import java.util.function.Function;
+import java.util.function.Predicate;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+/**
+ * This is a class that extends the functionality of StoredUserList. It provides functionality to manage a list
+ * of users and their operation permissions(data represented by type ServerOpListEntry), related to a game profile
+ * (data represented by type GameProfile).
+ * <p>
+ * An instance of it can be created by providing a file which acts as the storage medium for
+ * this user list.
+ * <p>
+ * This class may provide additions to StoredUserList, capturing behaviors specific to users
+ * who have operator permissions (as denoted by a ServerOpListEntry) linked to a specific game profile.
+ */
+public class PulvinarOperatorList extends ServerOpList {
+
+    private MetaList<OperatorData> cached;
+
+    /**
+     * Creates a predicate for comparing {@link OperatorData} based on the equality of their associated {@link GameProfile}.
+     *
+     * <p>This method returns a {@link Predicate} that compares {@link OperatorData} based on the equality of their associated {@link GameProfile}.
+     * The returned predicate tests whether the {@link GameProfile} ID of the provided {@link OperatorData} is equal to the ID of the specified {@link GameProfile}.</p>
+     *
+     * @param gameProfile the {@link GameProfile} to compare against
+     * @return a {@link Predicate} for comparing {@link OperatorData} based on the equality of their associated {@link GameProfile}
+     * @throws NullPointerException if the specified {@link GameProfile} is `null`
+     * @see OperatorData
+     * @see GameProfile
+     */
+    @Contract(pure = true, value = "_ -> new")
+    private static @NotNull Predicate<OperatorData> equals(@NotNull GameProfile gameProfile) {
+        return info -> Objects.equals(info.uuid(), gameProfile.getId());
+    }
+
+    /**
+     * This is a class that extends the functionality of StoredUserList. It provides functionality to manage a list
+     * of users and their operation permissions (data represented by type ServerOpListEntry), related to a game profile
+     * (data represented by type GameProfile).
+     * <p>
+     * It is initially not associated with any file storage. Thus, the user list is not loaded from any file nor
+     * does it persist between application invocations if not manually persisted.
+     * <p>
+     * This class may provide additions to StoredUserList, capturing behaviors specific to users
+     * who have operator permissions (as denoted by a ServerOpListEntry) linked to a specific game profile.
+     */
+    public PulvinarOperatorList() {
+        //noinspection DataFlowIssue
+        super(null); // not file based
+    }
+
+    @Override
+    public void add(@NotNull ServerOpListEntry entry) {
+        UUID id = Objects.requireNonNull(entry.getUser()).getId();
+        cached.add(new OperatorData(id, entry.getLevel(), entry.getBypassesPlayerLimit()));
+    }
+
+    @Nullable
+    @Override
+    public ServerOpListEntry get(@NotNull GameProfile key) {
+        return getCached(key).map(OperatorData::getServerOpListEntry).orElse(null);
+    }
+
+    @Override
+    public void remove(@NotNull StoredUserEntry<GameProfile> entry) {
+        remove(Objects.requireNonNull(entry.getUser()));
+    }
+
+    @Override
+    public void remove(@NotNull GameProfile key) {
+        cached.removeIf(equals(key));
+    }
+
+    @Override
+    public String @NotNull [] getUserList() {
+        return getCached().stream().flatMap(node -> {
+            GameProfile info = node.getServerOpListEntry().getUser();
+            return Stream.of(Objects.requireNonNull(info).getName());
+        }).toArray(String[]::new);
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return getCached().isEmpty();
+    }
+
+    @Override
+    protected boolean contains(@NotNull GameProfile k0) {
+        return getCached(k0).isPresent();
+    }
+
+    @Override
+    public @NotNull Collection<ServerOpListEntry> getEntries() {
+        return getCached().stream().map(OperatorData::getServerOpListEntry).collect(Collectors.toSet());
+    }
+
+    @Override
+    public void save() {
+        //ignored
+    }
+
+    @Override
+    protected @NotNull StoredUserEntry<GameProfile> createEntry(@NotNull JsonObject json) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public @NotNull File getFile() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void load() {
+        cached = getMeta().getCollection("operator_players", OperatorData.class).join();
+    }
+
+    @Override
+    protected @NotNull String getKeyForUser(@NotNull GameProfile profile) {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Retrieves implementation of {@link PulvinarUserImplementation} for {@link Context#LOCAL} and gets User Metadata.
+     *
+     * @return object meta of the local user.
+     */
+    protected @NotNull Meta getMeta() {
+        return Bukkit.getPulvinar().getImplementation(PulvinarUserImplementation.class).getMeta(Context.LOCAL);
+    }
+
+    /**
+     * Retrieves the cached {@link OperatorData} associated with the specified {@link GameProfile}, if present.
+     *
+     * <p>This method retrieves the cached {@link OperatorData} from the set of cached data by filtering the set based on the provided {@link GameProfile}.
+     * If the cached data for the specified {@link GameProfile} is found, it is wrapped in an {@link Optional} and returned; otherwise, an empty {@link Optional} is returned.</p>
+     *
+     * @param gameProfile the {@link GameProfile} for which to retrieve the cached {@link OperatorData}
+     * @return an {@link Optional} containing the cached {@link OperatorData} associated with the specified {@link GameProfile},
+     * or an empty {@link Optional} if no data is found for the specified {@link GameProfile}
+     * @throws NullPointerException if the specified {@link GameProfile} is `null`
+     * @see OperatorData
+     * @see GameProfile
+     */
+    protected @NotNull Optional<OperatorData> getCached(@NotNull GameProfile gameProfile) {
+        return getCached().stream().filter(equals(gameProfile)).findFirst();
+    }
+
+    /**
+     * Retrieves the set of LinkedOperatorDataNodes.
+     * <p>
+     * This method returns a set that contains all the LinkedOperatorDataNodes
+     * that are currently being managed.
+     *
+     * @return A Set containing all LinkedOperatorDataNodes.
+     * This returned set is not null.
+     */
+    protected @NotNull Set<OperatorData> getCached()
+    {
+        return Set.copyOf(cached);
+    }
+
+    /**
+     * Represents data for an operator.
+     *
+     * <p>An {@code OperatorData} object encapsulates information about an operator, including their UUID, level, and whether they can bypass server limits.</p>
+     *
+     * @param uuid the UUID of the operator. This value is not `null`.
+     * @param level the level of the operator.
+     * @param bypassServerLimit {@code true} if the operator can bypass server limits; {@code false} otherwise.
+     * @see UUID
+     */
+    protected record OperatorData(@NotNull UUID uuid, int level, boolean bypassServerLimit) {
+
+        /**
+         * Converts {@link UserInfo} to {@link GameProfile}.
+         *
+         * <p>This method returns a {@link Function} that converts a {@link UserInfo} object to a {@link GameProfile}.
+         * The returned function creates a new {@link GameProfile} using the UUID and name obtained from the provided {@link UserInfo}.</p>
+         *
+         * @return a {@link Function} for converting {@link UserInfo} to {@link GameProfile}
+         * @see UserInfo
+         * @see GameProfile
+         */
+        @Contract(pure = true, value = "-> new")
+        private static @NotNull Function<UserInfo, GameProfile> toGameProfile() {
+            return userInfo -> new GameProfile(userInfo.getUUID(), userInfo.getName());
+        }
+
+        /**
+         * Retrieves the {@link ServerOpListEntry} associated with this operator.
+         *
+         * <p>This method retrieves the {@link ServerOpListEntry} associated with this operator.
+         * It obtains the {@link GameProfile} from the cached user profile using the operator's UUID,
+         * then constructs a new {@link ServerOpListEntry} using the obtained {@link GameProfile},
+         * the operator's level, and whether the operator can bypass server limits.</p>
+         *
+         * @return the {@link ServerOpListEntry} associated with this operator
+         * @throws NoSuchElementException if the cached user profile is not present for the operator's UUID
+         * @see ServerOpListEntry
+         */
+        public @NotNull ServerOpListEntry getServerOpListEntry() {
+            UserImplementation userImplementation = Bukkit.getPulvinar().getImplementation(UserImplementation.class);
+            GameProfile gameProfile = userImplementation.getCachedUserProfile(uuid()).map(toGameProfile()).orElseThrow();
+            return new ServerOpListEntry(gameProfile, level(), bypassServerLimit());
+        }
+
+        @Contract(pure = true)
+        @Override
+        public @NotNull String toString() {
+            return "OperatorData{" + "uuid=" + uuid + ", level=" + level + ", bypassServerLimit=" + bypassServerLimit + '}';
+        }
+
+        @Override
+        public boolean equals(Object object) {
+            if (this == object) return true;
+            if (object == null || getClass() != object.getClass()) return false;
+            OperatorData that = (OperatorData) object;
+            return Objects.equals(uuid, that.uuid);
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hashCode(uuid);
+        }
+    }
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/user/PulvinarProfileCache.java b/src/main/java/net/kissenpvp/pulvinar/user/PulvinarProfileCache.java
new file mode 100644
index 0000000000000000000000000000000000000000..e3fb9b7afda13bfa4603a4584fa85f096d3b00fb
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/user/PulvinarProfileCache.java
@@ -0,0 +1,95 @@
+package net.kissenpvp.pulvinar.user;
+
+import com.mojang.authlib.GameProfile;
+import com.mojang.authlib.GameProfileRepository;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.api.user.UserInfo;
+import net.kissenpvp.core.api.user.UserRepository;
+import net.minecraft.server.players.GameProfileCache;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Optional;
+import java.util.UUID;
+import java.util.function.Function;
+
+/**
+ * PulvinarProfileCache is a cache specifically designed for Pulvinar profiles.
+ * This cache extends the {@code GameProfileCache} class to provide additional functionalities
+ * specific to the Pulvinar profiles. It has been designed to be used in the Pulvinar game application.
+ */
+public class PulvinarProfileCache extends GameProfileCache {
+
+    private final UserRepository userRepository;
+
+    /**
+     * Creates a new instance of PulvinarProfileCache.
+     *
+     * @param profileRepository - a not-null instance of a GameProfileRepository which is used to fetch and cache profiles
+     * @throws IllegalArgumentException if profileRepository is null
+     */
+    public PulvinarProfileCache(@NotNull GameProfileRepository profileRepository) {
+        //noinspection DataFlowIssue
+        super(profileRepository, null); // not file based
+        userRepository = new PulvinarUserRepository(profileRepository);
+        PulvinarUserImplementation.setProfileCache(this);
+    }
+
+    @Override
+    public void add(@NotNull GameProfile profile) { /* moved to net.kissenpvp.core.user.KissenPublicUser#setup(String, Map) */ }
+
+    @Nullable
+    @Override
+    public GameProfile getProfileIfCached(@NotNull String name) {
+        return get(name).orElse(null);
+    }
+
+    @Override
+    public @NotNull Optional<GameProfile> get(@NotNull String name) {
+        return Bukkit.getPulvinar().getImplementation(UserImplementation.class).getCachedUserProfile(name).map(transformUserInfo()).or(() -> getUserRepository().getUser(name).join().map(translateUser()));
+    }
+
+    @Override
+    public @NotNull Optional<GameProfile> get(@NotNull UUID uuid) {
+        return Bukkit.getPulvinar().getImplementation(UserImplementation.class).getCachedUserProfile(uuid).map(transformUserInfo()).or(() -> getUserRepository().getUser(uuid).join().map(translateUser()));
+    }
+
+    @Override
+    protected @NotNull List<GameProfileInfo> load() {
+        // ignored
+        return new ArrayList<>();
+    }
+
+    @Override
+    public void save(boolean asyncSave) {
+        // ignored
+    }
+
+    private @NotNull Function<UserInfo, GameProfile> transformUserInfo() {
+        return userInfo -> new GameProfile(userInfo.getUUID(), userInfo.getName());
+    }
+
+    /**
+     * Returns the UserRepository object used within this class.
+     *
+     * @return UserRepository that this class uses to perform user related operations
+     */
+    public @NotNull UserRepository getUserRepository() {
+        return userRepository;
+    }
+
+    /**
+     * Returns a Function that can be used to translate a User object into a GameProfile.
+     *
+     * @return Function that translates a User object into a GameProfile
+     */
+    @Contract(pure = true)
+    private @NotNull Function<User, GameProfile> translateUser() {
+        return user -> new GameProfile((UUID) user.getRawID(), user.getName());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/user/PulvinarPublicUser.java b/src/main/java/net/kissenpvp/pulvinar/user/PulvinarPublicUser.java
new file mode 100644
index 0000000000000000000000000000000000000000..d652421988cb96606afa92da88694d8970c222fa
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/user/PulvinarPublicUser.java
@@ -0,0 +1,227 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.pulvinar.user;
+
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import net.kissenpvp.core.api.database.DataWriter;
+import net.kissenpvp.core.api.database.StorageImplementation;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.database.meta.Meta;
+import net.kissenpvp.core.api.database.meta.Table;
+import net.kissenpvp.core.api.database.meta.list.MetaList;
+import net.kissenpvp.core.api.database.savable.SavableMap;
+import net.kissenpvp.core.api.networking.client.entitiy.PlayerClient;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.ban.warn.WarnNode;
+import net.kissenpvp.core.database.savable.KissenSavableMap;
+import net.kissenpvp.core.permission.PermissionNode;
+import net.kissenpvp.core.user.KissenPublicUser;
+import net.kissenpvp.core.user.KissenUser;
+import net.kissenpvp.pulvinar.api.base.Context;
+import net.kissenpvp.pulvinar.api.permission.Permission;
+import net.kissenpvp.pulvinar.permission.PulvinarPermission;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.*;
+
+/**
+ * The {@code PulvinarPublicUser} class extends the {@link KissenPublicUser} class with {@link Permission}
+ * as its generic type. It represents a public user within the Pulvinar system.
+ * <p>
+ * While it maintains the key characteristics of a {@link KissenPublicUser}, such as a UUID and name,
+ * the {@code PulvinarPublicUser} further enhances this with specifics for a user that has a public profile
+ * accessible across multiple servers.
+ *
+ * @see KissenPublicUser
+ */
+public class PulvinarPublicUser extends KissenPublicUser<Permission> {
+
+    /**
+     * The constructor for the {@code PulvinarPublicUser} class.
+     * It initializes a new instance of the class with a specified UUID and name.
+     *
+     * @param uuid A unique identifier. It may be nullable, representing a user, whose unique identifier
+     *             might not be known or relevant at the expire of creation.
+     * @param name A string representing the username. It may be nullable, representing a user whose name
+     *             might not be known or relevant at the expire of creation.
+     * @throws BackendException If an error occurs during the creation and initialization of a PulvinarPublicUser instance.
+     */
+    public PulvinarPublicUser(@Nullable UUID uuid, @Nullable String name) throws BackendException {
+        super(uuid, name);
+    }
+
+    @Override
+    public @NotNull PlayerClient<?, ?> getPlayerClient() {
+        return getPrivateUserEntry().getPlayerClient();
+    }
+
+    @Override
+    protected @NotNull Permission translatePermission(@NotNull PermissionNode permissionNode, @Nullable DataWriter<PermissionNode> dataWriter) {
+        return new net.kissenpvp.pulvinar.permission.PulvinarPermission(permissionNode, this, dataWriter);
+    }
+
+    @Override
+    public void login() {
+        super.login();
+        getStorage().put("name_hash", getNameHash());
+
+        ((KissenUser<?>) getPrivateUserEntry()).login();
+        getStorage().put("tick", true);
+    }
+
+    @Override
+    public void logout() {
+        super.logout();
+        Bukkit.getPulvinar().getImplementation(StorageImplementation.class).dropStorage(getDatabaseID());
+    }
+
+    @Override
+    public void tick() {
+        super.tick();
+        checkVisuals();
+
+        ((KissenUser<Permission>) getPrivateUserEntry()).tick();
+    }
+
+    @Override
+    protected @NotNull SavableMap createRepository(@Nullable Map<String, Object> data) {
+        Meta meta = Bukkit.getPulvinar().getImplementation(PulvinarUserImplementation.class).getMeta(Context.GLOBAL);
+        return new KissenSavableMap(getDatabaseID(), meta, Objects.requireNonNullElseGet(data, meta.getData(getDatabaseID())::join));
+    }
+
+    @Override
+    public int softDelete() {
+        return super.softDelete() + getPrivateUserEntry().delete();
+    }
+
+    /**
+     * The {@code getPrivateUserEntry} method retrieves an instance of a private user entry from the local storage.
+     * If the private user entry is not yet in the storage, it creates an entry using the 'setupPrivateUser' method.
+     * In case of an exception when creating the private user entry, an error log is produced, and the server
+     * is advised to be shut down to prevent further data problems.
+     *
+     * @return An instance of a {@link User} associated with the private user entry.
+     * Cast is performed without check, which assumes that "private_user_entry" in the storage is always of {@link User} type.
+     */
+    public @NotNull User getPrivateUserEntry() {
+        return (User) getStorage().computeIfAbsent("private_user_entry", (key) -> {
+            return setupPrivateUser(getRawID(), getRepository().getNotNull("name", String.class)); // If offline still return actual private entity
+        });
+    }
+
+    /**
+     * The {@code setupPrivateUser} method creates a new instance of a private user, {@link PulvinarPrivateUser}, using provided UUID and username.
+     *
+     * @param uuid The UUID for the private user to be created.
+     * @param name The username of the private user.
+     * @return An instance of a {@link PulvinarPrivateUser} initialized with the provided UUID and username.
+     * @throws BackendException If an error occurs during the creation and initialization of a PulvinarPrivateUser instance.
+     * @see PulvinarPrivateUser
+     */
+    protected @NotNull PulvinarPublicUser.PulvinarPrivateUser setupPrivateUser(UUID uuid, String name) throws BackendException {
+        return new PulvinarPrivateUser(uuid, name);
+    }
+
+    private void checkVisuals() {
+        int visualHash = getNameHash();
+        if (!Objects.equals(getStorage().get("name_hash"), visualHash)) {
+            updatePermissions(visualHash);
+        }
+    }
+
+    private void updatePermissions(int visualHash) {
+        getStorage().put("name_hash", visualHash);
+
+        if (getStorage().containsKey("tick")) {
+            ((KissenUser<?>) getPrivateUserEntry()).clearCache();
+            permissionUpdate();
+        }
+    }
+
+    private int getNameHash() {
+        return getPlayerClient().getRank().hashCode() + displayName().hashCode();
+    }
+
+    /**
+     * The nested class {@code PulvinarPrivateUser} extends the {@link KissenUser} class while specifying {@link Permission}
+     * as its generic type. It represents a private user entity within the Pulvinar system.
+     * <p>
+     * While the key characteristics of a {@link KissenUser} are maintained such as a UUID and name,
+     * the PulvinarPrivateUser further enhances this with specifics for a user that owns a private profile which only this
+     * server can access.
+     *
+     * @see KissenUser
+     */
+    public static class PulvinarPrivateUser extends KissenUser<Permission> {
+
+        /**
+         * The constructor for the {@code PulvinarPrivateUser} class.
+         * It initializes a new instance of the class with specified UUID and name.
+         *
+         * @param uuid A unique identifier. It may be nullable, representing a user whose unique identifier
+         *             might not be known or relevant at the expiry of creation.
+         * @param name A string representing the username. It may be nullable, representing a user whose name
+         *             might not be known or relevant at the expiry of creation.
+         * @throws BackendException If an error occurs during the creation and initialization of a PulvinarPrivateUser instance.
+         */
+        public PulvinarPrivateUser(@Nullable UUID uuid, @Nullable String name) throws BackendException {
+            super(uuid, name);
+        }
+
+        @Override
+        public @NotNull Table getTable() {
+            return Bukkit.getPulvinar().getImplementation(PulvinarUserImplementation.class).getTable(Context.LOCAL);
+        }
+
+        @Override
+        protected @NotNull SavableMap createRepository(@Nullable Map<String, Object> data) {
+            Meta meta = Bukkit.getPulvinar().getImplementation(PulvinarUserImplementation.class).getMeta(Context.LOCAL);
+            return new KissenSavableMap(getDatabaseID(), meta, Objects.requireNonNullElseGet(data, meta.getData(getDatabaseID())::join));
+        }
+
+        @Override
+        public @NotNull String getSaveID() {
+            return ((PulvinarUserImplementation) getImplementation()).getUserSaveID(Context.LOCAL);
+        }
+
+        @Override
+        public @NotNull PlayerClient<?, ?> getPlayerClient() {
+            UUID uuid = getRawID();
+            return Objects.requireNonNullElse(Bukkit.getPlayer(uuid), Bukkit.getOfflinePlayer(uuid));
+        }
+
+        @Override
+        protected @NotNull Permission translatePermission(@NotNull PermissionNode permissionNode, @Nullable DataWriter<PermissionNode> dataWriter) {
+            return new PulvinarPermission(permissionNode, this, dataWriter);
+        }
+
+        public @NotNull JsonElement getAdvancementsProgress()
+        {
+            return getRepository().get("advancements", JsonElement.class).orElseGet(JsonObject::new);
+        }
+
+        public void setAdvancementsProgress(@NotNull JsonElement progress)
+        {
+            getRepository().set("advancements", progress);
+        }
+    }
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/user/PulvinarUserImplementation.java b/src/main/java/net/kissenpvp/pulvinar/user/PulvinarUserImplementation.java
new file mode 100644
index 0000000000000000000000000000000000000000..e185edd2aa8400910f823e08b6b3d7fbfcb4ab0c
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/user/PulvinarUserImplementation.java
@@ -0,0 +1,169 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.pulvinar.user;
+
+import net.kissenpvp.core.api.database.connection.DatabaseConnection;
+import net.kissenpvp.core.api.database.connection.DatabaseImplementation;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.database.meta.Meta;
+import net.kissenpvp.core.api.database.savable.SavableMap;
+import net.kissenpvp.core.api.networking.client.entitiy.UnknownPlayerException;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.base.KissenImplementation;
+import net.kissenpvp.core.command.InternalCommandImplementation;
+import net.kissenpvp.core.database.KissenTable;
+import net.kissenpvp.core.message.localization.KissenLocalizationImplementation;
+import net.kissenpvp.core.user.KissenUserImplementation;
+import net.kissenpvp.pulvinar.api.base.Context;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+
+import java.text.MessageFormat;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.function.Supplier;
+
+/**
+ * The class 'PulvinarUserImplementation' is an extension of the 'KissenUserImplementation' in the Pulvinar system.
+ * This class is responsible for interacting with or manipulating the paper-related functionality of a Kissen user.
+ * The class holds an instance of PulvinarProfileCache which it uses to cache profiles for efficient read operations.
+ */
+public class PulvinarUserImplementation extends KissenUserImplementation implements KissenImplementation {
+
+    private static PulvinarProfileCache profileCache;
+    private KissenTable privateTable;
+
+    /**
+     * This private static method retrieves the current instance of PulvinarProfileCache.
+     *
+     * @return The current PulvinarProfileCache instance.
+     */
+    private static PulvinarProfileCache getProfileCache() {
+        return profileCache;
+    }
+
+    /**
+     * This public static method sets the PulvinarProfileCache with a new instance.
+     * The method expects to receive an instance of PulvinarProfileCache.
+     * If the input is null, an IllegalStateException will be thrown.
+     *
+     * @param profileCache A new PulvinarProfileCache instance.
+     * @throws IllegalStateException If the provided PulvinarProfileCache instance is null.
+     */
+    public static void setProfileCache(PulvinarProfileCache profileCache) {
+        if (profileCache == null) {
+            throw new IllegalStateException("Object already initialized.");
+        }
+        PulvinarUserImplementation.profileCache = profileCache;
+    }
+
+    public @NotNull KissenTable getTable(@NotNull Context context)
+    {
+        return switch (context)
+        {
+            case GLOBAL -> super.getTable();
+            case LOCAL -> privateTable;
+        };
+    }
+
+    @Override
+    public boolean preStart() {
+        DatabaseImplementation database = Bukkit.getPulvinar().getImplementation(DatabaseImplementation.class);
+
+        DatabaseConnection connection = database.getConnection("private").orElseGet(database::getPrimaryConnection);
+        privateTable = (KissenTable) connection.createTable("kissen_private_user_data");
+        return super.preStart();
+    }
+
+    @Override
+    public boolean start() {
+        InternalCommandImplementation<?> commandImplementation = Bukkit.getPulvinar().getImplementation(InternalCommandImplementation.class);
+        commandImplementation.getInternalHandler().registerExceptionHandler(new PlayerSettingCommand());
+
+        KissenLocalizationImplementation localize = Bukkit.getPulvinar().getImplementation(KissenLocalizationImplementation.class);
+        localize.register("server.user.setting.changed", new MessageFormat("The setting {0} has been set to {1}."));
+        localize.register("server.user.setting.value.invalid", new MessageFormat("The value {0} is not allowed in setting {1}."));
+        localize.register("server.user.setting.not.found", new MessageFormat("The setting {0} does not exists."));
+        localize.register("server.user.setting.reset", new MessageFormat("The setting {1} has been reset to its default value {0}."));
+
+        localize.register("server.user.suffix.granted", new MessageFormat("The suffix {0} was granted to {1}."));
+        localize.register("server.user.suffix.received", new MessageFormat("You have received the suffix {0}."));
+        localize.register("server.user.suffix.revoked", new MessageFormat("The suffix {0} from player {1} was revoked."));
+        localize.register("server.user.suffix.not.found", new MessageFormat("The suffix {0} from player {1} was not found."));
+
+        return super.start();
+    }
+
+    @Override
+    public void setupComplete() {
+        InternalCommandImplementation<?> commandImplementation = Bukkit.getPulvinar().getImplementation(InternalCommandImplementation.class);
+        commandImplementation.getInternalHandler().registerCommand(new PlayerSettingCommand());
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull UUID uuid) {
+
+        Supplier<User> createUser = () -> profileCache.getUserRepository().getUser(uuid).join().orElseThrow(() -> new UnknownPlayerException(String.valueOf(uuid)));
+        Supplier<User> loadUser = () -> {
+            CompletableFuture<SavableMap> future = getMeta(Context.GLOBAL).getData(getUserSaveID() + uuid);
+            return new PulvinarPublicUser(uuid, null);
+        };
+        return getOnlineUser(uuid).orElseGet(loadUser);
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull String name) throws BackendException {
+        try {
+            if (getUserProfiles().stream().noneMatch(userInfo -> userInfo.getName().equals(name))) {
+                throw new UnknownPlayerException(name);
+            }
+            return super.getUser(name);
+        } catch (UnknownPlayerException unknownPlayerException) {
+            return profileCache.getUserRepository().getUser(name).join().orElseThrow(() -> new UnknownPlayerException(name));
+        }
+    }
+
+    /**
+     * Returns the User Save ID for the specified context.
+     *
+     * @param context an enum constant representing the context, either GLOBAL or LOCAL
+     * @return String representing the User Save ID. If context is GLOBAL, the ID is retrieved by getUserSaveID(),
+     * otherwise for LOCAL context, Returns the server's name concatenated with 'privateuser'.
+     */
+    public @NotNull String getUserSaveID(@NotNull Context context) {
+        return switch (context) {
+            case GLOBAL -> getUserSaveID();
+            case LOCAL -> "privateuser";
+        };
+    }
+
+    /**
+     * Returns the User MetaData for the specified context.
+     *
+     * @param context an enum constant indicating the context, either GLOBAL or LOCAL
+     * @return ObjectMeta instance representing User's metadata. If context is GLOBAL, the metadata is retrieved by getUserMeta(),
+     * otherwise for LOCAL context, Returns the private metadata available in Bukkit's 'Kissen'.
+     */
+    public @NotNull Meta getMeta(@NotNull Context context) {
+        return switch (context) {
+            case GLOBAL -> super.getMeta();
+            case LOCAL -> privateTable.setupMeta(null);
+        };
+    }
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/user/PulvinarUserRepository.java b/src/main/java/net/kissenpvp/pulvinar/user/PulvinarUserRepository.java
new file mode 100644
index 0000000000000000000000000000000000000000..e2335922f5403dbdded24e74c009a7f7663cec23
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/user/PulvinarUserRepository.java
@@ -0,0 +1,132 @@
+package net.kissenpvp.pulvinar.user;
+
+import com.mojang.authlib.GameProfile;
+import com.mojang.authlib.GameProfileRepository;
+import com.mojang.authlib.ProfileLookupCallback;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.api.user.UserRepository;
+import net.minecraft.core.UUIDUtil;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Optional;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.atomic.AtomicReference;
+
+/**
+ * The class 'PulvinarUserRepository' implements the 'UserRepository' interface.
+ * It represents a repository for the User entities from mojang.
+ * Compliant with the Repository pattern, this class is intended to encapsulate all
+ * data access mechanics needed for User entities.
+ * <p>
+ * It also holds a 'GameProfileRepository' which perhaps holds the source data for the
+ * Users, or is another important factor in the retrieval or manipulation of User data.
+ */
+public class PulvinarUserRepository implements UserRepository {
+
+    private final GameProfileRepository gameProfileRepository;
+
+    /**
+     * The constructor for the 'PulvinarUserRepository' class.
+     * It initializes a new instance of the class with a specified 'GameProfileRepository' object.
+     *
+     * @param gameProfileRepository A 'GameProfileRepository' object.
+     * Specifies the game profile repository that the user repository will work with.
+     */
+    public PulvinarUserRepository(@NotNull GameProfileRepository gameProfileRepository) {
+        this.gameProfileRepository = gameProfileRepository;
+    }
+
+    @Override
+    public @NotNull CompletableFuture<Optional<User>> getUser(@NotNull String name) throws BackendException {
+
+        if(!shouldAuthorize())
+        {
+            //TODO
+        }
+
+        CompletableFuture<Optional<User>> gameProfileCompletableFuture = new CompletableFuture<>();
+        AtomicReference<Optional<GameProfile>> fetchedRef = new AtomicReference<>(Optional.empty());
+
+        gameProfileRepository.findProfilesByNames(new String[]{name}, new ProfileLookupCallback() {
+            @Override
+            public void onProfileLookupSucceeded(GameProfile gameProfile) {
+                fetchedRef.set(Optional.ofNullable(gameProfile));
+            }
+
+            @Override
+            public void onProfileLookupFailed(String s, Exception e) {
+                gameProfileCompletableFuture.completeExceptionally(e);
+            }
+        });
+
+        fetchedRef.get().ifPresentOrElse(gameProfile -> processGameProfile(gameProfileCompletableFuture, gameProfile), () -> processMissingProfile(gameProfileCompletableFuture, name));
+
+        return gameProfileCompletableFuture;
+    }
+
+    @Override
+    public @NotNull CompletableFuture<Optional<User>> getUser(@NotNull UUID uuid) {
+        return null; //TODO
+    }
+
+    /**
+     * This method is used to determine whether authorization should take place.
+     * Its behaviour may be determined by the 'GlobalConfiguration' setting 'isProxyOnlineMode'.
+     * The return value implies whether the proxy is in online mode or not,
+     * which further implies whether authentication is needed.
+     *
+     * @return A boolean value -- 'true' when proxy is in online mode implying authorization
+     * is required for network interactions, 'false' otherwise.
+     */
+    private boolean shouldAuthorize()
+    {
+        return io.papermc.paper.configuration.GlobalConfiguration.get().proxies.isProxyOnlineMode();
+    }
+
+    /**
+     * Processes a potentially missing user profile. If authentication is not required,
+     * it will generate and process a "cracked" user profile with an offline player UUID.
+     * Otherwise, the method will complete the CompletableFuture with an empty Optional.
+     *
+     * @param gameProfileFuture a CompletableFuture that will be completed with the found (or not found) User
+     * @param name the name of the user to lookup
+     */
+    private void processMissingProfile(CompletableFuture<Optional<User>> gameProfileFuture, String name) {
+        if (!shouldAuthorize()) {
+            // Create cracked user
+            UUID offlineUUID = UUIDUtil.createOfflinePlayerUUID(name);
+            processGameProfile(gameProfileFuture, new GameProfile(offlineUUID, name));
+            return;
+        }
+        gameProfileFuture.complete(Optional.empty());
+    }
+
+    /**
+     * Processes a game profile and completes the CompletableFuture with the translated User object.
+     * If any error occurs during the translation, the resulting BackendException will be completed exceptionally
+     * inside the CompletableFuture.
+     *
+     * @param gameProfileFuture a CompletableFuture that will be completed with the translated User or an Error.
+     * @param gameProfile the game profile to process.
+     */
+    private void processGameProfile(CompletableFuture<Optional<User>> gameProfileFuture, GameProfile gameProfile) {
+        try {
+            gameProfileFuture.complete(Optional.of(translate(gameProfile)));
+        } catch (BackendException backendException) {
+            gameProfileFuture.completeExceptionally(backendException);
+        }
+    }
+
+    /**
+     * Translates a game profile into a PulvinarPublicUser object.
+     *
+     * @param gameProfile the game profile to translate.
+     * @return PulvinarPublicUser a new user object with the id and name from the passed game profile.
+     * @throws BackendException if any error occurs during the translation process.
+     */
+    private @NotNull User translate(@NotNull GameProfile gameProfile) throws BackendException {
+        return new PulvinarPublicUser(gameProfile.getId(), gameProfile.getName());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/user/PulvinarUserWhiteList.java b/src/main/java/net/kissenpvp/pulvinar/user/PulvinarUserWhiteList.java
new file mode 100644
index 0000000000000000000000000000000000000000..11e5da902fe7acb0e67fbe09bf79bfdb5c4dfdb3
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/user/PulvinarUserWhiteList.java
@@ -0,0 +1,142 @@
+package net.kissenpvp.pulvinar.user;
+
+import com.google.gson.JsonObject;
+import com.mojang.authlib.GameProfile;
+import net.kissenpvp.core.api.database.meta.list.MetaList;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.api.user.UserInfo;
+import net.kissenpvp.pulvinar.api.base.Context;
+import net.minecraft.server.players.StoredUserEntry;
+import net.minecraft.server.players.UserWhiteList;
+import net.minecraft.server.players.UserWhiteListEntry;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Collection;
+import java.util.Objects;
+import java.util.Set;
+import java.util.UUID;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+
+/**
+ * Represents a user whitelist specific to the Kissen application.
+ *
+ * <p>The {@code KissenUserWhiteList} class extends {@link UserWhiteList} and provides functionality for managing a whitelist of users
+ * specific to the Kissen application. This class is not file-based, meaning it does not rely on external files for storing user whitelist data.</p>
+ *
+ * @see UserWhiteList
+ */
+public class PulvinarUserWhiteList extends UserWhiteList {
+
+    private MetaList<UUID> whitelisted;
+
+    /**
+     * Constructs a new instance of {@code KissenUserWhiteList}.
+     *
+     * <p>This constructor initializes the whitelist of users specific to the Kissen application. It sets up an empty HashSet to store whitelisted users.</p>
+     */
+    public PulvinarUserWhiteList() {
+        //noinspection DataFlowIssue
+        super(null); // not file based
+    }
+
+    private static @NotNull PulvinarUserImplementation getImplementation() {
+        return Bukkit.getPulvinar().getImplementation(PulvinarUserImplementation.class);
+    }
+
+    @Override
+    public @NotNull File getFile() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Nullable
+    @Override
+    public UserWhiteListEntry get(@NotNull GameProfile key) {
+        return getWhitelisted().stream().filter(userInfo -> userInfo.getUUID().equals(key.getId())).map(user -> new UserWhiteListEntry(new GameProfile(user.getUUID(), user.getName()))).findFirst().orElse(null);
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return getWhitelisted().isEmpty();
+    }
+
+    @Override
+    protected boolean contains(@NotNull GameProfile k0) {
+        return getWhitelisted().stream().anyMatch(userInfo -> userInfo.getUUID().equals(k0.getId()));
+    }
+
+    @Override
+    public @NotNull Collection<UserWhiteListEntry> getEntries() {
+        return getWhitelisted().stream().map(userInfo -> new GameProfile(userInfo.getUUID(), userInfo.getName())).map(UserWhiteListEntry::new).collect(Collectors.toSet());
+    }
+
+    @Override
+    public String @NotNull [] getUserList() {
+        return getWhitelisted().stream().map(UserInfo::getName).distinct().toArray(String[]::new);
+    }
+
+    @Override
+    public void save() throws IOException {
+        // ignored
+    }
+
+    @Override
+    public void add(@NotNull UserWhiteListEntry entry) {
+        if (!new io.papermc.paper.event.server.WhitelistStateUpdateEvent(com.destroystokyo.paper.profile.CraftPlayerProfile.asBukkitCopy(Objects.requireNonNull(entry.getUser())), io.papermc.paper.event.server.WhitelistStateUpdateEvent.WhitelistStatus.ADDED).callEvent()) {
+            return;
+        }
+
+        UserImplementation userImplementation = getImplementation();
+        whitelisted.replaceOrInsert(entry.getUser().getId());
+    }
+
+    @Override
+    public void remove(@NotNull StoredUserEntry<GameProfile> entry) {
+        remove(Objects.requireNonNull(entry.getUser()));
+    }
+
+    @Override
+    protected @NotNull StoredUserEntry<GameProfile> createEntry(@NotNull JsonObject json) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    protected @NotNull String getKeyForUser(@NotNull GameProfile gameProfile) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void remove(@NotNull GameProfile profile) {
+        if (!new io.papermc.paper.event.server.WhitelistStateUpdateEvent(com.destroystokyo.paper.profile.CraftPlayerProfile.asBukkitCopy(profile), io.papermc.paper.event.server.WhitelistStateUpdateEvent.WhitelistStatus.REMOVED).callEvent()) {
+            return;
+        }
+
+        whitelisted.remove(profile.getId());
+    }
+
+    @Override
+    public void load() throws IOException {
+        whitelisted = getImplementation().getMeta(Context.LOCAL).getCollection("whitelisted_players", UUID.class).join();
+    }
+
+    /**
+     * Retrieves the set of whitelisted user information.
+     *
+     * <p>This method returns an unmodifiable set containing user information of whitelisted users. Any attempt to modify the returned set will result in an UnsupportedOperationException.
+     * The set returned by this method is backed by the original set, meaning changes to the original set will be reflected in the returned set and vice versa.</p>
+     *
+     * @return an unmodifiable set containing user information of whitelisted users
+     * @see UserInfo
+     */
+    protected @NotNull Set<UserInfo> getWhitelisted() {
+        UserImplementation user = getImplementation();
+        Function<UUID, Stream<UserInfo>> toUser = uuid -> user.getCachedUserProfile(uuid).stream();
+        return whitelisted.stream().flatMap(toUser).collect(Collectors.toUnmodifiableSet());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/user/playersetting/PulvinarBoundPlayerSetting.java b/src/main/java/net/kissenpvp/pulvinar/user/playersetting/PulvinarBoundPlayerSetting.java
new file mode 100644
index 0000000000000000000000000000000000000000..b8e9035dfc4c5ec8e99cf39fc4eab54f7d5b1b11
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/user/playersetting/PulvinarBoundPlayerSetting.java
@@ -0,0 +1,74 @@
+package net.kissenpvp.pulvinar.user.playersetting;
+
+import net.kissenpvp.core.api.database.savable.SavableMap;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.api.user.exception.UnauthorizedException;
+import net.kissenpvp.core.api.user.playersettting.RegisteredPlayerSetting;
+import net.kissenpvp.core.api.user.playersettting.UserValue;
+import net.kissenpvp.core.user.playersetting.KissenBoundPlayerSetting;
+import net.kissenpvp.pulvinar.api.base.Context;
+import net.kissenpvp.pulvinar.api.user.playersetting.BoundPlayerSetting;
+import org.bukkit.OfflinePlayer;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Objects;
+import java.util.Optional;
+
+public class PulvinarBoundPlayerSetting<T> extends KissenBoundPlayerSetting<T, OfflinePlayer> implements BoundPlayerSetting<T> {
+
+    public PulvinarBoundPlayerSetting(@NotNull RegisteredPlayerSetting<T, OfflinePlayer> setting, @NotNull OfflinePlayer player) {
+        super(setting, player);
+    }
+
+    @Override
+    public @NotNull T setValue(@NotNull T value) throws UnauthorizedException {
+        return setValue(value, Context.LOCAL);
+    }
+
+    @Override
+    public @NotNull T getValue() {
+        return super.getValue(getPlayer().getUser(Context.LOCAL)).or(() -> {
+            User globalUser = getPlayer().getUser(Context.GLOBAL);
+            return super.getValue(globalUser);
+        }).orElse(getSetting().getParent().getDefaultValue(getPlayer()));
+    }
+
+    @Override
+    public void reset() {
+        //TODO debate
+        super.reset(getPlayer().getUser(Context.LOCAL));
+        super.reset(getPlayer().getUser(Context.GLOBAL));
+    }
+
+    @Override
+    public @NotNull T setValue(@NotNull T value, @NotNull Context context) throws UnauthorizedException {
+        T oldValue = getValue(context);
+
+        UserValue<T>[] possibilities = getSetting().getParent().getPossibleValues(getPlayer());
+        if (possibilities.length!=0) {
+            isAllowed(value, possibilities);
+        }
+
+        T defaultValue = getSetting().getParent().getDefaultValue(getPlayer());
+        if (Objects.equals(defaultValue, value)) {
+            reset();
+            return oldValue;
+        }
+
+        setValue(getPlayer().getUser(context), value);
+        return oldValue;
+    }
+
+    @Override
+    public @NotNull T getValue(@NotNull Context context) {
+        T defaultValue = getSetting().getParent().getDefaultValue(getPlayer());
+        SavableMap repo = getPlayer().getUser(context).getRepository(getSetting().getPlugin());
+        Optional<String> value = repo.get(getKey(), String.class);
+        return value.map(currentValue -> getSetting().getParent().deserialize(currentValue)).orElse(defaultValue);
+    }
+
+    @Override
+    public void reset(@NotNull Context context) {
+        super.reset(getPlayer().getUser(context));
+    }
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/user/rank/PulvinarFallBackRank.java b/src/main/java/net/kissenpvp/pulvinar/user/rank/PulvinarFallBackRank.java
new file mode 100644
index 0000000000000000000000000000000000000000..c7628e16d053649ef2a129deac2c9bec1a6c18f5
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/user/rank/PulvinarFallBackRank.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.pulvinar.user.rank;
+
+import net.kissenpvp.core.user.rank.KissenFallBackRank;
+import net.kissenpvp.pulvinar.api.user.rank.Rank;
+import org.bukkit.Bukkit;
+import org.bukkit.OfflinePlayer;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Set;
+import java.util.stream.Collectors;
+
+public class PulvinarFallBackRank extends KissenFallBackRank implements Rank {
+    @Override
+    public @NotNull @Unmodifiable Set<OfflinePlayer> getPlayers() {
+        return Bukkit.getOnlinePlayers().stream().filter(playerClient ->
+        {
+            Rank paperRank = playerClient.getRank().getSource();
+            return paperRank.equals(this);
+        }).collect(Collectors.toUnmodifiableSet());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/user/rank/PulvinarPlayerFallBackRank.java b/src/main/java/net/kissenpvp/pulvinar/user/rank/PulvinarPlayerFallBackRank.java
new file mode 100644
index 0000000000000000000000000000000000000000..2458fb71b6e1e021d2bb298da28dfb18c213c11f
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/user/rank/PulvinarPlayerFallBackRank.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.pulvinar.user.rank;
+
+import net.kissenpvp.core.api.database.DataWriter;
+import net.kissenpvp.core.user.rank.KissenPlayerFallBackRank;
+import net.kissenpvp.core.user.rank.PlayerRankNode;
+import net.kissenpvp.pulvinar.api.user.rank.PlayerRank;
+import net.kissenpvp.pulvinar.api.user.rank.Rank;
+import org.bukkit.OfflinePlayer;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class PulvinarPlayerFallBackRank extends KissenPlayerFallBackRank<Rank> implements PlayerRank
+{
+
+    private final OfflinePlayer player;
+
+    public PulvinarPlayerFallBackRank(@NotNull OfflinePlayer player) {
+        this.player = player;
+    }
+
+    @Override public @NotNull Rank getSource()
+    {
+        return new PulvinarFallBackRank();
+    }
+
+    @NotNull
+    @Override
+    public OfflinePlayer getPlayer() {
+        return player;
+    }
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/user/rank/PulvinarPlayerRank.java b/src/main/java/net/kissenpvp/pulvinar/user/rank/PulvinarPlayerRank.java
new file mode 100644
index 0000000000000000000000000000000000000000..5bd129138949086423460a59181dedea4283c861
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/user/rank/PulvinarPlayerRank.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.pulvinar.user.rank;
+
+import net.kissenpvp.core.api.database.DataWriter;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.user.rank.event.AbstractAsyncRankExpireEvent;
+import net.kissenpvp.core.api.user.rank.event.AbstractPostAsyncRankExpireEvent;
+import net.kissenpvp.core.user.rank.KissenPlayerRank;
+import net.kissenpvp.core.user.rank.PlayerRankNode;
+import net.kissenpvp.pulvinar.api.user.rank.PlayerRank;
+import net.kissenpvp.pulvinar.api.user.rank.Rank;
+import net.kissenpvp.pulvinar.user.rank.event.PulvinarAsyncRankExpireEvent;
+import net.kissenpvp.pulvinar.user.rank.event.PulvinarPostAsyncRankExpireEvent;
+import org.bukkit.Bukkit;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.time.Instant;
+import java.util.Objects;
+
+public class PulvinarPlayerRank extends KissenPlayerRank<Rank> implements PlayerRank {
+
+    private final OfflinePlayer player;
+
+    public PulvinarPlayerRank(@NotNull OfflinePlayer player, @NotNull PlayerRankNode playerRankNode, @Nullable DataWriter<PlayerRankNode> dataWriter) {
+        super(playerRankNode, dataWriter);
+        this.player = player;
+    }
+
+    @NotNull
+    @Override
+    public OfflinePlayer getPlayer() {
+        return player;
+    }
+
+    @Override
+    public void setEnd(@Nullable Instant end) throws EventCancelledException {
+        if (Objects.nonNull(end) && Instant.now().plusMillis(1).isAfter(end)) {
+            PulvinarAsyncRankExpireEvent asyncRankExpireEvent = new PulvinarAsyncRankExpireEvent(AbstractAsyncRankExpireEvent.ExpiryCause.MANUAL, this);
+            Bukkit.getPluginManager().callEvent(asyncRankExpireEvent);
+            if (asyncRankExpireEvent.isCancelled()) {
+                super.setEnd(asyncRankExpireEvent.getCancelled());
+                return;
+            }
+            super.setEnd(end);
+            if(getPlayer() instanceof Player)
+            {
+                getPlayer().getUser().getStorage().remove("rank_current_index");
+            }
+            PulvinarPostAsyncRankExpireEvent asyncRankExpiredEvent = new PulvinarPostAsyncRankExpireEvent(AbstractPostAsyncRankExpireEvent.ExpiryCause.MANUAL, this);
+            Bukkit.getPluginManager().callEvent(asyncRankExpiredEvent);
+            return;
+        }
+
+        super.setEnd(end);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/user/rank/PulvinarRank.java b/src/main/java/net/kissenpvp/pulvinar/user/rank/PulvinarRank.java
new file mode 100644
index 0000000000000000000000000000000000000000..836f1622e4e808c428d7239ac8eaeacbabdb074f
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/user/rank/PulvinarRank.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2023 KissenPvP
+ *
+ * This program is licensed under the Apache License, Version 2.0.
+ *
+ * This software may be redistributed and/or modified under the terms
+ * of the Apache License as published by the Apache Software Foundation,
+ * either version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, either express or implied. See the Apache
+ * License, Version 2.0 for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * You should have received a copy of the Apache License, Version 2.0
+ * along with this program. If not, see <http://www.apache.org/licenses/LICENSE-2.0>.
+ */
+
+package net.kissenpvp.pulvinar.user.rank;
+
+import net.kissenpvp.core.api.database.meta.Meta;
+import net.kissenpvp.core.api.database.meta.Table;
+import net.kissenpvp.core.api.database.savable.SavableMap;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.user.rank.event.AbstractAsyncRankDeleteEvent;
+import net.kissenpvp.core.database.savable.KissenSavableMap;
+import net.kissenpvp.core.user.rank.KissenRank;
+import net.kissenpvp.core.user.rank.KissenRankImplementation;
+import net.kissenpvp.core.user.rank.event.InternalAsyncRankDeleteEvent;
+import net.kissenpvp.pulvinar.api.user.rank.Rank;
+import net.kissenpvp.pulvinar.user.rank.event.PulvinarAsyncRankDeleteEvent;
+import net.kissenpvp.pulvinar.user.rank.event.PulvinarPostAsyncRankDeleteEvent;
+import net.kissenpvp.pulvinar.user.rank.event.PulvinarRankPriorityChangeEvent;
+import org.bukkit.Bukkit;
+import org.bukkit.OfflinePlayer;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.jetbrains.annotations.Unmodifiable;
+
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+public class PulvinarRank extends KissenRank implements Rank {
+
+    @Override
+    protected @NotNull SavableMap createRepository(@Nullable Map<String, Object> data) {
+        Meta meta = Bukkit.getPulvinar().getImplementation(KissenRankImplementation.class).getMeta();
+        return new KissenSavableMap(getDatabaseID(), meta, Objects.requireNonNullElseGet(data, meta.getData(getDatabaseID())::join));
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<OfflinePlayer> getPlayers() {
+        return Bukkit.getOnlinePlayers().stream().filter(playerClient -> {
+            Rank paperRank = playerClient.getRank().getSource();
+            return paperRank.equals(this);
+        }).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public void setPriority(int priority) {
+        PulvinarRankPriorityChangeEvent priorityChangeEvent = new PulvinarRankPriorityChangeEvent(this, getPriority(), priority);
+        Bukkit.getPluginManager().callEvent(priorityChangeEvent);
+        if (priorityChangeEvent.isCancelled()) {
+            throw new EventCancelledException();
+        }
+        super.setPriority(priorityChangeEvent.getPriority());
+    }
+
+    @Override
+    protected @NotNull AbstractAsyncRankDeleteEvent<?> deleteEvent() {
+        PulvinarAsyncRankDeleteEvent rankDeleteEvent = new PulvinarAsyncRankDeleteEvent(this);
+        Bukkit.getPluginManager().callEvent(rankDeleteEvent);
+        return rankDeleteEvent;
+    }
+
+    @Override
+    protected void deletedEvent() {
+        PulvinarPostAsyncRankDeleteEvent rankDeletedEvent = new PulvinarPostAsyncRankDeleteEvent(this);
+        Bukkit.getPluginManager().callEvent(rankDeletedEvent);
+    }
+
+    @Override
+    public @NotNull Table getTable() {
+        return Bukkit.getPulvinar().getImplementation(KissenRankImplementation.class).getTable();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/user/rank/PulvinarRankImplementation.java b/src/main/java/net/kissenpvp/pulvinar/user/rank/PulvinarRankImplementation.java
new file mode 100644
index 0000000000000000000000000000000000000000..d4529bdb7c7022fd1ba584c4d4b02f5a3756e86f
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/user/rank/PulvinarRankImplementation.java
@@ -0,0 +1,70 @@
+package net.kissenpvp.pulvinar.user.rank;
+
+import net.kissenpvp.core.api.database.savable.Savable;
+import net.kissenpvp.core.api.user.rank.AbstractRank;
+import net.kissenpvp.core.base.KissenImplementation;
+import net.kissenpvp.core.command.InternalCommandImplementation;
+import net.kissenpvp.core.message.localization.KissenLocalizationImplementation;
+import net.kissenpvp.core.user.rank.KissenRankImplementation;
+import net.kissenpvp.core.user.rank.event.InternalAsyncRankCreateEvent;
+import net.kissenpvp.pulvinar.api.user.rank.Rank;
+import net.kissenpvp.pulvinar.api.user.rank.RankImplementation;
+import net.kissenpvp.pulvinar.api.user.rank.RankParser;
+import net.kissenpvp.pulvinar.user.rank.event.PulvinarAsyncRankCreateEvent;
+import net.kissenpvp.pulvinar.user.rank.event.PulvinarPostAsyncRankCreateEvent;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+
+import java.text.MessageFormat;
+
+public class PulvinarRankImplementation extends KissenRankImplementation<Rank> implements RankImplementation, KissenImplementation {
+
+    @Override
+    public boolean start() {
+        KissenLocalizationImplementation localize = Bukkit.getPulvinar().getImplementation(KissenLocalizationImplementation.class);
+        localize.register("server.rank.edit.prefix.set", new MessageFormat("The prefix from rank {0} has been set to {1}.."));
+        localize.register("server.rank.edit.suffix.set", new MessageFormat("The suffix from rank {0} has been set to {1}.."));
+        localize.register("server.rank.edit.chatcolor.set", new MessageFormat("The chatcolor from rank {0} has been set to {1}."));
+        localize.register("server.rank.edit.priority.set", new MessageFormat("The priority from rank {0} has been set to {1}."));
+
+        localize.register("server.rank.player.granted", new MessageFormat("The player {0} now has the rank {1} granted."));
+        localize.register("server.rank.player.revoked", new MessageFormat("The rank {1} from player {0} has been revoked."));
+        localize.register("server.rank.player.not.found", new MessageFormat("The player {0} does not have a rank with the id {1}."));
+
+        localize.register("server.rank.created", new MessageFormat("The rank {0} has been created with the priority {1}."));
+        localize.register("server.rank.deleted", new MessageFormat("The rank {0} has been deleted."));
+
+        InternalCommandImplementation<CommandSender> command = Bukkit.getPulvinar().getImplementation(InternalCommandImplementation.class);
+        command.getInternalHandler().registerParser(Rank.class, new RankParser());
+        return super.start();
+    }
+
+    @Override
+    public void setupComplete() {
+        InternalCommandImplementation<CommandSender> commandImplementation = Bukkit.getPulvinar().getImplementation(InternalCommandImplementation.class);
+        commandImplementation.getInternalHandler().registerCommand(new RankCommand());
+    }
+
+    @Override
+    protected @NotNull InternalAsyncRankCreateEvent<? extends AbstractRank> createEvent(@NotNull Rank rank) {
+        PulvinarAsyncRankCreateEvent event = new PulvinarAsyncRankCreateEvent(rank);
+        Bukkit.getPluginManager().callEvent(event);
+        return event;
+    }
+
+    @Override
+    protected void postCreateEvent(@NotNull Rank rank) {
+        Bukkit.getPluginManager().callEvent(new PulvinarPostAsyncRankCreateEvent(rank));
+    }
+
+    @Override
+    protected @NotNull Savable<String> getSavableType() {
+        return new PulvinarRank();
+    }
+
+    @Override
+    protected @NotNull Rank getFallbackRank() {
+        return new PulvinarFallBackRank();
+    }
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/user/rank/RankCommand.java b/src/main/java/net/kissenpvp/pulvinar/user/rank/RankCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..5dc797b8b990b9d01a193ec1777000c5b4e3f6c7
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/user/rank/RankCommand.java
@@ -0,0 +1,132 @@
+package net.kissenpvp.pulvinar.user.rank;
+
+import net.kissenpvp.core.api.command.CommandPayload;
+import net.kissenpvp.core.api.command.annotations.ArgumentName;
+import net.kissenpvp.core.api.command.annotations.CommandData;
+import net.kissenpvp.core.api.command.annotations.TabCompleter;
+import net.kissenpvp.core.api.time.AccurateDuration;
+import net.kissenpvp.core.api.time.TemporalObject;
+import net.kissenpvp.core.api.user.rank.AbstractPlayerRank;
+import net.kissenpvp.pulvinar.api.command.parser.OfflinePlayerParser;
+import net.kissenpvp.pulvinar.api.user.rank.PlayerRank;
+import net.kissenpvp.pulvinar.api.user.rank.Rank;
+import net.kyori.adventure.text.Component;
+import org.bukkit.Bukkit;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+
+import java.time.Instant;
+import java.util.Collection;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.function.Function;
+import java.util.function.Predicate;
+import java.util.function.Supplier;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+/**
+ * The {@code RankCommand} class represents a command related to player ranks.
+ *
+ * <p>This class provides functionality for handling commands related to player ranks, such as setting, querying, or modifying
+ * rank-related information. It may include methods for managing player ranks, checking rank permissions, or performing
+ * rank-specific actions.</p>
+ */
+public class RankCommand {
+
+    /**
+     * Grants a rank to the specified offline player and generates a message indicating the rank has been granted.
+     *
+     * <p>The {@code rankGrant} method grants the specified {@link PlayerRank} to the {@link OfflinePlayer},
+     * generating a message indicating the successful grant. The generated message includes the player's display name
+     * and the name of the granted rank.</p>
+     *
+     * @param offlinePlayer   the {@link OfflinePlayer} to whom the rank is granted
+     * @param paperPlayerRank the {@link PlayerRank} to be granted
+     * @return a {@link Component} representing the message indicating the rank has been granted
+     * @throws NullPointerException if either {@code offlinePlayer} or {@code paperPlayerRank} is {@code null}
+     */
+    private static @NotNull Component rankGrant(@NotNull OfflinePlayer offlinePlayer, @NotNull PlayerRank paperPlayerRank) {
+        Component rankName = Component.text(paperPlayerRank.getSource().getName());
+        return Component.translatable("server.rank.player.granted", offlinePlayer.displayName(), rankName);
+    }
+
+    /**
+     * Returns a {@link Predicate} that ends the rank with the specified ID and sets its end time to the current instant.
+     *
+     * <p>The {@code endRank} method returns a {@link Predicate} that can be used with {@link Stream#anyMatch(Predicate)}
+     * to find and end the rank with the specified ID. If the rank is found and is currently valid, its end time is set to the
+     * current instant, and the predicate returns {@code true}; otherwise, it returns {@code false}.</p>
+     *
+     * <p>This method is intended for use with streams and filtering rank history based on the rank's ID.</p>
+     *
+     * @param id the ID of the rank to be ended
+     * @return a {@link Predicate} ending the rank with the specified ID
+     * @throws NullPointerException if {@code id} is {@code null}
+     */
+    @Contract(pure = true, value = "_ -> new")
+    private static @NotNull Predicate<PlayerRank> revokeRank(@NotNull String id) {
+        return current -> {
+            if (Objects.equals(current.getID(), id) && current.isValid()) {
+                current.setEnd(Instant.now());
+                return true;
+            }
+            return false;
+        };
+    }
+
+    @CommandData(value = "rank.grant")
+    public void rankGrant(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull OfflinePlayer offlinePlayer, @NotNull @ArgumentName("rank") Rank paperRank, @NotNull @ArgumentName("duration") Optional<AccurateDuration> accurateDuration) {
+        Function<AccurateDuration, PlayerRank> grant = duration -> offlinePlayer.grantRank(paperRank, duration);
+        Supplier<PlayerRank> orElse = () -> offlinePlayer.grantRank(paperRank);
+        commandPayload.getSender().sendMessage(rankGrant(offlinePlayer, accurateDuration.map(grant).orElseGet(orElse)));
+    }
+
+    @CommandData(value = "rank.revoke", runAsync = true)
+    public void rankRevoke(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull OfflinePlayer offlinePlayer, @ArgumentName("playerrankid") @NotNull String id) {
+
+        String translationString = "server.rank.player.not.found";
+        if (offlinePlayer.getRankHistory().stream().anyMatch(revokeRank(id))) {
+            translationString = "server.rank.player.revoked";
+        }
+
+        Component[] args = {offlinePlayer.displayName(), Component.text(id)};
+        commandPayload.getSender().sendMessage(Component.translatable(translationString, args));
+    }
+
+    @CommandData(value = "rank.edit.priority")
+    public void rankRevoke(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull Rank paperRank, @ArgumentName("priority") int priority) {
+        paperRank.setPriority(priority);
+
+        Component[] args = {Component.text(paperRank.getName()), Component.text(priority)};
+        commandPayload.getSender().sendMessage(Component.translatable("server.rank.edit.priority.set", args));
+    }
+
+    @CommandData(value = "rank.create", runAsync = true)
+    public void rankCreate(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull @ArgumentName("name") String name, @ArgumentName("priority") int priority) {
+        Class<PulvinarRankImplementation> clazz = PulvinarRankImplementation.class;
+        PulvinarRankImplementation rankImplementation = Bukkit.getPulvinar().getImplementation(clazz);
+        Rank paperRank = rankImplementation.createRankTemplate(name, priority);
+
+        Component[] args = {Component.text(paperRank.getName()), Component.text(priority)};
+        commandPayload.getSender().sendMessage(Component.translatable("server.rank.created", args));
+    }
+
+    @CommandData(value = "rank.delete", runAsync = true)
+    public void rankDelete(@NotNull CommandPayload<CommandSender> commandPayload, @NotNull Rank paperRank) {
+        paperRank.delete();
+        commandPayload.getSender().sendMessage(Component.translatable("server.rank.deleted", Component.text(paperRank.getName())));
+    }
+
+    @TabCompleter(value = "rank.revoke")
+    public @NotNull Collection<String> rankRevokeTab(@NotNull CommandPayload<CommandSender> commandPayload) {
+        OfflinePlayerParser offlinePlayerParser = new OfflinePlayerParser();
+        if (commandPayload.getArguments().length < 2) {
+            return offlinePlayerParser.tabCompletion(commandPayload);
+        }
+        OfflinePlayer offlinePlayer = offlinePlayerParser.deserialize(commandPayload.getArguments()[0]);
+        return offlinePlayer.getRankHistory().stream().filter(TemporalObject::isValid).map(AbstractPlayerRank::getID).collect(Collectors.toSet());
+    }
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/user/rank/event/PulvinarAsyncRankCreateEvent.java b/src/main/java/net/kissenpvp/pulvinar/user/rank/event/PulvinarAsyncRankCreateEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..06b797ff2f336ec02e4549e1ab86a7143db952e1
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/user/rank/event/PulvinarAsyncRankCreateEvent.java
@@ -0,0 +1,14 @@
+package net.kissenpvp.pulvinar.user.rank.event;
+
+import net.kissenpvp.core.user.rank.event.InternalAsyncRankCreateEvent;
+import net.kissenpvp.core.user.rank.event.InternalAsyncRankDeleteEvent;
+import net.kissenpvp.pulvinar.api.user.rank.Rank;
+import net.kissenpvp.pulvinar.api.user.rank.event.AsyncRankCreateEvent;
+import net.kissenpvp.pulvinar.api.user.rank.event.AsyncRankDeleteEvent;
+import org.jetbrains.annotations.NotNull;
+
+public class PulvinarAsyncRankCreateEvent extends InternalAsyncRankCreateEvent<Rank> implements AsyncRankCreateEvent {
+    public PulvinarAsyncRankCreateEvent(@NotNull Rank rankTemplate) {
+        super(rankTemplate);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/user/rank/event/PulvinarAsyncRankDeleteEvent.java b/src/main/java/net/kissenpvp/pulvinar/user/rank/event/PulvinarAsyncRankDeleteEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..db6497f9e05d8d9de33e0490b33d7be141631c4d
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/user/rank/event/PulvinarAsyncRankDeleteEvent.java
@@ -0,0 +1,12 @@
+package net.kissenpvp.pulvinar.user.rank.event;
+
+import net.kissenpvp.core.user.rank.event.InternalAsyncRankDeleteEvent;
+import net.kissenpvp.pulvinar.api.user.rank.Rank;
+import net.kissenpvp.pulvinar.api.user.rank.event.AsyncRankDeleteEvent;
+import org.jetbrains.annotations.NotNull;
+
+public class PulvinarAsyncRankDeleteEvent extends InternalAsyncRankDeleteEvent<Rank> implements AsyncRankDeleteEvent {
+    public PulvinarAsyncRankDeleteEvent(@NotNull Rank rankTemplate) {
+        super(rankTemplate);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/user/rank/event/PulvinarAsyncRankExpireEvent.java b/src/main/java/net/kissenpvp/pulvinar/user/rank/event/PulvinarAsyncRankExpireEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..e37ade2a2099f6f2c9d7d1068d25c93a37d5011f
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/user/rank/event/PulvinarAsyncRankExpireEvent.java
@@ -0,0 +1,12 @@
+package net.kissenpvp.pulvinar.user.rank.event;
+
+import net.kissenpvp.core.user.rank.event.InternalAsyncRankExpireEvent;
+import net.kissenpvp.pulvinar.api.user.rank.PlayerRank;
+import net.kissenpvp.pulvinar.api.user.rank.event.AsyncRankExpireEvent;
+import org.jetbrains.annotations.NotNull;
+
+public class PulvinarAsyncRankExpireEvent extends InternalAsyncRankExpireEvent<PlayerRank> implements AsyncRankExpireEvent {
+    public PulvinarAsyncRankExpireEvent(@NotNull ExpiryCause expiryCause, @NotNull PlayerRank playerRank) {
+        super(expiryCause, playerRank);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/user/rank/event/PulvinarPostAsyncRankCreateEvent.java b/src/main/java/net/kissenpvp/pulvinar/user/rank/event/PulvinarPostAsyncRankCreateEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..12c02ef27bb3bbfdebe2dafeecf6801105797bcb
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/user/rank/event/PulvinarPostAsyncRankCreateEvent.java
@@ -0,0 +1,14 @@
+package net.kissenpvp.pulvinar.user.rank.event;
+
+import net.kissenpvp.core.user.rank.event.InternalAsyncRankDeletedEvent;
+import net.kissenpvp.core.user.rank.event.InternalPostAsyncRankCreateEvent;
+import net.kissenpvp.pulvinar.api.user.rank.Rank;
+import net.kissenpvp.pulvinar.api.user.rank.event.PostAsyncRankCreateEvent;
+import net.kissenpvp.pulvinar.api.user.rank.event.PostAsyncRankDeleteEvent;
+import org.jetbrains.annotations.NotNull;
+
+public class PulvinarPostAsyncRankCreateEvent extends InternalPostAsyncRankCreateEvent<Rank> implements PostAsyncRankCreateEvent {
+    public PulvinarPostAsyncRankCreateEvent(@NotNull Rank rankTemplate) {
+        super(rankTemplate);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/user/rank/event/PulvinarPostAsyncRankDeleteEvent.java b/src/main/java/net/kissenpvp/pulvinar/user/rank/event/PulvinarPostAsyncRankDeleteEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..b5bf185a7b63eeb82c1ec3a4dcb617093629d74a
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/user/rank/event/PulvinarPostAsyncRankDeleteEvent.java
@@ -0,0 +1,12 @@
+package net.kissenpvp.pulvinar.user.rank.event;
+
+import net.kissenpvp.core.user.rank.event.InternalAsyncRankDeletedEvent;
+import net.kissenpvp.pulvinar.api.user.rank.Rank;
+import net.kissenpvp.pulvinar.api.user.rank.event.PostAsyncRankDeleteEvent;
+import org.jetbrains.annotations.NotNull;
+
+public class PulvinarPostAsyncRankDeleteEvent extends InternalAsyncRankDeletedEvent<Rank> implements PostAsyncRankDeleteEvent {
+    public PulvinarPostAsyncRankDeleteEvent(@NotNull Rank rankTemplate) {
+        super(rankTemplate);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/user/rank/event/PulvinarPostAsyncRankExpireEvent.java b/src/main/java/net/kissenpvp/pulvinar/user/rank/event/PulvinarPostAsyncRankExpireEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..53a115289cee448d477a372d938b8dbaaca29b80
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/user/rank/event/PulvinarPostAsyncRankExpireEvent.java
@@ -0,0 +1,13 @@
+package net.kissenpvp.pulvinar.user.rank.event;
+
+import net.kissenpvp.core.user.rank.event.InternalPostAsyncRankExpireEvent;
+import net.kissenpvp.pulvinar.api.user.rank.PlayerRank;
+import net.kissenpvp.pulvinar.api.user.rank.event.PostAsyncRankExpireEvent;
+import org.jetbrains.annotations.NotNull;
+
+public class PulvinarPostAsyncRankExpireEvent extends InternalPostAsyncRankExpireEvent<PlayerRank> implements PostAsyncRankExpireEvent {
+
+    public PulvinarPostAsyncRankExpireEvent(@NotNull ExpiryCause expiryCause, @NotNull PlayerRank playerRank) {
+        super(expiryCause, playerRank);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/user/rank/event/PulvinarRankEvent.java b/src/main/java/net/kissenpvp/pulvinar/user/rank/event/PulvinarRankEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..3a667d0f69ff253f573a04d08191784ce67c6757
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/user/rank/event/PulvinarRankEvent.java
@@ -0,0 +1,12 @@
+package net.kissenpvp.pulvinar.user.rank.event;
+
+import net.kissenpvp.core.user.rank.event.InternalRankEvent;
+import net.kissenpvp.pulvinar.api.user.rank.Rank;
+import net.kissenpvp.pulvinar.api.user.rank.event.RankEvent;
+import org.jetbrains.annotations.NotNull;
+
+public class PulvinarRankEvent extends InternalRankEvent<Rank> implements RankEvent {
+    public PulvinarRankEvent(@NotNull Rank rank) {
+        super(rank);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/user/rank/event/PulvinarRankGrantEvent.java b/src/main/java/net/kissenpvp/pulvinar/user/rank/event/PulvinarRankGrantEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..fe51fb81a74b3a0c0b639589fc62dd8c6925bc7a
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/user/rank/event/PulvinarRankGrantEvent.java
@@ -0,0 +1,12 @@
+package net.kissenpvp.pulvinar.user.rank.event;
+
+import net.kissenpvp.core.user.rank.event.InternalRankGrantEvent;
+import net.kissenpvp.pulvinar.api.user.rank.PlayerRank;
+import net.kissenpvp.pulvinar.api.user.rank.event.RankGrantEvent;
+import org.jetbrains.annotations.NotNull;
+
+public class PulvinarRankGrantEvent extends InternalRankGrantEvent<PlayerRank> implements RankGrantEvent {
+    public PulvinarRankGrantEvent(@NotNull PlayerRank oldRank, @NotNull PlayerRank rank) {
+        super(oldRank, rank);
+    }
+}
diff --git a/src/main/java/net/kissenpvp/pulvinar/user/rank/event/PulvinarRankPriorityChangeEvent.java b/src/main/java/net/kissenpvp/pulvinar/user/rank/event/PulvinarRankPriorityChangeEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..2ccd382c937c741a83f16f55e5777b78f537bb5e
--- /dev/null
+++ b/src/main/java/net/kissenpvp/pulvinar/user/rank/event/PulvinarRankPriorityChangeEvent.java
@@ -0,0 +1,12 @@
+package net.kissenpvp.pulvinar.user.rank.event;
+
+import net.kissenpvp.core.user.rank.event.InternalRankPriorityChangeEvent;
+import net.kissenpvp.pulvinar.api.user.rank.Rank;
+import net.kissenpvp.pulvinar.api.user.rank.event.RankPriorityChangeEvent;
+import org.jetbrains.annotations.NotNull;
+
+public class PulvinarRankPriorityChangeEvent extends InternalRankPriorityChangeEvent<Rank> implements RankPriorityChangeEvent {
+    public PulvinarRankPriorityChangeEvent(@NotNull Rank rank, int previousPriority, int priority) {
+        super(rank, previousPriority, priority);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Main.java b/src/main/java/net/minecraft/server/Main.java
index 0f7d6da8685716604f0749d4f5b60730a44cde73..db8962b02212fb88650f39a753b007bdbbf62d14 100644
--- a/src/main/java/net/minecraft/server/Main.java
+++ b/src/main/java/net/minecraft/server/Main.java
@@ -188,15 +188,17 @@ public class Main {
             org.spigotmc.SpigotConfig.disabledAdvancements = spigotConfiguration.getStringList("advancements.disabled"); // Paper - fix SPIGOT-5885, must be set early in init
             // Paper start - fix SPIGOT-5824
             File file;
-            File userCacheFile = new File(Services.USERID_CACHE_FILE);
+            /* Pulvinar - remove cache file
+             * File userCacheFile = new File(Services.USERID_CACHE_FILE);
+             */
             if (optionset.has("universe")) {
                 file = (File) optionset.valueOf("universe"); // CraftBukkit
-                userCacheFile = new File(file, Services.USERID_CACHE_FILE);
+                //userCacheFile = new File(file, Services.USERID_CACHE_FILE); // Pulvinar
             } else {
                 file = new File(bukkitConfiguration.getString("settings.world-container", "."));
             }
             // Paper end - fix SPIGOT-5824
-            Services services = Services.create(new com.destroystokyo.paper.profile.PaperAuthenticationService(Proxy.NO_PROXY), file, userCacheFile, optionset); // Paper - pass OptionSet to load paper config files; override authentication service; fix world-container
+            Services services = Services.create(new com.destroystokyo.paper.profile.PaperAuthenticationService(Proxy.NO_PROXY), file/*, userCacheFile Pulvinar - remove cache file*/, optionset); // Paper - pass OptionSet to load paper config files; override authentication service; fix world-container
             // CraftBukkit start
             String s = (String) Optional.ofNullable((String) optionset.valueOf("world")).orElse(dedicatedserversettings.getProperties().levelName);
             LevelStorageSource convertable = LevelStorageSource.createDefault(file.toPath());
diff --git a/src/main/java/net/minecraft/server/Services.java b/src/main/java/net/minecraft/server/Services.java
index 33e3815a0c979609d4c7ab83ad91e87ac07a556d..a586088fb740e9c04992c702942a8e6098eb82f2 100644
--- a/src/main/java/net/minecraft/server/Services.java
+++ b/src/main/java/net/minecraft/server/Services.java
@@ -26,10 +26,10 @@ public record Services(
     // Paper end - add paper configuration files
     public static final String USERID_CACHE_FILE = "usercache.json"; // Paper - private -> public
 
-    public static Services create(YggdrasilAuthenticationService authenticationService, File rootDirectory, File userCacheFile, joptsimple.OptionSet optionSet) throws Exception { // Paper - add optionset to load paper config files; add userCacheFile parameter
+    public static Services create(YggdrasilAuthenticationService authenticationService, File rootDirectory, /* File userCacheFile Pulvinar - remove cache file,*/ joptsimple.OptionSet optionSet) throws Exception { // Paper - add optionset to load paper config files; add userCacheFile parameter
         MinecraftSessionService minecraftSessionService = authenticationService.createMinecraftSessionService();
         GameProfileRepository gameProfileRepository = authenticationService.createProfileRepository();
-        GameProfileCache gameProfileCache = new GameProfileCache(gameProfileRepository, userCacheFile); // Paper - use specified user cache file
+        GameProfileCache gameProfileCache = /*new GameProfileCache(gameProfileRepository, userCacheFile);*/  new net.kissenpvp.pulvinar.user.PulvinarProfileCache(gameProfileRepository); // Paper - use specified user cache file  // Pulvinar - use database instead
         // Paper start - load paper config files from cli options
         final java.nio.file.Path legacyConfigPath = ((File) optionSet.valueOf("paper-settings")).toPath();
         final java.nio.file.Path configDirPath = ((File) optionSet.valueOf("paper-settings-directory")).toPath();
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedPlayerList.java b/src/main/java/net/minecraft/server/dedicated/DedicatedPlayerList.java
index 22c4f8dea99f92a1eb3da2baf0a15bf9d2ca0462..91bc235e7a7fbde5bde4a60a8f623bbf3b6b65ec 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedPlayerList.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedPlayerList.java
@@ -30,7 +30,7 @@ public class DedicatedPlayerList extends PlayerList {
         this.loadOps();
         this.loadWhiteList();
         this.saveOps();
-        if (!this.getWhiteList().getFile().exists()) {
+        if (/*!this.getWhiteList().getFile().exists()*/ true) { // Pulvinar
             this.saveWhiteList();
         }
     }
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index 4b5d0ccd37534bd987d997338033e363a7a56b76..18141baee317e2a0cab36664fc097cd4a0883609 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -2287,17 +2287,22 @@ public class ServerPlayer extends net.minecraft.world.entity.player.Player imple
 
     public void sendSystemMessage(Component message, boolean overlay) {
         if (this.acceptsSystemMessages(overlay)) {
-            this.connection.send(new ClientboundSystemChatPacket(message, overlay), PacketSendListener.exceptionallySend(() -> {
-                if (this.acceptsSystemMessages(false)) {
-                    boolean flag1 = true;
-                    String s = message.getString(256);
-                    MutableComponent ichatmutablecomponent = Component.literal(s).withStyle(ChatFormatting.YELLOW);
-
-                    return new ClientboundSystemChatPacket(Component.translatable("multiplayer.message_not_delivered", ichatmutablecomponent).withStyle(ChatFormatting.RED), false);
-                } else {
-                    return null;
-                }
-            }));
+            // Pulvinar start - add custom renderer
+            net.kyori.adventure.text.Component component = PaperAdventure.asAdventure(message);
+            Bukkit.getPulvinar().getImplementation(net.kissenpvp.core.api.message.ChatImplementation.class).handle(Bukkit.getConsoleSender(), getBukkitEntity(), component).ifPresent(styled ->
+                this.connection.send(new ClientboundSystemChatPacket(styled, overlay), PacketSendListener.exceptionallySend(() -> {
+                    if (this.acceptsSystemMessages(false)) {
+                        boolean flag1 = true;
+                        String s = message.getString(256);
+                        MutableComponent ichatmutablecomponent = Component.literal(s).withStyle(ChatFormatting.YELLOW);
+
+                        return new ClientboundSystemChatPacket(PaperAdventure.asAdventure(Component.translatable("multiplayer.message_not_delivered", ichatmutablecomponent).withStyle(ChatFormatting.RED)), false);
+                    } else {
+                        return null;
+                    }
+                }))
+            );
+            // Pulvinar end
         }
     }
 
diff --git a/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
index 5edd8e6bcabe5714c89d4c88f672cc3130c27045..f063aadc2659ec6b706a48c693b08749338dfe59 100644
--- a/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
@@ -52,6 +52,13 @@ import org.bukkit.craftbukkit.util.Waitable;
 import org.bukkit.event.player.AsyncPlayerPreLoginEvent;
 import org.bukkit.event.player.PlayerPreLoginEvent;
 
+// Pulvinar start
+import org.bukkit.Bukkit;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.user.KissenUserImplementation;
+import net.kissenpvp.pulvinar.user.PulvinarPublicUser;
+// Pulvinar end
+
 public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener, TickablePacketListener, CraftPlayer.TransferCookieConnection {
 
     @Override
@@ -355,6 +362,17 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener,
             return gameprofile;
         }
         // Paper end - Add Velocity IP Forwarding Support
+
+        // Pulvinar start
+        PulvinarPublicUser publicUser = new PulvinarPublicUser(gameprofile.getId(), gameprofile.getName());
+        if (!loginUser(publicUser, gameprofile))
+        {
+            publicUser.logout();
+            return gameprofile;
+        }
+        // Pulvinar end
+
+        // Paper end - Velocity support
         String playerName = gameprofile.getName();
         java.net.InetAddress address = ((java.net.InetSocketAddress) this.connection.getRemoteAddress()).getAddress();
         java.util.UUID uniqueId = gameprofile.getId();
@@ -398,6 +416,46 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener,
     }
     // CraftBukkit end
 
+    // Pulvinar start
+    /**
+     * Attempts to log in a user represented by a GameProfile object. This includes loading the PulvinarPublicUser via a
+     * KissenUserImplementation, checking the user's ban status, and if not banned, loading the user's
+     * private data.
+     *
+     * <p>If the user cannot be loaded, or they have an outstanding punishment, the method
+     * will disconnect them with an appropriate message and return false. If an exception occurs in the process,
+     * the user is also disconnected and false is returned. If the user is loaded successfully and has no
+     * outstanding punishments, true is returned.</p>
+     *
+     * @param gameProfile The GameProfile of the user attempting to log in. This parameter must not be null.
+     * @return true if the user was successfully logged in, false otherwise.
+     * @throws NullPointerException If gameProfile is null.
+     *
+     * @see PulvinarPublicUser
+     * @see GameProfile
+     */
+    private boolean loginUser(@org.jetbrains.annotations.NotNull PulvinarPublicUser user, @org.jetbrains.annotations.NotNull GameProfile gameProfile) {
+        try {
+            if(!Bukkit.getPulvinar().getImplementation(KissenUserImplementation.class).loadUser(user))
+            {
+                disconnect(Component.translatable("multiplayer.disconnect.unverified_username"));
+                return false;
+            }
+
+            if(Bukkit.hasWhitelist() && !MinecraftServer.getServer().getPlayerList().isWhiteListed(gameProfile))
+            {
+                disconnect(Component.translatable("multiplayer.disconnect.not_whitelisted"));
+                return false;
+            }
+
+        } catch (BackendException backendException) {
+            disconnect(Component.translatable("multiplayer.disconnect.unverified_username")); // maybe better message
+            return false;
+        }
+        return true;
+    }
+    // Pulvinar end
+
     @Override
     public void handleCustomQueryPacket(ServerboundCustomQueryAnswerPacket packet) {
         // Paper start - Add Velocity IP Forwarding Support
diff --git a/src/main/java/net/minecraft/server/players/GameProfileCache.java b/src/main/java/net/minecraft/server/players/GameProfileCache.java
index 34b4166adfae8ff7d1eb73d56a72931b005330a7..5534457a2898ea447aaeab997adad93e0afc36e0 100644
--- a/src/main/java/net/minecraft/server/players/GameProfileCache.java
+++ b/src/main/java/net/minecraft/server/players/GameProfileCache.java
@@ -230,7 +230,7 @@ public class GameProfileCache {
         return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z", Locale.ROOT);
     }
 
-    public List<GameProfileCache.GameProfileInfo> load() {
+    protected List<GameProfileCache.GameProfileInfo> load() { // Pulvinar - private -> protected
         List<GameProfileCache.GameProfileInfo> list = Lists.newArrayList();
 
         try {
@@ -401,7 +401,7 @@ public class GameProfileCache {
         }
     }
 
-    private static class GameProfileInfo {
+    protected static class GameProfileInfo { // Pulvinar - private -> protected
 
         private final GameProfile profile;
         final Date expirationDate;
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index b14e56c6b117b28c604259ad179d10e79f7c4cdd..9cbb8e26c9f835b788282b9836a74bfa1b8a9df9 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -168,8 +168,8 @@ public abstract class PlayerList {
 
         this.bans = new UserBanList(PlayerList.USERBANLIST_FILE);
         this.ipBans = new IpBanList(PlayerList.IPBANLIST_FILE);
-        this.ops = new ServerOpList(PlayerList.OPLIST_FILE);
-        this.whitelist = new UserWhiteList(PlayerList.WHITELIST_FILE);
+        this.ops = /*new ServerOpList(PlayerList.OPLIST_FILE);*/ new net.kissenpvp.pulvinar.user.PulvinarOperatorList(); // Pulvinar
+        this.whitelist = /*new UserWhiteList(PlayerList.WHITELIST_FILE);*/ new net.kissenpvp.pulvinar.user.PulvinarUserWhiteList(); // Pulvinar
         // CraftBukkit start
         // this.stats = Maps.newHashMap();
         // this.advancements = Maps.newHashMap();
@@ -314,7 +314,6 @@ public abstract class PlayerList {
         } else {
             ichatmutablecomponent = Component.translatable("multiplayer.player.joined.renamed", player.getDisplayName(), s);
         }
-        // CraftBukkit start
         ichatmutablecomponent.withStyle(ChatFormatting.YELLOW);
         Component joinMessage = ichatmutablecomponent; // Paper - Adventure
 
@@ -343,6 +342,13 @@ public abstract class PlayerList {
         // Ensure that player inventory is populated with its viewer
         player.containerMenu.transferTo(player.containerMenu, bukkitPlayer);
 
+        // Pulvinar start
+        if(!org.bukkit.Bukkit.getPulvinar().getImplementation(net.kissenpvp.core.user.KissenUserImplementation.class).loginUser(bukkitPlayer.getUser()))
+        {
+            //TODO disconnect player
+        }
+        // Pulvinar end
+
         PlayerJoinEvent playerJoinEvent = new PlayerJoinEvent(bukkitPlayer, io.papermc.paper.adventure.PaperAdventure.asAdventure(ichatmutablecomponent)); // Paper - Adventure
         this.cserver.getPluginManager().callEvent(playerJoinEvent);
 
@@ -683,6 +689,12 @@ public abstract class PlayerList {
         this.cserver.getScoreboardManager().removePlayer(entityplayer.getBukkitEntity());
         // CraftBukkit end
 
+        // Pulvinar start - logout user
+        if(!org.bukkit.Bukkit.getPulvinar().getImplementation(net.kissenpvp.core.user.KissenUserImplementation.class).logoutUser(entityplayer.getBukkitEntity().getUser()))
+        {
+            PlayerList.LOGGER.warn("Player {} was on the server but was not recognized by the system.", entityplayer.getName());
+        }
+
         return playerQuitEvent.quitMessage(); // Paper - Adventure
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java b/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java
index 29d2fb87a65778926aea2cfc7a5b486cad596515..ae06979699340d221e55eb49a6ffa09b9c0ce1c5 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java
@@ -42,6 +42,11 @@ public class CraftOfflinePlayer implements OfflinePlayer, ConfigurationSerializa
     private final CraftServer server;
     private final PlayerDataStorage storage;
 
+    // Pulvinar start
+    private final org.bukkit.permissions.Permissible permissible = new net.kissenpvp.pulvinar.permission.permissible.PulvinarPlayerPermissible(this);
+    private net.kissenpvp.pulvinar.networking.client.entity.InternalPulvinarPlayerClient pulvinarPlayer;
+    // Pulvinar end
+
     protected CraftOfflinePlayer(CraftServer server, GameProfile profile) {
         this.server = server;
         this.profile = profile;
@@ -797,4 +802,387 @@ public class CraftOfflinePlayer implements OfflinePlayer, ConfigurationSerializa
         }
     }
     // Purpur end - OfflinePlayer API
+
+    // Pulvinar start - integrate kissen user
+    private @org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.networking.client.entity.InternalPulvinarPlayerClient getPulvinarPlayer()
+    {
+        if(pulvinarPlayer== null) {
+            pulvinarPlayer = new net.kissenpvp.pulvinar.networking.client.entity.InternalPulvinarPlayerClient() {
+
+                private net.kissenpvp.core.api.user.User cachedUser;
+
+                @Override
+                public @org.jetbrains.annotations.NotNull net.kissenpvp.core.api.user.User getUser() {
+                    return java.util.Optional.ofNullable(cachedUser).orElseGet(() ->
+                    {
+                        cachedUser = super.getUser();
+                        return cachedUser;
+                    });
+                }
+
+                @Override
+                public @org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.permission.PaperPermissible getPermissible() throws net.kissenpvp.pulvinar.api.permission.PermissibleOverriddenException {
+                    return (net.kissenpvp.pulvinar.api.permission.PaperPermissible) permissible;
+                }
+
+                @Override
+                public @org.jetbrains.annotations.NotNull UUID getUniqueId() {
+                    return CraftOfflinePlayer.this.getUniqueId();
+                }
+
+                @Override
+                public boolean isConnected() {
+                    return false;
+                }
+            };
+        }
+        return pulvinarPlayer;
+    }
+
+    @Override
+    public final boolean isClient() {
+        return true;
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull java.util.Set<UUID> getAltAccounts() {
+        return getPulvinarPlayer().getAltAccounts();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull UUID getTotalID() {
+        return getPulvinarPlayer().getTotalID();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.ban.Punishment punish(@org.jetbrains.annotations.NotNull net.kissenpvp.core.api.ban.AbstractBanTemplate ban, @org.jetbrains.annotations.NotNull net.kissenpvp.core.api.networking.client.entitiy.ServerEntity banOperator) {
+        return getPulvinarPlayer().punish(ban, banOperator);
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.ban.Punishment punish(@org.jetbrains.annotations.NotNull net.kissenpvp.core.api.ban.AbstractBanTemplate ban, @org.jetbrains.annotations.NotNull net.kissenpvp.core.api.networking.client.entitiy.ServerEntity banOperator, @org.jetbrains.annotations.Nullable net.kyori.adventure.text.Component reason) {
+        return getPulvinarPlayer().punish(ban, banOperator, reason);
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull java.util.Optional<net.kissenpvp.pulvinar.api.ban.Punishment> getPunishment(@org.jetbrains.annotations.NotNull String id) {
+        return getPulvinarPlayer().getPunishment(id);
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull @org.jetbrains.annotations.Unmodifiable List<net.kissenpvp.pulvinar.api.ban.Punishment> getPunishmentHistory() {
+        return getPulvinarPlayer().getPunishmentHistory();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull net.kyori.adventure.text.Component displayName() {
+        return getPulvinarPlayer().displayName();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull net.kissenpvp.core.api.time.AccurateDuration getOnlineTime() {
+        return getPulvinarPlayer().getOnlineTime();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull net.kissenpvp.core.api.user.User getUser() {
+        return getPulvinarPlayer().getUser();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull @org.jetbrains.annotations.Unmodifiable List<net.kissenpvp.pulvinar.api.user.rank.PlayerRank> getRankHistory() {
+        return getPulvinarPlayer().getRankHistory();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.user.rank.PlayerRank getRank() {
+        return getPulvinarPlayer().getRank();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.user.rank.PlayerRank grantRank(@org.jetbrains.annotations.NotNull net.kissenpvp.core.api.user.rank.AbstractRank rank) {
+        return getPulvinarPlayer().grantRank(rank);
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.user.rank.PlayerRank grantRank(@org.jetbrains.annotations.NotNull net.kissenpvp.core.api.user.rank.AbstractRank rank, @org.jetbrains.annotations.Nullable net.kissenpvp.core.api.time.AccurateDuration accurateDuration) {
+        return getPulvinarPlayer().grantRank(rank, accurateDuration);
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull java.util.Locale getCurrentLocale() {
+        return getPulvinarPlayer().getCurrentLocale();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull java.util.Set<net.kissenpvp.pulvinar.api.networking.client.entity.PulvinarOnlinePlayerClient> getOnlineAltAccounts() {
+        return getPulvinarPlayer().getOnlineAltAccounts();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull net.kissenpvp.core.api.time.AccurateDuration getOnlineTime(@org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.base.Context context) {
+        return getPulvinarPlayer().getOnlineTime(context);
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull net.kissenpvp.core.api.user.User getUser(@org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.base.Context context) {
+        return getPulvinarPlayer().getUser(context);
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.permission.PaperPermissible getPermissible() throws net.kissenpvp.pulvinar.api.permission.PermissibleOverriddenException {
+        return getPulvinarPlayer().getPermissible();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull <X> net.kissenpvp.pulvinar.api.user.playersetting.BoundPlayerSetting<X> getSetting(@org.jetbrains.annotations.NotNull Class<? extends net.kissenpvp.pulvinar.api.user.playersetting.PlayerSetting<X>> settingClass) {
+        return getPulvinarPlayer().getSetting(settingClass);
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull <X> net.kissenpvp.pulvinar.api.user.playersetting.BoundPlayerSetting<X> getSetting(@org.jetbrains.annotations.NotNull Class<? extends net.kissenpvp.pulvinar.api.user.playersetting.PlayerSetting<X>> settingClass, @org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.base.Context context)
+    {
+        return getPulvinarPlayer().getSetting(settingClass, context);
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.ban.warn.Warn warn(@org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.ban.BanTemplate ban, @org.jetbrains.annotations.NotNull net.kissenpvp.core.api.networking.client.entitiy.ServerEntity warnOperator)
+    {
+        return getPulvinarPlayer().warn(ban, warnOperator);
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.ban.warn.Warn warn(@org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.ban.BanTemplate ban, @org.jetbrains.annotations.NotNull net.kissenpvp.core.api.networking.client.entitiy.ServerEntity warnOperator, @org.jetbrains.annotations.Nullable net.kyori.adventure.text.Component reason)
+    {
+        return getPulvinarPlayer().warn(ban, warnOperator, reason);
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull @org.jetbrains.annotations.Unmodifiable List<net.kissenpvp.pulvinar.api.ban.warn.Warn> getWarnHistory()
+    {
+        return getPulvinarPlayer().getWarnHistory();
+    }
+
+    @Override
+    public void clearActiveWarns()
+    {
+        getPulvinarPlayer().clearActiveWarns();
+    }
+
+    @Override
+    public boolean isPermissionSet(@org.jetbrains.annotations.NotNull String name) {
+        return getPulvinarPlayer().getPermissionContext().isPermissionSet(name);
+    }
+
+    @Override
+    public boolean isPermissionSet(@org.jetbrains.annotations.NotNull org.bukkit.permissions.Permission perm) {
+        return getPulvinarPlayer().getPermissionContext().isPermissionSet(perm);
+    }
+
+    @Override
+    public boolean hasPermission(@org.jetbrains.annotations.NotNull String name) {
+        return getPulvinarPlayer().getPermissionContext().hasPermission(name);
+    }
+
+    @Override
+    public boolean hasPermission(@org.jetbrains.annotations.NotNull org.bukkit.permissions.Permission perm) {
+        return getPulvinarPlayer().getPermissionContext().hasPermission(perm);
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull org.bukkit.permissions.PermissionAttachment addAttachment(@org.jetbrains.annotations.NotNull Plugin plugin, @org.jetbrains.annotations.NotNull String name, boolean value) {
+        return getPulvinarPlayer().getPermissionContext().addAttachment(plugin, name, value);
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull org.bukkit.permissions.PermissionAttachment addAttachment(@org.jetbrains.annotations.NotNull Plugin plugin) {
+        return getPulvinarPlayer().getPermissionContext().addAttachment(plugin);
+    }
+
+    @Override
+    public @org.jetbrains.annotations.Nullable org.bukkit.permissions.PermissionAttachment addAttachment(@org.jetbrains.annotations.NotNull Plugin plugin, @org.jetbrains.annotations.NotNull String name, boolean value, int ticks) {
+        return getPulvinarPlayer().getPermissionContext().addAttachment(plugin, name, value, ticks);
+    }
+
+    @Override
+    public @org.jetbrains.annotations.Nullable org.bukkit.permissions.PermissionAttachment addAttachment(@org.jetbrains.annotations.NotNull Plugin plugin, int ticks) {
+        return getPulvinarPlayer().getPermissionContext().addAttachment(plugin, ticks);
+    }
+
+    @Override
+    public void removeAttachment(@org.jetbrains.annotations.NotNull org.bukkit.permissions.PermissionAttachment attachment) {
+        getPulvinarPlayer().getPermissionContext().removeAttachment(attachment);
+    }
+
+    @Override
+    public void recalculatePermissions() {
+        getPulvinarPlayer().getPermissionContext().recalculatePermissions();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull java.util.Set<org.bukkit.permissions.PermissionAttachmentInfo> getEffectivePermissions() {
+        return getPulvinarPlayer().getPermissionContext().getEffectivePermissions();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull java.util.Set<net.kissenpvp.pulvinar.api.permission.Permission> getOwnPermissions() {
+        return getPulvinarPlayer().getPermissionContext().getOwnPermissions();
+    }
+
+    @Override
+    public int wipeGroups() {
+        return getPulvinarPlayer().getPermissionContext().wipeGroups();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull @org.jetbrains.annotations.Unmodifiable List<net.kissenpvp.core.api.permission.AbstractPermissionGroup<net.kissenpvp.pulvinar.api.permission.Permission>> getOwnPermissionGroups()
+    {
+        return getPulvinarPlayer().getPermissionContext().getOwnPermissionGroups();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull @org.jetbrains.annotations.Unmodifiable List<net.kissenpvp.core.api.permission.AbstractPermissionGroup<net.kissenpvp.pulvinar.api.permission.Permission>> getPermissionGroups() {
+        return getPulvinarPlayer().getPermissionContext().getPermissionGroups();
+    }
+
+    @Override
+    public boolean inGroup(@org.jetbrains.annotations.NotNull net.kissenpvp.core.api.permission.AbstractPermissionGroup<net.kissenpvp.pulvinar.api.permission.Permission> permissionGroup) {
+        return getPulvinarPlayer().getPermissionContext().inGroup(permissionGroup);
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull String getPermissionID() {
+        return getPulvinarPlayer().getPermissionContext().getPermissionID();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.permission.Permission setPermission(@org.jetbrains.annotations.NotNull String permission) throws net.kissenpvp.core.api.event.EventCancelledException {
+        return getPulvinarPlayer().getPermissionContext().setPermission(permission);
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.permission.Permission setPermission(@org.jetbrains.annotations.NotNull String permission, boolean value) throws net.kissenpvp.core.api.event.EventCancelledException {
+        return getPulvinarPlayer().getPermissionContext().setPermission(permission, value);
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.permission.Permission setPermission(@org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.permission.Permission permission) throws net.kissenpvp.core.api.event.EventCancelledException {
+        return getPulvinarPlayer().getPermissionContext().setPermission(permission);
+    }
+
+    @Override
+    public boolean unsetPermission(@org.jetbrains.annotations.NotNull String permission) {
+        return getPulvinarPlayer().getPermissionContext().unsetPermission(permission);
+    }
+
+    @Override
+    public int wipePermissions() {
+        return getPulvinarPlayer().getPermissionContext().wipePermissions();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull java.util.Set<net.kissenpvp.pulvinar.api.permission.Permission> getPermissionList() {
+        return getPulvinarPlayer().getPermissionContext().getPermissionList();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull java.util.Optional<net.kissenpvp.pulvinar.api.permission.Permission> getPermission(@org.jetbrains.annotations.NotNull String permission) {
+        return getPulvinarPlayer().getPermissionContext().getPermission(permission);
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull java.util.Set<UUID> getAffectedUsers() {
+        return java.util.Collections.EMPTY_SET;
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull java.util.Set<net.kissenpvp.core.api.permission.AbstractGroupablePermissionEntry<net.kissenpvp.pulvinar.api.permission.Permission>> getConnectedEntries()
+    {
+        return java.util.Collections.EMPTY_SET;
+    }
+
+    @Override
+    public void permissionUpdate() {/* ignored */ }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull java.util.Optional<net.kissenpvp.pulvinar.api.permission.Permission> getOwnPermission(@org.jetbrains.annotations.NotNull String permission)
+    {
+        return getPulvinarPlayer().getPermissionContext().getOwnPermission(permission);
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull java.util.Optional<net.kissenpvp.pulvinar.api.permission.Permission> getOwnPermission(@org.jetbrains.annotations.NotNull String permission, @org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.base.Context context)
+    {
+        return getPulvinarPlayer().getPermissionContext().getOwnPermission(permission, context);
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull List<net.kissenpvp.core.api.permission.AbstractPermissionGroup<net.kissenpvp.pulvinar.api.permission.Permission>> getOwnPermissionsGroups(@org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.base.Context context)
+    {
+        return getPulvinarPlayer().getPermissionContext().getOwnPermissionsGroups(context);
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull List<net.kissenpvp.core.api.permission.AbstractPermissionGroup<net.kissenpvp.pulvinar.api.permission.Permission>> getPermissionGroups(@org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.base.Context context)
+    {
+        return getPulvinarPlayer().getPermissionContext().getPermissionGroups(context);
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull java.util.Set<net.kissenpvp.pulvinar.api.permission.Permission> getOwnPermissions(@org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.base.Context context) {
+        return getPulvinarPlayer().getPermissionContext().getOwnPermissions(context);
+    }
+
+    @Override
+    public boolean inGroup(@org.jetbrains.annotations.NotNull net.kissenpvp.core.api.permission.AbstractPermissionGroup<net.kissenpvp.pulvinar.api.permission.Permission> permissionGroup, @org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.base.Context context) {
+        return getPulvinarPlayer().getPermissionContext().inGroup(permissionGroup, context);
+    }
+
+    @Override
+    public int wipeGroups(@org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.base.Context context)
+    {
+        return getPulvinarPlayer().getPermissionContext().wipeGroups(context);
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.permission.Permission setPermission(@org.jetbrains.annotations.NotNull String permission, @org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.base.Context context) throws net.kissenpvp.core.api.event.EventCancelledException {
+        return getPulvinarPlayer().getPermissionContext().setPermission(permission, context);
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.permission.Permission setPermission(@org.jetbrains.annotations.NotNull String permission, boolean value, @org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.base.Context context) throws net.kissenpvp.core.api.event.EventCancelledException {
+        return getPulvinarPlayer().getPermissionContext().setPermission(permission, value, context);
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.permission.Permission setPermission(@org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.permission.Permission permission, @org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.base.Context context) throws net.kissenpvp.core.api.event.EventCancelledException {
+        return getPulvinarPlayer().getPermissionContext().setPermission(permission, context);
+    }
+
+    @Override
+    public boolean unsetPermission(@org.jetbrains.annotations.NotNull String permission, @org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.base.Context context) {
+        return getPulvinarPlayer().getPermissionContext().unsetPermission(permission, context);
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull java.util.Set<net.kissenpvp.pulvinar.api.permission.Permission> getPermissionList(@org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.base.Context context) {
+        return getPulvinarPlayer().getPermissionContext().getPermissionList(context);
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull java.util.Optional<net.kissenpvp.pulvinar.api.permission.Permission> getPermission(@org.jetbrains.annotations.NotNull String permission, @org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.base.Context context) {
+        return getPulvinarPlayer().getPermissionContext().getPermission(permission, context);
+    }
+
+    @Override
+    public boolean hasPermission(@org.jetbrains.annotations.NotNull String permission, @org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.base.Context context) {
+        return getPulvinarPlayer().getPermissionContext().hasPermission(permission, context);
+    }
+
+    @Override
+    public int wipePermissions(@org.jetbrains.annotations.NotNull net.kissenpvp.pulvinar.api.base.Context context)
+    {
+        return getPulvinarPlayer().getPermissionContext().wipePermissions(context);
+    }
+    // Pulvinar end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java b/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java
index 9607675e6c5bff2183c4420d11fc63eeb5747fb6..ca05e178839fdc91e44530bc7fee18b59c330a9c 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java
@@ -109,4 +109,11 @@ public class CraftConsoleCommandSender extends ServerCommandSender implements Co
         return io.papermc.paper.configuration.GlobalConfiguration.get().console.hasAllPermissions || super.hasPermission(perm);
     }
     // Paper end
+
+    // Pulvinar start
+    @Override
+    public net.kyori.adventure.audience.@org.jetbrains.annotations.NotNull Audience getKyoriAudience() {
+        return this;
+    }
+    // Pulvinar end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/command/ProxiedNativeCommandSender.java b/src/main/java/org/bukkit/craftbukkit/command/ProxiedNativeCommandSender.java
index 3e7d14564f11a3ed0b0766444e9d681804597e9a..70b03c85c68557d71e133c3a631db3d70291d344 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/ProxiedNativeCommandSender.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/ProxiedNativeCommandSender.java
@@ -146,4 +146,26 @@ public class ProxiedNativeCommandSender implements ProxiedCommandSender {
        return this.getCaller().spigot();
     }
     // Spigot end
+
+    // Pulvinar start
+    @Override
+    public @org.jetbrains.annotations.NotNull java.util.Locale getCurrentLocale() {
+        return this.getCaller().getCurrentLocale();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.NotNull net.kyori.adventure.text.Component displayName() {
+        return this.getCaller().displayName();
+    }
+
+    @Override
+    public boolean isConnected() {
+        return this.getCaller().isConnected();
+    }
+
+    @Override
+    public boolean isClient() {
+        return this.getCaller().isClient();
+    }
+    // Pulvinar end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/command/ServerCommandSender.java b/src/main/java/org/bukkit/craftbukkit/command/ServerCommandSender.java
index 1e3091687735b461d3b6a313ab8761127981d3e8..deb0902d85bc80f022f06817c439d2e5d55da925 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/ServerCommandSender.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/ServerCommandSender.java
@@ -145,4 +145,21 @@ public abstract class ServerCommandSender implements CommandSender {
         return this.adventure$pointers;
     }
     // Paper end
+
+    // Pulvinar start
+    @Override
+    public @org.jetbrains.annotations.NotNull java.util.Locale getCurrentLocale() {
+        return Bukkit.getPulvinar().getImplementation(net.kissenpvp.core.api.message.localization.LocalizationImplementation.class).getDefaultLocale();
+    }
+
+    @Override
+    public final boolean isConnected() {
+        return true;
+    }
+
+    @Override
+    public final boolean isClient() {
+        return false;
+    }
+    // Pulvinar end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index 4b7d38a5ac6247c6e9d71ac7f3b65765ed3cf3ee..877438db64d9a089e77616f94f048d81c757d458 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -1338,4 +1338,21 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         return !getHandle().dismountsUnderwater();
     }
     // Purpur end
+
+    // Pulvinar start
+    @Override
+    public @org.jetbrains.annotations.NotNull java.util.Locale getCurrentLocale() {
+        return org.bukkit.Bukkit.getPulvinar().getImplementation(net.kissenpvp.core.api.message.localization.LocalizationImplementation.class).getDefaultLocale();
+    }
+
+    @Override
+    public boolean isConnected() {
+        return true;
+    }
+
+    @Override
+    public final boolean isClient() { // Kinda useless for this use case
+        return true;
+    }
+    // Pulvinar end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
index 69304fa6eb65dd37e74db9ad62eac0bddfdea2c1..abbfe95c425ebe9a66cd60c4ef1c8ac2d7feddc8 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
@@ -70,7 +70,7 @@ import org.bukkit.plugin.Plugin;
 public class CraftHumanEntity extends CraftLivingEntity implements HumanEntity {
     private CraftInventoryPlayer inventory;
     private final CraftInventory enderChest;
-    protected final PermissibleBase perm = new PermissibleBase(this);
+    protected final /* PermissibleBase */ org.bukkit.permissions.Permissible perm = new net.kissenpvp.pulvinar.permission.permissible.PulvinarPlayerPermissible(this); // Pulvinar
     private boolean op;
     private GameMode mode;
 
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 6a3b023b0f60dbb350943bdd7f0bfead9e8e3ce0..f634554385ea5046ff8129a16615d1fac409bea6 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -193,6 +193,33 @@ import org.jetbrains.annotations.NotNull;
 
 import net.md_5.bungee.api.chat.BaseComponent; // Spigot
 
+// Pulvinar start
+import net.kissenpvp.pulvinar.api.ban.BanTemplate;
+import net.kissenpvp.pulvinar.api.ban.Punishment;
+import net.kissenpvp.pulvinar.api.ban.warn.Warn;
+import net.kissenpvp.pulvinar.api.base.Context;
+import net.kissenpvp.pulvinar.api.networking.client.entity.PulvinarOnlinePlayerClient;
+import net.kissenpvp.pulvinar.api.permission.PaperPermissible;
+import net.kissenpvp.pulvinar.api.permission.PermissibleOverriddenException;
+import net.kissenpvp.pulvinar.api.permission.Permission;
+import net.kissenpvp.pulvinar.api.user.playersetting.BoundPlayerSetting;
+import net.kissenpvp.pulvinar.api.user.playersetting.PlayerSetting;
+import net.kissenpvp.pulvinar.api.user.rank.PlayerRank;
+import net.kissenpvp.core.api.base.KissenServer;
+import net.kissenpvp.core.api.database.meta.BackendException;
+import net.kissenpvp.core.api.event.EventCancelledException;
+import net.kissenpvp.core.api.networking.client.entitiy.ServerEntity;
+import net.kissenpvp.core.api.permission.AbstractPermissionGroup;
+import net.kissenpvp.core.api.user.User;
+import net.kissenpvp.core.api.ban.AbstractBanTemplate;
+import net.kissenpvp.core.api.user.UserImplementation;
+import net.kissenpvp.core.api.user.rank.AbstractRank;
+import net.kissenpvp.core.api.time.AccurateDuration;
+import net.kissenpvp.pulvinar.permission.permissible.PulvinarPermissible;
+import net.kissenpvp.pulvinar.user.PulvinarPublicUser;
+import org.jetbrains.annotations.Unmodifiable;
+// Pulvinar stop
+
 @DelegateDeserialization(CraftOfflinePlayer.class)
 public class CraftPlayer extends CraftHumanEntity implements Player {
     private long firstPlayed = 0;
@@ -213,6 +240,10 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     private static final boolean DISABLE_CHANNEL_LIMIT = System.getProperty("paper.disableChannelLimit") != null; // Paper - add a flag to disable the channel limit
     private long lastSaveTime; // Paper - getLastPlayed replacement API
 
+    // Pulvinar start
+    private net.kissenpvp.pulvinar.networking.client.entity.InternalPulvinarOnlinePlayerClient pulvinarPlayer;
+    // Pulvinar end
+
     public CraftPlayer(CraftServer server, ServerPlayer entity) {
         super(server, entity);
 
@@ -2669,7 +2700,16 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     public void disconnect(String reason) {
         this.conversationTracker.abandonAllConversations();
-        this.perm.clearPermissions();
+        // Pulvinar start - logout user
+        try {
+            ((PulvinarPermissible) getPermissible()).unsubscribe();
+        } catch (PermissibleOverriddenException overridden) {
+            if (this.perm instanceof org.bukkit.permissions.PermissibleBase permissibleBase) {
+                permissibleBase.clearPermissions();
+            }
+        }
+        ((net.kissenpvp.core.user.KissenUser) getUser(Context.LOCAL)).writeOnlineTimeData(Instant.ofEpochMilli(getLastLogin()));
+        // Pulvinar end - logout user
     }
 
     @Override
@@ -3042,7 +3082,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     // Paper start
     @Override
     public java.util.Locale locale() {
-        return getHandle().adventure$locale;
+        return /* getHandle().adventure$locale; */ getCurrentLocale(); // Pulvinar
     }
     // Paper end
     @Override
@@ -3177,7 +3217,14 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     public void sendMessage(final net.kyori.adventure.identity.Identity identity, final net.kyori.adventure.text.Component message, final net.kyori.adventure.audience.MessageType type) {
         if (getHandle().connection == null) return;
         final net.minecraft.core.Registry<net.minecraft.network.chat.ChatType> chatTypeRegistry = this.getHandle().level().registryAccess().registryOrThrow(net.minecraft.core.registries.Registries.CHAT_TYPE);
-        this.getHandle().connection.send(new net.minecraft.network.protocol.game.ClientboundSystemChatPacket(message, false));
+
+        // Pulvinar start - add custom renderer
+        Bukkit.getPulvinar().getImplementation(net.kissenpvp.core.api.message.ChatImplementation.class).handle(Bukkit.getConsoleSender(), this, message).ifPresent(styled ->
+
+            this.getHandle().connection.send(new net.minecraft.network.protocol.game.ClientboundSystemChatPacket(styled, false))
+
+        );
+        // Pulvinar end
     }
 
     @Override
@@ -3439,7 +3486,15 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         public void sendMessage(net.md_5.bungee.api.ChatMessageType position, UUID sender, BaseComponent... components) {
             if ( CraftPlayer.this.getHandle().connection == null ) return;
 
-            CraftPlayer.this.getHandle().connection.send(new net.minecraft.network.protocol.game.ClientboundSystemChatPacket(components, position == net.md_5.bungee.api.ChatMessageType.ACTION_BAR));
+            // Pulvinar start - add custom renderer
+            net.kyori.adventure.text.Component[] componentData = java.util.Arrays.stream(components).map(net.md_5.bungee.chat.ComponentSerializer::toString).map(json ->
+                net.kyori.adventure.text.serializer.json.JSONComponentSerializer.json().deserialize(json)
+            ).toList().toArray(new net.kyori.adventure.text.Component[0]);
+
+            Bukkit.getPulvinar().getImplementation(net.kissenpvp.core.api.message.ChatImplementation.class).handle(Bukkit.getConsoleSender(), CraftPlayer.this, componentData).ifPresent(styled ->
+                CraftPlayer.this.getHandle().connection.send(new net.minecraft.network.protocol.game.ClientboundSystemChatPacket(styled, position == net.md_5.bungee.api.ChatMessageType.ACTION_BAR))
+            );
+            // Pulvinar end
         }
 
         // Paper start
@@ -3648,4 +3703,352 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         this.getHandle().connection.send(new net.minecraft.network.protocol.game.ClientboundPlayerCombatKillPacket(getEntityId(), io.papermc.paper.adventure.PaperAdventure.asVanilla(message)));
     }
     // Purpur end
+
+    // Pulvinar start - integrate user methods provided by the kissen implementation
+    private @NotNull net.kissenpvp.pulvinar.networking.client.entity.InternalPulvinarOnlinePlayerClient getPulvinarPlayer() {
+        if (pulvinarPlayer== null) {
+            pulvinarPlayer = new net.kissenpvp.pulvinar.networking.client.entity.InternalPulvinarOnlinePlayerClient() {
+                @Override
+                public @NotNull CraftPlayer getCraftPlayer() {
+                    return CraftPlayer.this;
+                }
+
+                @Override
+                public @NotNull PaperPermissible getPermissible() throws PermissibleOverriddenException {
+                    if (!(perm instanceof PaperPermissible permissible)) {
+                        throw new PermissibleOverriddenException();
+                    }
+                    return permissible;
+                }
+
+                @Override
+                public @NotNull UUID getUniqueId() {
+                    return CraftPlayer.this.getUniqueId();
+                }
+            };
+        }
+        return pulvinarPlayer;
+    }
+
+    @Override
+    public @NotNull User getUser() {
+        return getUser(Context.GLOBAL);
+    }
+
+    @Override
+    public @NotNull User getUser(@NotNull Context context) {
+        PulvinarPublicUser kissenPublicUser = (PulvinarPublicUser) Bukkit.getPulvinar()
+                .getImplementation(UserImplementation.class)
+                .getOnlineUser(getUniqueId())
+                .orElseThrow(IllegalStateException::new);
+        return switch (context)
+        {
+            case GLOBAL -> kissenPublicUser;
+            case LOCAL -> kissenPublicUser.getPrivateUserEntry();
+        };
+    }
+
+    @Override
+    public @NotNull io.netty.channel.Channel getConnection() {
+        return getHandle().connection.connection.channel;
+    }
+
+    @Override
+    public void sendPacket(@NotNull Object object) throws ClassNotFoundException, ClassCastException {
+        getHandle().connection.send((net.minecraft.network.protocol.Packet<?>) object);
+    }
+
+    @Override
+    public @NotNull net.kyori.adventure.audience.Audience getKyoriAudience() {
+        return this;
+    }
+
+    @Override
+    public @NotNull java.util.Locale getCurrentLocale() {
+        return getPulvinarPlayer().getCurrentLocale();
+    }
+
+    // -
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAltAccounts() throws BackendException {
+        return getPulvinarPlayer().getAltAccounts();
+    }
+
+    @Override
+    public @NotNull UUID getTotalID() {
+        return getPulvinarPlayer().getTotalID();
+    }
+
+    @Override
+    public @NotNull Punishment punish(@NotNull AbstractBanTemplate ban, @NotNull ServerEntity banOperator) {
+        return getPulvinarPlayer().punish(ban, banOperator);
+    }
+
+    @Override
+    public @NotNull Punishment punish(@NotNull AbstractBanTemplate ban, @NotNull ServerEntity banOperator, net.kyori.adventure.text.@org.jetbrains.annotations.Nullable Component reason) {
+        return getPulvinarPlayer().punish(ban, banOperator, reason);
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable Punishment> getPunishment(@NotNull String id) {
+        return getPulvinarPlayer().getPunishment(id);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<Punishment> getPunishmentHistory() throws BackendException {
+        return getPulvinarPlayer().getPunishmentHistory();
+    }
+
+    @Override
+    public @NotNull net.kissenpvp.core.api.time.AccurateDuration getOnlineTime() {
+        return getPulvinarPlayer().getOnlineTime();
+    }
+
+    @Override
+    public void kick(@NotNull String message) {
+        getPulvinarPlayer().kick(message);
+    }
+
+    @Override
+    public void killConnection() {
+        getPulvinarPlayer().killConnection();
+    }
+
+    @Override
+    public @org.jetbrains.annotations.Nullable KissenServer getCurrentServer() {
+        return getPulvinarPlayer().getCurrentServer();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<PlayerRank> getRankHistory() {
+        return getPulvinarPlayer().getRankHistory();
+    }
+
+    @Override
+    public @NotNull PlayerRank getRank() {
+        return getPulvinarPlayer().getRank();
+    }
+
+    @Override
+    public @NotNull PlayerRank grantRank(@NotNull AbstractRank rank) {
+        return getPulvinarPlayer().grantRank(rank);
+    }
+
+    @Override
+    public @NotNull PlayerRank grantRank(@NotNull AbstractRank rank, @org.jetbrains.annotations.Nullable AccurateDuration accurateDuration) {
+        return getPulvinarPlayer().grantRank(rank, accurateDuration);
+    }
+
+    @Override
+    public @NotNull net.kissenpvp.pulvinar.api.ban.warn.Warn warn(@NotNull BanTemplate ban, @NotNull ServerEntity warnOperator) {
+        return getPulvinarPlayer().warn(ban, warnOperator);
+    }
+
+    @Override
+    public @NotNull net.kissenpvp.pulvinar.api.ban.warn.Warn warn(@NotNull BanTemplate ban, @NotNull ServerEntity warnOperator, net.kyori.adventure.text.@org.jetbrains.annotations.Nullable Component reason) {
+        return getPulvinarPlayer().warn(ban, warnOperator, reason);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<Warn> getWarnHistory()
+    {
+        return getPulvinarPlayer().getWarnHistory();
+    }
+
+    @Override
+    public void clearActiveWarns()
+    {
+        getPulvinarPlayer().clearActiveWarns();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<@NotNull PulvinarOnlinePlayerClient> getOnlineAltAccounts() {
+        return getPulvinarPlayer().getOnlineAltAccounts();
+    }
+
+    @Override
+    public @NotNull net.kissenpvp.core.api.time.AccurateDuration getOnlineTime(@NotNull Context context) {
+        return getPulvinarPlayer().getOnlineTime(context);
+    }
+
+    @Override
+    public @NotNull PaperPermissible getPermissible() throws PermissibleOverriddenException {
+        return getPulvinarPlayer().getPermissible();
+    }
+
+    @Override
+    public @NotNull <X> BoundPlayerSetting<X> getSetting(@NotNull Class<? extends PlayerSetting<X>> settingClass) {
+        return getPulvinarPlayer().getSetting(settingClass);
+    }
+
+    @Override
+    public @NotNull <X> BoundPlayerSetting<X> getSetting(@NotNull Class<? extends PlayerSetting<X>> settingClass, @NotNull Context context)
+    {
+        return getPulvinarPlayer().getSetting(settingClass, context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<Permission> getOwnPermissions() {
+        return getPulvinarPlayer().getPermissionContext().getOwnPermissions();
+    }
+
+    @Override
+    public int wipeGroups() {
+        return getPulvinarPlayer().getPermissionContext().wipeGroups();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<AbstractPermissionGroup<Permission>> getOwnPermissionGroups()
+    {
+        return getPulvinarPlayer().getPermissionContext().getOwnPermissionGroups();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<AbstractPermissionGroup<Permission>> getPermissionGroups() {
+        return getPulvinarPlayer().getPermissionContext().getPermissionGroups();
+    }
+
+    @Override
+    public boolean inGroup(@NotNull AbstractPermissionGroup<Permission> permissionGroup) {
+        return getPulvinarPlayer().getPermissionContext().inGroup(permissionGroup);
+    }
+
+    @Override
+    public @NotNull String getPermissionID() {
+        return getPulvinarPlayer().getPermissionContext().getPermissionID();
+    }
+
+    @Override
+    public @NotNull Permission setPermission(@NotNull String permission) throws EventCancelledException {
+        return getPulvinarPlayer().getPermissionContext().setPermission(permission);
+    }
+
+    @Override
+    public @NotNull Permission setPermission(@NotNull String permission, boolean value) throws EventCancelledException {
+        return getPulvinarPlayer().getPermissionContext().setPermission(permission, value);
+    }
+
+    @Override
+    public @NotNull Permission setPermission(@NotNull Permission permission) throws EventCancelledException {
+        return getPulvinarPlayer().getPermissionContext().setPermission(permission);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission) {
+        return getPulvinarPlayer().getPermissionContext().unsetPermission(permission);
+    }
+
+    @Override
+    public int wipePermissions() {
+        return getPulvinarPlayer().getPermissionContext().wipePermissions();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<Permission> getPermissionList() {
+        return getPulvinarPlayer().getPermissionContext().getPermissionList();
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable Permission> getPermission(@NotNull String permission) {
+        return getPulvinarPlayer().getPermissionContext().getPermission(permission);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<UUID> getAffectedUsers() {
+        return java.util.Collections.singleton(getUniqueId());
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<net.kissenpvp.core.api.permission.AbstractGroupablePermissionEntry<Permission>> getConnectedEntries()
+    {
+        return java.util.Collections.singleton(this);
+    }
+
+    @Override
+    public void permissionUpdate() {
+        getPermissible().permissionUpdate();
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<Permission> getOwnPermissions(@NotNull Context context) {
+        return getPulvinarPlayer().getPermissionContext().getOwnPermissions(context);
+    }
+
+    @Override
+    public @NotNull Optional<Permission> getOwnPermission(@NotNull String permission)
+    {
+        return getPulvinarPlayer().getPermissionContext().getOwnPermission(permission);
+    }
+
+    @Override
+    public @NotNull Optional<Permission> getOwnPermission(@NotNull String permission, @NotNull Context context)
+    {
+        return getPulvinarPlayer().getPermissionContext().getOwnPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<AbstractPermissionGroup<Permission>> getOwnPermissionsGroups(@NotNull Context context)
+    {
+        return getPulvinarPlayer().getPermissionContext().getOwnPermissionsGroups(context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable List<AbstractPermissionGroup<Permission>> getPermissionGroups(@NotNull Context context)
+    {
+        return getPulvinarPlayer().getPermissionContext().getPermissionGroups(context);
+    }
+
+    @Override
+    public boolean inGroup(@NotNull AbstractPermissionGroup<Permission> permissionGroup, @NotNull Context context) {
+        return getPulvinarPlayer().getPermissionContext().inGroup(permissionGroup, context);
+    }
+
+    @Override
+    public int wipeGroups(@NotNull Context context)
+    {
+        return getPulvinarPlayer().getPermissionContext().wipeGroups(context);
+    }
+
+    @Override
+    public @NotNull Permission setPermission(@NotNull String permission, @NotNull Context context) throws EventCancelledException {
+        return getPulvinarPlayer().getPermissionContext().setPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull Permission setPermission(@NotNull String permission, boolean value, @NotNull Context context) throws EventCancelledException {
+        return getPulvinarPlayer().getPermissionContext().setPermission(permission, value, context);
+    }
+
+    @Override
+    public @NotNull Permission setPermission(@NotNull Permission permission, @NotNull Context context) throws EventCancelledException {
+        return getPulvinarPlayer().getPermissionContext().setPermission(permission, context);
+    }
+
+    @Override
+    public boolean unsetPermission(@NotNull String permission, @NotNull Context context) {
+        return getPulvinarPlayer().getPermissionContext().unsetPermission(permission, context);
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<Permission> getPermissionList(@NotNull Context context) {
+        return getPulvinarPlayer().getPermissionContext().getPermissionList(context);
+    }
+
+    @Override
+    public @NotNull Optional<@org.jetbrains.annotations.Nullable Permission> getPermission(@NotNull String permission, @NotNull Context context) {
+        return getPulvinarPlayer().getPermissionContext().getPermission(permission, context);
+    }
+
+    @Override
+    public boolean hasPermission(@NotNull String permission, @NotNull Context context) {
+        return getPulvinarPlayer().getPermissionContext().hasPermission(permission, context);
+    }
+
+    @Override
+    public int wipePermissions(@NotNull Context context)
+    {
+        return getPulvinarPlayer().getPermissionContext().wipePermissions(context);
+    }
+    // Pulvinar end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/profile/CraftPlayerProfile.java b/src/main/java/org/bukkit/craftbukkit/profile/CraftPlayerProfile.java
index 0121c90dd7f57be5f484f970f78747a92a734611..9838bd3480d6725d499323993e171feac0b96cf6 100644
--- a/src/main/java/org/bukkit/craftbukkit/profile/CraftPlayerProfile.java
+++ b/src/main/java/org/bukkit/craftbukkit/profile/CraftPlayerProfile.java
@@ -358,4 +358,12 @@ public final class CraftPlayerProfile implements PlayerProfile, com.destroystoky
     public boolean complete(final boolean textures, final boolean onlineMode) {
         throw new UnsupportedOperationException("Do not cast to com.destroystokyo.paper.profile.PlayerProfile");
     }
+
+    // Pulvinar start
+    @Override
+    public @org.jetbrains.annotations.NotNull net.kissenpvp.core.api.user.User getUser()
+    {
+        return org.bukkit.Bukkit.getPulvinar().getImplementation(net.kissenpvp.core.api.user.UserImplementation.class).getUser(getId());
+    }
+    // Pulvinar end
 }
